To: vim-dev@vim.org
Subject: Patch 6.2.431
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 6.2.431
Problem:    When using the horizontal scrollbar, the scrolling is limited to
	    the length of the cursor line.
Solution:   Make the scroll limit depend on the longest visible line.  The
	    cursor is moved when necessary.  Including the 'h' flag in
	    'guioptions' disables this.
Files:	    runtime/doc/gui.txt, runtime/doc/options.txt, src/gui.c,
	    src/misc2.c, src/option.h


*** ../vim-6.2.430/runtime/doc/gui.txt	Sun Jun  1 12:20:32 2003
--- runtime/doc/gui.txt	Fri Apr  2 20:50:19 2004
***************
*** 1,4 ****
! *gui.txt*       For Vim version 6.2.  Last change: 2003 Apr 25
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *gui.txt*       For Vim version 6.2.  Last change: 2004 Apr 02
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 183,201 ****
  If a window is shrunk to zero height (by the growth of another window) its
  scrollbar disappears. It reappears when the window is restored.
  
! If a window is vertically split, it will only get a scrollbar when it is the
! current window, or the middle of the current window is above or below it.
  When there are scrollbars on both sides, and the middle of the current window
  is on the left halve, the right scrollbar column will contain scrollbars for
  the rightmost windows.  The same happens on the other side.
  
  
! Horizontal Scrollbars					*gui-horiz-scroll*
  
  The horizontal scrollbar (at the bottom of the Vim GUI) may be used to
  scroll text sideways when the 'wrap' option is turned off.  The
! scrollbar-thumb size is such that the text of the current cursor line may be
! scrolled as far as possible left and right.
  
  							*athena-intellimouse*
  If you have an Intellimouse and an X server that supports using the wheel,
--- 183,210 ----
  If a window is shrunk to zero height (by the growth of another window) its
  scrollbar disappears. It reappears when the window is restored.
  
! If a window is vertically split, it will get a scrollbar when it is the
! current window and when, taking the middle of the current window and drawing a
! vertical line, this line goes through the window.
  When there are scrollbars on both sides, and the middle of the current window
  is on the left halve, the right scrollbar column will contain scrollbars for
  the rightmost windows.  The same happens on the other side.
  
  
! HORIZONTAL SCROLLBARS					*gui-horiz-scroll*
  
  The horizontal scrollbar (at the bottom of the Vim GUI) may be used to
  scroll text sideways when the 'wrap' option is turned off.  The
! scrollbar-thumb size is such that the text of the longest visible line may be
! scrolled as far as possible left and right.  The cursor is moved when
! necessary, it must remain on a visible character (unless 'virtualedit' is
! set).
! 
! Computing the length of the longest visible takes quite a bit of computation,
! and it has to be done every time something changes.  If this takes too much
! time or you don't like the cursor jumping to another line, include the 'h'
! flag in 'guioptions'.  Then the scrolling is limited by the text of the
! current cursor line.
  
  							*athena-intellimouse*
  If you have an Intellimouse and an X server that supports using the wheel,
*** ../vim-6.2.430/runtime/doc/options.txt	Tue Mar 30 21:58:19 2004
--- runtime/doc/options.txt	Fri Apr  2 20:46:57 2004
***************
*** 1,4 ****
! *options.txt*	For Vim version 6.2.  Last change: 2004 Mar 30
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
--- 1,4 ----
! *options.txt*	For Vim version 6.2.  Last change: 2004 Apr 02
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
***************
*** 2909,2914 ****
--- 2932,2938 ----
  
  	  'c'	Use console dialogs instead of popup dialogs for simple
  		choices.
+ 
  	  'f'	Foreground: Don't use fork() to detach the GUI from the shell
  		where it was started.  Use this for programs that wait for the
  		editor to finish (e.g., an e-mail program).  Alternatively you
***************
*** 2942,2948 ****
  	  'l'	Left-hand scrollbar is always present.
  	  'L'	Left-hand scrollbar is present when there is a vertically
  		split window.
! 	  'b'	Bottom (horizontal) scrollbar is present.
  
  	And yes, you may even have scrollbars on the left AND the right if
  	you really want to :-).  See |gui-scrollbars| for more information.
--- 2966,2976 ----
  	  'l'	Left-hand scrollbar is always present.
  	  'L'	Left-hand scrollbar is present when there is a vertically
  		split window.
! 	  'b'	Bottom (horizontal) scrollbar is present.  Its size depends on
! 	  	the longest visible line, or on the cursor line if the 'h'
! 		flag is included. |gui-horiz-scroll|
! 	  'h'	Limit horizontal scrollbar size to the length of the cursor
! 		line.  Reduces computations. |gui-horiz-scroll|
  
  	And yes, you may even have scrollbars on the left AND the right if
  	you really want to :-).  See |gui-scrollbars| for more information.
*** ../vim-6.2.430/src/gui.c	Wed Mar 17 22:18:24 2004
--- src/gui.c	Fri Apr  2 20:55:43 2004
***************
*** 27,32 ****
--- 27,33 ----
  static void gui_insert_lines __ARGS((int row, int count));
  static void fill_mouse_coord __ARGS((char_u *p, int col, int row));
  static void gui_do_scrollbar __ARGS((win_T *wp, int which, int enable));
+ static colnr_T scroll_line_len __ARGS((linenr_T lnum));
  static void gui_update_horiz_scrollbar __ARGS((int));
  static win_T *xy2win __ARGS((int x, int y));
  
***************
*** 1642,1650 ****
  	}
      }
  
!     /* Don't update cursor when ScreenLines[] is invalid (busy scrolling). */
!     if (can_update_cursor && force_cursor)
! 	gui_update_cursor(force_cursor, TRUE);
  
      /* When switching to another window the dragging must have stopped.
       * Required for GTK, dragged_sb isn't reset. */
--- 1643,1652 ----
  	}
      }
  
!     /* Postponed update of the cursor (won't work if "can_update_cursor" isn't
!      * set). */
!     if (force_cursor)
! 	gui_update_cursor(TRUE, TRUE);
  
      /* When switching to another window the dragging must have stopped.
       * Required for GTK, dragged_sb isn't reset. */
***************
*** 2866,2873 ****
  	else if (button ==
  # ifdef RISCOS
  		/* Only start a drag on a drag event. Otherwise
! 		 * we don't get a release event.
! 		 */
  		    MOUSE_DRAG
  # else
  		    MOUSE_LEFT
--- 2868,2874 ----
  	else if (button ==
  # ifdef RISCOS
  		/* Only start a drag on a drag event. Otherwise
! 		 * we don't get a release event. */
  		    MOUSE_DRAG
  # else
  		    MOUSE_LEFT
***************
*** 3813,3824 ****
   * Horizontal scrollbar stuff:
   */
  
      static void
  gui_update_horiz_scrollbar(force)
      int		force;
  {
      long	value, size, max;	/* need 32 bit ints here */
-     char_u	*p;
  
      if (!gui.which_scrollbars[SBAR_BOTTOM])
  	return;
--- 3814,3858 ----
   * Horizontal scrollbar stuff:
   */
  
+ /*
+  * Return length of line "lnum" for horizontal scrolling.
+  */
+     static colnr_T
+ scroll_line_len(lnum)
+     linenr_T	lnum;
+ {
+     char_u	*p;
+     colnr_T	col;
+     int		w;
+ 
+     p = ml_get(lnum);
+     col = 0;
+     if (*p != NUL)
+ 	for (;;)
+ 	{
+ 	    w = chartabsize(p, col);
+ #ifdef FEAT_MBYTE
+ 	    if (has_mbyte)
+ 		p += (*mb_ptr2len_check)(p);
+ 	    else
+ #endif
+ 		++p;
+ 	    if (*p == NUL)		/* don't count the last character */
+ 		break;
+ 	    col += w;
+ 	}
+     return col;
+ }
+ 
+ /* Remember which line is currently the longest, so that we don't have to
+  * search for it when scrolling horizontally. */
+ static linenr_T longest_lnum = 0;
+ 
      static void
  gui_update_horiz_scrollbar(force)
      int		force;
  {
      long	value, size, max;	/* need 32 bit ints here */
  
      if (!gui.which_scrollbars[SBAR_BOTTOM])
  	return;
***************
*** 3853,3875 ****
      {
  	value = curwin->w_leftcol;
  
! 	/* Calculate max for horizontal scrollbar */
! 	p = ml_get_curline();
! 	max = 0;
! 	if (p != NULL && p[0] != NUL)
! 	    for (;;)
  	    {
! 		int w = chartabsize(p, (colnr_T)max);
! #ifdef FEAT_MBYTE
! 		if (has_mbyte)
! 		    p += (*mb_ptr2len_check)(p);
! 		else
! #endif
! 		    ++p;
! 		if (*p == NUL)		/* Don't count last character */
! 		    break;
! 		max += w;
  	    }
  #ifndef SCROLL_PAST_END
  	max += W_WIDTH(curwin) - 1;
  #endif
--- 3887,3928 ----
      {
  	value = curwin->w_leftcol;
  
! 	/* Calculate maximum for horizontal scrollbar. */
! 	if (vim_strchr(p_go, GO_HORSCROLL) == NULL)
! 	{
! 	    linenr_T	lnum;
! 	    colnr_T	n;
! 
! 	    /* Use maximum of all visible lines.  Remember the lnum of the
! 	     * longest line, clostest to the cursor line.  Used when scrolling
! 	     * below. */
! 	    max = 0;
! 	    for (lnum = curwin->w_topline; lnum < curwin->w_botline; ++lnum)
  	    {
! 		n = scroll_line_len(lnum);
! 		if (n > (colnr_T)max)
! 		{
! 		    max = n;
! 		    longest_lnum = lnum;
! 		}
! 		else if (n == (colnr_T)max
! 			&& abs(lnum - curwin->w_cursor.lnum)
! 				  < abs(longest_lnum - curwin->w_cursor.lnum))
! 		    longest_lnum = lnum;
  	    }
+ 	}
+ 	else
+ 	    /* Use cursor line only. */
+ 	    max = scroll_line_len(curwin->w_cursor.lnum);
+ #ifdef FEAT_VIRTUALEDIT
+ 	if (virtual_active())
+ 	{
+ 	    /* May move the cursor even further to the right. */
+ 	    if (curwin->w_virtcol >= max)
+ 		max = curwin->w_virtcol;
+ 	}
+ #endif
+ 
  #ifndef SCROLL_PAST_END
  	max += W_WIDTH(curwin) - 1;
  #endif
***************
*** 3923,3928 ****
--- 3976,3997 ----
  	return FALSE;
  
      curwin->w_leftcol = scrollbar_value;
+ 
+     /* When the line of the cursor is too short, move the cursor to the
+      * longest visible line.  Do a sanity check on "longest_lnum", just in
+      * case. */
+     if (vim_strchr(p_go, GO_HORSCROLL) == NULL
+ 	    && longest_lnum >= curwin->w_topline
+ 	    && longest_lnum < curwin->w_botline
+ 	    && !virtual_active())
+     {
+ 	if (scrollbar_value > scroll_line_len(curwin->w_cursor.lnum))
+ 	{
+ 	    curwin->w_cursor.lnum = longest_lnum;
+ 	    curwin->w_cursor.col = 0;
+ 	}
+     }
+ 
      return leftcol_changed();
  }
  
*** ../vim-6.2.430/src/misc2.c	Tue Mar 30 22:17:27 2004
--- src/misc2.c	Fri Apr  2 20:39:20 2004
***************
*** 560,566 ****
       * advance the cursor one more char.  If this fails (last char of the
       * line) adjust the scrolling.
       */
!     getvcol(curwin, &curwin->w_cursor, &s, NULL, &e);
      if (e > (colnr_T)lastcol)
      {
  	retval = TRUE;
--- 560,566 ----
       * advance the cursor one more char.  If this fails (last char of the
       * line) adjust the scrolling.
       */
!     getvvcol(curwin, &curwin->w_cursor, &s, NULL, &e);
      if (e > (colnr_T)lastcol)
      {
  	retval = TRUE;
*** ../vim-6.2.430/src/option.h	Sun Feb 29 21:06:13 2004
--- src/option.h	Fri Apr  2 19:37:58 2004
***************
*** 202,207 ****
--- 202,208 ----
  #define GO_CONDIALOG	'c'		/* use console dialog */
  #define GO_FORG		'f'		/* start GUI in foreground */
  #define GO_GREY		'g'		/* use grey menu items */
+ #define GO_HORSCROLL	'h'		/* flexible horizontal scrolling */
  #define GO_ICON		'i'		/* use Vim icon */
  #define GO_LEFT		'l'		/* use left scrollbar */
  #define GO_VLEFT	'L'		/* left scrollbar with vert split */
***************
*** 214,220 ****
  #define GO_TOOLBAR	'T'		/* add toolbar */
  #define GO_FOOTER	'F'		/* add footer */
  #define GO_VERTICAL	'v'		/* arrange dialog buttons vertically */
! #define GO_ALL		"aAbcfFgilmMprtTv" /* all possible flags for 'go' */
  
  /* flags for 'comments' option */
  #define COM_NEST	'n'		/* comments strings nest */
--- 215,221 ----
  #define GO_TOOLBAR	'T'		/* add toolbar */
  #define GO_FOOTER	'F'		/* add footer */
  #define GO_VERTICAL	'v'		/* arrange dialog buttons vertically */
! #define GO_ALL		"aAbcfFghilmMprtTv" /* all possible flags for 'go' */
  
  /* flags for 'comments' option */
  #define COM_NEST	'n'		/* comments strings nest */
*** ../vim-6.2.430/src/version.c	Fri Apr  2 15:28:03 2004
--- src/version.c	Fri Apr  2 21:02:32 2004
***************
*** 639,640 ****
--- 639,642 ----
  {   /* Add new patch number below this line */
+ /**/
+     431,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
248. You sign your letters with your e-mail address instead of your name.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        Sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\              Project leader for A-A-P -- http://www.A-A-P.org        ///
 \\\  Buy at Amazon and help AIDS victims -- http://ICCF.nl/click1.html ///
