To: vim-dev@vim.org
Subject: Patch 6.2.468
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 6.2.468
Problem:    Compiler warnings for shadowed variables. (Matthias Mohr)
Solution:   Delete superfluous variables and rename others.
Files:	    src/eval.c, src/ex_docmd.c, src/ex_eval.c, src/if_cscope.c,
	    src/fold.c, src/option.c, src/os_unix.c, src/quickfix.c,
	    src/regexp.c


*** ../vim-6.2.467/src/eval.c	Wed Apr  7 19:48:53 2004
--- src/eval.c	Tue Apr 13 15:37:27 2004
***************
*** 1149,1157 ****
  	     */
  	    else if (eval_isnamec(*arg) && !isdigit(*arg))
  	    {
- 		char_u *expr_start;
- 		char_u *expr_end;
- 
  		/* Find the end of the name. */
  		p = find_name_end(arg, &expr_start, &expr_end);
  
--- 1149,1154 ----
***************
*** 7790,7796 ****
  eval_isnamec(c)
      int	    c;
  {
!     return (ASCII_ISALPHA(c) || isdigit(c) || c == '_' || c == ':'
  #ifdef FEAT_MAGIC_BRACES
  	    || c == '{' || c == '}'
  #endif
--- 7787,7793 ----
  eval_isnamec(c)
      int	    c;
  {
!     return (ASCII_ISALNUM(c) || c == '_' || c == ':'
  #ifdef FEAT_MAGIC_BRACES
  	    || c == '{' || c == '}'
  #endif
***************
*** 8878,8884 ****
  	else
  	{
  	    arg = p;
! 	    while (ASCII_ISALPHA(*p) || isdigit(*p) || *p == '_')
  		++p;
  	    if (arg == p || isdigit(*arg)
  		    || (p - arg == 9 && STRNCMP(arg, "firstline", 9) == 0)
--- 8875,8881 ----
  	else
  	{
  	    arg = p;
! 	    while (ASCII_ISALNUM(*p) || *p == '_')
  		++p;
  	    if (arg == p || isdigit(*arg)
  		    || (p - arg == 9 && STRNCMP(arg, "firstline", 9) == 0)
*** ../vim-6.2.467/src/ex_docmd.c	Sun Apr  4 16:35:39 2004
--- src/ex_docmd.c	Tue Apr 13 15:40:49 2004
***************
*** 126,132 ****
  #endif
  
  static int	check_more __ARGS((int, int));
! static linenr_T get_address __ARGS((char_u **, int skip, int otherfile));
  static char_u	*invalid_range __ARGS((exarg_T *eap));
  static void	correct_range __ARGS((exarg_T *eap));
  static char_u	*repl_cmdline __ARGS((exarg_T *eap, char_u *src, int srclen, char_u *repl, char_u **cmdlinep));
--- 126,132 ----
  #endif
  
  static int	check_more __ARGS((int, int));
! static linenr_T get_address __ARGS((char_u **, int skip, int to_other_file));
  static char_u	*invalid_range __ARGS((exarg_T *eap));
  static void	correct_range __ARGS((exarg_T *eap));
  static char_u	*repl_cmdline __ARGS((exarg_T *eap, char_u *src, int srclen, char_u *repl, char_u **cmdlinep));
***************
*** 3588,3597 ****
   * Return MAXLNUM when no Ex address was found.
   */
      static linenr_T
! get_address(ptr, skip, otherfile)
      char_u	**ptr;
      int		skip;	    /* only skip the address, don't use it */
!     int		otherfile;  /* flag: may jump to other file */
  {
      int		c;
      int		i;
--- 3586,3595 ----
   * Return MAXLNUM when no Ex address was found.
   */
      static linenr_T
! get_address(ptr, skip, to_other_file)
      char_u	**ptr;
      int		skip;	    /* only skip the address, don't use it */
!     int		to_other_file;  /* flag: may jump to other file */
  {
      int		c;
      int		i;
***************
*** 3629,3635 ****
  			{
  			    /* Only accept a mark in another file when it is
  			     * used by itself: ":'M". */
! 			    fp = getmark(*cmd, otherfile && cmd[1] == NUL);
  			    ++cmd;
  			    if (fp == (pos_T *)-1)
  				/* Jumped to another file. */
--- 3627,3633 ----
  			{
  			    /* Only accept a mark in another file when it is
  			     * used by itself: ":'M". */
! 			    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);
  			    ++cmd;
  			    if (fp == (pos_T *)-1)
  				/* Jumped to another file. */
*** ../vim-6.2.467/src/ex_eval.c	Mon Mar 29 14:32:19 2004
--- src/ex_eval.c	Tue Apr 13 15:44:50 2004
***************
*** 147,154 ****
   * set to TRUE, if a later but severer message should be used instead.
   */
      int
! cause_errthrow(msg, severe, ignore)
!     char_u	*msg;
      int		severe;
      int		*ignore;
  {
--- 147,154 ----
   * set to TRUE, if a later but severer message should be used instead.
   */
      int
! cause_errthrow(mesg, severe, ignore)
!     char_u	*mesg;
      int		severe;
      int		*ignore;
  {
***************
*** 197,203 ****
       * interrupt exception is catchable by the innermost try conditional and
       * not replaced by an interrupt message error exception.
       */
!     if (msg == (char_u *)_(e_interr))
      {
  	*ignore = TRUE;
  	return TRUE;
--- 197,203 ----
       * interrupt exception is catchable by the innermost try conditional and
       * not replaced by an interrupt message error exception.
       */
!     if (mesg == (char_u *)_(e_interr))
      {
  	*ignore = TRUE;
  	return TRUE;
***************
*** 265,271 ****
  	    }
  	    else
  	    {
! 		elem->msg = vim_strsave(msg);
  		if (elem->msg == NULL)
  		{
  		    vim_free(elem);
--- 265,271 ----
  	    }
  	    else
  	    {
! 		elem->msg = vim_strsave(mesg);
  		if (elem->msg == NULL)
  		{
  		    vim_free(elem);
***************
*** 420,426 ****
      char_u	*cmdname;
  {
      except_T	*excp;
!     char_u	*p, *msg, *val;
      int		cmdlen;
  
      /*
--- 420,426 ----
      char_u	*cmdname;
  {
      except_T	*excp;
!     char_u	*p, *mesg, *val;
      int		cmdlen;
  
      /*
***************
*** 448,459 ****
  	/* Store the original message and prefix the exception value with
  	 * "Vim:" or, if a command name is given, "Vim(cmdname):". */
  	excp->messages = (struct msglist *)value;
! 	msg = excp->messages->throw_msg;
  	if (cmdname != NULL && *cmdname != NUL)
  	{
  	    cmdlen = STRLEN(cmdname);
  	    excp->value = vim_strnsave((char_u *)"Vim(",
! 					   4 + cmdlen + 2 + (int)STRLEN(msg));
  	    if (excp->value == NULL)
  		goto nomem;
  	    STRCPY(&excp->value[4], cmdname);
--- 448,459 ----
  	/* Store the original message and prefix the exception value with
  	 * "Vim:" or, if a command name is given, "Vim(cmdname):". */
  	excp->messages = (struct msglist *)value;
! 	mesg = excp->messages->throw_msg;
  	if (cmdname != NULL && *cmdname != NUL)
  	{
  	    cmdlen = STRLEN(cmdname);
  	    excp->value = vim_strnsave((char_u *)"Vim(",
! 					   4 + cmdlen + 2 + (int)STRLEN(mesg));
  	    if (excp->value == NULL)
  		goto nomem;
  	    STRCPY(&excp->value[4], cmdname);
***************
*** 462,468 ****
  	}
  	else
  	{
! 	    excp->value = vim_strnsave((char_u *)"Vim:", 4 + (int)STRLEN(msg));
  	    if (excp->value == NULL)
  		goto nomem;
  	    val = excp->value + 4;
--- 462,468 ----
  	}
  	else
  	{
! 	    excp->value = vim_strnsave((char_u *)"Vim:", 4 + (int)STRLEN(mesg));
  	    if (excp->value == NULL)
  		goto nomem;
  	    val = excp->value + 4;
***************
*** 471,477 ****
  	/* msg_add_fname may have been used to prefix the message with a file
  	 * name in quotes.  In the exception value, put the file name in
  	 * parentheses and move it to the end. */
! 	for (p = msg; ; p++)
  	{
  	    if (*p == NUL || (*p == 'E' &&
  			isdigit(p[1]) &&
--- 471,477 ----
  	/* msg_add_fname may have been used to prefix the message with a file
  	 * name in quotes.  In the exception value, put the file name in
  	 * parentheses and move it to the end. */
! 	for (p = mesg; ; p++)
  	{
  	    if (*p == NUL || (*p == 'E' &&
  			isdigit(p[1]) &&
***************
*** 479,497 ****
  					 (p[3] == ':' || (isdigit(p[3]) &&
  							  p[4] == ':'))))))
  	    {
! 		if (*p == NUL || p == msg)  /* 'E123' missing or at beginning */
! 		    STRCAT(val, msg);
  		else
  		{
  		    /* '"filename" E123: message text' */
! 		    if (msg[0] != '"' || p-2 < &msg[1] ||
  			    p[-2] != '"' || p[-1] != ' ')
  			/* "E123:" is part of the file name. */
  			continue;
  
  		    STRCAT(val, p);
  		    p[-2] = NUL;
! 		    sprintf((char *)(val + STRLEN(p)), " (%s)", &msg[1]);
  		    p[-2] = '"';
  		}
  		break;
--- 479,497 ----
  					 (p[3] == ':' || (isdigit(p[3]) &&
  							  p[4] == ':'))))))
  	    {
! 		if (*p == NUL || p == mesg)  /* 'E123' missing or at beginning */
! 		    STRCAT(val, mesg);
  		else
  		{
  		    /* '"filename" E123: message text' */
! 		    if (mesg[0] != '"' || p-2 < &mesg[1] ||
  			    p[-2] != '"' || p[-1] != ' ')
  			/* "E123:" is part of the file name. */
  			continue;
  
  		    STRCAT(val, p);
  		    p[-2] = NUL;
! 		    sprintf((char *)(val + STRLEN(p)), " (%s)", &mesg[1]);
  		    p[-2] = '"';
  		}
  		break;
***************
*** 696,702 ****
      int		pending;
      void	*value;
  {
!     char_u	*msg;
      char	*s;
      int		save_msg_silent;
  
--- 696,702 ----
      int		pending;
      void	*value;
  {
!     char_u	*mesg;
      char	*s;
      int		save_msg_silent;
  
***************
*** 704,717 ****
      switch (action)
      {
  	case RP_MAKE:
! 	    msg = (char_u *)_("%s made pending");
  	    break;
  	case RP_RESUME:
! 	    msg = (char_u *)_("%s resumed");
  	    break;
  	/* case RP_DISCARD: */
  	default:
! 	    msg = (char_u *)_("%s discarded");
  	    break;
      }
  
--- 704,717 ----
      switch (action)
      {
  	case RP_MAKE:
! 	    mesg = (char_u *)_("%s made pending");
  	    break;
  	case RP_RESUME:
! 	    mesg = (char_u *)_("%s resumed");
  	    break;
  	/* case RP_DISCARD: */
  	default:
! 	    mesg = (char_u *)_("%s discarded");
  	    break;
      }
  
***************
*** 737,745 ****
  	default:
  	    if (pending & CSTP_THROW)
  	    {
! 		sprintf((char *)IObuff, (char *)msg, _("Exception"));
! 		msg = vim_strnsave(IObuff, (int)STRLEN(IObuff) + 4);
! 		STRCAT(msg, ": %s");
  		s = (char *)((except_T *)value)->value;
  	    }
  	    else if ((pending & CSTP_ERROR) && (pending & CSTP_INTERRUPT))
--- 737,745 ----
  	default:
  	    if (pending & CSTP_THROW)
  	    {
! 		sprintf((char *)IObuff, (char *)mesg, _("Exception"));
! 		mesg = vim_strnsave(IObuff, (int)STRLEN(IObuff) + 4);
! 		STRCAT(mesg, ": %s");
  		s = (char *)((except_T *)value)->value;
  	    }
  	    else if ((pending & CSTP_ERROR) && (pending & CSTP_INTERRUPT))
***************
*** 755,761 ****
  	msg_silent = FALSE;	/* display messages */
      ++no_wait_return;
      msg_scroll = TRUE;		/* always scroll up, don't overwrite */
!     msg_str(msg, (char_u *)s);
      msg_puts((char_u *)"\n");   /* don't overwrite this either */
      cmdline_row = msg_row;
      --no_wait_return;
--- 755,761 ----
  	msg_silent = FALSE;	/* display messages */
      ++no_wait_return;
      msg_scroll = TRUE;		/* always scroll up, don't overwrite */
!     msg_str(mesg, (char_u *)s);
      msg_puts((char_u *)"\n");   /* don't overwrite this either */
      cmdline_row = msg_row;
      --no_wait_return;
***************
*** 765,771 ****
      if (pending == CSTP_RETURN)
  	vim_free(s);
      else if (pending & CSTP_THROW)
! 	vim_free(msg);
  }
  
  /*
--- 765,771 ----
      if (pending == CSTP_RETURN)
  	vim_free(s);
      else if (pending & CSTP_THROW)
! 	vim_free(mesg);
  }
  
  /*
*** ../vim-6.2.467/src/if_cscope.c	Thu Apr  1 13:01:12 2004
--- src/if_cscope.c	Tue Apr 13 16:07:15 2004
***************
*** 1358,1374 ****
   * find cscope command in command table
   */
      static cscmd_T *
! cs_lookup_cmd(exp)
!     exarg_T *exp;
  {
      cscmd_T *cmdp;
      char *stok;
      size_t len;
  
!     if (exp->arg == NULL)
  	return NULL;
  
!     if ((stok = strtok((char *)(exp->arg), (const char *)" ")) == NULL)
  	return NULL;
  
      len = strlen(stok);
--- 1358,1374 ----
   * find cscope command in command table
   */
      static cscmd_T *
! cs_lookup_cmd(eap)
!     exarg_T *eap;
  {
      cscmd_T *cmdp;
      char *stok;
      size_t len;
  
!     if (eap->arg == NULL)
  	return NULL;
  
!     if ((stok = strtok((char *)(eap->arg), (const char *)" ")) == NULL)
  	return NULL;
  
      len = strlen(stok);
*** ../vim-6.2.467/src/fold.c	Wed Mar  3 21:08:15 2004
--- src/fold.c	Tue Apr 13 16:11:28 2004
***************
*** 1273,1279 ****
      if (foldmethodIsDiff(curwin) && curwin->w_p_scb)
      {
  	win_T	    *wp;
! 	linenr_T    lnum;
  
  	/*
  	 * Do the same operation in other windows in diff mode.  Calculate the
--- 1273,1279 ----
      if (foldmethodIsDiff(curwin) && curwin->w_p_scb)
      {
  	win_T	    *wp;
! 	linenr_T    dlnum;
  
  	/*
  	 * Do the same operation in other windows in diff mode.  Calculate the
***************
*** 1283,1291 ****
  	{
  	    if (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)
  	    {
! 		lnum = diff_lnum_win(curwin->w_cursor.lnum, wp);
! 		if (lnum != 0)
! 		    (void)setManualFoldWin(wp, lnum, opening, recurse, NULL);
  	    }
  	}
      }
--- 1283,1291 ----
  	{
  	    if (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)
  	    {
! 		dlnum = diff_lnum_win(curwin->w_cursor.lnum, wp);
! 		if (dlnum != 0)
! 		    (void)setManualFoldWin(wp, dlnum, opening, recurse, NULL);
  	    }
  	}
      }
*** ../vim-6.2.467/src/option.c	Mon Apr  5 19:51:11 2004
--- src/option.c	Tue Apr 13 16:09:31 2004
***************
*** 4975,4988 ****
      else if (gvarp == &p_mps)
      {
  	/* Check for "x:y,x:y" */
! 	for (p = *varp; *p; p += 4)
  	{
! 	    if (!p[0] || p[1] != ':' || !p[2] || (p[3] && p[3] != ','))
  	    {
  		errmsg = e_invarg;
  		break;
  	    }
! 	    if (!p[3])
  		break;
  	}
      }
--- 4987,5000 ----
      else if (gvarp == &p_mps)
      {
  	/* Check for "x:y,x:y" */
! 	for (p = *varp; *p != NUL; p += 4)
  	{
! 	    if (p[1] != ':' || p[2] == NUL || (p[3] != NUL && p[3] != ','))
  	    {
  		errmsg = e_invarg;
  		break;
  	    }
! 	    if (p[3] == NUL)
  		break;
  	}
      }
***************
*** 5629,5636 ****
      {
  	if (p_csqf != NULL)
  	{
! 	    char_u *p = p_csqf;
! 
  	    while (*p != NUL)
  	    {
  		if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL
--- 5641,5647 ----
      {
  	if (p_csqf != NULL)
  	{
! 	    p = p_csqf;
  	    while (*p != NUL)
  	    {
  		if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL
***************
*** 6308,6314 ****
      else if ((int *)varp == &p_acd)
      {
  	if (p_acd && curbuf->b_ffname != NULL
! 		&& vim_chdirfile(curbuf->b_ffname) == OK)
  	    shorten_fnames(TRUE);
      }
  #endif
--- 6319,6325 ----
      else if ((int *)varp == &p_acd)
      {
  	if (p_acd && curbuf->b_ffname != NULL
! 				     && vim_chdirfile(curbuf->b_ffname) == OK)
  	    shorten_fnames(TRUE);
      }
  #endif
***************
*** 6765,6771 ****
      {
  	if (errbuf != NULL)
  	{
! 	    sprintf((char *)errbuf, _("E593: Need at least %d lines"), min_rows());
  	    errmsg = errbuf;
  	}
  	Rows = min_rows();
--- 6776,6783 ----
      {
  	if (errbuf != NULL)
  	{
! 	    sprintf((char *)errbuf, _("E593: Need at least %d lines"),
! 								  min_rows());
  	    errmsg = errbuf;
  	}
  	Rows = min_rows();
***************
*** 6774,6780 ****
      {
  	if (errbuf != NULL)
  	{
! 	    sprintf((char *)errbuf, _("E594: Need at least %d columns"), MIN_COLUMNS);
  	    errmsg = errbuf;
  	}
  	Columns = MIN_COLUMNS;
--- 6786,6793 ----
      {
  	if (errbuf != NULL)
  	{
! 	    sprintf((char *)errbuf, _("E594: Need at least %d columns"),
! 								 MIN_COLUMNS);
  	    errmsg = errbuf;
  	}
  	Columns = MIN_COLUMNS;
*** ../vim-6.2.467/src/os_unix.c	Fri Apr  2 14:41:35 2004
--- src/os_unix.c	Tue Apr 13 16:13:28 2004
***************
*** 3743,3749 ****
  			if (has_mbyte)
  			{
  			    int		l;
- 			    char_u	*p;
  
  			    /* Check if the last character in buffer[] is
  			     * incomplete, keep these bytes for the next
--- 3743,3748 ----
***************
*** 4309,4320 ****
  	if (msec > 0)
  	{
  # ifdef USE_START_TV
! 	    struct timeval  tv;
  
  	    /* Compute remaining wait time. */
! 	    gettimeofday(&tv, NULL);
! 	    msec -= (tv.tv_sec - start_tv.tv_sec) * 1000L
! 				    + (tv.tv_usec - start_tv.tv_usec) / 1000L;
  # else
  	    /* Guess we got interrupted halfway. */
  	    msec = msec / 2;
--- 4308,4319 ----
  	if (msec > 0)
  	{
  # ifdef USE_START_TV
! 	    struct timeval  mtv;
  
  	    /* Compute remaining wait time. */
! 	    gettimeofday(&mtv, NULL);
! 	    msec -= (mtv.tv_sec - start_tv.tv_sec) * 1000L
! 				   + (mtv.tv_usec - start_tv.tv_usec) / 1000L;
  # else
  	    /* Guess we got interrupted halfway. */
  	    msec = msec / 2;
*** ../vim-6.2.467/src/quickfix.c	Sun Feb 15 13:04:14 2004
--- src/quickfix.c	Tue Apr 13 16:14:07 2004
***************
*** 87,93 ****
  };
  
  static void	qf_new_list __ARGS((void));
! static int	qf_add_entry __ARGS((struct qf_line **prevp, char_u *dir, char_u *fname, char_u *msg, long lnum, int col, int virt_col, int nr, int type, int valid));
  static void	qf_msg __ARGS((void));
  static void	qf_free __ARGS((int idx));
  static char_u	*qf_types __ARGS((int, int));
--- 87,93 ----
  };
  
  static void	qf_new_list __ARGS((void));
! static int	qf_add_entry __ARGS((struct qf_line **prevp, char_u *dir, char_u *fname, char_u *mesg, long lnum, int col, int virt_col, int nr, int type, int valid));
  static void	qf_msg __ARGS((void));
  static void	qf_free __ARGS((int idx));
  static char_u	*qf_types __ARGS((int, int));
***************
*** 677,687 ****
   * Returns OK or FAIL.
   */
      static int
! qf_add_entry(prevp, dir, fname, msg, lnum, col, virt_col, nr, type, valid)
      struct qf_line **prevp;	/* pointer to previously added entry or NULL */
      char_u	*dir;		/* optional directory name */
      char_u	*fname;		/* file name or NULL */
!     char_u	*msg;		/* message */
      long	lnum;		/* line number */
      int		col;		/* column */
      int		virt_col;	/* using virtual column */
--- 677,687 ----
   * Returns OK or FAIL.
   */
      static int
! qf_add_entry(prevp, dir, fname, mesg, lnum, col, virt_col, nr, type, valid)
      struct qf_line **prevp;	/* pointer to previously added entry or NULL */
      char_u	*dir;		/* optional directory name */
      char_u	*fname;		/* file name or NULL */
!     char_u	*mesg;		/* message */
      long	lnum;		/* line number */
      int		col;		/* column */
      int		virt_col;	/* using virtual column */
***************
*** 695,701 ****
  								      == NULL)
  	return FAIL;
      qfp->qf_fnum = qf_get_fnum(dir, fname);
!     if ((qfp->qf_text = vim_strsave(msg)) == NULL)
      {
  	vim_free(qfp);
  	return FAIL;
--- 695,701 ----
  								      == NULL)
  	return FAIL;
      qfp->qf_fnum = qf_get_fnum(dir, fname);
!     if ((qfp->qf_text = vim_strsave(mesg)) == NULL)
      {
  	vim_free(qfp);
  	return FAIL;
***************
*** 2163,2171 ****
  	{
  	    copy_option_part(&p, NameBuff, MAXPATHL, ",");
  
! 	    /* Find all "doc / *.txt" files in this directory. */
  	    add_pathsep(NameBuff);
! 	    STRCAT(NameBuff, "doc/*.txt");
  	    if (gen_expand_wildcards(1, &NameBuff, &fcount,
  					     &fnames, EW_FILE|EW_SILENT) == OK
  		    && fcount > 0)
--- 2163,2171 ----
  	{
  	    copy_option_part(&p, NameBuff, MAXPATHL, ",");
  
! 	    /* Find all "*.txt" and "*.??x" files in the "doc" directory. */
  	    add_pathsep(NameBuff);
! 	    STRCAT(NameBuff, "doc/*.\\(txt\\|??x\\)");
  	    if (gen_expand_wildcards(1, &NameBuff, &fcount,
  					     &fnames, EW_FILE|EW_SILENT) == OK
  		    && fcount > 0)
*** ../vim-6.2.467/src/regexp.c	Mon Apr  5 22:14:07 2004
--- src/regexp.c	Tue Apr 13 16:15:41 2004
***************
*** 2045,2051 ****
  		    if (enc_utf8)
  		    {
  			int	off;
! 			int	len;
  
  			/* Need to get composing character too, directly
  			 * access regparse for that, because skipchr() skips
--- 2045,2051 ----
  		    if (enc_utf8)
  		    {
  			int	off;
! 			int	l;
  
  			/* Need to get composing character too, directly
  			 * access regparse for that, because skipchr() skips
***************
*** 2057,2067 ****
  			    off = 0;
  			for (;;)
  			{
! 			    len = utf_ptr2len_check(regparse + off);
  			    if (!UTF_COMPOSINGLIKE(regparse + off,
! 							regparse + off + len))
  				break;
! 			    off += len;
  			    regmbc(utf_ptr2char(regparse + off));
  			}
  			skipchr();
--- 2057,2067 ----
  			    off = 0;
  			for (;;)
  			{
! 			    l = utf_ptr2len_check(regparse + off);
  			    if (!UTF_COMPOSINGLIKE(regparse + off,
! 							  regparse + off + l))
  				break;
! 			    off += l;
  			    regmbc(utf_ptr2char(regparse + off));
  			}
  			skipchr();
*** ../vim-6.2.467/src/version.c	Wed Apr 14 10:43:29 2004
--- src/version.c	Wed Apr 14 10:46:18 2004
***************
*** 639,640 ****
--- 639,642 ----
  {   /* Add new patch number below this line */
+ /**/
+     468,
  /**/

-- 
       [Autumn changed into Winter ... Winter changed into Spring ...  Spring
       changed back into Autumn and Autumn gave Winter and Spring a miss and
       went straight on into Summer ...  Until one day ...]
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        Sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\              Project leader for A-A-P -- http://www.A-A-P.org        ///
 \\\  Buy at Amazon and help AIDS victims -- http://ICCF.nl/click1.html ///
