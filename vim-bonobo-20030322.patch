diff --new-file -u -r --exclude-from=excludelist vimcopy/src/Make_container.mak vim/src/Make_container.mak
--- vimcopy/src/Make_container.mak	Wed Dec 31 18:00:00 1969
+++ vim/src/Make_container.mak	Fri Mar 21 23:22:33 2003
@@ -0,0 +1,11 @@
+gnomeccFlags = `pkg-config --cflags libgnomeui-2.0 libgnome-2.0`
+ccFlags = -g -c ${gnomeccFlags}
+ldFlags = `pkg-config --libs libgnomeui-2.0 libgnome-2.0`
+
+all: container
+
+container: container.o
+	gcc -o container ${ldFlags} container.o
+
+%.o: %.c
+	gcc ${ccFlags} $< -o $@
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/Makefile vim/src/Makefile
--- vimcopy/src/Makefile	Fri Mar 21 23:08:10 2003
+++ vim/src/Makefile	Sat Mar 22 11:07:26 2003
@@ -1268,6 +1268,9 @@
 	objects/term.o \
 	objects/ui.o \
 	objects/undo.o \
+ 	objects/vim_bonobo_main.o \
+ 	objects/vim_bonobo_factory.o \
+ 	objects/vim_bonobo_control.o \
 	objects/window.o \
 	$(GUI_OBJ) \
 	$(PERL_OBJ) \
@@ -1277,7 +1280,7 @@
 	$(OS_EXTRA_OBJ) \
 	$(WORKSHOP_OBJ) \
 	$(NETBEANS_OBJ) \
-	$(WSDEBUG_OBJ)
+ 	$(WSDEBUG_OBJ)
 
 PRO_AUTO = \
 	buffer.pro \
@@ -2194,6 +2197,15 @@
 
 objects/undo.o: undo.c
 	$(CCC) -o $@ undo.c
+
+objects/vim_bonobo_control.o: vim_bonobo_control.c
+	$(CCC) -o $@ vim_bonobo_control.c
+
+objects/vim_bonobo_factory.o: vim_bonobo_factory.c
+	$(CCC) -o $@ vim_bonobo_factory.c
+
+objects/vim_bonobo_main.o: vim_bonobo_main.c
+	$(CCC) -o $@ vim_bonobo_main.c
 
 objects/window.o: window.c
 	$(CCC) -o $@ window.c
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/Vim_Control.server vim/src/Vim_Control.server
--- vimcopy/src/Vim_Control.server	Wed Dec 31 18:00:00 1969
+++ vim/src/Vim_Control.server	Fri Mar 21 23:22:33 2003
@@ -0,0 +1,34 @@
+<oaf_info>
+
+<oaf_server iid="OAFIID:Vim_Control_Factory" type="exe" location="/home/jdhildeb/projects/gnome-vim/vim/src/vim">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/GenericFactory:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control factory"/>
+  <oaf_attribute name="description" type="string" value="Vim Control factory"/>
+</oaf_server>
+
+<oaf_server iid="OAFIID:Vim_Control" type="factory"
+ location="OAFIID:Vim_Control_Factory">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/Unknown:1.0"/>
+    <item value="IDL:Bonobo/Control:1.0"/>
+    <item value="IDL:Bonobo/ItemContainer:1.0"/>
+    <item value="IDL:Bonobo/PersistStream:1.0"/>
+    <item value="IDL:Bonobo/PersistFile:1.0"/>
+    <item value="IDL:Bonobo/Persist:1.0"/>
+    <item value="IDL:Nautilus/View:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control"/>
+  <oaf_attribute name="description" type="string" value="Vim Control"/>
+  <oaf_attribute name="bonobo:editable" type="boolean" value="false"/>
+  <oaf_attribute name="bonobo:supported_mime_types" type="stringv">
+    <item value="text/plain"/>
+    <item value="text/*"/>
+  </oaf_attribute>
+  <oaf_attribute name="nautilus:view_as_name" type="string" value="Text"/>
+  <oaf_attribute name="nautilus:view_as_label" type="string" value="View/Edit in Vim"/>
+  <oaf_attribute name="nautilus:viewer_label" type="string" value="Vim"/>
+</oaf_server>
+
+</oaf_info>
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/config.h.in vim/src/config.h.in
--- vimcopy/src/config.h.in	Fri Mar 21 23:15:56 2003
+++ vim/src/config.h.in	Fri Mar 21 23:22:33 2003
@@ -314,6 +314,9 @@
 /* Define if GTK+ multihead support is available (requires GTK+ >= 2.1.1). */
 #undef HAVE_GTK_MULTIHEAD
 
+/* Define if you want component (i.e. Bonobo) support. */
+#undef FEAT_GUI_COMPONENT
+ 
 /* Define if your X has own locale library */
 #undef X_LOCALE
 
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/configure.in vim/src/configure.in
--- vimcopy/src/configure.in	Fri Mar 21 23:15:56 2003
+++ vim/src/configure.in	Fri Mar 21 23:22:33 2003
@@ -1091,9 +1091,9 @@
     AC_MSG_CHECKING(for libgnomeui-2.0)
     if $PKG_CONFIG --exists libgnomeui-2.0; then
       AC_MSG_RESULT(yes)
-      GNOME_LIBS=`$PKG_CONFIG --libs-only-l libgnomeui-2.0`
-      GNOME_LIBDIR=`$PKG_CONFIG --libs-only-L libgnomeui-2.0`
-      GNOME_INCLUDEDIR=`$PKG_CONFIG --cflags libgnomeui-2.0`
+      GNOME_LIBS=`$PKG_CONFIG --libs-only-l libgnomeui-2.0 libnautilus`
+      GNOME_LIBDIR=`$PKG_CONFIG --libs-only-L libgnomeui-2.0 libnautilus`
+      GNOME_INCLUDEDIR=`$PKG_CONFIG --cflags libgnomeui-2.0 libnautilus`
       $1
     else
       AC_MSG_RESULT(not found)
@@ -1241,6 +1241,20 @@
 	  AC_DEFINE(FEAT_GUI_GNOME)
 	  GUI_INC_LOC="$GUI_INC_LOC $GNOME_INCLUDEDIR"
 	  GTK_LIBNAME="$GTK_LIBNAME $GNOME_LIBDIR $GNOME_LIBS"
+          AC_MSG_CHECKING(whether or not to include bonobo support)
+          AC_ARG_ENABLE(bonobo,
+            [  --enable-bonobo         If using GNOME, enable bonobo support [default=no]],
+            , enable_bonobo="no")
+          if test "x$enable_bonobo" = "xno"; then
+            AC_MSG_RESULT($enable_bonobo);
+          else
+            if test "x$SKIP_BONOBO" != "xYES" -a $gtk_major_version -ge 2; then
+              AC_MSG_RESULT(yes);
+              AC_DEFINE(FEAT_GUI_COMPONENT) 
+            else
+              AC_MSG_RESULT(no (bonobo requires Gnome 2));
+            fi
+          fi
 	fi
       }
       fi
Binary files vimcopy/src/container and vim/src/container differ
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/container.c vim/src/container.c
--- vimcopy/src/container.c	Wed Dec 31 18:00:00 1969
+++ vim/src/container.c	Sat Mar 22 15:33:04 2003
@@ -0,0 +1,176 @@
+
+#include <bonobo.h>
+#include <glib.h>
+
+BonoboControlFrame  *ctrl_frame;
+BonoboUIComponent   *ui_comp;
+
+/* vbox */
+GtkWidget           *box;
+GtkWidget           *ctrl_widget;
+
+char * filename;
+
+static Bonobo_Control
+instantiate_control()
+{
+	Bonobo_Control control;
+	Bonobo_PersistFile pfile;
+	CORBA_Environment ev;
+
+	CORBA_exception_init (&ev);
+
+	/* get control component */
+	control = bonobo_get_object ("OAFIID:Vim_Control",
+				     "Bonobo/Control", &ev);
+	if (BONOBO_EX (&ev) || (control == CORBA_OBJECT_NIL))
+        exit(1);
+	
+#if 0
+	/* get PersistFile interface */
+    pfile = Bonobo_Unknown_queryInterface (control, "IDL:Bonobo/PersistFile:1.0", &ev);
+    if (BONOBO_EX (&ev) || (pfile == CORBA_OBJECT_NIL))
+    exit(1);
+	
+	/* load the file */
+    Bonobo_PersistFile_load (pfile, filename, &ev);
+	bonobo_object_release_unref (pfile, NULL);
+#endif
+    return control;
+}
+
+static void
+verb_FileNewWindow (BonoboUIComponent *uic, gpointer user_data, const char *cname)
+{
+    printf("Got New Window!\n");
+}
+
+static void
+verb_DoNothing (BonoboUIComponent *uic, gpointer user_data, const char *cname)
+{
+}
+
+static BonoboUIVerb app_verbs[] = {
+	BONOBO_UI_VERB ("FileNewWindow", verb_FileNewWindow),
+	BONOBO_UI_VERB ("FileOpen",      verb_DoNothing),
+	BONOBO_UI_VERB ("FileCloseWindow", verb_DoNothing),
+	BONOBO_UI_VERB ("FileExit",      verb_DoNothing),
+	BONOBO_UI_VERB ("Preferences",   verb_DoNothing),
+	BONOBO_UI_VERB ("HelpAbout",     verb_DoNothing),
+	BONOBO_UI_VERB ("Help",          verb_DoNothing),
+	BONOBO_UI_VERB ("DnDNewWindow",  verb_DoNothing),
+	BONOBO_UI_VERB ("DnDSameWindow", verb_DoNothing),
+	BONOBO_UI_VERB ("DnDCancel",     verb_DoNothing),
+	BONOBO_UI_VERB_END
+};
+
+static void 
+add_control_to_ui (BonoboWindow *window, Bonobo_Control control)
+{
+	CORBA_Environment ev;
+	Bonobo_PropertyControl prop_control;
+	BonoboUIContainer *ui_container;
+    char *curdir;
+
+	g_return_if_fail (window != NULL);
+	g_return_if_fail (BONOBO_IS_WINDOW (window));
+	
+	CORBA_exception_init (&ev);
+
+	ui_container = bonobo_window_get_ui_container (BONOBO_WINDOW (window));
+	ctrl_frame = bonobo_control_frame_new (BONOBO_OBJREF (ui_container));
+
+	/* bind and view new control widget */
+	bonobo_control_frame_bind_to_control (ctrl_frame, control, &ev);
+	bonobo_control_frame_control_activate (ctrl_frame);
+	if (control != CORBA_OBJECT_NIL && ctrl_widget == NULL) {
+		ctrl_widget = bonobo_control_frame_get_widget (ctrl_frame);
+		if (!ctrl_widget)
+			g_assert_not_reached ();
+
+        bonobo_window_set_contents (BONOBO_WINDOW(window), GTK_WIDGET(ctrl_widget));
+		gtk_widget_show (ctrl_widget);
+	}
+
+	ui_comp = bonobo_ui_component_new ("vim-container");
+	bonobo_ui_component_set_container (ui_comp, BONOBO_OBJREF (ui_container), NULL);
+
+    curdir = (char *)getcwd(NULL, 0);
+	bonobo_ui_util_set_ui (ui_comp, curdir, "vim-container.xml", "Vim", NULL);
+    free( curdir );
+    bonobo_ui_component_add_verb_list_with_data (ui_comp, app_verbs, window);
+
+	/* update sensitivity of the properties menu item */
+	prop_control = Bonobo_Unknown_queryInterface (control, 
+						      "IDL:Bonobo/PropertyControl:1.0", &ev);
+	bonobo_ui_component_set_prop (ui_comp,
+				      "/commands/Preferences",
+				      "sensitive",
+				      prop_control == CORBA_OBJECT_NIL ? "0" : "1",
+				      &ev);
+	
+	bonobo_object_release_unref (prop_control, &ev);
+
+	/* enable view menu */
+	/* FIXME: We should check if the component adds anything to 
+	 *        the menu, so that we don't view an empty menu.
+	 */
+	/*bonobo_ui_component_set_prop (ui_comp, "/menu/View", "hidden", "0", &ev);*/
+
+	CORBA_exception_free (&ev);
+
+	/* retrieve control properties and install listeners */
+	//check_for_control_properties (window);
+}
+
+static void
+window_destroyed (GtkWindow *window, char * data)
+{
+    Bonobo_Control control;
+    bonobo_control_frame_control_deactivate(ctrl_frame);
+    control = bonobo_control_frame_get_control(ctrl_frame);
+    bonobo_object_release_unref( control, NULL );
+    bonobo_main_quit();
+}
+
+int main(int argc, char * argv[] ) 
+{
+    BonoboWidget * bw;
+    BonoboWindow      *window;
+	BonoboUIEngine    *engine;
+	BonoboUIContainer *container;
+    Bonobo_Control    control;
+
+#if 0
+    if( argc <= 1 ) { 
+        fprintf(stderr, "%s: not enough args\n", argv[0] );
+        fprintf(stderr, "Usage: %s <image file>\n", argv[0]);
+        exit(1);
+    }
+    image_file = argv[1];
+#endif
+
+    bonobo_ui_init ("container", "1.0", &argc, argv);
+
+	if(gnome_vfs_init () == FALSE)
+		g_error (_("Could not initialize GnomeVFS!\n"));
+
+	window = BONOBO_WINDOW ( bonobo_window_new ("Window", "Vim Test Container"));
+
+    // instantiate a control
+    control = instantiate_control();
+    
+    // put it into our window
+    add_control_to_ui (window, control);
+
+    g_signal_connect (window, "destroy",
+          G_CALLBACK (window_destroyed),
+          &window);
+
+
+    gtk_widget_show_all( GTK_WIDGET( window ));
+
+    bonobo_main();
+
+    return 0;
+}
Binary files vimcopy/src/container.o and vim/src/container.o differ
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/ex_docmd.c vim/src/ex_docmd.c
--- vimcopy/src/ex_docmd.c	Fri Mar 21 23:05:42 2003
+++ vim/src/ex_docmd.c	Fri Mar 21 23:22:33 2003
@@ -4974,8 +4974,13 @@
     }
     else
     {
+#ifdef FEAT_GUI_COMPONENT
+        EMSG(_("E462: Quit not allowed from embedded component"));
+        not_exiting();
+        return;
+#endif
 #ifdef FEAT_WINDOWS
-	if (only_one_window())	    /* quit last window */
+        if (only_one_window()) 	    /* quit last window */
 #endif
 	    getout(0);
 #ifdef FEAT_WINDOWS
@@ -4996,8 +5001,12 @@
 ex_cquit(eap)
     exarg_T	*eap;
 {
+#ifdef FEAT_GUI_COMPONENT
+    EMSG(_("E462: Quit not allowed from embedded component"));
+    return;
+#endif
     getout(1);	/* this does not always pass on the exit code to the Manx
-		   compiler. why? */
+                   compiler. why? */
 }
 
 /*
@@ -5017,6 +5026,10 @@
 	return;
     }
 # endif
+#ifdef FEAT_GUI_COMPONENT
+    EMSG(_("E462: Quit not allowed from embedded component"));
+    return;
+#endif
     exiting = TRUE;
     if (eap->forceit || !check_changed_any(FALSE))
 	getout(0);
@@ -5211,8 +5224,13 @@
     }
     else
     {
+#ifdef FEAT_GUI_COMPONENT
+        EMSG(_("E462: Quit not allowed from embedded component"));
+        not_exiting();
+        return;
+#endif
 #ifdef FEAT_WINDOWS
-	if (only_one_window())	    /* quit last window, exit Vim */
+        if ( only_one_window())	    /* quit last window, exit Vim */
 #endif
 	    getout(0);
 #ifdef FEAT_WINDOWS
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/gui.c vim/src/gui.c
--- vimcopy/src/gui.c	Fri Mar 21 23:15:57 2003
+++ vim/src/gui.c	Fri Mar 21 23:22:33 2003
@@ -433,8 +433,12 @@
      * Create the GUI shell.
      */
     gui.in_use = TRUE;		/* Must be set after menus have been set up */
+#ifdef FEAT_GUI_COMPONENT
+    vim_bonobo_wait_for_instantiation();
+#else
     if (gui_mch_init() == FAIL)
 	goto error;
+#endif
 
     /* Avoid a delay for an error message that was printed in the terminal
      * where Vim was started. */
@@ -4022,8 +4026,8 @@
 
 #ifdef FEAT_GUI_GTK
 	/* Need to wake up the main loop */
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
+	if (MAIN_LEVEL() > 0)
+	    MAIN_QUIT();
 #endif
     }
 }
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/gui.h vim/src/gui.h
--- vimcopy/src/gui.h	Fri Mar 21 23:15:57 2003
+++ vim/src/gui.h	Fri Mar 21 23:30:43 2003
@@ -35,6 +35,21 @@
 # include <gtk/gtk.h>
 #endif
 
+# if defined(FEAT_GUI_GNOME) && defined(FEAT_GUI_COMPONENT)
+    #include "libbonoboui.h"
+    #include "vim_bonobo_main.h"
+    #include "vim_bonobo_factory.h"
+    #define MAIN vim_bonobo_main
+    #define MAIN_LEVEL vim_bonobo_main_level
+    #define MAIN_QUIT vim_bonobo_main_quit
+    #define MAIN_ITERATION_DO vim_bonobo_main_iteration_do
+# else
+    #define MAIN gtk_main
+    #define MAIN_LEVEL gtk_main_level
+    #define MAIN_QUIT gtk_main_quit
+    #define MAIN_ITERATION_DO gtk_main_iteration_do
+#endif
+
 #ifdef FEAT_GUI_BEOS
 # include "gui_beos.h"
 #endif
@@ -391,6 +406,10 @@
     GtkWidget	*toolbar;	    /* toolbar */
 # endif
 # ifdef FEAT_GUI_GNOME
+#  ifdef FEAT_GUI_COMPONENT
+    GtkVBox     *vbox;
+    BonoboControl *control;
+#  endif
     GtkWidget	*menubar_h;	    /* menubar handle */
     GtkWidget	*toolbar_h;	    /* toolbar handle */
 # endif
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/gui_gtk.c vim/src/gui_gtk.c
--- vimcopy/src/gui_gtk.c	Fri Mar 21 23:15:57 2003
+++ vim/src/gui_gtk.c	Fri Mar 21 23:22:33 2003
@@ -37,7 +37,7 @@
 
 #include "vim.h"
 
-#ifdef FEAT_GUI_GNOME
+#if 0
 /* Gnome redefines _() and N_().  Grrr... */
 # ifdef _
 #  undef _
@@ -414,6 +414,7 @@
     char_u      *actext;
     int         use_mnemonic;
 
+
     /* It would be neat to have image menu items, but that requires major
      * changes to Vim's menu system.  Not to mention that all the translations
      * had to be updated. */
@@ -570,12 +571,307 @@
 
 # endif /* !HAVE_GTK2 */
 
+#ifdef FEAT_GUI_COMPONENT
+
+
+static void
+verb_activate( BonoboUIComponent *uic, gpointer data, const char *cname )
+{
+    gui_menu_cb((vimmenu_T *) data);
+
+    /* make sure the menu action is taken immediately */
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
+}
+
+static void g_string_append_normalized_name( GString * dest, char_u * name )
+{
+    gchar * cur;
+
+    if( name == NULL ) 
+    {
+        return;
+    }
+    cur = name;
+    while( *cur != '\0' ) {
+        gunichar wc;
+        wc = g_utf8_get_char(cur);
+        if( g_unichar_isalnum( wc ) ) {
+            g_string_append_unichar( dest, wc );
+        }
+        cur = g_utf8_next_char(cur);
+    }
+}
+
+static
+char * menu_xml_path( vimmenu_T * menu, int only_parent )
+{
+    GString * normname;
+    GString * path;
+    char * retpath;
+    
+    normname = g_string_sized_new( 64 );
+    path = g_string_sized_new( 128 );
+    while( 1 ) {
+        if( menu_is_toolbar(menu->name) ) {
+            /* "Toolbar" is a standard Bonobo UI element, but Vim uses "ToolBar", so we
+             * have to check for this. */
+            g_string_prepend( path, "/Toolbar");
+        } else {
+            g_string_assign( normname, "" );
+            g_string_append_normalized_name( normname, menu->dname );
+            g_string_prepend( path, normname->str );
+            g_string_prepend( path, "/" );
+        }
+        if( menu->parent == NULL ) {
+            if( menu && menu_is_menubar( menu->name ) ) {
+                g_string_prepend( path, "/menu" );
+            }
+            break;
+        }
+        menu = menu->parent;
+    }
+    g_string_free( normname, TRUE );
+    retpath = path->str;
+    g_string_free( path, FALSE );
+
+    if( only_parent ) {
+        gchar * slash;
+        slash = g_strrstr(retpath, "/");
+        if( slash == retpath )
+            slash[1] = '\0';
+        else if( slash ) 
+            *slash = '\0';
+    }
+    return( retpath );
+}
+
+static char *
+gtk_image_to_xml_attrs( GtkImage * image)
+{
+    GString * xml = g_string_sized_new(32);
+    GtkImageType type = gtk_image_get_storage_type(image);
+    char * attrs;
+    char * imagexml;
+
+    if( type == GTK_IMAGE_STOCK ) {
+        GtkIconSize size;
+        GtkIconSet * iconset;
+        gchar * stockname;
+        GdkPixbuf * pixbuf;
+
+        gtk_image_get_stock(image, &stockname, &size);
+        pixbuf = gtk_widget_render_icon(gui.drawarea, stockname, size, NULL);
+        imagexml = bonobo_ui_util_pixbuf_to_xml(pixbuf);
+        g_string_append_printf(xml, " pixtype=\"pixbuf\" pixname=\"%s\"", imagexml);
+        g_object_unref(pixbuf);
+        g_free(imagexml);
+    } else if( type == GTK_IMAGE_PIXBUF ) {
+        imagexml = bonobo_ui_util_pixbuf_to_xml(gtk_image_get_pixbuf(image));
+        g_string_append_printf(xml, " pixtype=\"pixbuf\" pixname=\"%s\"", imagexml);
+        g_free(imagexml);
+    }
+    attrs = xml->str;
+    g_string_free(xml, FALSE);
+    return( attrs );
+}
+
+static
+void generate_gui_xml_recurse( vimmenu_T * menu, GString * xml, GSList ** commands, int do_siblings)
+{
+    GString * normname = g_string_sized_new(16);
+    GString * verbname = g_string_sized_new(32);
+    char_u * label;
+    int use_mnemonic;
+    BonoboUIComponent *uic;
+    gchar * command;
+
+    uic = bonobo_control_get_ui_component (BONOBO_CONTROL (gui.control));
+
+    while( menu ) 
+    {
+        use_mnemonic = (p_wak[0] != 'n' );
+        label = translate_mnemonic_tag( menu->name, use_mnemonic );
+        g_string_assign( normname, "" );
+        g_string_append_normalized_name( normname, menu->dname );
+        if( menu->children ) {
+            if( menu_is_toolbar( menu->name )) {
+                g_string_append( xml, "<dockitem name=\"Toolbar\" look=\"icon\" tips=\"1\">");
+                generate_gui_xml_recurse( menu->children, xml, commands, TRUE );
+                g_string_append( xml, "</dockitem>");
+            } else {
+                g_string_append_printf( xml, "<submenu name=\"%s\" label=\"%s\">\n", normname->str, label);
+
+                generate_gui_xml_recurse( menu->children, xml, commands, TRUE );
+                g_string_append( xml, "</submenu>\n");
+            }
+        } else if( menu_is_separator(menu->name)) {
+            g_string_append( xml, "<separator />\n" );
+        } else if( menu->parent && menu_is_toolbar(menu->parent->name)) {
+            char * menupath = menu_xml_path(menu, FALSE);
+            GtkImage *image = NULL;
+            char * imagexml;
+            char_u *tooltip;
+
+            g_string_assign(verbname, "");
+            g_string_append_normalized_name(verbname, menupath);
+            vim_free(menupath);
+            image = GTK_IMAGE(create_menu_icon(menu, GTK_ICON_SIZE_SMALL_TOOLBAR));
+            imagexml = gtk_image_to_xml_attrs(image);
+            tooltip = CONVERT_TO_UTF8(menu->strings[MENU_INDEX_TIP]);
+            g_string_append_printf( xml, "<toolitem name=\"%s\" label=\"%s\" verb=\"%s\" tip=\"%s\" %s />\n", normname->str, label, verbname->str, tooltip, imagexml);
+            gtk_object_sink(GTK_OBJECT(image));
+            g_free(imagexml);
+            CONVERT_TO_UTF8_FREE(tooltip);
+            
+            command = g_strdup_printf( "<cmd name=\"%s\" sensitive=\"%c\" />\n", verbname->str, menu->sensitive ? '1' : '0');
+            *commands = g_slist_prepend( *commands, command );
+            bonobo_ui_component_add_verb(uic, verbname->str, verb_activate, menu);
+        } else if( menu_is_menubar(menu->name)) {
+            char * menupath = menu_xml_path(menu, FALSE);
+
+            g_string_assign(verbname, "");
+            g_string_append_normalized_name(verbname, menupath);
+            vim_free(menupath);
+            
+            g_string_append_printf( xml, "<menuitem name=\"%s\" label=\"%s\" verb=\"%s\" />\n", normname->str, label, verbname->str);
+
+            command = g_strdup_printf( "<cmd name=\"%s\" sensitive=\"%c\" />\n", verbname->str, menu->sensitive ? '1' : '0');
+            *commands = g_slist_prepend( *commands, command );
+            bonobo_ui_component_add_verb(uic, verbname->str, verb_activate, menu);
+        }
+        if( label ) {
+            vim_free( label );
+        }
+        if( do_siblings ) {
+            menu = menu->next;
+        } else {
+            menu = NULL;
+        }
+    }
+    g_string_free( normname, TRUE );
+}
+
+static
+void set_gui_xml(vimmenu_T * menu)
+{
+    GSList * commands = NULL;
+    GSList * command;
+    BonoboUIComponent *uic;
+    GString * xml = g_string_sized_new(1024);
+    int path_exists;
+    uic = bonobo_control_get_ui_component (BONOBO_CONTROL (gui.control));
+
+    if( bonobo_ui_component_get_container(uic) == CORBA_OBJECT_NIL ) {
+        return;
+    }
+
+    while( menu ) {
+        if( menu->dirty ) {
+            if (menu_is_popup(menu->name)) {
+                /* do nothing */            
+            } else if( menu_is_menubar(menu->name)) {
+                char * menupath = menu_xml_path(menu, TRUE);
+                path_exists = bonobo_ui_component_path_exists(uic, menupath, NULL);
+                g_string_assign(xml, "");
+                generate_gui_xml_recurse (menu, xml, &commands, FALSE);
+                /*fprintf(stdout, "set %s\n", menupath);*/
+                /*fprintf(stdout, "set %s\n%s", menupath, xml->str);*/
+                /*fflush(stdout);*/
+                bonobo_ui_component_set(uic, menupath, xml->str, NULL);
+                g_free(menupath);
+            } else if( menu_is_toolbar(menu->name)) {
+                char * menupath = menu_xml_path(menu, TRUE);
+                path_exists = bonobo_ui_component_path_exists(uic, menupath, NULL);
+                g_string_assign(xml, "");
+                generate_gui_xml_recurse (menu, xml, &commands, FALSE);
+                /*fprintf(stdout, "set %s\n", menupath);*/
+                /*fprintf(stdout, "set %s\n%s", menupath, xml->str);*/
+                /*fflush(stdout);*/
+                bonobo_ui_component_set(uic, menupath, xml->str, NULL);
+                g_free(menupath);
+            }
+            menu->dirty = FALSE;
+        }
+        menu = menu->next;
+    }
+    /* the commands are inserted separately into a list, and set one by one,
+     * otherwise it's not possible to update a subtree of the UI 
+     */
+    command = commands;
+    while( command ) {
+        /*fprintf(stdout, "set %s\n%s", "/commands", command->data);
+        fflush(stdout);*/
+        bonobo_ui_component_set(uic, "/commands", command->data, NULL);
+        g_free(command->data);
+        command = command->next;
+    }
+    g_slist_free( commands );
+}
+
+static gboolean update_gui_idle_installed = FALSE;
+
+static gboolean
+update_gui_idle(gpointer data)
+{
+    BonoboUIComponent *uic;
+
+    uic = bonobo_control_get_ui_component (BONOBO_CONTROL (gui.control));
+    if( bonobo_ui_component_get_container(uic) == CORBA_OBJECT_NIL ) {
+        /* we aren't in a container yet; try again later... */
+        g_timeout_add(100, &update_gui_idle, NULL);
+        return FALSE;
+    }
+    bonobo_ui_component_freeze(uic, NULL);
+    set_gui_xml( (vimmenu_T *)root_menu );
+    update_gui_idle_installed = FALSE;
+    bonobo_ui_component_thaw(uic, NULL);
+    return FALSE; /* don't call me again */
+}
+
+void
+update_menu_later(vimmenu_T *menu)
+{
+    if (!update_gui_idle_installed)
+    {
+        update_gui_idle_installed = TRUE;
+        g_idle_add_full(GDK_PRIORITY_EVENTS + 10,
+                        &update_gui_idle, NULL, NULL);
+    }
+    while( menu->parent ) 
+        menu = menu->parent;
+    menu->dirty = TRUE;
+}
+
+void update_ui_later()
+{
+    vimmenu_T *menu = root_menu;
+
+    if (!update_gui_idle_installed)
+    {
+        update_gui_idle_installed = TRUE;
+        g_idle_add_full(GDK_PRIORITY_EVENTS + 10,
+                        &update_gui_idle, NULL, NULL);
+    }
+    while( menu ) {
+        menu->dirty = TRUE;
+        menu = menu->next;
+    }
+}
+#endif
+
+
 /*ARGSUSED*/
     void
 gui_mch_add_menu(vimmenu_T *menu, int idx)
 {
+#ifdef FEAT_GUI_COMPONENT
+    update_menu_later(menu);
+    return;
+#else
     vimmenu_T	*parent = menu->parent;
 
+
     if (menu_is_popup(menu->name))
     {
 	menu->submenu_id = gtk_menu_new();
@@ -626,6 +922,7 @@
     if (vim_strchr(p_go, GO_TEAROFF) != NULL)
 	gtk_widget_show(menu->tearoff_handle);
     gtk_menu_prepend(GTK_MENU(menu->submenu_id), menu->tearoff_handle);
+#endif
 }
 
 /*ARGSUSED*/
@@ -635,8 +932,8 @@
     gui_menu_cb((vimmenu_T *) data);
 
     /* make sure the menu action is taken immediately */
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 # if defined(FEAT_TOOLBAR) && !defined(HAVE_GTK2)
@@ -742,6 +1039,10 @@
     void
 gui_mch_add_menu_item(vimmenu_T *menu, int idx)
 {
+#ifdef FEAT_GUI_COMPONENT
+    update_menu_later(menu);
+    return;
+#else
     vimmenu_T *parent;
 
     parent = menu->parent;
@@ -844,6 +1145,7 @@
             gtk_signal_connect(GTK_OBJECT(menu->id), "activate",
                                GTK_SIGNAL_FUNC(menu_item_activate), menu);
     }
+#endif
 }
 #endif /* FEAT_MENU */
 
@@ -867,6 +1169,10 @@
     vimmenu_T   *menu;
     char_u      *name;
 
+#ifdef FEAT_GUI_COMPONENT
+    return;
+#endif
+
     for (menu = root_menu; menu != NULL; menu = menu->next)
     {
         if (menu->id == NULL)
@@ -981,6 +1287,9 @@
     void
 gui_mch_toggle_tearoffs(int enable)
 {
+#ifdef FEAT_GUI_COMPONENT
+    return;
+#endif
     recurse_tearoffs(root_menu, enable);
 }
 #endif /* FEAT_MENU */
@@ -1055,6 +1364,9 @@
     void
 gui_mch_menu_set_tip(vimmenu_T *menu)
 {
+#ifdef FEAT_GUI_COMPONENT
+    return;
+#endif
     if (menu->id != NULL && menu->parent != NULL &&
         gui.toolbar != NULL && menu_is_toolbar(menu->parent->name))
     {
@@ -1082,6 +1394,9 @@
     void
 gui_mch_destroy_menu(vimmenu_T *menu)
 {
+#ifdef FEAT_GUI_COMPONENT
+    return;
+#endif
 # ifdef FEAT_TOOLBAR
     if (menu->parent != NULL && menu_is_toolbar(menu->parent->name))
     {
@@ -1184,8 +1499,8 @@
 
     gui_drag_scrollbar(sb, value, dragging);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /* SBAR_VERT or SBAR_HORIZ */
@@ -1244,8 +1559,8 @@
     vw->browse_fname = (char_u *)g_strdup(gtk_file_selection_get_filename(
 					GTK_FILE_SELECTION(vw->filedlg)));
     gtk_widget_hide(vw->filedlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*ARGSUSED*/
@@ -1260,8 +1575,8 @@
 	vw->browse_fname = NULL;
     }
     gtk_widget_hide(vw->filedlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*ARGSUSED*/
@@ -1275,8 +1590,8 @@
     }
     gui.filedlg = NULL;
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 
     return FALSE;
 }
@@ -1359,7 +1674,7 @@
 
     gtk_widget_show(gui.filedlg);
     while (gui.filedlg && GTK_WIDGET_DRAWABLE(gui.filedlg))
-	gtk_main_iteration_do(TRUE);
+	MAIN_ITERATION_DO(TRUE);
 
     if (gui.browse_fname == NULL)
 	return NULL;
@@ -1579,8 +1894,8 @@
 dlg_destroy_cb(int *p)
 {
     *p = TRUE;		/* set dialog_destroyed to break out of the loop */
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /* ARGSUSED */
@@ -1880,7 +2195,7 @@
     /* loop here until the dialog goes away */
     while (dialog_status == -1 && !dialog_destroyed
 					       && GTK_WIDGET_DRAWABLE(dialog))
-	gtk_main_iteration_do(TRUE);
+	MAIN_ITERATION_DO(TRUE);
 
     if (dialog_status < 0)
 	dialog_status = 0;
@@ -2810,8 +3125,8 @@
     CONVERT_FROM_UTF8_FREE(find_text);
 #endif
 
-    if (rc && gtk_main_level() > 0)
-        gtk_main_quit(); /* make sure cmd will be handled immediately */
+    if (rc && MAIN_LEVEL() > 0)
+        MAIN_QUIT(); /* make sure cmd will be handled immediately */
 }
 
 /* our usual callback function */
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/gui_gtk_x11.c vim/src/gui_gtk_x11.c
--- vimcopy/src/gui_gtk_x11.c	Fri Mar 21 23:15:57 2003
+++ vim/src/gui_gtk_x11.c	Sat Mar 22 11:33:04 2003
@@ -23,6 +23,7 @@
 
 #include "vim.h"
 #ifdef FEAT_GUI_GNOME
+ #if 0
 /* Gnome redefines _() and N_().  Grrr... */
 # ifdef _
 #  undef _
@@ -36,6 +37,7 @@
 # ifdef bindtextdomain
 #  undef bindtextdomain
 # endif
+ #endif
 # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
 #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
 # endif
@@ -646,8 +648,8 @@
 	xev.xproperty.state = PropertyNewValue;
 	serverEventProc(GDK_WINDOW_XDISPLAY(event->window), &xev);
 
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
+ 	if (MAIN_LEVEL() > 0)
+ 	    MAIN_QUIT();
     }
     return FALSE;
 }
@@ -748,6 +750,10 @@
     if (blink_state == BLINK_NONE)
 	gui_mch_start_blink();
 
+#ifdef FEAT_GUI_COMPONENT
+    gtk_widget_grab_focus(gui.drawarea);
+    gtk_grab_add(gui.drawarea);
+#endif
     /* make sure keyboard input goes there */
     if (gtk_socket_id == 0 || !GTK_WIDGET_HAS_FOCUS(gui.drawarea))
 	gtk_widget_grab_focus(gui.drawarea);
@@ -759,6 +765,9 @@
     static gint
 leave_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
 {
+#ifdef FEAT_GUI_COMPONENT
+    gtk_grab_remove(gui.drawarea);
+#endif
     if (blink_state != BLINK_NONE)
 	gui_mch_stop_blink();
 
@@ -1106,8 +1115,8 @@
     if (p_mh)
 	gui_mch_mousehide(TRUE);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();
 
     return TRUE;
 }
@@ -1137,8 +1146,8 @@
     else
 	clip_lose_selection(&clip_star);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+ 	MAIN_QUIT();
 
     return TRUE;
 }
@@ -1312,7 +1321,7 @@
     int
 gui_mch_init_check(void)
 {
-    int init_failed;
+    int init_failed = 0;
 
 #ifndef HAVE_GTK2
     /* This is needed to make the locale handling consistant between the GUI
@@ -1328,13 +1337,18 @@
      * For GNOME 2, always use gtk_init_check() since gnome_program_init()
      * exits on failure.  So let's call it later in gui_mch_init().
      */
-#if defined(FEAT_GUI_GNOME) && !defined(HAVE_GTK2)
+#ifdef FEAT_GUI_COMPONENT
+    init_failed = 0;
+    vim_bonobo_init(&gui_argc, gui_argv);
+#else
+# if defined(FEAT_GUI_GNOME) && !defined(HAVE_GTK2)
     if (using_gnome)
 	init_failed = gnome_init("vim", VIM_VERSION_SHORT, gui_argc, gui_argv);
     else
-#else
+# else
 	/* Don't use gtk_init(), it exits on failure. */
 	init_failed = !gtk_init_check(&gui_argc, &gui_argv);
+# endif
 #endif
 
     if (init_failed)
@@ -1347,6 +1361,22 @@
     return OK;
 }
 
+static gint
+control_activate_event(BonoboControl *control, gboolean activated)
+{
+    if (activated) 
+    {
+        gui_focus_change (TRUE);
+        if (blink_state == BLINK_NONE)
+            gui_mch_start_blink();
+    } else {
+        gui_focus_change (FALSE);
+        if (blink_state != BLINK_NONE)
+            gui_mch_stop_blink();
+    }
+    return TRUE;
+}
+
 
 /****************************************************************************
  * Mouse handling callbacks
@@ -1407,8 +1437,8 @@
     /* inform the editor engine about the occurence of this event */
     gui_send_mouse_event(button, x, y, FALSE, vim_modifiers);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 
     /*
      * Auto repeat timer handling.
@@ -1539,6 +1569,9 @@
     int_u vim_modifiers;
 
     /* Make sure we have focus now we've been selected */
+#ifdef FEAT_GUI_COMPONENT
+    gtk_widget_grab_focus(gui.drawarea);
+#endif
     if (gtk_socket_id != 0 && !GTK_WIDGET_HAS_FOCUS(gui.drawarea))
 	gtk_widget_grab_focus(gui.drawarea);
 
@@ -1603,8 +1636,8 @@
 	vim_modifiers |= MOUSE_ALT;
 
     gui_send_mouse_event(button, x, y, repeated_click, vim_modifiers);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();	/* make sure the above will be handled immediately */
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();            /* make sure the above will be handled immediately */
 
     return TRUE;
 }
@@ -1651,8 +1684,8 @@
 
     gui_send_mouse_event(button, event->x, event->y, FALSE, vim_modifiers);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit(); /* make sure the above will be handled immediately */
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();	/* make sure the above will be handled immediately */
 
     return TRUE;
 }
@@ -1687,8 +1720,8 @@
 	vim_modifiers |= MOUSE_ALT;
 
     gui_send_mouse_event(MOUSE_RELEASE, x, y, FALSE, vim_modifiers);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();		/* make sure it will be handled immediately */
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();	/* make sure the above will be handled immediately */
 
     return TRUE;
 }
@@ -2246,6 +2279,7 @@
     static void
 mainwin_realize(GtkWidget *widget, gpointer data)
 {
+#ifndef FEAT_GUI_COMPONENT
 /* If you get an error message here, you still need to unpack the runtime
  * archive! */
 #ifdef magick
@@ -2332,6 +2366,7 @@
 
 #endif /* !HAVE_GTK2 */
     }
+#endif /* FEAT_GUI_COMPONENT */
 
 #ifndef USE_GNOME_SESSION
     /* Register a handler for WM_SAVE_YOURSELF with GDK's low-level X I/F */
@@ -2350,7 +2385,7 @@
 #endif
 	setup_save_yourself();
 
-#ifdef FEAT_CLIENTSERVER
+#if defined(FEAT_CLIENTSERVER) &&!defined(FEAT_GUI_COMPONENT)
     if (serverName == NULL && serverDelayedStartName != NULL)
     {
 	/* This is a :gui command in a plain vim with no previous server */
@@ -2374,7 +2409,7 @@
 #endif
 }
 
-#ifdef HAVE_GTK_MULTIHEAD
+#if defined(GTK2_MULTIHEAD) && !defined(FEAT_GUI_COMPONENT)
 /*ARGSUSED1*/
     static void
 mainwin_screen_changed_cb(GtkWidget *widget,
@@ -2704,23 +2739,38 @@
     {
 #ifdef FEAT_GUI_GNOME
 	if (using_gnome)
-	    gui.mainwin = gnome_app_new("Vim", NULL);
+        {
+# if defined(FEAT_GUI_COMPONENT)
+             gui.mainwin = NULL;
+# else
+             gui.mainwin = gnome_app_new("vim", "vim");
+# endif
+        }
 	else
 #endif
 	    gui.mainwin = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     }
 
+#ifndef FEAT_GUI_COMPONENT
     gtk_widget_set_name(gui.mainwin, "vim-main-window");
+#endif
+    vbox = gtk_vbox_new(FALSE, 0);
+    gui.vbox = vbox;
 
 #ifdef HAVE_GTK2
     /* Create the PangoContext used for drawing all text. */
+#ifdef FEAT_GUI_COMPONENT
+    gui.text_context = gtk_widget_create_pango_context(GTK_WIDGET(gui.vbox));
+#else
     gui.text_context = gtk_widget_create_pango_context(gui.mainwin);
+#endif
     pango_context_set_base_dir(gui.text_context, PANGO_DIRECTION_LTR);
 #endif
 
 #ifndef HAVE_GTK2
     gtk_window_set_policy(GTK_WINDOW(gui.mainwin), TRUE, TRUE, TRUE);
 #endif
+#ifndef FEAT_GUI_COMPONENT
     gtk_container_border_width(GTK_CONTAINER(gui.mainwin), 0);
     gtk_widget_add_events(gui.mainwin, GDK_VISIBILITY_NOTIFY_MASK);
 
@@ -2740,8 +2790,6 @@
     gui.accel_group = gtk_accel_group_get_default();
 #endif
 
-    vbox = gtk_vbox_new(FALSE, 0);
-
 #ifdef FEAT_GUI_GNOME
     if (using_gnome)
     {
@@ -2757,6 +2805,11 @@
 	gtk_container_add(GTK_CONTAINER(gui.mainwin), vbox);
 	gtk_widget_show(vbox);
     }
+#else
+    gtk_widget_show(vbox);
+#endif
+  
+#ifndef FEAT_GUI_COMPONENT
 
 #ifdef FEAT_MENU
     /*
@@ -2862,6 +2915,7 @@
 	gtk_box_pack_start(GTK_BOX(vbox), gui.toolbar, FALSE, FALSE, 0);
     }
 #endif /* FEAT_TOOLBAR */
+#endif /* FEAT_GUI_COMPONENT */
 
     gui.formwin = gtk_form_new();
     gtk_container_border_width(GTK_CONTAINER(gui.formwin), 0);
@@ -2889,6 +2943,11 @@
     gtk_widget_show(gui.formwin);
     gtk_box_pack_start(GTK_BOX(vbox), gui.formwin, TRUE, TRUE, 0);
 
+#ifdef FEAT_GUI_COMPONENT
+    GTK_WIDGET_SET_FLAGS (gui.drawarea, GTK_CAN_FOCUS);
+    g_signal_connect(G_OBJECT(gui.drawarea), "key_press_event",
+                        G_CALLBACK(key_press_event), NULL);
+#else
     /* For GtkSockets, key-presses must go to the focus widget (drawarea)
      * and not the window. */
     gtk_signal_connect((gtk_socket_id == 0) ? GTK_OBJECT(gui.mainwin)
@@ -2903,6 +2962,7 @@
 		     "key_release_event",
 		     G_CALLBACK(&key_release_event), NULL);
 #endif
+#endif /* FEAT_GUI_COMPONENT */
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "realize",
 		       GTK_SIGNAL_FUNC(drawarea_realize_cb), NULL);
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "unrealize",
@@ -2938,16 +2998,27 @@
      */
     gui.border_offset = gui.border_width;
 
+#ifdef FEAT_GUI_COMPONENT
+    gtk_signal_connect(GTK_OBJECT(gui.vbox), "visibility_notify_event",
+		       GTK_SIGNAL_FUNC(visibility_event), NULL);
+#else
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "visibility_notify_event",
 		       GTK_SIGNAL_FUNC(visibility_event), NULL);
+#endif
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "expose_event",
 		       GTK_SIGNAL_FUNC(expose_event), NULL);
 
     /*
      * Only install these enter/leave callbacks when 'p' in 'guioptions'.
      * Only needed for some window managers.
+     *
+     * Force this on for bonobo, otherwise the toolbar gets the focus 
+     * after you click a button, and you can't get the focus back to the 
+     * drawarea.
      */
+#ifndef FEAT_GUI_COMPONENT
     if (vim_strchr(p_go, GO_POINTER) != NULL)
+#endif
     {
 	gtk_signal_connect(GTK_OBJECT(gui.drawarea), "leave_notify_event",
 			   GTK_SIGNAL_FUNC(leave_notify_event), NULL);
@@ -2955,10 +3026,15 @@
 			   GTK_SIGNAL_FUNC(enter_notify_event), NULL);
     }
 
+#ifdef FEAT_GUI_COMPONENT
+    g_signal_connect(G_OBJECT(gui.control), "activate",
+		     G_CALLBACK (control_activate_event), NULL);
+#else	
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "focus_out_event",
 			   GTK_SIGNAL_FUNC(focus_out_event), NULL);
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "focus_in_event",
 			   GTK_SIGNAL_FUNC(focus_in_event), NULL);
+#endif
 
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "motion_notify_event",
 		       GTK_SIGNAL_FUNC(motion_notify_event), NULL);
@@ -3155,6 +3231,7 @@
 	geometry.min_height  = height + MIN_LINES   * gui.char_height;
 	geometry_mask        = GDK_HINT_BASE_SIZE|GDK_HINT_RESIZE_INC
 			       |GDK_HINT_MIN_SIZE;
+#ifndef FEAT_GUI_COMPONENT
 # ifdef HAVE_GTK2
 	/* Using gui.formwin as geometry widget doesn't work as expected
 	 * with GTK+ 2 -- dunno why.  Presumably all the resizing hacks
@@ -3165,6 +3242,7 @@
 	gtk_window_set_geometry_hints(GTK_WINDOW(gui.mainwin), gui.formwin,
 				      &geometry, geometry_mask);
 # endif
+#endif
 	old_width  = width;
 	old_height = height;
 	old_char_width  = gui.char_width;
@@ -3341,8 +3419,10 @@
      * changed them). */
     highlight_gui_started();	/* re-init colors and fonts */
 
+#ifndef FEAT_GUI_COMPONENT
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "destroy",
 		       GTK_SIGNAL_FUNC(mainwin_destroy_cb), NULL);
+#endif
 
 #ifndef HAVE_GTK2
     /* Make this run after any internal handling of the client event happened
@@ -3418,7 +3498,9 @@
 						  NULL);
 # endif
 #endif
-	gtk_widget_show(gui.mainwin);
+#ifndef FEAT_GUI_COMPONENT
+        gtk_widget_show(gui.mainwin);
+#endif
 
 #if defined(FEAT_GUI_GNOME) && defined(HAVE_GTK2) && defined(FEAT_MENU)
 	if (menu_handler != 0)
@@ -3448,8 +3530,8 @@
     if (gui.mainwin != NULL)
 	gtk_widget_destroy(gui.mainwin);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();	/* make sure the above will be handled immediately */
 }
 
 /*
@@ -3543,7 +3625,7 @@
     /* this will cause the proper resizement to happen too */
     update_window_manager_hints();
 
-#ifdef HAVE_GTK2
+#if defined( HAVE_GTK2 ) && !defined( FEAT_GUI_COMPONENT )
     /* With GTK+ 2, changing the size of the form widget doesn't resize
      * the window.  So lets do it the other way around and resize the
      * main window instead. */
@@ -3621,6 +3703,7 @@
 {
     GtkWidget *widget;
 
+#ifndef FEAT_GUI_COMPONENT
 # ifdef FEAT_GUI_GNOME
     if (using_gnome)
 	widget = gui.menubar_h;
@@ -3637,6 +3720,7 @@
 
 	update_window_manager_hints();
     }
+#endif
 }
 #endif /* FEAT_MENU */
 
@@ -3691,8 +3775,8 @@
     vw->fontname = vim_strsave((char_u *)gtk_font_selection_dialog_get_font_name(fs));
     gtk_widget_hide(vw->fontdlg);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*ARGSUSED*/
@@ -3702,8 +3786,8 @@
     gui_T *vw = (gui_T *)cbdata;
 
     gtk_widget_hide(vw->fontdlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*ARGSUSED*/
@@ -3713,8 +3797,8 @@
     gui_T *vw = (gui_T *)cbdata;
 
     vw->fontdlg = NULL;
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 #endif /* !HAVE_GTK2 */
 
@@ -3874,7 +3958,7 @@
 
     /* Wait for the font dialog to be closed. */
     while (gui.fontdlg && GTK_WIDGET_DRAWABLE(gui.fontdlg))
-	gtk_main_iteration_do(TRUE);
+	MAIN_ITERATION_DO(TRUE);
 
     if (gui.fontname == NULL)
 	return NULL;
@@ -5371,7 +5455,7 @@
 gui_mch_update(void)
 {
     while (gtk_events_pending() && !vim_is_input_buf_full())
-	gtk_main_iteration_do(FALSE);
+	MAIN_ITERATION_DO(FALSE);
 }
 
     static gint
@@ -5382,8 +5466,8 @@
     /* Just inform the caller about the occurence of it */
     *timed_out = TRUE;
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 
     return FALSE;		/* don't happen again */
 }
@@ -5403,8 +5487,8 @@
 
     add_to_input_buf(bytes, 3);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 #endif
 
@@ -5471,7 +5555,7 @@
 	/*
 	 * Loop in GTK+ processing  until a timeout or input occurs.
 	 */
-	gtk_main();
+	MAIN();
 
 	/* Got char, return immediately */
 	if (!vim_is_input_buf_empty())
@@ -5548,6 +5632,7 @@
 	gdk_window_clear(gui.drawarea->window);
 }
 
+
 /*
  * Redraw any text revealed by scrolling up/down.
  */
@@ -5649,7 +5734,7 @@
 				    cbd->gtk_sel_atom, vim_atom,
 				    (guint32)GDK_CURRENT_TIME);
     while (received_selection == RS_NONE)
-	gtk_main();		/* wait for selection_received_cb */
+	MAIN();		/* wait for selection_received_cb */
 
     if (received_selection == RS_FAIL)
     {
@@ -5659,7 +5744,7 @@
 				    gdk_atom_intern("COMPOUND_TEXT", FALSE),
 				    (guint32)GDK_CURRENT_TIME);
 	while (received_selection == RS_NONE)
-	    gtk_main();		/* wait for selection_received_cb */
+	    MAIN();		/* wait for selection_received_cb */
     }
     if (received_selection == RS_FAIL)
     {
@@ -5669,7 +5754,7 @@
 				    gdk_atom_intern("TEXT", FALSE),
 				    (guint32)GDK_CURRENT_TIME);
 	while (received_selection == RS_NONE)
-	    gtk_main();		/* wait for selection_received_cb */
+	    MAIN();		/* wait for selection_received_cb */
     }
     if (received_selection == RS_FAIL)
     {
@@ -5679,7 +5764,7 @@
 				    (GdkAtom)GDK_TARGET_STRING,
 				    (guint32)GDK_CURRENT_TIME);
 	while (received_selection == RS_NONE)
-	    gtk_main();		/* wait for selection_received_cb */
+	    MAIN();		/* wait for selection_received_cb */
     }
     if (received_selection == RS_FAIL)
     {
@@ -5748,6 +5833,13 @@
     void
 gui_mch_menu_grey(vimmenu_T *menu, int grey)
 {
+#ifdef FEAT_GUI_COMPONENT
+    if( menu->sensitive != !grey ) {
+        menu->sensitive = !grey;
+        update_menu_later(menu);
+    }
+    return;
+#endif
     if (menu->id == NULL)
 	return;
 
@@ -5888,6 +5980,40 @@
 /* The last set mouse pointer shape is remembered, to be used when it goes
  * from hidden to not hidden. */
 static int last_shape = 0;
+#endif
+
+#if 0
+static BonoboWindow *
+bonobo_create_window(void)
+{
+    BonoboWindow      *win;
+    BonoboUIContainer *ui_container;
+    BonoboUIComponent *ui_component;
+                                                                                
+    win = BONOBO_WINDOW (bonobo_window_new ("vim", "vim"));                                                                                
+    ui_container = bonobo_window_get_ui_container (win);
+    bonobo_ui_engine_config_set_path (bonobo_window_get_ui_engine (win),
+                      "/gnome-vim/UIConfig/kvps");
+                                                                                
+    /* Create a UI component with which to communicate with the window */
+    ui_component = bonobo_ui_component_new_default ();
+
+    gui.component = ui_component;
+                                                                                
+    /* Associate the BonoboUIComponent with the container */
+    bonobo_ui_component_set_container (
+        ui_component, BONOBO_OBJREF (ui_container), NULL);
+                                                                                
+    //bonobo_ui_util_set_ui (ui_component, "", 
+                   //HELLO_SRCDIR HELLO_UI_XML,
+                   //"bonobo-hello", NULL);
+                                                                                
+    /* Associate our verb -> callback mapping with the BonoboWindow */
+    /* All the callback's user_data pointers will be set to 'win' */
+    //bonobo_ui_component_add_verb_list_with_data (ui_component, hello_verbs, win);
+                                                                                
+    return win;
+}
 #endif
 
 /*
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/main.c vim/src/main.c
--- vimcopy/src/main.c	Fri Mar 21 23:15:57 2003
+++ vim/src/main.c	Fri Mar 21 23:22:34 2003
@@ -79,7 +79,7 @@
 # ifdef VIMDLL
 _export
 # endif
-# ifdef FEAT_GUI_MSWIN
+# if defined(FEAT_GUI_MSWIN)
 #  ifdef __BORLANDC__
 _cdecl
 #  endif
@@ -239,8 +239,12 @@
     TIME_MSG("locale set");
 #endif
 
-#ifdef FEAT_GUI
+#if defined(FEAT_GUI_COMPONENT)
+    gui.dofork = FALSE;		    /* don't use fork when running as component */
+#else
+# if defined(FEAT_GUI) && !defined(FEAT_GUI_COMPONENT)
     gui.dofork = TRUE;		    /* default is to use fork() */
+# endif
 #endif
 
 #if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER)
@@ -441,6 +445,10 @@
 	evim_mode = TRUE;
 	++initstr;
     }
+
+#ifdef FEAT_GUI_COMPONENT
+    main_start_gui();
+#endif
 
     if (TOLOWER_ASC(initstr[0]) == 'g')
     {
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/mbyte.c vim/src/mbyte.c
--- vimcopy/src/mbyte.c	Fri Mar 21 23:15:57 2003
+++ vim/src/mbyte.c	Fri Mar 21 23:22:34 2003
@@ -2839,8 +2839,8 @@
 
     im_add_to_input((char_u *)str, strlen(str));
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*
@@ -3782,7 +3782,11 @@
 	    if (gui.fontset != NOFONTSET
 		    && gui.fontset->type == GDK_FONT_FONTSET)
 	    {
+#ifdef FEAT_GUI_COMPONENT
+		widget = gui.drawarea;
+#else
 		widget = gui.mainwin;
+#endif
 		gdk_window_get_size(widget->window, &width, &height);
 
 		attrmask |= (int)GDK_IC_STATUS_AREA;
@@ -4359,9 +4363,15 @@
 	while (event_queue != NULL && processing_queued_event)
 	{
 	    GdkEvent *ev = event_queue->data;
-
+            GtkWidget *output;
+            
 	    gboolean *ret;
-	    gtk_signal_emit_by_name((GtkObject*)gui.mainwin, "key_press_event",
+#ifdef FEAT_GUI_COMPONENT
+            output = gui.drawarea;
+#else
+            output = gui.mainwin;
+#endif
+	    gtk_signal_emit_by_name((GtkObject*)output, "key_press_event",
 								    ev, &ret);
 	    gdk_event_free(ev);
 	    event_queue = event_queue->next;
@@ -4373,8 +4383,8 @@
 	    key_press_event_queue = NULL;
 	}
     }
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*
@@ -4509,7 +4519,11 @@
 	GtkWidget	*widget = gui.drawarea;
 
 	attr->style = (GdkIMStyle)xim_input_style;
+#ifdef FEAT_GUI_COMPONENT
+	attr->client_window = gui.drawarea->window;
+#else
 	attr->client_window = gui.mainwin->window;
+#endif
 
 	if ((colormap = gtk_widget_get_colormap(widget)) !=
 	    gtk_widget_get_default_colormap())
@@ -4556,7 +4570,11 @@
 	    }
 	    else
 	    {
+#ifdef FEAT_GUI_COMPONENT
+		gdk_window_get_size(gui.drawarea->window, &width, &height);
+#else
 		gdk_window_get_size(gui.mainwin->window, &width, &height);
+#endif
 		attrmask |= (int)GDK_IC_STATUS_AREA_REQ;
 		attr->status_area.x = 0;
 		attr->status_area.y = height - gui.char_height - 1;
Binary files vimcopy/src/objects/buffer.o and vim/src/objects/buffer.o differ
Binary files vimcopy/src/objects/charset.o and vim/src/objects/charset.o differ
Binary files vimcopy/src/objects/diff.o and vim/src/objects/diff.o differ
Binary files vimcopy/src/objects/digraph.o and vim/src/objects/digraph.o differ
Binary files vimcopy/src/objects/edit.o and vim/src/objects/edit.o differ
Binary files vimcopy/src/objects/eval.o and vim/src/objects/eval.o differ
Binary files vimcopy/src/objects/ex_cmds.o and vim/src/objects/ex_cmds.o differ
Binary files vimcopy/src/objects/ex_cmds2.o and vim/src/objects/ex_cmds2.o differ
Binary files vimcopy/src/objects/ex_docmd.o and vim/src/objects/ex_docmd.o differ
Binary files vimcopy/src/objects/ex_getln.o and vim/src/objects/ex_getln.o differ
Binary files vimcopy/src/objects/fileio.o and vim/src/objects/fileio.o differ
Binary files vimcopy/src/objects/fold.o and vim/src/objects/fold.o differ
Binary files vimcopy/src/objects/getchar.o and vim/src/objects/getchar.o differ
Binary files vimcopy/src/objects/gui.o and vim/src/objects/gui.o differ
Binary files vimcopy/src/objects/gui_beval.o and vim/src/objects/gui_beval.o differ
Binary files vimcopy/src/objects/gui_gtk.o and vim/src/objects/gui_gtk.o differ
Binary files vimcopy/src/objects/gui_gtk_f.o and vim/src/objects/gui_gtk_f.o differ
Binary files vimcopy/src/objects/gui_gtk_x11.o and vim/src/objects/gui_gtk_x11.o differ
Binary files vimcopy/src/objects/if_cscope.o and vim/src/objects/if_cscope.o differ
Binary files vimcopy/src/objects/if_xcmdsrv.o and vim/src/objects/if_xcmdsrv.o differ
Binary files vimcopy/src/objects/main.o and vim/src/objects/main.o differ
Binary files vimcopy/src/objects/mark.o and vim/src/objects/mark.o differ
Binary files vimcopy/src/objects/mbyte.o and vim/src/objects/mbyte.o differ
Binary files vimcopy/src/objects/memfile.o and vim/src/objects/memfile.o differ
Binary files vimcopy/src/objects/memline.o and vim/src/objects/memline.o differ
Binary files vimcopy/src/objects/menu.o and vim/src/objects/menu.o differ
Binary files vimcopy/src/objects/message.o and vim/src/objects/message.o differ
Binary files vimcopy/src/objects/misc1.o and vim/src/objects/misc1.o differ
Binary files vimcopy/src/objects/misc2.o and vim/src/objects/misc2.o differ
Binary files vimcopy/src/objects/move.o and vim/src/objects/move.o differ
Binary files vimcopy/src/objects/normal.o and vim/src/objects/normal.o differ
Binary files vimcopy/src/objects/ops.o and vim/src/objects/ops.o differ
Binary files vimcopy/src/objects/option.o and vim/src/objects/option.o differ
Binary files vimcopy/src/objects/os_unix.o and vim/src/objects/os_unix.o differ
Binary files vimcopy/src/objects/pathdef.o and vim/src/objects/pathdef.o differ
Binary files vimcopy/src/objects/pty.o and vim/src/objects/pty.o differ
Binary files vimcopy/src/objects/quickfix.o and vim/src/objects/quickfix.o differ
Binary files vimcopy/src/objects/regexp.o and vim/src/objects/regexp.o differ
Binary files vimcopy/src/objects/screen.o and vim/src/objects/screen.o differ
Binary files vimcopy/src/objects/search.o and vim/src/objects/search.o differ
Binary files vimcopy/src/objects/syntax.o and vim/src/objects/syntax.o differ
Binary files vimcopy/src/objects/tag.o and vim/src/objects/tag.o differ
Binary files vimcopy/src/objects/term.o and vim/src/objects/term.o differ
Binary files vimcopy/src/objects/ui.o and vim/src/objects/ui.o differ
Binary files vimcopy/src/objects/undo.o and vim/src/objects/undo.o differ
Binary files vimcopy/src/objects/version.o and vim/src/objects/version.o differ
Binary files vimcopy/src/objects/vim_bonobo_control.o and vim/src/objects/vim_bonobo_control.o differ
Binary files vimcopy/src/objects/vim_bonobo_factory.o and vim/src/objects/vim_bonobo_factory.o differ
Binary files vimcopy/src/objects/vim_bonobo_main.o and vim/src/objects/vim_bonobo_main.o differ
Binary files vimcopy/src/objects/window.o and vim/src/objects/window.o differ
Binary files vimcopy/src/po/af.mo and vim/src/po/af.mo differ
Binary files vimcopy/src/po/cs.cp1250.mo and vim/src/po/cs.cp1250.mo differ
Binary files vimcopy/src/po/cs.mo and vim/src/po/cs.mo differ
Binary files vimcopy/src/po/de.mo and vim/src/po/de.mo differ
Binary files vimcopy/src/po/es.mo and vim/src/po/es.mo differ
Binary files vimcopy/src/po/fr.mo and vim/src/po/fr.mo differ
Binary files vimcopy/src/po/it.mo and vim/src/po/it.mo differ
Binary files vimcopy/src/po/ja.mo and vim/src/po/ja.mo differ
Binary files vimcopy/src/po/ja.sjis.mo and vim/src/po/ja.sjis.mo differ
Binary files vimcopy/src/po/ko.mo and vim/src/po/ko.mo differ
Binary files vimcopy/src/po/pl.mo and vim/src/po/pl.mo differ
Binary files vimcopy/src/po/sk.cp1250.mo and vim/src/po/sk.cp1250.mo differ
Binary files vimcopy/src/po/sk.mo and vim/src/po/sk.mo differ
Binary files vimcopy/src/po/uk.mo and vim/src/po/uk.mo differ
Binary files vimcopy/src/po/zh_CN.UTF-8.mo and vim/src/po/zh_CN.UTF-8.mo differ
Binary files vimcopy/src/po/zh_CN.cp936.mo and vim/src/po/zh_CN.cp936.mo differ
Binary files vimcopy/src/po/zh_CN.mo and vim/src/po/zh_CN.mo differ
Binary files vimcopy/src/po/zh_TW.mo and vim/src/po/zh_TW.mo differ
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/structs.h vim/src/structs.h
--- vimcopy/src/structs.h	Fri Mar 21 23:05:49 2003
+++ vim/src/structs.h	Fri Mar 21 23:22:34 2003
@@ -1607,8 +1607,11 @@
     GtkWidget	*tearoff_handle;
     GtkWidget   *label;		    /* Used by "set wak=" code. */
 #endif
-#ifdef FEAT_GUI_MOTIF
+#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_COMPONENT)
     int		sensitive;	    /* turn button on/off */
+#if defined(FEAT_GUI_COMPONENT)
+    int         dirty;              /* menu item has been updated; container needs to know */
+#endif
 #endif
 #if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MOTIF)
     Pixmap	image;		    /* Toolbar image */
Binary files vimcopy/src/vim and vim/src/vim differ
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/vim-container.xml vim/src/vim-container.xml
--- vimcopy/src/vim-container.xml	Wed Dec 31 18:00:00 1969
+++ vim/src/vim-container.xml	Fri Mar 21 23:22:34 2003
@@ -0,0 +1,83 @@
+<Root>
+
+<commands>
+	<cmd name="FileNewWindow" _label="_New Window" _tip="Open a new window"
+             pixtype="stock" pixname="gtk-new" accel="*Control*n"/>
+
+	<cmd name="FileOpen" _label="_Open..." _tip="Open a file"
+	     pixtype="stock" pixname="gtk-open" accel="*Control*o"/>
+
+	<cmd name="FileCloseWindow" _label="_Close" _tip="Close window"
+             pixtype="stock" pixname="gtk-close" accel="*Control*w"/>
+
+        <cmd name="FileExit" _label="_Quit" _tip="Quit the program"
+	     pixtype="stock" pixname="gtk-quit" accel="*Control*q"/>
+	
+	<cmd name="Preferences" _label="_Preferences..." _tip="Change preferences"  sensitive="0"
+	     pixtype="stock" pixname="gtk-preferences"/>
+
+	<cmd name="HelpAbout" _label="_About" _tip="About this application"
+	     pixtype="stock" pixname="About"/>
+	<cmd name="Help" _label="Contents" _tip="Help On this application"
+	     pixtype="stock" pixname="Help" accel="F1"/>
+
+
+	<cmd name="DnDNewWindow" _label="Open in new window"/>
+	<cmd name="DnDSameWindow" _label="Open in this window"/>
+	<cmd name="DnDCancel" _label="Cancel"
+	     pixtype="stock" pixname="Cancel"/>
+</commands>
+
+<menu>
+        <submenu name="File" _label="_File">
+
+		<menuitem name="FileNewWindow" verb=""/>
+
+		<placeholder name="Open Placeholder" delimit="top">
+			<menuitem name="FileOpen" verb=""/>
+		</placeholder>
+
+		<placeholder name="File Items Placeholder" delimit="top"/>
+
+		<separator/>
+
+		<menuitem name="FileCloseWindow" verb=""/>
+
+		<menuitem name="FileExit" verb=""/>
+
+	</submenu>
+
+	<submenu name="Edit" _label="_Edit">
+		<menuitem name="Preferences" verb=""/>
+        </submenu>
+
+	<submenu name="View" _label="_View" hidden="1">
+		<placeholder name="View Preferences Placeholder"/>
+		<placeholder name="View Items Placeholder" delimit="top"/>
+	</submenu>
+
+	<submenu name="Help" _label="_Help">
+		<menuitem name="Help" verb=""/>
+	        <menuitem name="HelpAbout" verb=""/>
+	</submenu>
+</menu>
+
+<dockitem name="Toolbar" relief="none" homogeneous="1" behavior="exclusive">
+
+        <toolitem name="TBOpen" _label="Open" pixtype="stock"
+                  pixname="Open" verb="FileOpen"/>
+
+        <toolitem name="TBCloseWindow" _label="Close" pixtype="stock"
+                  pixname="Close" verb="FileCloseWindow"/>
+</dockitem>
+
+<popups>
+        <popup name="dragndrop">
+	      <menuitem name="DnDNewWindow" verb=""/>
+	      <menuitem name="DnDSameWindow" verb=""/>
+	      <separator/>
+	      <menuitem name="DnDCancel" verb=""/>
+        </popup>
+</popups>
+
+</Root>
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/vim_bonobo_control.c vim/src/vim_bonobo_control.c
--- vimcopy/src/vim_bonobo_control.c	Wed Dec 31 18:00:00 1969
+++ vim/src/vim_bonobo_control.c	Fri Mar 21 23:22:34 2003
@@ -0,0 +1,262 @@
+/**
+ * vim_bonobo_control.c
+ *
+ * Author:
+ *   Jason Hildebrand <jason@peaceworks.ca>
+ *
+ */
+#include <stdio.h>
+
+#include "vim.h"
+#include "vim_bonobo_control.h"
+
+#include <gnome.h>
+#include <libbonoboui.h>
+#include <libbonobo.h>
+#include <libnautilus/nautilus-view.h>
+
+
+struct _VimControlPrivate {
+    BonoboUIComponent *component;
+};
+
+static GObjectClass *vim_control_parent_class;
+
+static gboolean
+quit_vim(gpointer data)
+{
+    MAIN_QUIT();
+    exit(0);
+}
+
+static void
+vim_control_destroy (BonoboObject *control)
+{
+	BonoboUIComponent *uic;
+
+	g_return_if_fail (control != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (control));
+
+    g_message ("Destroying VimControl...");
+
+	uic = bonobo_control_get_ui_component (BONOBO_CONTROL (control));
+    if( uic != CORBA_OBJECT_NIL )
+        bonobo_ui_component_unset_container (uic, NULL);
+
+	BONOBO_OBJECT_CLASS (vim_control_parent_class)->destroy (control);
+
+    /* we only support creating one vim control per process, so when this one
+     * is finished, we're done. */ 
+    /* BONOBO_FIXME: shut down vim cleanly! */
+    g_timeout_add(100, &quit_vim, NULL);
+}
+
+static void
+vim_control_finalize (GObject *object)
+{
+	VimControl *control;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (object));
+
+	control = VIM_CONTROL (object);
+
+	g_free (control->priv);
+
+	G_OBJECT_CLASS (vim_control_parent_class)->finalize (object);
+}
+
+static void
+vim_control_set_ui_container (VimControl *control,
+			      Bonobo_UIContainer ui_container)
+{
+	BonoboUIComponent *uic;
+	
+	g_return_if_fail (control != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (control));
+	g_return_if_fail (ui_container != CORBA_OBJECT_NIL);
+
+	uic = bonobo_control_get_ui_component (BONOBO_CONTROL (control));
+	bonobo_ui_component_set_container (uic, ui_container, NULL);
+
+    /* update vim's UI now */
+    update_ui_later();
+}
+
+static void
+vim_control_unset_ui_container (VimControl *control)
+{
+	BonoboUIComponent *uic;
+
+	g_return_if_fail (control != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (control));
+
+	uic = bonobo_control_get_ui_component (BONOBO_CONTROL (control));
+	bonobo_ui_component_unset_container (uic, NULL);
+}
+
+static void
+vim_control_activate (BonoboControl *object, gboolean state)
+{
+	VimControl *control;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (object));
+
+	control = VIM_CONTROL (object);
+
+	if (state) {
+		Bonobo_UIContainer ui_container;
+
+		ui_container = bonobo_control_get_remote_ui_container (BONOBO_CONTROL (control), NULL);
+		if (ui_container != CORBA_OBJECT_NIL) {
+			vim_control_set_ui_container (control, ui_container);
+			bonobo_object_release_unref (ui_container, NULL);
+		}
+	} else
+		vim_control_unset_ui_container (control);
+
+	if (BONOBO_CONTROL_CLASS (vim_control_parent_class)->activate)
+		BONOBO_CONTROL_CLASS (vim_control_parent_class)->activate (object, state);
+}
+
+static void
+vim_control_class_init (VimControl *klass)
+{
+	GObjectClass *gobject_class = (GObjectClass *)klass;
+	BonoboObjectClass *bonobo_object_class = (BonoboObjectClass *)klass;
+	BonoboControlClass *control_class = (BonoboControlClass *)klass;
+
+	vim_control_parent_class= g_type_class_peek_parent (klass);
+
+	bonobo_object_class->destroy = vim_control_destroy;
+	gobject_class->finalize = vim_control_finalize;
+	control_class->activate = vim_control_activate;
+}
+
+
+static gint
+load_vim_from_file (BonoboPersistFile *pf, const CORBA_char *text_uri,
+              CORBA_Environment *ev, void *closure)
+{
+    return 0;
+}
+
+static void
+nv_load_location_cb (NautilusView *view, const char *location, gpointer user_data)
+{
+	g_return_if_fail (NAUTILUS_IS_VIEW (view));
+	g_return_if_fail (location != NULL);
+
+	nautilus_view_report_load_underway (NAUTILUS_VIEW (view));
+
+    /* FIXME: load the file here (using gnome-vfs)! */
+	nautilus_view_report_load_complete (NAUTILUS_VIEW (view));
+}
+
+static void
+vim_control_init (VimControl *control)
+{
+	control->priv = g_new0 (VimControlPrivate, 1);
+}
+
+BONOBO_TYPE_FUNC (VimControl, BONOBO_TYPE_CONTROL, vim_control);
+
+BonoboObject *
+vim_control_add_interfaces (VimControl     *control,
+			  BonoboObject *to_aggregate)
+{
+	BonoboPersistFile   *file;
+    NautilusView        *nv;
+	//BonoboPersistStream *stream;
+	//BonoboItemContainer *item_container;
+	
+	g_return_val_if_fail (VIM_IS_CONTROL (control), NULL);
+	g_return_val_if_fail (BONOBO_IS_OBJECT (to_aggregate), NULL);
+
+	/* Interface Bonobo::PersistFile */
+	file = bonobo_persist_file_new (load_vim_from_file, 
+					    NULL, "OAFIID:GNOME_Vim_Control", control);
+	if (!file) {
+		bonobo_object_unref (BONOBO_OBJECT (to_aggregate));
+		return NULL;
+	}
+
+	bonobo_object_add_interface (BONOBO_OBJECT (to_aggregate),
+				     BONOBO_OBJECT (file));
+
+    nv = nautilus_view_new_from_bonobo_control(BONOBO_CONTROL(control));
+    if( !nv ) {
+        bonobo_object_unref (BONOBO_OBJECT(to_aggregate));
+        return NULL;
+    }
+	bonobo_object_add_interface (BONOBO_OBJECT (to_aggregate),
+				     BONOBO_OBJECT (nv));
+
+	g_signal_connect (G_OBJECT (nv), "load_location",
+			  G_CALLBACK (nv_load_location_cb), NULL);
+
+	return to_aggregate;
+}
+
+static gint
+key_press_event(GtkAccelGroup * group, GObject * acceleratable, guint keyval, GdkModifierType mod)
+{
+    printf("accel key pressed: %d %d!\n", keyval, mod);
+    return FALSE;
+}
+
+
+VimControl *
+vim_control_construct (VimControl    *control)
+{
+	GtkWidget             *button;
+	GtkWidget             *label;
+    BonoboPlug            *plug;
+    GtkAccelGroup         *group;
+    GClosure              *closure;
+	//VimControlPrivate     *priv;
+	
+	g_return_val_if_fail (control != NULL, NULL);
+	g_return_val_if_fail (VIM_IS_CONTROL (control), NULL);
+
+
+	if (!vim_control_add_interfaces (control, BONOBO_OBJECT (control)))
+		return NULL;
+
+    gui.control = BONOBO_CONTROL(control);
+    gui_mch_init();
+
+	/* Create the vim-view */
+	//priv->image_view = vim_image_view_new (vim, FALSE);
+	//if (!priv->image_view) {
+		//bonobo_object_unref (BONOBO_OBJECT (control));
+		//return NULL;
+	//}
+    
+    
+	bonobo_control_construct (BONOBO_CONTROL (control), GTK_WIDGET(gui.vbox));
+
+    group = gtk_accel_group_new();
+    plug = (BonoboPlug *)bonobo_control_get_plug(control);
+    gtk_window_add_accel_group(GTK_WINDOW(plug), group);
+    closure = g_cclosure_new (G_CALLBACK (key_press_event), NULL, (GClosureNotify)g_free);
+    gtk_accel_group_connect(group, GDK_Escape, 0, 0, closure);
+    closure = g_cclosure_new (G_CALLBACK (key_press_event), NULL, (GClosureNotify)g_free);
+    gtk_accel_group_connect(group, GDK_n, GDK_CONTROL_MASK, 0, closure);
+
+	return control;
+}
+
+VimControl *
+vim_control_new (void)
+{
+	VimControl *control;
+	
+    g_message ("Creating VimControl...");
+
+	control = g_object_new (VIM_CONTROL_TYPE, NULL);
+
+	return vim_control_construct (control);
+}
+
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/vim_bonobo_control.h vim/src/vim_bonobo_control.h
--- vimcopy/src/vim_bonobo_control.h	Wed Dec 31 18:00:00 1969
+++ vim/src/vim_bonobo_control.h	Fri Mar 21 23:22:34 2003
@@ -0,0 +1,44 @@
+/*
+ * vim_bonobo_control.h
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#ifndef _VIM_CONTROL_H_
+#define _VIM_CONTROL_H_
+
+#include <bonobo/bonobo-control.h>
+
+G_BEGIN_DECLS
+ 
+#define VIM_CONTROL_TYPE           (vim_control_get_type ())
+#define VIM_CONTROL(o)             (G_TYPE_CHECK_INSTANCE_CAST ((o), VIM_CONTROL_TYPE, VimControl))
+#define VIM_CONTROL_CLASS(k)       (G_TYPE_CHECK_CLASS_CAST((k), VIM_CONTROL_TYPE, VimControlClass))
+
+#define VIM_IS_CONTROL(o)          (G_TYPE_CHECK_INSTANCE_TYPE ((o), VIM_CONTROL_TYPE))
+#define VIM_IS_CONTROL_CLASS(k)    (G_TYPE_CHECK_CLASS_TYPE ((k), VIM_CONTROL_TYPE))
+#define VIM_CONTROL_GET_CLASS(o)   (G_TYPE_INSTANCE_GET_CLASS ((o), VIM_CONTROL_TYPE, VimControlClass))
+
+typedef struct _VimControl         VimControl;
+typedef struct _VimControlClass    VimControlClass;
+typedef struct _VimControlPrivate  VimControlPrivate;
+
+struct _VimControl {
+	BonoboControl control;
+
+	VimControlPrivate *priv;
+};
+
+struct _VimControlClass {
+	BonoboControlClass parent_class;
+};
+
+GType         vim_control_get_type                    (void);
+VimControl    *vim_control_new                         (void);
+VimControl    *vim_control_construct                   (VimControl    *control);
+
+G_END_DECLS
+
+#endif /* _VIM_CONTROL_H_*/
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/vim_bonobo_factory.c vim/src/vim_bonobo_factory.c
--- vimcopy/src/vim_bonobo_factory.c	Wed Dec 31 18:00:00 1969
+++ vim/src/vim_bonobo_factory.c	Fri Mar 21 23:22:34 2003
@@ -0,0 +1,75 @@
+/*
+ * vim_bonobo_factory.c
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#include "vim.h"
+#include "version.h"
+#include <bonobo/bonobo-generic-factory.h>
+#include "vim_bonobo_control.h"
+
+static BonoboGenericFactory *factory = NULL;
+static int vim_instantiated = 0;
+
+static BonoboObject *
+vim_bonobo_factory(BonoboGenericFactory *this,
+              const char           *oaf_iid,
+              void                 *data)
+{
+    VimControl     *vim;
+    BonoboObject *retval;
+
+    g_return_val_if_fail (this != NULL, NULL);
+    g_return_val_if_fail (oaf_iid != NULL, NULL);
+
+    if( vim_instantiated ) {
+        /* we cannot instantiate more than one control from this process,
+         * because of all of vim's global variables */
+        return NULL;
+    }
+                                                                                
+    g_message ("Trying to produce a '%s'...", oaf_iid);
+                                                                                
+    if (strcmp (oaf_iid, "OAFIID:Vim_Control") == 0) {
+        vim = vim_control_new ();
+        if (vim == NULL)
+            return NULL;
+        retval = BONOBO_OBJECT (vim);
+    } else {
+        g_warning ("Unknown IID `%s' requested", oaf_iid);
+        return NULL;
+    }
+    vim_instantiated = 1;
+                                                                                
+    return retval;
+}
+
+/* wait until this component is instantiated */
+int vim_bonobo_wait_for_instantiation()
+{
+    while( !vim_instantiated) {
+        MAIN_ITERATION_DO(TRUE);
+    }
+}
+
+
+void vim_bonobo_init(int *argc, char *argv[])
+{
+    if (!bonobo_ui_init ("gnome-vim", VIM_VERSION_SHORT, argc, argv))
+        g_error (_("Could not initialize Bonobo"));
+                                                                                
+    factory = bonobo_generic_factory_new (
+        "OAFIID:Vim_Control_Factory", vim_bonobo_factory, NULL);
+                                                                                
+    if (factory == NULL) {
+        g_error ("Couldn't create factory.\n");
+
+        /* in component mode, we don't care about trying to continue without 
+         * a gui; if we can't create the factory, we might as well quit. */
+        mch_exit(2);
+    }
+}
+
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/vim_bonobo_factory.h vim/src/vim_bonobo_factory.h
--- vimcopy/src/vim_bonobo_factory.h	Wed Dec 31 18:00:00 1969
+++ vim/src/vim_bonobo_factory.h	Fri Mar 21 23:22:34 2003
@@ -0,0 +1,15 @@
+/*
+ * vim_bonobo_factory.h
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#if !defined( _VIM_BONOBO_FACTORY_H)
+#define _VIM_BONOBO_FACTORY_H
+
+void gui_component_init(int *argc, char *argv []);
+int gui_component_wait_for_instantiation(void);
+
+#endif
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/vim_bonobo_main.c vim/src/vim_bonobo_main.c
--- vimcopy/src/vim_bonobo_main.c	Wed Dec 31 18:00:00 1969
+++ vim/src/vim_bonobo_main.c	Fri Mar 21 23:22:34 2003
@@ -0,0 +1,60 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+#include <glib/gmain.h>
+#include <glib-object.h>
+
+static guint              bonobo_main_loop_level = 0;
+static GSList *           bonobo_main_loops = NULL;
+
+
+/**
+ * bonobo_main:
+ * 
+ * Activates the Bonobo POA Manager and enters the main event loop.
+ */
+void
+vim_bonobo_main (void)
+{
+	GMainLoop *loop;
+
+	bonobo_activate ();
+
+	bonobo_main_loop_level++;
+  
+	loop = g_main_loop_new (NULL, TRUE);
+	bonobo_main_loops = g_slist_prepend (bonobo_main_loops, loop);
+
+	if (g_main_loop_is_running (bonobo_main_loops->data))
+		g_main_loop_run (loop);
+
+	bonobo_main_loops = g_slist_remove (bonobo_main_loops, loop);
+
+	g_main_loop_unref (loop);
+
+	bonobo_main_loop_level--;
+}
+
+/**
+ * bonobo_main_quit:
+ * 
+ * Quits the main event loop.
+ */
+void
+vim_bonobo_main_quit (void)
+{
+	g_return_if_fail (bonobo_main_loops != NULL);
+
+	g_main_loop_quit (bonobo_main_loops->data);
+}
+
+int
+vim_bonobo_main_level(void)
+{
+    return bonobo_main_loop_level;
+}
+
+gboolean
+vim_bonobo_main_iteration_do(may_block)
+{
+    g_main_context_iteration(NULL, may_block);
+}
diff --new-file -u -r --exclude-from=excludelist vimcopy/src/vim_bonobo_main.h vim/src/vim_bonobo_main.h
--- vimcopy/src/vim_bonobo_main.h	Wed Dec 31 18:00:00 1969
+++ vim/src/vim_bonobo_main.h	Sat Mar 22 11:10:00 2003
@@ -0,0 +1,14 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+#ifndef __VIM_BONOBO_MAIN_H__
+#define __VIM_BONOBO_MAIN_H__
+
+#include <glib-object.h>
+#include <bonobo/Bonobo.h>
+
+void			    vim_bonobo_main			 (void);
+void                vim_bonobo_main_quit     (void);
+int                 vim_bonobo_level(void);
+gboolean            vim_bonobo_main_iteration_do(int may_block);
+
+#endif /* __VIM_BONOBO_MAIN_H__ */
Binary files vimcopy/src/xxd/xxd and vim/src/xxd/xxd differ
diff --new-file -u -r --exclude-from=excludelist vimcopy/vim/src/Make_container.mak vim/vim/src/Make_container.mak
--- vimcopy/vim/src/Make_container.mak	Wed Dec 31 18:00:00 1969
+++ vim/vim/src/Make_container.mak	Fri Mar 21 23:22:34 2003
@@ -0,0 +1,11 @@
+gnomeccFlags = `pkg-config --cflags libgnomeui-2.0 libgnome-2.0`
+ccFlags = -g -c ${gnomeccFlags}
+ldFlags = `pkg-config --libs libgnomeui-2.0 libgnome-2.0`
+
+all: container
+
+container: container.o
+	gcc -o container ${ldFlags} container.o
+
+%.o: %.c
+	gcc ${ccFlags} $< -o $@
