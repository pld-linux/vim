Index: runtime/doc/quickref.txt
===================================================================
*** runtime/doc/quickref.txt	(revision 1159)
--- runtime/doc/quickref.txt	(working copy)
***************
*** 817,822 ****
--- 817,823 ----
  'pumheight'	  'ph'	    maximum height of the popup menu
  'quoteescape'	  'qe'	    escape characters used in a string
  'readonly'	  'ro'	    disallow writing the buffer
+ 'relativenumber'  'rnu'	    print relative line number in front of each line
  'redrawtime'	  'rdt'     timeout for 'hlsearch' and |:match| highlighting
  'remap'			    allow mappings to work recursively
  'report'		    threshold for reporting nr. of lines changed
Index: runtime/doc/version7.txt
===================================================================
*** runtime/doc/version7.txt	(revision 1159)
--- runtime/doc/version7.txt	(working copy)
***************
*** 638,645 ****
  'maxmempattern'		maximum amount of memory to use for pattern matching
  'mkspellmem'		parameters for |:mkspell| memory use
  'mzquantum'		Time in msec to schedule MzScheme threads.
! 'numberwidth'		Minimal width of the space used for the 'number'
! 			option. (Emmanuel Renieris)
  'omnifunc'		The name of the function used for omni completion.
  'operatorfunc'		function to be called for |g@| operator
  'printmbcharset'	CJK character set to be used for :hardcopy
--- 638,645 ----
  'maxmempattern'		maximum amount of memory to use for pattern matching
  'mkspellmem'		parameters for |:mkspell| memory use
  'mzquantum'		Time in msec to schedule MzScheme threads.
! 'numberwidth'		Minimal width of the space used for the 'number' and
! 			'relativenumber' option. (Emmanuel Renieris)
  'omnifunc'		The name of the function used for omni completion.
  'operatorfunc'		function to be called for |g@| operator
  'printmbcharset'	CJK character set to be used for :hardcopy
Index: runtime/doc/options.txt
===================================================================
*** runtime/doc/options.txt	(revision 1159)
--- runtime/doc/options.txt	(working copy)
***************
*** 1874,1881 ****
  			parenthesis match.  When included "%" ignores
  			backslashes, which is Vi compatible.
  								*cpo-n*
! 		n	When included, the column used for 'number' will also
! 			be used for text of wrapped lines.
  								*cpo-o*
  		o	Line offset to search command is not remembered for
  			next search.
--- 1874,1882 ----
  			parenthesis match.  When included "%" ignores
  			backslashes, which is Vi compatible.
  								*cpo-n*
! 		n	When included, the column used for 'number' and
! 			'relativenumber' will also be used for text of wrapped
! 			lines.
  								*cpo-o*
  		o	Line offset to search command is not remembered for
  			next search.
***************
*** 3577,3583 ****
  	|hl-Search|	 l  last search pattern highlighting (see 'hlsearch')
  	|hl-MoreMsg|	 m  |more-prompt|
  	|hl-ModeMsg|	 M  Mode (e.g., "-- INSERT --")
! 	|hl-LineNr|	 n  line number for ":number" and ":#" commands
  	|hl-Question|	 r  |hit-enter| prompt and yes/no questions
  	|hl-StatusLine|	 s  status line of current window |status-line|
  	|hl-StatusLineNC| S  status lines of not-current windows
--- 3578,3585 ----
  	|hl-Search|	 l  last search pattern highlighting (see 'hlsearch')
  	|hl-MoreMsg|	 m  |more-prompt|
  	|hl-ModeMsg|	 M  Mode (e.g., "-- INSERT --")
! 	|hl-LineNr|	 n  line number for ":number" and ":#" commands, and
! 			    when 'number' or 'relativenumber' option is set.
  	|hl-Question|	 r  |hit-enter| prompt and yes/no questions
  	|hl-StatusLine|	 s  status line of current window |status-line|
  	|hl-StatusLineNC| S  status lines of not-current windows
***************
*** 4834,4839 ****
--- 4836,4842 ----
  	When a long, wrapped line doesn't start with the first character, '-'
  	characters are put before the number.
  	See |hl-LineNr| for the highlighting used for the number.
+ 	When setting this option, 'relativenumber' is being reset.
  
  						*'numberwidth'* *'nuw'*
  'numberwidth' 'nuw'	number	(Vim default: 4  Vi default: 8)
***************
*** 4842,4854 ****
  			{only available when compiled with the |+linebreak|
  			feature}
  	Minimal number of columns to use for the line number.  Only relevant
! 	when the 'number' option is set or printing lines with a line number.
! 	Since one space is always between the number and the text, there is
! 	one less character for the number itself.
  	The value is the minimum width.  A bigger width is used when needed to
! 	fit the highest line number in the buffer.  Thus with the Vim default
! 	of 4 there is room for a line number up to 999.  When the buffer has
! 	1000 lines five columns will be used.
  	The minimum value is 1, the maximum value is 10.
  	NOTE: 'numberwidth' is reset to 8 when 'compatible' is set.
  
--- 4845,4858 ----
  			{only available when compiled with the |+linebreak|
  			feature}
  	Minimal number of columns to use for the line number.  Only relevant
! 	when the 'number' or 'relativenumber' option is set or printing lines
! 	with a line number. Since one space is always between the number and
! 	the text, there is one less character for the number itself.
  	The value is the minimum width.  A bigger width is used when needed to
! 	fit the highest line number in the buffer respectively the number of
! 	rows in the window, depending on whether 'number' or 'relativenumber'
! 	is set. Thus with the Vim default of 4 there is room for a line number
! 	up to 999. When the buffer has 1000 lines five columns will be used.
  	The minimum value is 1, the maximum value is 10.
  	NOTE: 'numberwidth' is reset to 8 when 'compatible' is set.
  
***************
*** 5222,5227 ****
--- 5226,5250 ----
  	matches will be highlighted.  This is used to avoid that Vim hangs
  	when using a very complicated pattern.
  
+ 		*'relativenumber'* *'rnu'* *'norelativenumber'* *'nornu'*
+ 'relativenumber' 'rnu'	boolean	(default off)
+ 			local to window
+ 			{not in Vi}
+ 	Print the line number relative to the line with the cursor in front of
+ 	each line. Relative line numbers help you using the |count| you can
+ 	precede some vertival motion commands (e.g. j k + -) with, without
+ 	having to calculate it by yourself. Especially useful in combination
+ 	with other commands (e.g. y d c < > gq gw =).
+ 	When the 'n' option is excluded from 'cpoptions' a wrapped
+ 	line will not use the column of line numbers (this is the default when
+ 	'compatible' isn't set).
+ 	The 'numberwidth' option can be used to set the room used for the line
+ 	number.
+ 	When a long, wrapped line doesn't start with the first character, '-'
+ 	characters are put before the number.
+ 	See |hl-LineNr| for the highlighting used for the number.
+ 	When setting this option, 'number' is being reset.
+ 
  						*'remap'* *'noremap'*
  'remap'			boolean	(default on)
  			global
Index: runtime/doc/syntax.txt
===================================================================
*** runtime/doc/syntax.txt	(revision 1159)
--- runtime/doc/syntax.txt	(working copy)
***************
*** 4154,4160 ****
  		":s///c"
  							*hl-LineNr*
  LineNr		Line number for ":number" and ":#" commands, and when 'number'
! 		option is set.
  							*hl-MatchParen*
  MatchParen	The character under the cursor or just before it, if it
  		is a paired bracket, and its match. |pi_paren.txt|
--- 4154,4160 ----
  		":s///c"
  							*hl-LineNr*
  LineNr		Line number for ":number" and ":#" commands, and when 'number'
! 		or 'relativenumber' option is set.
  							*hl-MatchParen*
  MatchParen	The character under the cursor or just before it, if it
  		is a paired bracket, and its match. |pi_paren.txt|
Index: runtime/doc/tags
===================================================================
*** runtime/doc/tags	(revision 1159)
--- runtime/doc/tags	(working copy)
***************
*** 557,562 ****
--- 557,563 ----
  'noprompt'	options.txt	/*'noprompt'*
  'nopvw'	options.txt	/*'nopvw'*
  'noreadonly'	options.txt	/*'noreadonly'*
+ 'norelativenumber'	options.txt	/*'norelativenumber'*
  'noremap'	options.txt	/*'noremap'*
  'norestorescreen'	options.txt	/*'norestorescreen'*
  'norevins'	options.txt	/*'norevins'*
***************
*** 565,570 ****
--- 566,572 ----
  'norightleftcmd'	options.txt	/*'norightleftcmd'*
  'norl'	options.txt	/*'norl'*
  'norlc'	options.txt	/*'norlc'*
+ 'nornu'	options.txt	/*'nornu'*
  'noro'	options.txt	/*'noro'*
  'nors'	options.txt	/*'nors'*
  'noru'	options.txt	/*'noru'*
***************
*** 706,711 ****
--- 708,714 ----
  'readonly'	options.txt	/*'readonly'*
  'redraw'	vi_diff.txt	/*'redraw'*
  'redrawtime'	options.txt	/*'redrawtime'*
+ 'relativenumber'	options.txt	/*'relativenumber'*
  'remap'	options.txt	/*'remap'*
  'report'	options.txt	/*'report'*
  'restorescreen'	options.txt	/*'restorescreen'*
***************
*** 715,720 ****
--- 718,724 ----
  'rightleftcmd'	options.txt	/*'rightleftcmd'*
  'rl'	options.txt	/*'rl'*
  'rlc'	options.txt	/*'rlc'*
+ 'rnu'	options.txt	/*'rnu'*
  'ro'	options.txt	/*'ro'*
  'rs'	options.txt	/*'rs'*
  'rtp'	options.txt	/*'rtp'*
Index: runtime/lang/menu_de_de.latin1.vim
===================================================================
*** runtime/lang/menu_de_de.latin1.vim	(revision 1159)
--- runtime/lang/menu_de_de.latin1.vim	(working copy)
***************
*** 84,96 ****
  menutrans F&ile\ Settings				&Datei-Einstellungen
  
  " Boolean options
! menutrans Toggle\ Line\ &Numbering<Tab>:set\ nu!	Anzeige\ der\ Zeilen&nummer\ ein-\ und\ ausschalten<Tab>:set\ nu!
! menutrans Toggle\ &List\ Mode<Tab>:set\ list!		&List-Modus\ ein-\ und\ ausschalten<Tab>:set\ list!
! menutrans Toggle\ Line\ &Wrap<Tab>:set\ wrap!		&Zeilenumbruch\ ein-\ und\ ausschalten<Tab>:set\ wrap!
! menutrans Toggle\ W&rap\ at\ word<Tab>:set\ lbr!	Umbruch\ an\ &Wortgrenzen\ ein-\ und\ ausschalten<Tab>:set\ lbr!
! menutrans Toggle\ &expand-tab<Tab>:set\ et!		&Erweiterung\ von\ Tabulatoren\ ein-\ und\ ausschalten<Tab>:set\ et!
! menutrans Toggle\ &auto-indent<Tab>:set\ ai!		&Automatische\ Einrückung\ ein-\ und\ ausschalten<Tab>:set\ ai!
! menutrans Toggle\ &C-indenting<Tab>:set\ cin!		&C-Einrückung\ ein-\ und\ ausschalten<Tab>:set\ cin!
  
  " other options
  menutrans &Shiftwidth					&Schiebeweite
--- 84,97 ----
  menutrans F&ile\ Settings				&Datei-Einstellungen
  
  " Boolean options
! menutrans Toggle\ Line\ &Numbering<Tab>:set\ nu!		Anzeige\ der\ Zeilen&nummer\ ein-\ und\ ausschalten<Tab>:set\ nu!
! menutrans Toggle\ relati&ve\ Line\ Numbering<Tab>:set\ rnu!	Anzeige\ der\ relati&ven\ Zeilennummer\ ein-\ und\ ausschalten<Tab>:set\ rnu!
! menutrans Toggle\ &List\ Mode<Tab>:set\ list!			&List-Modus\ ein-\ und\ ausschalten<Tab>:set\ list!
! menutrans Toggle\ Line\ &Wrap<Tab>:set\ wrap!			&Zeilenumbruch\ ein-\ und\ ausschalten<Tab>:set\ wrap!
! menutrans Toggle\ W&rap\ at\ word<Tab>:set\ lbr!		Umbruch\ an\ &Wortgrenzen\ ein-\ und\ ausschalten<Tab>:set\ lbr!
! menutrans Toggle\ &expand-tab<Tab>:set\ et!			&Erweiterung\ von\ Tabulatoren\ ein-\ und\ ausschalten<Tab>:set\ et!
! menutrans Toggle\ &auto-indent<Tab>:set\ ai!			&Automatische\ Einrückung\ ein-\ und\ ausschalten<Tab>:set\ ai!
! menutrans Toggle\ &C-indenting<Tab>:set\ cin!			&C-Einrückung\ ein-\ und\ ausschalten<Tab>:set\ cin!
  
  " other options
  menutrans &Shiftwidth					&Schiebeweite
Index: runtime/syntax/vim.vim
===================================================================
*** runtime/syntax/vim.vim	(revision 1159)
--- runtime/syntax/vim.vim	(working copy)
***************
*** 30,46 ****
  syn keyword vimOption contained	al antialias autochdir background balloondelay bexpr bk bs casemap cfu cinkeys cmdwinheight commentstring conskey cscopepathcomp csprg cursorcolumn delcombine diffopt ea efm ep et fdc fdo ffs fk foldcolumn foldmethod formatoptions gd go guifont guitabtooltip hid hkp iconstring imd include inex isi js kp linebreak lm lz matchpairs maxmemtot mkspellmem mod mousef mouset nf oft pa path pheader previewheight printmbcharset pvw report rlc ruler sc scrolloff sel shcf shellslash shm showmatch sidescrolloff smartindent softtabstop spellfile splitright ssl statusline suffixes swf syntax tagbsearch tb term textwidth timeoutlen tm tr ttm ttyscroll undolevels vdir viewdir wa wd wi wildmode winfixwidth wiw wrap writedelay
  syn keyword vimOption contained	aleph ar autoindent backspace ballooneval bg bkc bsdir cb ch cino cmp compatible copyindent cscopeprg csqf cursorline dex digraph ead ei equalalways eventignore fde fdt fileencoding fkmap foldenable foldminlines formatprg gdefault gp guifontset helpfile hidden hl ignorecase imdisable includeexpr inf isident key langmap lines lmap ma matchtime mco ml modeline mousefocus mousetime nrformats ofu para pdev pi previewwindow printmbfont qe restorescreen ro rulerformat scb scrollopt selection shell shelltemp shortmess showmode siso smarttab sol spelllang spr ssop stl suffixesadd switchbuf ta taglength tbi termbidi tf title to ts tty ttytype updatecount ve viewoptions wak weirdinvert wig wildoptions winheight wm wrapmargin ws
  syn keyword vimOption contained	allowrevins arab autoread backup balloonexpr bh bl bsk ccv charconvert cinoptions cms complete cot cscopequickfix cst cwh dg dip eadirection ek equalprg ex fdi fen fileencodings flp foldexpr foldnestmax fp gfm grepformat guifontwide helpheight highlight hlg im imi incsearch infercase isk keymap langmenu linespace loadplugins macatsui maxcombine mef mls modelines mousehide mp nu omnifunc paragraphs penc pm printdevice printoptions quoteescape revins rs runtimepath scr scs selectmode shellcmdflag shelltype shortname showtabline sj smc sp spellsuggest sps st stmp sw sws tabline tagrelative tbidi termencoding tgst titlelen toolbar tsl ttybuiltin tw updatetime verbose viminfo warn wfh wildchar wim winminheight wmh wrapscan ww
! syn keyword vimOption contained	altkeymap arabic autowrite backupcopy bdir bin bomb bt cd ci cinw co completefunc cp cscopetag csto debug dict dir eb enc errorbells expandtab fdl fenc fileformat fml foldignore foldopen fs gfn grepprg guiheadroom helplang history hls imactivatekey iminsert inde insertmode iskeyword keymodel laststatus lisp lpl magic maxfuncdepth menuitems mm modifiable mousem mps number opendevice paste pex pmbcs printencoding prompt rdt ri 
  
  " vimOptions: These are the turn-off setting variants {{{2
  syn keyword vimOption contained	noacd noallowrevins noantialias noarabic noarshape noautoread noaw noballooneval nobinary nobk nobuflisted nocin noconfirm nocopyindent nocscopeverbose nocuc nocursorline nodg nodisable noeb noedcompatible noendofline noequalalways noesckeys noex noexrc nofk nofoldenable nogdefault nohid nohk nohkmapp nohls noic noignorecase noimc noimd noinf noinsertmode nojoinspaces nolazyredraw nolinebreak nolist nolpl noma nomagic noml nomodeline nomodified nomousef nomousehide nonumber noopendevice nopi nopreviewwindow nopvw noremap norevins norightleft norl noro noru nosb noscb noscs nosft noshelltemp noshortname noshowfulltag noshowmode nosm nosmartindent nosmd nosol nosplitbelow nospr nossl nostartofline noswapfile nota notagrelative notbi notbs noterse notextmode notgst notimeout noto notr nottybuiltin notx novisualbell nowarn noweirdinvert nowfw nowinfixheight nowiv nowrap nowrite nowritebackup
  syn keyword vimOption contained	noai noaltkeymap noar noarabicshape noautochdir noautowrite noawa nobeval nobiosk nobl nocf nocindent noconsk nocp nocst nocul nodeco nodiff noea noed noek noeol noerrorbells noet noexpandtab nofen nofkmap nogd noguipty nohidden nohkmap nohkp nohlsearch noicon noim noimcmdline noincsearch noinfercase nois nojs nolbr nolisp noloadplugins nolz nomacatsui nomh nomod nomodifiable nomore nomousefocus nonu noodev nopaste nopreserveindent noprompt noreadonly norestorescreen nori norightleftcmd norlc nors noruler nosc noscrollbind nosecure noshellslash noshiftround noshowcmd noshowmatch nosi nosmartcase nosmarttab nosn nospell nosplitright nosr nosta nostmp noswf notagbsearch notagstack notbidi notermbidi notextauto notf notildeop notitle notop nottimeout nottyfast novb nowa nowb nowfh nowildmenu nowinfixwidth nowmnu nowrapscan nowriteany nows
! syn keyword vimOption contained	noakm noanti noarab noari noautoindent noautowriteall nobackup nobin nobioskey nobomb noci nocompatible noconskey nocscopetag nocsverb nocursorcolumn nodelcombine nodigraph 
  
  " vimOptions: These are the invertible variants {{{2
  syn keyword vimOption contained	invacd invallowrevins invantialias invarabic invarshape invautoread invaw invballooneval invbinary invbk invbuflisted invcin invconfirm invcopyindent invcscopeverbose invcuc invcursorline invdg invdisable inveb invedcompatible invendofline invequalalways invesckeys invex invexrc invfk invfoldenable invgdefault invhid invhk invhkmapp invhls invic invignorecase invimc invimd invinf invinsertmode invjoinspaces invlazyredraw invlinebreak invlist invlpl invma invmagic invml invmodeline invmodified invmousef invmousehide invnumber invopendevice invpi invpreviewwindow invpvw invremap invrevins invrightleft invrl invro invru invsb invscb invscs invsft invshelltemp invshortname invshowfulltag invshowmode invsm invsmartindent invsmd invsol invsplitbelow invspr invssl invstartofline invswapfile invta invtagrelative invtbi invtbs invterse invtextmode invtgst invtimeout invto invtr invttybuiltin invtx invvisualbell invwarn invweirdinvert invwfw invwinfixheight invwiv invwrap invwrite invwritebackup
  syn keyword vimOption contained	invai invaltkeymap invar invarabicshape invautochdir invautowrite invawa invbeval invbiosk invbl invcf invcindent invconsk invcp invcst invcul invdeco invdiff invea inved invek inveol inverrorbells invet invexpandtab invfen invfkmap invgd invguipty invhidden invhkmap invhkp invhlsearch invicon invim invimcmdline invincsearch invinfercase invis invjs invlbr invlisp invloadplugins invlz invmacatsui invmh invmod invmodifiable invmore invmousefocus invnu invodev invpaste invpreserveindent invprompt invreadonly invrestorescreen invri invrightleftcmd invrlc invrs invruler invsc invscrollbind invsecure invshellslash invshiftround invshowcmd invshowmatch invsi invsmartcase invsmarttab invsn invspell invsplitright invsr invsta invstmp invswf invtagbsearch invtagstack invtbidi invtermbidi invtextauto invtf invtildeop invtitle invtop invttimeout invttyfast invvb invwa invwb invwfh invwildmenu invwinfixwidth invwmnu invwrapscan invwriteany invws
! syn keyword vimOption contained	invakm invanti invarab invari invautoindent invautowriteall invbackup invbin invbioskey invbomb invci invcompatible invconskey invcscopetag invcsverb invcursorcolumn invdelcombine invdigraph 
  
  " termcap codes (which can also be set) {{{2
  syn keyword vimOption contained	t_AB t_al t_bc t_ce t_cl t_Co t_cs t_Cs t_CS t_CV t_da t_db t_dl t_DL t_EI t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_te t_ti t_ts t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xs t_ZH t_ZR
--- 30,46 ----
  syn keyword vimOption contained	al antialias autochdir background balloondelay bexpr bk bs casemap cfu cinkeys cmdwinheight commentstring conskey cscopepathcomp csprg cursorcolumn delcombine diffopt ea efm ep et fdc fdo ffs fk foldcolumn foldmethod formatoptions gd go guifont guitabtooltip hid hkp iconstring imd include inex isi js kp linebreak lm lz matchpairs maxmemtot mkspellmem mod mousef mouset nf oft pa path pheader previewheight printmbcharset pvw report rlc ruler sc scrolloff sel shcf shellslash shm showmatch sidescrolloff smartindent softtabstop spellfile splitright ssl statusline suffixes swf syntax tagbsearch tb term textwidth timeoutlen tm tr ttm ttyscroll undolevels vdir viewdir wa wd wi wildmode winfixwidth wiw wrap writedelay
  syn keyword vimOption contained	aleph ar autoindent backspace ballooneval bg bkc bsdir cb ch cino cmp compatible copyindent cscopeprg csqf cursorline dex digraph ead ei equalalways eventignore fde fdt fileencoding fkmap foldenable foldminlines formatprg gdefault gp guifontset helpfile hidden hl ignorecase imdisable includeexpr inf isident key langmap lines lmap ma matchtime mco ml modeline mousefocus mousetime nrformats ofu para pdev pi previewwindow printmbfont qe restorescreen ro rulerformat scb scrollopt selection shell shelltemp shortmess showmode siso smarttab sol spelllang spr ssop stl suffixesadd switchbuf ta taglength tbi termbidi tf title to ts tty ttytype updatecount ve viewoptions wak weirdinvert wig wildoptions winheight wm wrapmargin ws
  syn keyword vimOption contained	allowrevins arab autoread backup balloonexpr bh bl bsk ccv charconvert cinoptions cms complete cot cscopequickfix cst cwh dg dip eadirection ek equalprg ex fdi fen fileencodings flp foldexpr foldnestmax fp gfm grepformat guifontwide helpheight highlight hlg im imi incsearch infercase isk keymap langmenu linespace loadplugins macatsui maxcombine mef mls modelines mousehide mp nu omnifunc paragraphs penc pm printdevice printoptions quoteescape revins rs runtimepath scr scs selectmode shellcmdflag shelltype shortname showtabline sj smc sp spellsuggest sps st stmp sw sws tabline tagrelative tbidi termencoding tgst titlelen toolbar tsl ttybuiltin tw updatetime verbose viminfo warn wfh wildchar wim winminheight wmh wrapscan ww
! syn keyword vimOption contained	altkeymap arabic autowrite backupcopy bdir bin bomb bt cd ci cinw co completefunc cp cscopetag csto debug dict dir eb enc errorbells expandtab fdl fenc fileformat fml foldignore foldopen fs gfn grepprg guiheadroom helplang history hls imactivatekey iminsert inde insertmode iskeyword keymodel laststatus lisp lpl magic maxfuncdepth menuitems mm modifiable mousem mps number opendevice paste pex pmbcs printencoding prompt rdt ri relativenumber rnu
  
  " vimOptions: These are the turn-off setting variants {{{2
  syn keyword vimOption contained	noacd noallowrevins noantialias noarabic noarshape noautoread noaw noballooneval nobinary nobk nobuflisted nocin noconfirm nocopyindent nocscopeverbose nocuc nocursorline nodg nodisable noeb noedcompatible noendofline noequalalways noesckeys noex noexrc nofk nofoldenable nogdefault nohid nohk nohkmapp nohls noic noignorecase noimc noimd noinf noinsertmode nojoinspaces nolazyredraw nolinebreak nolist nolpl noma nomagic noml nomodeline nomodified nomousef nomousehide nonumber noopendevice nopi nopreviewwindow nopvw noremap norevins norightleft norl noro noru nosb noscb noscs nosft noshelltemp noshortname noshowfulltag noshowmode nosm nosmartindent nosmd nosol nosplitbelow nospr nossl nostartofline noswapfile nota notagrelative notbi notbs noterse notextmode notgst notimeout noto notr nottybuiltin notx novisualbell nowarn noweirdinvert nowfw nowinfixheight nowiv nowrap nowrite nowritebackup
  syn keyword vimOption contained	noai noaltkeymap noar noarabicshape noautochdir noautowrite noawa nobeval nobiosk nobl nocf nocindent noconsk nocp nocst nocul nodeco nodiff noea noed noek noeol noerrorbells noet noexpandtab nofen nofkmap nogd noguipty nohidden nohkmap nohkp nohlsearch noicon noim noimcmdline noincsearch noinfercase nois nojs nolbr nolisp noloadplugins nolz nomacatsui nomh nomod nomodifiable nomore nomousefocus nonu noodev nopaste nopreserveindent noprompt noreadonly norestorescreen nori norightleftcmd norlc nors noruler nosc noscrollbind nosecure noshellslash noshiftround noshowcmd noshowmatch nosi nosmartcase nosmarttab nosn nospell nosplitright nosr nosta nostmp noswf notagbsearch notagstack notbidi notermbidi notextauto notf notildeop notitle notop nottimeout nottyfast novb nowa nowb nowfh nowildmenu nowinfixwidth nowmnu nowrapscan nowriteany nows
! syn keyword vimOption contained	noakm noanti noarab noari noautoindent noautowriteall nobackup nobin nobioskey nobomb noci nocompatible noconskey nocscopetag nocsverb nocursorcolumn nodelcombine nodigraph norelativenumber nornu
  
  " vimOptions: These are the invertible variants {{{2
  syn keyword vimOption contained	invacd invallowrevins invantialias invarabic invarshape invautoread invaw invballooneval invbinary invbk invbuflisted invcin invconfirm invcopyindent invcscopeverbose invcuc invcursorline invdg invdisable inveb invedcompatible invendofline invequalalways invesckeys invex invexrc invfk invfoldenable invgdefault invhid invhk invhkmapp invhls invic invignorecase invimc invimd invinf invinsertmode invjoinspaces invlazyredraw invlinebreak invlist invlpl invma invmagic invml invmodeline invmodified invmousef invmousehide invnumber invopendevice invpi invpreviewwindow invpvw invremap invrevins invrightleft invrl invro invru invsb invscb invscs invsft invshelltemp invshortname invshowfulltag invshowmode invsm invsmartindent invsmd invsol invsplitbelow invspr invssl invstartofline invswapfile invta invtagrelative invtbi invtbs invterse invtextmode invtgst invtimeout invto invtr invttybuiltin invtx invvisualbell invwarn invweirdinvert invwfw invwinfixheight invwiv invwrap invwrite invwritebackup
  syn keyword vimOption contained	invai invaltkeymap invar invarabicshape invautochdir invautowrite invawa invbeval invbiosk invbl invcf invcindent invconsk invcp invcst invcul invdeco invdiff invea inved invek inveol inverrorbells invet invexpandtab invfen invfkmap invgd invguipty invhidden invhkmap invhkp invhlsearch invicon invim invimcmdline invincsearch invinfercase invis invjs invlbr invlisp invloadplugins invlz invmacatsui invmh invmod invmodifiable invmore invmousefocus invnu invodev invpaste invpreserveindent invprompt invreadonly invrestorescreen invri invrightleftcmd invrlc invrs invruler invsc invscrollbind invsecure invshellslash invshiftround invshowcmd invshowmatch invsi invsmartcase invsmarttab invsn invspell invsplitright invsr invsta invstmp invswf invtagbsearch invtagstack invtbidi invtermbidi invtextauto invtf invtildeop invtitle invtop invttimeout invttyfast invvb invwa invwb invwfh invwildmenu invwinfixwidth invwmnu invwrapscan invwriteany invws
! syn keyword vimOption contained	invakm invanti invarab invari invautoindent invautowriteall invbackup invbin invbioskey invbomb invci invcompatible invconskey invcscopetag invcsverb invcursorcolumn invdelcombine invdigraph invrelativenumber invrnu
  
  " termcap codes (which can also be set) {{{2
  syn keyword vimOption contained	t_AB t_al t_bc t_ce t_cl t_Co t_cs t_Cs t_CS t_CV t_da t_db t_dl t_DL t_EI t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_te t_ti t_ts t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xs t_ZH t_ZR
Index: runtime/menu.vim
===================================================================
*** runtime/menu.vim	(revision 1159)
--- runtime/menu.vim	(working copy)
***************
*** 275,280 ****
--- 275,281 ----
  
  " Boolean options
  an 20.440.100 &Edit.F&ile\ Settings.Toggle\ Line\ &Numbering<Tab>:set\ nu!	:set nu! nu?<CR>
+ an 20.440.105 &Edit.F&ile\ Settings.Toggle\ relati&ve\ Line\ Numbering<Tab>:set\ rnu!	:set rnu! rnu?<CR>
  an 20.440.110 &Edit.F&ile\ Settings.Toggle\ &List\ Mode<Tab>:set\ list!	:set list! list?<CR>
  an 20.440.120 &Edit.F&ile\ Settings.Toggle\ Line\ &Wrap<Tab>:set\ wrap!	:set wrap! wrap?<CR>
  an 20.440.130 &Edit.F&ile\ Settings.Toggle\ W&rap\ at\ word<Tab>:set\ lbr!	:set lbr! lbr?<CR>
Index: runtime/optwin.vim
===================================================================
*** runtime/optwin.vim	(revision 1159)
--- runtime/optwin.vim	(working copy)
***************
*** 365,370 ****
--- 365,373 ----
  call append("$", "number\tshow the line number for each line")
  call append("$", "\t(local to window)")
  call <SID>BinOptionL("nu")
+ call append("$", "relativenumber\tshow the relative line number for each line")
+ call append("$", "\t(local to window)")
+ call <SID>BinOptionL("rnu")
  if has("linebreak")
    call append("$", "numberwidth\tnumber of columns to use for the line number")
    call append("$", "\t(local to window)")
Index: src/proto/misc2.pro
===================================================================
*** src/proto/misc2.pro	(revision 1159)
--- src/proto/misc2.pro	(working copy)
***************
*** 11,16 ****
--- 11,17 ----
  int dec_cursor __ARGS((void));
  int dec __ARGS((pos_T *lp));
  int decl __ARGS((pos_T *lp));
+ linenr_T get_cursor_rel_lnum __ARGS((win_T *wp, linenr_T lnum));
  void check_cursor_lnum __ARGS((void));
  void check_cursor_col __ARGS((void));
  void check_cursor __ARGS((void));
Index: src/edit.c
===================================================================
*** src/edit.c	(revision 1159)
--- src/edit.c	(working copy)
***************
*** 6165,6171 ****
  		    )
  	    textwidth -= 1;
  #endif
! 	if (curwin->w_p_nu)
  	    textwidth -= 8;
      }
      if (textwidth < 0)
--- 6165,6171 ----
  		    )
  	    textwidth -= 1;
  #endif
! 	if (curwin->w_p_nu || curwin->w_p_rnu)
  	    textwidth -= 8;
      }
      if (textwidth < 0)
Index: src/ex_cmds.c
===================================================================
*** src/ex_cmds.c	(revision 1159)
--- src/ex_cmds.c	(working copy)
***************
*** 3472,3477 ****
--- 3472,3478 ----
  	curbuf->b_p_ma = FALSE;		/* not modifiable */
  	curbuf->b_p_bin = FALSE;	/* reset 'bin' before reading file */
  	curwin->w_p_nu = 0;		/* no line numbers */
+ 	curwin->w_p_rnu = 0;		/* no relative line numbers */
  #ifdef FEAT_SCROLLBIND
  	curwin->w_p_scb = FALSE;	/* no scroll binding */
  #endif
Index: src/gui.c
===================================================================
*** src/gui.c	(revision 1159)
--- src/gui.c	(working copy)
***************
*** 4362,4368 ****
  	max += W_WIDTH(curwin) - 1;
  #endif
  	/* The line number isn't scrolled, thus there is less space when
! 	 * 'number' is set (also for 'foldcolumn'). */
  	size -= curwin_col_off();
  #ifndef SCROLL_PAST_END
  	max -= curwin_col_off();
--- 4362,4368 ----
  	max += W_WIDTH(curwin) - 1;
  #endif
  	/* The line number isn't scrolled, thus there is less space when
! 	 * 'number' or 'relativenumber' is set (also for 'foldcolumn'). */
  	size -= curwin_col_off();
  #ifndef SCROLL_PAST_END
  	max -= curwin_col_off();
Index: src/misc1.c
===================================================================
*** src/misc1.c	(revision 1159)
--- src/misc1.c	(working copy)
***************
*** 1740,1746 ****
  	col += 1;
  
      /*
!      * Add column offset for 'number' and 'foldcolumn'.
       */
      width = W_WIDTH(wp) - win_col_off(wp);
      if (width <= 0)
--- 1740,1746 ----
  	col += 1;
  
      /*
!      * Add column offset for 'number', 'relativenumber' and 'foldcolumn'.
       */
      width = W_WIDTH(wp) - win_col_off(wp);
      if (width <= 0)
***************
*** 1801,1807 ****
  	col += win_lbr_chartabsize(wp, s, (colnr_T)col, NULL) - 1;
  
      /*
!      * Add column offset for 'number', 'foldcolumn', etc.
       */
      width = W_WIDTH(wp) - win_col_off(wp);
      if (width <= 0)
--- 1801,1807 ----
  	col += win_lbr_chartabsize(wp, s, (colnr_T)col, NULL) - 1;
  
      /*
!      * Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.
       */
      width = W_WIDTH(wp) - win_col_off(wp);
      if (width <= 0)
Index: src/misc2.c
===================================================================
*** src/misc2.c	(revision 1159)
--- src/misc2.c	(working copy)
***************
*** 469,474 ****
--- 469,525 ----
  }
  
  /*
+  * Get the line number relative to the actual cursor position, i.e. the
+  * difference between line number and cursor position. Only look for lines that
+  * can be visible, folded lines don't count.
+  */
+     linenr_T
+ get_cursor_rel_lnum(wp, lnum)
+     win_T	*wp;
+     linenr_T	lnum;		    /* line number to get the result for */
+ {
+     linenr_T	cursor = wp->w_cursor.lnum;
+     linenr_T	retval = 0;
+ 
+ #ifdef FEAT_FOLDING
+     if (hasAnyFolding(wp))
+     {
+ 	if (lnum > cursor)
+ 	{
+ 	    while (lnum > cursor)
+ 	    {
+ 		(void)hasFolding(lnum, &lnum, NULL);
+ 		/* if lnum and cursor are in the same fold,
+ 		 * now lnum <= cursor */
+ 		if (lnum > cursor)
+ 		    retval++;
+ 		lnum--;
+ 	    }
+ 	}
+ 	else if (lnum < cursor)
+ 	{
+ 	    while (lnum < cursor)
+ 	    {
+ 		(void)hasFolding(lnum, NULL, &lnum);
+ 		/* if lnum and cursor are in the same fold,
+ 		 * now lnum >= cursor */
+ 		if (lnum < cursor)
+ 		    retval--;
+ 		lnum++;
+ 	    }
+ 	}
+ 	/* else if (lnum == cursor)
+ 	 *     retval = 0;
+ 	 */
+     }
+     else
+ #endif
+ 	retval = lnum - cursor;
+ 
+     return retval;
+ }
+ 
+ /*
   * Make sure curwin->w_cursor.lnum is valid.
   */
      void
Index: src/move.c
===================================================================
*** src/move.c	(revision 1159)
--- src/move.c	(working copy)
***************
*** 910,923 ****
  }
  
  /*
!  * Compute offset of a window, occupied by line number, fold column and sign
!  * column (these don't move when scrolling horizontally).
   */
      int
  win_col_off(wp)
      win_T	*wp;
  {
!     return ((wp->w_p_nu ? number_width(wp) + 1 : 0)
  #ifdef FEAT_CMDWIN
  	    + (cmdwin_type == 0 || wp != curwin ? 0 : 1)
  #endif
--- 910,923 ----
  }
  
  /*
!  * Compute offset of a window, occupied by absolute or relative line number,
!  * fold column and sign column (these don't move when scrolling horizontally).
   */
      int
  win_col_off(wp)
      win_T	*wp;
  {
!     return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)
  #ifdef FEAT_CMDWIN
  	    + (cmdwin_type == 0 || wp != curwin ? 0 : 1)
  #endif
***************
*** 943,955 ****
  
  /*
   * Return the difference in column offset for the second screen line of a
!  * wrapped line.  It's 8 if 'number' is on and 'n' is in 'cpoptions'.
   */
      int
  win_col_off2(wp)
      win_T	*wp;
  {
!     if (wp->w_p_nu && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)
  	return number_width(wp) + 1;
      return 0;
  }
--- 943,956 ----
  
  /*
   * Return the difference in column offset for the second screen line of a
!  * wrapped line.  It's 8 if 'number' or 'relativenumber' is on and 'n' is in
!  * 'cpoptions'.
   */
      int
  win_col_off2(wp)
      win_T	*wp;
  {
!     if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)
  	return number_width(wp) + 1;
      return 0;
  }
***************
*** 1211,1227 ****
      if (prev_skipcol != curwin->w_skipcol)
  	redraw_later(NOT_VALID);
  
  #ifdef FEAT_SYN_HL
!     /* Redraw when w_virtcol changes and 'cursorcolumn' is set, or when w_row
!      * changes and 'cursorline' is set. */
!     if (((curwin->w_p_cuc && (curwin->w_valid & VALID_VIRTCOL) == 0)
! 		|| (curwin->w_p_cul && (curwin->w_valid & VALID_WROW) == 0))
  # ifdef FEAT_INS_EXPAND
! 	    && !pum_visible()
  # endif
! 	    )
! 	redraw_later(SOME_VALID);
! #endif
  
      curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;
  }
--- 1212,1233 ----
      if (prev_skipcol != curwin->w_skipcol)
  	redraw_later(NOT_VALID);
  
+     /* Redraw when w_row changes and 'relativenumber' is set */
+     if (((curwin->w_valid & VALID_WROW) == 0 && (curwin->w_p_rnu
  #ifdef FEAT_SYN_HL
! 	/* or when w_row changes and 'cursorline' is set. */
! 						|| curwin->w_p_cul
! #endif
! 	))
! #ifdef FEAT_SYN_HL
! 	/* or when w_virtcol changes and 'cursorcolumn' is set */
! 	|| (curwin->w_p_cuc && (curwin->w_valid & VALID_VIRTCOL) == 0)
! #endif
! 	)
  # ifdef FEAT_INS_EXPAND
! 	    if (!pum_visible())
  # endif
! 		redraw_later(SOME_VALID);
  
      curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;
  }
Index: src/netbeans.c
===================================================================
*** src/netbeans.c	(revision 1159)
--- src/netbeans.c	(working copy)
***************
*** 3119,3125 ****
  
      if (bufno >= 0 && curwin != NULL && curwin->w_buffer == curbuf)
      {
! 	int col = mouse_col - W_WINCOL(curwin) - (curwin->w_p_nu ? 9 : 1);
  	long off = pos2off(curbuf, &curwin->w_cursor);
  
  	/* sync the cursor position */
--- 3119,3126 ----
  
      if (bufno >= 0 && curwin != NULL && curwin->w_buffer == curbuf)
      {
! 	int col = mouse_col - W_WINCOL(curwin)
! 		  - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
  	long off = pos2off(curbuf, &curwin->w_cursor);
  
  	/* sync the cursor position */
Index: src/normal.c
===================================================================
*** src/normal.c	(revision 1159)
--- src/normal.c	(working copy)
***************
*** 7783,7790 ****
  	}
  	else
  	    i = curwin->w_leftcol;
! 	/* Go to the middle of the screen line.  When 'number' is on and lines
! 	 * are wrapping the middle can be more to the left. */
  	if (cap->nchar == 'm')
  	    i += (W_WIDTH(curwin) - curwin_col_off()
  		    + ((curwin->w_p_wrap && i > 0)
--- 7783,7791 ----
  	}
  	else
  	    i = curwin->w_leftcol;
! 	/* Go to the middle of the screen line.  When 'number' or
! 	 * 'relativenumber' is on and lines are wrapping the middle can be more
! 	 * to the left.*/
  	if (cap->nchar == 'm')
  	    i += (W_WIDTH(curwin) - curwin_col_off()
  		    + ((curwin->w_p_wrap && i > 0)
Index: src/option.c
===================================================================
*** src/option.c	(revision 1159)
--- src/option.c	(working copy)
***************
*** 207,212 ****
--- 207,213 ----
  # define PV_LBR		OPT_WIN(WV_LBR)
  #endif
  #define PV_NU		OPT_WIN(WV_NU)
+ #define PV_RNU		OPT_WIN(WV_RNU)
  #ifdef FEAT_LINEBREAK
  # define PV_NUW		OPT_WIN(WV_NUW)
  #endif
***************
*** 2018,2023 ****
--- 2018,2026 ----
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)2000L, (char_u *)0L} SCRIPTID_INIT},
+     {"relativenumber", "rnu", P_BOOL|P_VI_DEF|P_RWIN,
+ 			    (char_u *)VAR_WIN, PV_RNU,
+ 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"remap",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_remap, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
***************
*** 7318,7323 ****
--- 7322,7340 ----
  	    curwin->w_leftcol = 0;
      }
  
+     /* If 'number' is set, reset 'relativenumber'. */
+     else if ((int *)varp == &curwin->w_p_nu)
+     {
+ 	if (curwin->w_p_nu)
+ 	    curwin->w_p_rnu = FALSE;
+     }
+     /* If 'relativenumber' is set, reset 'number'. */
+     else if ((int *)varp == &curwin->w_p_rnu)
+     {
+ 	if (curwin->w_p_rnu)
+ 	    curwin->w_p_nu = FALSE;
+     }
+ 
  #ifdef FEAT_WINDOWS
      else if ((int *)varp == &p_ea)
      {
***************
*** 9028,9033 ****
--- 9045,9051 ----
  	case PV_FMR:	return (char_u *)&(curwin->w_p_fmr);
  #endif
  	case PV_NU:	return (char_u *)&(curwin->w_p_nu);
+ 	case PV_RNU:	return (char_u *)&(curwin->w_p_rnu);
  #ifdef FEAT_LINEBREAK
  	case PV_NUW:	return (char_u *)&(curwin->w_p_nuw);
  #endif
***************
*** 9213,9218 ****
--- 9231,9237 ----
  #endif
      to->wo_list = from->wo_list;
      to->wo_nu = from->wo_nu;
+     to->wo_rnu = from->wo_rnu;
  #ifdef FEAT_LINEBREAK
      to->wo_nuw = from->wo_nuw;
  #endif
Index: src/option.h
===================================================================
*** src/option.h	(revision 1159)
--- src/option.h	(working copy)
***************
*** 1039,1044 ****
--- 1039,1045 ----
      , WV_LBR
  #endif
      , WV_NU
+     , WV_RNU
  #ifdef FEAT_LINEBREAK
      , WV_NUW
  #endif
Index: src/screen.c
===================================================================
*** src/screen.c	(revision 1159)
--- src/screen.c	(working copy)
***************
*** 420,428 ****
  	check_for_delay(FALSE);
  
  #ifdef FEAT_LINEBREAK
!     /* Force redraw when width of 'number' column changes. */
      if (curwin->w_redr_type < NOT_VALID
! 	   && curwin->w_nrwidth != (curwin->w_p_nu ? number_width(curwin) : 0))
  	curwin->w_redr_type = NOT_VALID;
  #endif
  
--- 420,430 ----
  	check_for_delay(FALSE);
  
  #ifdef FEAT_LINEBREAK
!     /* Force redraw when width of 'number' or 'relativenumber' column
!      * changes. */
      if (curwin->w_redr_type < NOT_VALID
! 	   && curwin->w_nrwidth != ((curwin->w_p_nu || curwin->w_p_rnu)
! 				    ? number_width(curwin) : 0))
  	curwin->w_redr_type = NOT_VALID;
  #endif
  
***************
*** 861,868 ****
  #endif
  
  #ifdef FEAT_LINEBREAK
!     /* Force redraw when width of 'number' column changes. */
!     i = wp->w_p_nu ? number_width(wp) : 0;
      if (wp->w_nrwidth != i)
      {
  	type = NOT_VALID;
--- 863,871 ----
  #endif
  
  #ifdef FEAT_LINEBREAK
!     /* Force redraw when width of 'number' or 'relativenumber' column
!      * changes. */
!     i = (wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) : 0;
      if (wp->w_nrwidth != i)
      {
  	type = NOT_VALID;
***************
*** 2108,2114 ****
      /* Build the fold line:
       * 1. Add the cmdwin_type for the command-line window
       * 2. Add the 'foldcolumn'
!      * 3. Add the 'number' column
       * 4. Compose the text
       * 5. Add the text
       * 6. set highlighting for the Visual area an other text
--- 2111,2117 ----
      /* Build the fold line:
       * 1. Add the cmdwin_type for the command-line window
       * 2. Add the 'foldcolumn'
!      * 3. Add the 'number' or 'relativenumber' column
       * 4. Compose the text
       * 5. Add the text
       * 6. set highlighting for the Visual area an other text
***************
*** 2170,2176 ****
  				 ScreenAttrs[off + (p) + ri] = v
  #endif
  
!     /* Set all attributes of the 'number' column and the text */
      RL_MEMSET(col, hl_attr(HLF_FL), W_WIDTH(wp) - col);
  
  #ifdef FEAT_SIGNS
--- 2173,2180 ----
  				 ScreenAttrs[off + (p) + ri] = v
  #endif
  
!     /* Set all attributes of the 'number' or 'relativenumber' column and the
!      * text */
      RL_MEMSET(col, hl_attr(HLF_FL), W_WIDTH(wp) - col);
  
  #ifdef FEAT_SIGNS
***************
*** 2196,2213 ****
  #endif
  
      /*
!      * 3. Add the 'number' column
       */
!     if (wp->w_p_nu)
      {
  	len = W_WIDTH(wp) - col;
  	if (len > 0)
  	{
  	    int	    w = number_width(wp);
  
  	    if (len > w + 1)
  		len = w + 1;
! 	    sprintf((char *)buf, "%*ld ", w, (long)lnum);
  #ifdef FEAT_RIGHTLEFT
  	    if (wp->w_p_rl)
  		/* the line number isn't reversed */
--- 2200,2226 ----
  #endif
  
      /*
!      * 3. Add the 'number' or 'relativenumber' column
       */
!     if (wp->w_p_nu || wp->w_p_rnu)
      {
  	len = W_WIDTH(wp) - col;
  	if (len > 0)
  	{
  	    int	    w = number_width(wp);
+ 	    long num;
  
  	    if (len > w + 1)
  		len = w + 1;
! 
! 	    if (wp->w_p_nu)
! 		/* 'number' */
! 		num = (long)lnum;
! 	    else
! 		/* 'relativenumber', don't use negative numbers */
! 		num = (long)abs((int)get_cursor_rel_lnum(wp, lnum));
! 
! 	    sprintf((char *)buf, "%*ld ", w, num);
  #ifdef FEAT_RIGHTLEFT
  	    if (wp->w_p_rl)
  		/* the line number isn't reversed */
***************
*** 3286,3294 ****
  	    if (draw_state == WL_NR - 1 && n_extra == 0)
  	    {
  		draw_state = WL_NR;
! 		/* Display the line number.  After the first fill with blanks
! 		 * when the 'n' flag isn't in 'cpo' */
! 		if (wp->w_p_nu
  			&& (row == startrow
  #ifdef FEAT_DIFF
  			    + filler_lines
--- 3299,3307 ----
  	    if (draw_state == WL_NR - 1 && n_extra == 0)
  	    {
  		draw_state = WL_NR;
! 		/* Display the absolute or relative line number. After the
! 		 * first fill with blanks when the 'n' flag isn't in 'cpo' */
! 		if ((wp->w_p_nu || wp->w_p_rnu)
  			&& (row == startrow
  #ifdef FEAT_DIFF
  			    + filler_lines
***************
*** 3302,3309 ****
  #endif
  			    )
  		    {
  			sprintf((char *)extra, "%*ld ",
! 						number_width(wp), (long)lnum);
  			if (wp->w_skipcol > 0)
  			    for (p_extra = extra; *p_extra == ' '; ++p_extra)
  				*p_extra = '-';
--- 3315,3332 ----
  #endif
  			    )
  		    {
+ 			long num;
+ 
+ 			if (wp->w_p_nu)
+ 			    /* 'number' */
+ 			    num = (long)lnum;
+ 			else
+ 			    /* 'relativenumber', don't use negative numbers */
+ 			    num = (long)abs((int)get_cursor_rel_lnum(wp,
+ 								    lnum));
+ 
  			sprintf((char *)extra, "%*ld ",
! 						number_width(wp), num);
  			if (wp->w_skipcol > 0)
  			    for (p_extra = extra; *p_extra == ' '; ++p_extra)
  				*p_extra = '-';
***************
*** 4696,4702 ****
  	else
  	    --n_skip;
  
! 	/* Only advance the "vcol" when after the 'number' column. */
  	if (draw_state > WL_NR
  #ifdef FEAT_DIFF
  		&& filler_todo <= 0
--- 4696,4703 ----
  	else
  	    --n_skip;
  
! 	/* Only advance the "vcol" when after the 'number' or 'relativenumber'
! 	 * column. */
  	if (draw_state > WL_NR
  #ifdef FEAT_DIFF
  		&& filler_todo <= 0
***************
*** 9622,9629 ****
  
  #if defined(FEAT_LINEBREAK) || defined(PROTO)
  /*
!  * Return the width of the 'number' column.
!  * Caller may need to check if 'number' is set.
   * Otherwise it depends on 'numberwidth' and the line count.
   */
      int
--- 9646,9653 ----
  
  #if defined(FEAT_LINEBREAK) || defined(PROTO)
  /*
!  * Return the width of the 'number' and 'relativenumber' column.
!  * Caller may need to check if 'number' or 'relativenumber' is set.
   * Otherwise it depends on 'numberwidth' and the line count.
   */
      int
***************
*** 9633,9639 ****
      int		n;
      linenr_T	lnum;
  
!     lnum = wp->w_buffer->b_ml.ml_line_count;
      if (lnum == wp->w_nrwidth_line_count)
  	return wp->w_nrwidth_width;
      wp->w_nrwidth_line_count = lnum;
--- 9657,9669 ----
      int		n;
      linenr_T	lnum;
  
!     if (wp->w_p_nu)
! 	/* 'number' */
! 	lnum = wp->w_buffer->b_ml.ml_line_count;
!     else
! 	/* 'relativenumber' */
! 	lnum = wp->w_height;
! 
      if (lnum == wp->w_nrwidth_line_count)
  	return wp->w_nrwidth_width;
      wp->w_nrwidth_line_count = lnum;
Index: src/structs.h
===================================================================
*** src/structs.h	(revision 1159)
--- src/structs.h	(working copy)
***************
*** 169,174 ****
--- 169,176 ----
  #define w_p_list w_onebuf_opt.wo_list	/* 'list' */
      int		wo_nu;
  #define w_p_nu w_onebuf_opt.wo_nu	/* 'number' */
+     int		wo_rnu;
+ #define w_p_rnu w_onebuf_opt.wo_rnu	/* 'relativenumber' */
  #ifdef FEAT_LINEBREAK
      long	wo_nuw;
  # define w_p_nuw w_onebuf_opt.wo_nuw	/* 'numberwidth' */
***************
*** 1890,1896 ****
  				       recomputed */
  #endif
  #ifdef FEAT_LINEBREAK
!     int		w_nrwidth;	    /* width of 'number' column being used */
  #endif
  
      /*
--- 1892,1899 ----
  				       recomputed */
  #endif
  #ifdef FEAT_LINEBREAK
!     int		w_nrwidth;	    /* width of 'number' and 'relativenumber'
! 				       column being used */
  #endif
  
      /*
