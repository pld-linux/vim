To: vim-dev@vim.org
Subject: Patch 7.0.160
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.0.160
Problem:    ":@a" echoes the command, Vi doesn't do that.
Solution:   Set the silent flag in the typeahead buffer to avoid echoing the
            command.
Files:      src/ex_docmd.c, src/normal.c, src/ops.c, src/proto/ops.pro


*** ../vim-7.0.159/src/ex_docmd.c	Tue Oct 24 13:02:27 2006
--- src/ex_docmd.c	Tue Nov  7 17:42:52 2006
***************
*** 8219,8226 ****
      c = *eap->arg;
      if (c == NUL || (c == '*' && *eap->cmd == '*'))
  	c = '@';
!     /* put the register in mapbuf */
!     if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL) == FAIL)
      {
  	beep_flush();
      }
--- 8219,8227 ----
      c = *eap->arg;
      if (c == NUL || (c == '*' && *eap->cmd == '*'))
  	c = '@';
!     /* Put the register in the typeahead buffer with the "silent" flag. */
!     if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)
! 								      == FAIL)
      {
  	beep_flush();
      }
*** ../vim-7.0.159/src/normal.c	Tue Oct 17 22:40:14 2006
--- src/normal.c	Tue Nov  7 17:42:59 2006
***************
*** 8860,8866 ****
  #endif
      while (cap->count1-- && !got_int)
      {
! 	if (do_execreg(cap->nchar, FALSE, FALSE) == FAIL)
  	{
  	    clearopbeep(cap->oap);
  	    break;
--- 8860,8866 ----
  #endif
      while (cap->count1-- && !got_int)
      {
! 	if (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)
  	{
  	    clearopbeep(cap->oap);
  	    break;
*** ../vim-7.0.159/src/ops.c	Tue Oct 17 16:26:52 2006
--- src/ops.c	Tue Nov  7 17:52:30 2006
***************
*** 95,102 ****
  static void block_insert __ARGS((oparg_T *oap, char_u *s, int b_insert, struct block_def*bdp));
  #endif
  static int	stuff_yank __ARGS((int, char_u *));
! static void	put_reedit_in_typebuf __ARGS((void));
! static int	put_in_typebuf __ARGS((char_u *s, int colon));
  static void	stuffescaped __ARGS((char_u *arg, int literally));
  #ifdef FEAT_MBYTE
  static void	mb_adjust_opend __ARGS((oparg_T *oap));
--- 95,102 ----
  static void block_insert __ARGS((oparg_T *oap, char_u *s, int b_insert, struct block_def*bdp));
  #endif
  static int	stuff_yank __ARGS((int, char_u *));
! static void	put_reedit_in_typebuf __ARGS((int silent));
! static int	put_in_typebuf __ARGS((char_u *s, int colon, int silent));
  static void	stuffescaped __ARGS((char_u *arg, int literally));
  #ifdef FEAT_MBYTE
  static void	mb_adjust_opend __ARGS((oparg_T *oap));
***************
*** 1120,1129 ****
   * return FAIL for failure, OK otherwise
   */
      int
! do_execreg(regname, colon, addcr)
      int	    regname;
      int	    colon;		/* insert ':' before each line */
      int	    addcr;		/* always add '\n' to end of line */
  {
      static int	lastc = NUL;
      long	i;
--- 1120,1130 ----
   * return FAIL for failure, OK otherwise
   */
      int
! do_execreg(regname, colon, addcr, silent)
      int	    regname;
      int	    colon;		/* insert ':' before each line */
      int	    addcr;		/* always add '\n' to end of line */
+     int	    silent;		/* set "silent" flag in typeahead buffer */
  {
      static int	lastc = NUL;
      long	i;
***************
*** 1173,1181 ****
  	    /* When in Visual mode "'<,'>" will be prepended to the command.
  	     * Remove it when it's already there. */
  	    if (VIsual_active && STRNCMP(p, "'<,'>", 5) == 0)
! 		retval = put_in_typebuf(p + 5, TRUE);
  	    else
! 		retval = put_in_typebuf(p, TRUE);
  	}
  	vim_free(p);
      }
--- 1174,1182 ----
  	    /* When in Visual mode "'<,'>" will be prepended to the command.
  	     * Remove it when it's already there. */
  	    if (VIsual_active && STRNCMP(p, "'<,'>", 5) == 0)
! 		retval = put_in_typebuf(p + 5, TRUE, silent);
  	    else
! 		retval = put_in_typebuf(p, TRUE, silent);
  	}
  	vim_free(p);
      }
***************
*** 1186,1192 ****
  	p = get_expr_line();
  	if (p == NULL)
  	    return FAIL;
! 	retval = put_in_typebuf(p, colon);
  	vim_free(p);
      }
  #endif
--- 1187,1193 ----
  	p = get_expr_line();
  	if (p == NULL)
  	    return FAIL;
! 	retval = put_in_typebuf(p, colon, silent);
  	vim_free(p);
      }
  #endif
***************
*** 1198,1204 ****
  	    EMSG(_(e_noinstext));
  	    return FAIL;
  	}
! 	retval = put_in_typebuf(p, colon);
  	vim_free(p);
      }
      else
--- 1199,1205 ----
  	    EMSG(_(e_noinstext));
  	    return FAIL;
  	}
! 	retval = put_in_typebuf(p, colon, silent);
  	vim_free(p);
      }
      else
***************
*** 1213,1232 ****
  	/*
  	 * Insert lines into typeahead buffer, from last one to first one.
  	 */
! 	put_reedit_in_typebuf();
  	for (i = y_current->y_size; --i >= 0; )
  	{
  	    /* insert NL between lines and after last line if type is MLINE */
  	    if (y_current->y_type == MLINE || i < y_current->y_size - 1
  								     || addcr)
  	    {
! 		if (ins_typebuf((char_u *)"\n", remap, 0, TRUE, FALSE) == FAIL)
  		    return FAIL;
  	    }
! 	    if (ins_typebuf(y_current->y_array[i], remap, 0, TRUE, FALSE)
  								      == FAIL)
  		return FAIL;
! 	    if (colon && ins_typebuf((char_u *)":", remap, 0, TRUE, FALSE)
  								      == FAIL)
  		return FAIL;
  	}
--- 1214,1233 ----
  	/*
  	 * Insert lines into typeahead buffer, from last one to first one.
  	 */
! 	put_reedit_in_typebuf(silent);
  	for (i = y_current->y_size; --i >= 0; )
  	{
  	    /* insert NL between lines and after last line if type is MLINE */
  	    if (y_current->y_type == MLINE || i < y_current->y_size - 1
  								     || addcr)
  	    {
! 		if (ins_typebuf((char_u *)"\n", remap, 0, TRUE, silent) == FAIL)
  		    return FAIL;
  	    }
! 	    if (ins_typebuf(y_current->y_array[i], remap, 0, TRUE, silent)
  								      == FAIL)
  		return FAIL;
! 	    if (colon && ins_typebuf((char_u *)":", remap, 0, TRUE, silent)
  								      == FAIL)
  		return FAIL;
  	}
***************
*** 1240,1246 ****
   * used only after other typeahead has been processed.
   */
      static void
! put_reedit_in_typebuf()
  {
      char_u	buf[3];
  
--- 1241,1248 ----
   * used only after other typeahead has been processed.
   */
      static void
! put_reedit_in_typebuf(silent)
!     int		silent;
  {
      char_u	buf[3];
  
***************
*** 1257,1281 ****
  	    buf[0] = restart_edit == 'I' ? 'i' : restart_edit;
  	    buf[1] = NUL;
  	}
! 	if (ins_typebuf(buf, REMAP_NONE, 0, TRUE, FALSE) == OK)
  	    restart_edit = NUL;
      }
  }
  
      static int
! put_in_typebuf(s, colon)
      char_u	*s;
      int		colon;	    /* add ':' before the line */
  {
      int		retval = OK;
  
!     put_reedit_in_typebuf();
      if (colon)
! 	retval = ins_typebuf((char_u *)"\n", REMAP_YES, 0, TRUE, FALSE);
      if (retval == OK)
! 	retval = ins_typebuf(s, REMAP_YES, 0, TRUE, FALSE);
      if (colon && retval == OK)
! 	retval = ins_typebuf((char_u *)":", REMAP_YES, 0, TRUE, FALSE);
      return retval;
  }
  
--- 1259,1284 ----
  	    buf[0] = restart_edit == 'I' ? 'i' : restart_edit;
  	    buf[1] = NUL;
  	}
! 	if (ins_typebuf(buf, REMAP_NONE, 0, TRUE, silent) == OK)
  	    restart_edit = NUL;
      }
  }
  
      static int
! put_in_typebuf(s, colon, silent)
      char_u	*s;
      int		colon;	    /* add ':' before the line */
+     int		silent;
  {
      int		retval = OK;
  
!     put_reedit_in_typebuf(silent);
      if (colon)
! 	retval = ins_typebuf((char_u *)"\n", REMAP_YES, 0, TRUE, silent);
      if (retval == OK)
! 	retval = ins_typebuf(s, REMAP_YES, 0, TRUE, silent);
      if (colon && retval == OK)
! 	retval = ins_typebuf((char_u *)":", REMAP_YES, 0, TRUE, silent);
      return retval;
  }
  
*** ../vim-7.0.159/src/proto/ops.pro	Tue Oct 17 16:26:52 2006
--- src/proto/ops.pro	Tue Nov  7 18:08:35 2006
***************
*** 17,23 ****
  extern void put_register __ARGS((int name, void *reg));
  extern int yank_register_mline __ARGS((int regname));
  extern int do_record __ARGS((int c));
! extern int do_execreg __ARGS((int regname, int colon, int addcr));
  extern int insert_reg __ARGS((int regname, int literally));
  extern int get_spec_reg __ARGS((int regname, char_u **argp, int *allocated, int errmsg));
  extern int cmdline_paste_reg __ARGS((int regname, int literally, int remcr));
--- 17,23 ----
  extern void put_register __ARGS((int name, void *reg));
  extern int yank_register_mline __ARGS((int regname));
  extern int do_record __ARGS((int c));
! extern int do_execreg __ARGS((int regname, int colon, int addcr, int silent));
  extern int insert_reg __ARGS((int regname, int literally));
  extern int get_spec_reg __ARGS((int regname, char_u **argp, int *allocated, int errmsg));
  extern int cmdline_paste_reg __ARGS((int regname, int literally, int remcr));
*** ../vim-7.0.159/src/version.c	Tue Nov  7 18:02:19 2006
--- src/version.c	Tue Nov  7 18:05:36 2006
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     160,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
172. You join listservers just for the extra e-mail.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
