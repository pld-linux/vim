To: vim-dev@vim.org
Subject: Patch 6.2.328
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 6.2.328
Problem:    XIM with GTK: It is hard to understand what XIM is doing.
Solution:   Add xim_log() to log XIM events and help with debugging.
Files:	    src/mbyte.c


*** ../vim-6.2.327/src/mbyte.c	Mon Mar  1 17:11:04 2004
--- src/mbyte.c	Fri Mar  5 15:57:24 2004
***************
*** 133,138 ****
--- 133,169 ----
      3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1,
  };
  
+ /*
+  * XIM often causes trouble.  Define XIM_DEBUG to get a log of XIM callbacks
+  * in the "xim.log" file.
+  */
+ /* #define XIM_DEBUG */
+ #ifdef XIM_DEBUG
+     static void
+ xim_log(char *s, ...)
+ {
+     va_list arglist;
+     static FILE *fd = NULL;
+ 
+     if (fd == (FILE *)-1)
+ 	return;
+     if (fd == NULL)
+     {
+ 	fd = fopen("xim.log", "w");
+ 	if (fd == NULL)
+ 	{
+ 	    EMSG("Cannot open xim.log");
+ 	    fd = (FILE *)-1;
+ 	    return;
+ 	}
+     }
+ 
+     va_start(arglist, s);
+     vfprintf(fd, s, arglist);
+     va_end(arglist);
+ }
+ #endif
+ 
  #endif
  
  #if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT) || defined(PROTO)
***************
*** 3007,3012 ****
--- 3038,3057 ----
  
  #if defined(FEAT_XIM) || defined(PROTO)
  
+ # ifdef FEAT_GUI_GTK
+ /*
+  * Set preedit_start_col to the current cursor position.
+  */
+     static void
+ init_preedit_start_col(void)
+ {
+     if (State & CMDLINE)
+ 	preedit_start_col = cmdline_getvcol_cursor();
+     else if (curwin != NULL)
+ 	getvcol(curwin, &curwin->w_cursor, &preedit_start_col, NULL, NULL);
+ }
+ # endif
+ 
  # if defined(HAVE_GTK2) && !defined(PROTO)
  
  static int im_is_active	       = FALSE;	/* IM is enabled for current mode    */
***************
*** 3128,3135 ****
      static void
  im_commit_cb(GtkIMContext *context, const gchar *str, gpointer data)
  {
!     int slen = (int)strlen(str);
!     int add_to_input = TRUE;
  
      /* The imhangul module doesn't reset the preedit string before
       * committing.  Call im_delete_preedit() to work around that. */
--- 3173,3184 ----
      static void
  im_commit_cb(GtkIMContext *context, const gchar *str, gpointer data)
  {
!     int		slen = (int)STRLEN(str);
!     int		add_to_input = TRUE;
! 
! #ifdef XIM_DEBUG
!     xim_log("im_commit_cb(): %s\n", str);
! #endif
  
      /* The imhangul module doesn't reset the preedit string before
       * committing.  Call im_delete_preedit() to work around that. */
***************
*** 3141,3166 ****
      /* Is this a single character that matches a keypad key that's just
       * been pressed?  If so, we don't want it to be entered as such - let
       * us carry on processing the raw keycode so that it may be used in
!      * mappings as <kSomething>
!      */
      if (xim_expected_char != NUL)
      {
!         /* We're currently processing a keypad or other special key */
!         if (slen == 1 && str[0] == xim_expected_char)
!         {
!             /* It's a match - don't do it here */
!             xim_ignored_char = TRUE;
!             add_to_input = FALSE;
!         }
!         else
!         {
!             /* Not a match */
!             xim_ignored_char = FALSE;
!         }
      }
  
      if (add_to_input)
!         im_add_to_input((char_u *)str, slen);
  
      if (gtk_main_level() > 0)
  	gtk_main_quit();
--- 3190,3214 ----
      /* Is this a single character that matches a keypad key that's just
       * been pressed?  If so, we don't want it to be entered as such - let
       * us carry on processing the raw keycode so that it may be used in
!      * mappings as <kSomething>. */
      if (xim_expected_char != NUL)
      {
! 	/* We're currently processing a keypad or other special key */
! 	if (slen == 1 && str[0] == xim_expected_char)
! 	{
! 	    /* It's a match - don't do it here */
! 	    xim_ignored_char = TRUE;
! 	    add_to_input = FALSE;
! 	}
! 	else
! 	{
! 	    /* Not a match */
! 	    xim_ignored_char = FALSE;
! 	}
      }
  
      if (add_to_input)
! 	im_add_to_input((char_u *)str, slen);
  
      if (gtk_main_level() > 0)
  	gtk_main_quit();
***************
*** 3173,3181 ****
--- 3221,3234 ----
      static void
  im_preedit_start_cb(GtkIMContext *context, gpointer data)
  {
+ #ifdef XIM_DEBUG
+     xim_log("im_preedit_start_cb()\n");
+ #endif
+ 
      im_is_active = TRUE;
      gui_update_cursor(TRUE, FALSE);
  }
+ 
  /*
   * Callback invoked after end to the preedit.
   */
***************
*** 3183,3188 ****
--- 3236,3244 ----
      static void
  im_preedit_end_cb(GtkIMContext *context, gpointer data)
  {
+ #ifdef XIM_DEBUG
+     xim_log("im_preedit_end_cb()\n");
+ #endif
      im_is_active = FALSE;
      gui_update_cursor(TRUE, FALSE);
  }
***************
*** 3239,3244 ****
--- 3295,3304 ----
  				      &preedit_string, NULL,
  				      &cursor_index);
  
+ #ifdef XIM_DEBUG
+     xim_log("im_preedit_changed_cb(): %s\n", preedit_string);
+ #endif
+ 
      g_return_if_fail(preedit_string != NULL); /* just in case */
  
      /* If at the start position (after typing backspace) preedit_start_col
***************
*** 3246,3258 ****
      if (cursor_index == 0)
  	preedit_start_col = MAXCOL;
  
      if (preedit_start_col == MAXCOL && preedit_string[0] != '\0')
      {
  	/* Urgh, this breaks if the input buffer isn't empty now */
! 	if (State & CMDLINE)
! 	    preedit_start_col = cmdline_getvcol_cursor();
! 	else if (curwin != NULL)
! 	    getvcol(curwin, &curwin->w_cursor, &preedit_start_col, NULL, NULL);
      }
  
      im_delete_preedit();
--- 3306,3316 ----
      if (cursor_index == 0)
  	preedit_start_col = MAXCOL;
  
+     /* If preedit_start_col is MAXCOL set it to the current cursor position. */
      if (preedit_start_col == MAXCOL && preedit_string[0] != '\0')
      {
  	/* Urgh, this breaks if the input buffer isn't empty now */
! 	init_preedit_start_col();
      }
  
      im_delete_preedit();
***************
*** 3396,3401 ****
--- 3454,3463 ----
      void
  xim_init(void)
  {
+ #ifdef XIM_DEBUG
+     xim_log("xim_init()\n");
+ #endif
+ 
      g_return_if_fail(gui.drawarea != NULL);
      g_return_if_fail(gui.drawarea->window != NULL);
  
***************
*** 3416,3421 ****
--- 3478,3487 ----
      void
  im_shutdown(void)
  {
+ #ifdef XIM_DEBUG
+     xim_log("im_shutdown()\n");
+ #endif
+ 
      if (xic != NULL)
      {
  	gtk_im_context_focus_out(xic);
***************
*** 3559,3564 ****
--- 3625,3631 ----
  	    im_synthesize_keypress(GDK_Escape, 0U);
  
  	gtk_im_context_reset(xic);
+ 
  	/*
  	 * HACK for Ami: This sequence of function calls makes Ami handle
  	 * the IM reset gratiously, without breaking loads of other stuff.
***************
*** 3677,3685 ****
              if (xim_expected_char != NUL && xim_ignored_char)
                  /* We had a keypad key, and XIM tried to thieve it */
                  return FALSE;
!             else
!                 /* Normal processing */
!                 return imresult;
          }
      }
  
--- 3744,3752 ----
              if (xim_expected_char != NUL && xim_ignored_char)
                  /* We had a keypad key, and XIM tried to thieve it */
                  return FALSE;
! 
! 	    /* Normal processing */
! 	    return imresult;
          }
      }
  
***************
*** 3959,3968 ****
      if (xim_input_style & XIMPreeditCallbacks)
      {
  	preedit_buf_len = 0;
! 	if (State & CMDLINE)
! 	    preedit_start_col = cmdline_getvcol_cursor();
! 	else
! 	    getvcol(curwin, &curwin->w_cursor, &preedit_start_col, NULL, NULL);
      }
  #else
  # if 0
--- 4026,4032 ----
      if (xim_input_style & XIMPreeditCallbacks)
      {
  	preedit_buf_len = 0;
! 	init_preedit_start_col();
      }
  #else
  # if 0
***************
*** 4352,4357 ****
--- 4416,4425 ----
      Window	x11_window;
      Display	*x11_display;
  
+ #ifdef XIM_DEBUG
+     xim_log("xim_instantiate_cb()\n");
+ #endif
+ 
      gui_get_x11_windis(&x11_window, &x11_display);
      if (display != x11_display)
  	return;
***************
*** 4373,4378 ****
--- 4441,4449 ----
      Window	x11_window;
      Display	*x11_display;
  
+ #ifdef XIM_DEBUG
+     xim_log("xim_destroy_cb()\n");
+ #endif
      gui_get_x11_windis(&x11_window, &x11_display);
  
      xic = NULL;
***************
*** 4391,4396 ****
--- 4462,4471 ----
      Window	x11_window;
      Display	*x11_display;
  
+ #ifdef XIM_DEBUG
+     xim_log("xim_init()\n");
+ #endif
+ 
      gui_get_x11_windis(&x11_window, &x11_display);
  
      xic = NULL;
***************
*** 4643,4648 ****
--- 4718,4727 ----
  				 (int)GDK_IM_STATUS_NONE |
  				 (int)GDK_IM_STATUS_NOTHING;
  
+ #ifdef XIM_DEBUG
+     xim_log("xim_decide_input_style()\n");
+ #endif
+ 
      if (!gdk_im_ready())
  	xim_input_style = 0;
      else
***************
*** 4672,4677 ****
--- 4751,4760 ----
      static void
  preedit_start_cbproc(XIC xic, XPointer client_data, XPointer call_data)
  {
+ #ifdef XIM_DEBUG
+     xim_log("xim_decide_input_style()\n");
+ #endif
+ 
      draw_feedback = NULL;
      xim_preediting = TRUE;
      gui_update_cursor(TRUE, FALSE);
***************
*** 4706,4721 ****
      char	*src;
      GSList	*event_queue;
  
      draw_data = (XIMPreeditDrawCallbackStruct *) call_data;
      text = (XIMText *) draw_data->text;
  
      if ((text == NULL && draw_data->chg_length == preedit_buf_len)
! 	    || preedit_buf_len == 0)
      {
! 	if (State & CMDLINE)
! 	    preedit_start_col = cmdline_getvcol_cursor();
! 	else
! 	    getvcol(curwin, &curwin->w_cursor, &preedit_start_col, NULL, NULL);
  	vim_free(draw_feedback);
  	draw_feedback = NULL;
      }
--- 4789,4805 ----
      char	*src;
      GSList	*event_queue;
  
+ #ifdef XIM_DEBUG
+     xim_log("preedit_draw_cbproc()\n");
+ #endif
+ 
      draw_data = (XIMPreeditDrawCallbackStruct *) call_data;
      text = (XIMText *) draw_data->text;
  
      if ((text == NULL && draw_data->chg_length == preedit_buf_len)
! 						      || preedit_buf_len == 0)
      {
! 	init_preedit_start_col();
  	vim_free(draw_feedback);
  	draw_feedback = NULL;
      }
***************
*** 4840,4851 ****
--- 4924,4942 ----
      static void
  preedit_caret_cbproc(XIC xic, XPointer client_data, XPointer call_data)
  {
+ #ifdef XIM_DEBUG
+     xim_log("preedit_caret_cbproc()\n");
+ #endif
  }
  
  /*ARGSUSED*/
      static void
  preedit_done_cbproc(XIC xic, XPointer client_data, XPointer call_data)
  {
+ #ifdef XIM_DEBUG
+     xim_log("preedit_done_cbproc()\n");
+ #endif
+ 
      vim_free(draw_feedback);
      draw_feedback = NULL;
      xim_preediting = FALSE;
***************
*** 4862,4867 ****
--- 4953,4962 ----
  {
      char *text;
  
+ #ifdef XIM_DEBUG
+     xim_log("xim_reset()\n");
+ #endif
+ 
      if (xic != NULL)
      {
  	text = XmbResetIC(((GdkICPrivate *)xic)->xic);
***************
*** 4878,4883 ****
--- 4973,4982 ----
      int
  xim_queue_key_press_event(GdkEventKey *event, int down)
  {
+ #ifdef XIM_DEBUG
+     xim_log("xim_queue_key_press_event()\n");
+ #endif
+ 
      if (preedit_buf_len <= 0)
  	return FALSE;
      if (processing_queued_event)
***************
*** 4928,4933 ****
--- 5027,5036 ----
      void
  xim_init(void)
  {
+ #ifdef XIM_DEBUG
+     xim_log("xim_init()\n");
+ #endif
+ 
      xic = NULL;
      xic_attr = NULL;
  
***************
*** 5031,5036 ****
--- 5134,5143 ----
      void
  im_shutdown(void)
  {
+ #ifdef XIM_DEBUG
+     xim_log("im_shutdown()\n");
+ #endif
+ 
      if (xic != NULL)
      {
  	gdk_im_end();
*** ../vim-6.2.327/src/version.c	Mon Mar  8 12:27:39 2004
--- src/version.c	Mon Mar  8 15:09:57 2004
***************
*** 639,640 ****
--- 639,642 ----
  {   /* Add new patch number below this line */
+ /**/
+     328,
  /**/

-- 
Mynd you, m00se bites Kan be pretty nasti ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        Sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\              Project leader for A-A-P -- http://www.A-A-P.org        ///
 \\\  Buy at Amazon and help AIDS victims -- http://ICCF.nl/click1.html ///
