To: vim-dev@vim.org
Subject: Patch 6.2.193
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 6.2.193
Problem:    When recalling a search pattern from the history from a ":s,a/c,"
	    command the '/' ends the search string. (JC van Winkel)
Solution:   Store the separator character with the history entries.  Escape
	    characters when needed, replace the old separator with the new one.
	    Also fixes that recalling a "/" search for a "?" command messes up 
	    trailing flags.
Files:	    src/eval.c, src/ex_getln.c, src/normal.c, src/proto/ex_getln.pro,
	    src/search.c, src/tag.c


*** ../vim-6.2.192/src/eval.c	Sun Jan 18 20:46:13 2004
--- src/eval.c	Sun Jan 18 16:51:58 2004
***************
*** 5140,5146 ****
  	str = get_var_string_buf(&argvars[1], buf);
  	if (*str != NUL)
  	{
! 	    add_to_history(histype, str, FALSE);
  	    retvar->var_val.var_number = TRUE;
  	    return;
  	}
--- 5140,5146 ----
  	str = get_var_string_buf(&argvars[1], buf);
  	if (*str != NUL)
  	{
! 	    add_to_history(histype, str, FALSE, NUL);
  	    retvar->var_val.var_number = TRUE;
  	    return;
  	}
*** ../vim-6.2.192/src/ex_getln.c	Sat Sep 27 19:36:46 2003
--- src/ex_getln.c	Sun Jan 18 14:43:53 2004
***************
*** 42,48 ****
  typedef struct hist_entry
  {
      int		hisnum;		/* identifying number */
!     char_u	*hisstr;	/* actual entry */
  } histentry_T;
  
  static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};
--- 42,48 ----
  typedef struct hist_entry
  {
      int		hisnum;		/* identifying number */
!     char_u	*hisstr;	/* actual entry, separator char after the NUL */
  } histentry_T;
  
  static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};
***************
*** 1286,1291 ****
--- 1286,1293 ----
  		if (hiscnt != i)	/* jumped to other entry */
  		{
  		    char_u	*p;
+ 		    int		len;
+ 		    int		old_firstc;
  
  		    vim_free(ccline.cmdbuff);
  		    if (hiscnt == hislen)
***************
*** 1293,1302 ****
  		    else
  			p = history[histype][hiscnt].hisstr;
  
! 		    alloc_cmdbuff((int)STRLEN(p));
! 		    if (ccline.cmdbuff == NULL)
! 			goto returncmd;
! 		    STRCPY(ccline.cmdbuff, p);
  
  		    ccline.cmdpos = ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);
  		    redrawcmd();
--- 1295,1353 ----
  		    else
  			p = history[histype][hiscnt].hisstr;
  
! 		    if (histype == HIST_SEARCH
! 			    && p != lookfor
! 			    && (old_firstc = p[STRLEN(p) + 1]) != firstc)
! 		    {
! 			/* Correct for the separator character used when
! 			 * adding the history entry vs the one used now.
! 			 * First loop: count length.
! 			 * Second loop: copy the characters. */
! 			for (i = 0; i <= 1; ++i)
! 			{
! 			    len = 0;
! 			    for (j = 0; p[j] != NUL; ++j)
! 			    {
! 				/* Replace old sep with new sep, unless it is
! 				 * escaped. */
! 				if (p[j] == old_firstc
! 					      && (j == 0 || p[j - 1] != '\\'))
! 				{
! 				    if (i > 0)
! 					ccline.cmdbuff[len] = firstc;
! 				}
! 				else
! 				{
! 				    /* Escape new sep, unless it is already
! 				     * escaped. */
! 				    if (p[j] == firstc
! 					      && (j == 0 || p[j - 1] != '\\'))
! 				    {
! 					if (i > 0)
! 					    ccline.cmdbuff[len] = '\\';
! 					++len;
! 				    }
! 				    if (i > 0)
! 					ccline.cmdbuff[len] = p[j];
! 				}
! 				++len;
! 			    }
! 			    if (i == 0)
! 			    {
! 				alloc_cmdbuff(len);
! 				if (ccline.cmdbuff == NULL)
! 				    goto returncmd;
! 			    }
! 			}
! 			ccline.cmdbuff[len] = NUL;
! 		    }
! 		    else
! 		    {
! 			alloc_cmdbuff((int)STRLEN(p));
! 			if (ccline.cmdbuff == NULL)
! 			    goto returncmd;
! 			STRCPY(ccline.cmdbuff, p);
! 		    }
  
  		    ccline.cmdpos = ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);
  		    redrawcmd();
***************
*** 1556,1562 ****
  	if (ccline.cmdlen && firstc != NUL
  		&& (some_key_typed || histype == HIST_SEARCH))
  	{
! 	    add_to_history(histype, ccline.cmdbuff, TRUE);
  	    if (firstc == ':')
  	    {
  		vim_free(new_last_cmdline);
--- 1607,1614 ----
  	if (ccline.cmdlen && firstc != NUL
  		&& (some_key_typed || histype == HIST_SEARCH))
  	{
! 	    add_to_history(histype, ccline.cmdbuff, TRUE,
! 				       histype == HIST_SEARCH ? firstc : NUL);
  	    if (firstc == ':')
  	    {
  		vim_free(new_last_cmdline);
***************
*** 4185,4196 ****
   * values.
   */
      void
! add_to_history(histype, new_entry, in_map)
      int		histype;
      char_u	*new_entry;
      int		in_map;		/* consider maptick when inside a mapping */
  {
      histentry_T	*hisptr;
  
      if (hislen == 0)		/* no history */
  	return;
--- 4239,4252 ----
   * values.
   */
      void
! add_to_history(histype, new_entry, in_map, sep)
      int		histype;
      char_u	*new_entry;
      int		in_map;		/* consider maptick when inside a mapping */
+     int		sep;		/* separator character used (search hist) */
  {
      histentry_T	*hisptr;
+     int		len;
  
      if (hislen == 0)		/* no history */
  	return;
***************
*** 4221,4227 ****
  	    hisidx[histype] = 0;
  	hisptr = &history[histype][hisidx[histype]];
  	vim_free(hisptr->hisstr);
! 	hisptr->hisstr = vim_strsave(new_entry);
  	hisptr->hisnum = ++hisnum[histype];
  	if (histype == HIST_SEARCH && in_map)
  	    last_maptick = maptick;
--- 4277,4289 ----
  	    hisidx[histype] = 0;
  	hisptr = &history[histype][hisidx[histype]];
  	vim_free(hisptr->hisstr);
! 
! 	/* Store the separator after the NUL of the string. */
! 	len = STRLEN(new_entry);
! 	hisptr->hisstr = vim_strnsave(new_entry, len + 2);
! 	if (hisptr->hisstr != NULL)
! 	    hisptr->hisstr[len + 1] = sep;
! 
  	hisptr->hisnum = ++hisnum[histype];
  	if (histype == HIST_SEARCH && in_map)
  	    last_maptick = maptick;
***************
*** 4586,4592 ****
  		if (i == hislen)
  		    i = 0;
  		if (hist[i].hisstr != NULL
! 		    && hist[i].hisnum >= j && hist[i].hisnum <= k)
  		{
  		    msg_putchar('\n');
  		    sprintf((char *)IObuff, "%c%6d  %s", i == idx ? '>' : ' ',
--- 4648,4654 ----
  		if (i == hislen)
  		    i = 0;
  		if (hist[i].hisstr != NULL
! 			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
  		{
  		    msg_putchar('\n');
  		    sprintf((char *)IObuff, "%c%6d  %s", i == idx ? '>' : ' ',
***************
*** 4682,4697 ****
      vir_T	*virp;
  {
      int		type;
      char_u	*val;
  
      type = hist_char2type(virp->vir_line[0]);
      if (viminfo_hisidx[type] < viminfo_hislen[type])
      {
! 	val = viminfo_readstring(virp, 1, TRUE);
  	if (val != NULL)
  	{
  	    if (!in_history(type, val, viminfo_add_at_front))
  		viminfo_history[type][viminfo_hisidx[type]++] = val;
  	    else
  		vim_free(val);
  	}
--- 4744,4782 ----
      vir_T	*virp;
  {
      int		type;
+     int		sep;
+     int		len;
      char_u	*val;
  
      type = hist_char2type(virp->vir_line[0]);
      if (viminfo_hisidx[type] < viminfo_hislen[type])
      {
! 	/* Use a zero offset, so that we have some extra space in the
! 	 * allocated memory for the separator. */
! 	val = viminfo_readstring(virp, 0, TRUE);
  	if (val != NULL)
  	{
  	    if (!in_history(type, val, viminfo_add_at_front))
+ 	    {
+ 		len = STRLEN(val);
+ 		if (type == HIST_SEARCH)
+ 		{
+ 		    /* Search entry: Move the separator from the second column
+ 		     * to after the NUL. */
+ 		    sep = val[1];
+ 		    --len;
+ 		    mch_memmove(val, val + 2, (size_t)len);
+ 		    val[len + 1] = (sep == ' ' ? NUL : sep);
+ 		}
+ 		else
+ 		{
+ 		    /* Not a search entry: No separator in the viminfo file,
+ 		     * add a NUL separator. */
+ 		    mch_memmove(val, val + 1, (size_t)len);
+ 		    val[len + 1] = NUL;
+ 		}
  		viminfo_history[type][viminfo_hisidx[type]++] = val;
+ 	    }
  	    else
  		vim_free(val);
  	}
***************
*** 4757,4762 ****
--- 4842,4849 ----
      int	    i;
      int	    type;
      int	    num_saved;
+     char_u  *p;
+     int	    c;
  
      init_history();
      if (hislen == 0)
***************
*** 4779,4788 ****
  	if (i >= 0)
  	    while (num_saved--)
  	    {
! 		if (history[type][i].hisstr != NULL)
  		{
  		    putc(hist_type2char(type, TRUE), fp);
! 		    viminfo_writestring(fp, history[type][i].hisstr);
  		}
  		if (--i < 0)
  		    i = hislen - 1;
--- 4866,4883 ----
  	if (i >= 0)
  	    while (num_saved--)
  	    {
! 		p = history[type][i].hisstr;
! 		if (p != NULL)
  		{
  		    putc(hist_type2char(type, TRUE), fp);
! 		    /* For the search history: put the separator in the second
! 		     * column; use a space if there isn't one. */
! 		    if (type == HIST_SEARCH)
! 		    {
! 			c = p[STRLEN(p) + 1];
! 			putc(c == NUL ? ' ' : c, fp);
! 		    }
! 		    viminfo_writestring(fp, p);
  		}
  		if (--i < 0)
  		    i = hislen - 1;
*** ../vim-6.2.192/src/normal.c	Sun Jan 18 20:28:26 2004
--- src/normal.c	Sun Jan 18 18:49:04 2004
***************
*** 4920,4926 ****
  	    STRCAT(buf, "\\>");
  #ifdef FEAT_CMDHIST
  	/* put pattern in search history */
! 	add_to_history(HIST_SEARCH, buf, TRUE);
  #endif
  	normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0);
      }
--- 4932,4938 ----
  	    STRCAT(buf, "\\>");
  #ifdef FEAT_CMDHIST
  	/* put pattern in search history */
! 	add_to_history(HIST_SEARCH, buf, TRUE, NUL);
  #endif
  	normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0);
      }
*** ../vim-6.2.192/src/proto/ex_getln.pro	Sun Aug 10 22:24:37 2003
--- src/proto/ex_getln.pro	Sun Jan 18 13:36:26 2004
***************
*** 25,31 ****
  int ExpandGeneric __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file, char_u *((*func)(expand_T *, int))));
  char_u *globpath __ARGS((char_u *path, char_u *file));
  int get_histtype __ARGS((char_u *name));
! void add_to_history __ARGS((int histype, char_u *new_entry, int in_map));
  int get_history_idx __ARGS((int histype));
  char_u *get_history_entry __ARGS((int histype, int idx));
  int clr_history __ARGS((int histype));
--- 25,31 ----
  int ExpandGeneric __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file, char_u *((*func)(expand_T *, int))));
  char_u *globpath __ARGS((char_u *path, char_u *file));
  int get_histtype __ARGS((char_u *name));
! void add_to_history __ARGS((int histype, char_u *new_entry, int in_map, int sep));
  int get_history_idx __ARGS((int histype));
  char_u *get_history_entry __ARGS((int histype, int idx));
  int clr_history __ARGS((int histype));
*** ../vim-6.2.192/src/search.c	Sat Sep 27 19:36:47 2003
--- src/search.c	Sun Jan 18 13:05:15 2004
***************
*** 172,178 ****
      }
  #ifdef FEAT_CMDHIST
      else if (options & SEARCH_HIS)	/* put new pattern in history */
! 	add_to_history(HIST_SEARCH, pat, TRUE);
  #endif
  
  #ifdef FEAT_RIGHTLEFT
--- 172,178 ----
      }
  #ifdef FEAT_CMDHIST
      else if (options & SEARCH_HIS)	/* put new pattern in history */
! 	add_to_history(HIST_SEARCH, pat, TRUE, NUL);
  #endif
  
  #ifdef FEAT_RIGHTLEFT
*** ../vim-6.2.192/src/tag.c	Sun Jan 18 20:58:01 2004
--- src/tag.c	Sun Jan 18 13:05:42 2004
***************
*** 2699,2705 ****
  #if 0	/* disabled for now */
  #ifdef FEAT_CMDHIST
  	    /* put pattern in search history */
! 	    add_to_history(HIST_SEARCH, pbuf + 1, TRUE);
  #endif
  #endif
  	    save_lnum = curwin->w_cursor.lnum;
--- 2699,2705 ----
  #if 0	/* disabled for now */
  #ifdef FEAT_CMDHIST
  	    /* put pattern in search history */
! 	    add_to_history(HIST_SEARCH, pbuf + 1, TRUE, pbuf[0]);
  #endif
  #endif
  	    save_lnum = curwin->w_cursor.lnum;
*** ../vim-6.2.192/src/version.c	Sun Jan 18 21:22:26 2004
--- src/version.c	Sun Jan 18 21:24:10 2004
***************
*** 639,640 ****
--- 639,642 ----
  {   /* Add new patch number below this line */
+ /**/
+     193,
  /**/

-- 
WOMAN:   Dennis, there's some lovely filth down here.  Oh -- how d'you do?
ARTHUR:  How do you do, good lady.  I am Arthur, King of the Britons.
         Who's castle is that?
WOMAN:   King of the who?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        Sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\              Project leader for A-A-P -- http://www.A-A-P.org        ///
 \\\  Help AIDS victims, buy here: http://ICCF-Holland.org/click1.html  ///
