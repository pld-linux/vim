To: vim-dev@vim.org
Subject: Patch 6.2.290 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 6.2.290 (extra)
Problem:    Mac: The mousewheel doesn't work.
Solution:   Add mousewheel support.  Also fix updating the thumb after a drag
	    and then using another way to scroll.  (Eckehard Berns)
Files:	    src/gui_mac.c


*** ../vim-6.2.289/src/gui_mac.c	Tue Feb 24 20:56:55 2004
--- src/gui_mac.c	Wed Feb 25 10:57:41 2004
***************
*** 82,87 ****
--- 82,93 ----
  # endif
  #endif
  
+ #undef USE_MOUSEWHEEL
+ #if defined(MACOS_X) && defined(USE_CARBONIZED)
+ # define USE_MOUSEWHEEL
+ static EventHandlerUPP mouseWheelHandlerUPP = NULL;
+ #endif
+ 
  /* Debugging feature: start Vim window OFFSETed */
  #undef USE_OFFSETED_WINDOW
  
***************
*** 1525,1531 ****
      void
  gui_mac_drag_thumb (ControlHandle theControl, short partCode)
  {
-     /* TODO: have live support */
      scrollbar_T		*sb;
      int			value, dragging;
      ControlHandle	theControlToUse;
--- 1531,1536 ----
***************
*** 1540,1546 ****
  
      /* Need to find value by diff between Old Poss New Pos */
      value = GetControl32BitValue (theControlToUse);
!     dragging = TRUE;
  
      /* When "allow_scrollbar" is FALSE still need to remember the new
       * position, but don't actually scroll by setting "dont_scroll". */
--- 1545,1551 ----
  
      /* Need to find value by diff between Old Poss New Pos */
      value = GetControl32BitValue (theControlToUse);
!     dragging = (partCode != 0);
  
      /* When "allow_scrollbar" is FALSE still need to remember the new
       * position, but don't actually scroll by setting "dont_scroll". */
***************
*** 1678,1683 ****
--- 1683,1690 ----
  #else
  	    TrackControl(theControl, thePoint, NULL);
  #endif
+ 	    /* pass 0 as the part to tell gui_mac_drag_thumb, that the mouse
+ 	     * button has been released */
  	    gui_mac_drag_thumb (theControl, 0); /* Should it be thePortion ? (Dany) */
  	    dragged_sb = NULL;
  	}
***************
*** 2250,2255 ****
--- 2306,2369 ----
        (MOUSE_RELEASE, thePoint.h, thePoint.v, FALSE, vimModifiers);
  }
  
+ #ifdef USE_MOUSEWHEEL
+     static pascal OSStatus
+ gui_mac_mouse_wheel(EventHandlerCallRef nextHandler, EventRef theEvent,
+ 								   void *data)
+ {
+     EventRef	bogusEvent;
+     Point	point;
+     Rect	bounds;
+     UInt32	mod;
+     SInt32	delta;
+     int_u	vim_mod;
+ 
+     if (noErr != GetEventParameter(theEvent, kEventParamMouseWheelDelta,
+ 			      typeSInt32, NULL, sizeof(SInt32), NULL, &delta))
+ 	goto bail;
+     if (noErr != GetEventParameter(theEvent, kEventParamMouseLocation,
+ 			      typeQDPoint, NULL, sizeof(Point), NULL, &point))
+ 	goto bail;
+     if (noErr != GetEventParameter(theEvent, kEventParamKeyModifiers,
+ 				typeUInt32, NULL, sizeof(UInt32), NULL, &mod))
+ 	goto bail;
+ 
+     vim_mod = 0;
+     if (mod & shiftKey)
+ 	vim_mod |= MOUSE_SHIFT;
+     if (mod & controlKey)
+ 	vim_mod |= MOUSE_CTRL;
+     if (mod & optionKey)
+ 	vim_mod |= MOUSE_ALT;
+ 
+     /* post a bogus event to wake up WaitNextEvent */
+     if (noErr != CreateEvent(NULL, kEventClassMouse, kEventMouseMoved, 0,
+ 					    kEventAttributeNone, &bogusEvent))
+ 	goto bail;
+     if (noErr != PostEventToQueue(GetMainEventQueue(), bogusEvent,
+ 							   kEventPriorityLow))
+ 	goto bail;
+ 
+     if (noErr == GetWindowBounds(gui.VimWindow, kWindowContentRgn, &bounds))
+     {
+ 	point.h -= bounds.left;
+ 	point.v -= bounds.top;
+     }
+ 
+     gui_send_mouse_event((delta > 0) ? MOUSE_4 : MOUSE_5,
+ 					    point.h, point.v, FALSE, vim_mod);
+ 
+     return noErr;
+ 
+   bail:
+     /*
+      * when we fail give any additional callback handler a chance to perform
+      * it's actions
+      */
+     return CallNextEventHandler(nextHandler, theEvent);
+ }
+ #endif /* defined(USE_MOUSEWHEEL) */
+ 
  #if 0
  
  /*
***************
*** 2739,2744 ****
--- 2853,2862 ----
  #ifdef USE_CTRLCLICKMENU
      long	gestalt_rc;
  #endif
+ #ifdef USE_MOUSEWHEEL
+     EventTypeSpec   eventTypeSpec;
+     EventHandlerRef mouseWheelHandlerRef;
+ #endif
  #if 1
      InitCursor();
  
***************
*** 2875,2880 ****
--- 2998,3016 ----
      vim_setenv((char_u *)"QDTEXT_MINSIZE", (char_u *)"1");
  #endif
  
+ #ifdef USE_MOUSEWHEEL
+     eventTypeSpec.eventClass = kEventClassMouse;
+     eventTypeSpec.eventKind = kEventMouseWheelMoved;
+     mouseWheelHandlerUPP = NewEventHandlerUPP(gui_mac_mouse_wheel);
+     if (noErr != InstallApplicationEventHandler(mouseWheelHandlerUPP, 1,
+ 				 &eventTypeSpec, NULL, &mouseWheelHandlerRef))
+     {
+ 	mouseWheelHandlerRef = NULL;
+ 	DisposeEventHandlerUPP(mouseWheelHandlerUPP);
+ 	mouseWheelHandlerUPP = NULL;
+     }
+ #endif
+ 
      /* TODO: Load bitmap if using TOOLBAR */
      return OK;
  }
***************
*** 2922,2927 ****
--- 3058,3069 ----
  {
      /* TODO: find out all what is missing here? */
      DisposeRgn(cursorRgn);
+ 
+ #ifdef USE_MOUSEWHEEL
+     if (mouseWheelHandlerUPP != NULL)
+ 	DisposeEventHandlerUPP(mouseWheelHandlerUPP);
+ #endif
+ 
      /* Exit to shell? */
      exit(rc);
  }
*** ../vim-6.2.289/src/version.c	Tue Feb 24 22:17:28 2004
--- src/version.c	Wed Feb 25 12:53:07 2004
***************
*** 639,640 ****
--- 639,642 ----
  {   /* Add new patch number below this line */
+ /**/
+     290,
  /**/

-- 
If VIM were a woman, I'd marry her.  Slim, organized, helpful
and beautiful; what's not to like?     --David A. Rogers

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        Sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\              Project leader for A-A-P -- http://www.A-A-P.org        ///
 \\\  Help AIDS victims, buy here: http://ICCF-Holland.org/click1.html  ///
