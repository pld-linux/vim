To: vim-dev@vim.org
Subject: Patch 6.2.238
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 6.2.238 (after 6.2.231)
Problem:    ":function" does not work inside a while loop. (Servatius Brandt)
Solution:   Add get_while_line() and pass it to do_one_cmd() when in a while
	    loop, so that all lines are stored and can be used again when
	    repeating the loop.
	    Adjust test 49 so that it checks for the fixed problems.
	    (Servatius Brandt)
Files:	    src/digraph.c, src/ex_cmds2.c, src/ex_docmd.c, src/ex_eval.c,
	    src/proto/ex_cmds2.pro, src/proto/ex_docmd.pro,
	    src/testdir/test49.in, src/testdir/test49.ok,
	    src/testdir/test49.vim


*** ../vim-6.2.237/src/digraph.c	Thu Sep 11 21:11:22 2003
--- src/digraph.c	Mon Feb  2 21:33:07 2004
***************
*** 2366,2372 ****
      int		i;
      char_u	*save_cpo = p_cpo;
  
!     if (eap->getline != getsourceline)
      {
  	EMSG(_("E105: Using :loadkeymap not in a sourced file"));
  	return;
--- 2366,2372 ----
      int		i;
      char_u	*save_cpo = p_cpo;
  
!     if (!getline_equal(eap->getline, eap->cookie, getsourceline))
      {
  	EMSG(_("E105: Using :loadkeymap not in a sourced file"));
  	return;
***************
*** 2388,2394 ****
       */
      for (;;)
      {
! 	line = getsourceline(0, eap->cookie, 0);
  	if (line == NULL)
  	    break;
  
--- 2388,2394 ----
       */
      for (;;)
      {
! 	line = eap->getline(0, eap->cookie, 0);
  	if (line == NULL)
  	    break;
  
*** ../vim-6.2.237/src/ex_cmds2.c	Sun Jan 25 19:56:12 2004
--- src/ex_cmds2.c	Tue Feb  3 13:57:13 2004
***************
*** 208,214 ****
  	    n = debug_break_level;
  	    debug_break_level = -1;
  	    (void)do_cmdline(cmdline, getexline, NULL,
! 			     DOCMD_VERBOSE|DOCMD_EXCRESET);
  	    debug_break_level = n;
  
  	    vim_free(cmdline);
--- 208,214 ----
  	    n = debug_break_level;
  	    debug_break_level = -1;
  	    (void)do_cmdline(cmdline, getexline, NULL,
! 						DOCMD_VERBOSE|DOCMD_EXCRESET);
  	    debug_break_level = n;
  
  	    vim_free(cmdline);
***************
*** 724,740 ****
  # endif
  					))
  			++count;
! #ifdef FEAT_AUTOCMD
  	    if (!buf_valid(buf))
  		/* Autocommand deleted buffer, oops!  It's not changed now. */
  		return FALSE;
! #endif
  	    dialog_changed(buf, count > 1);
! #ifdef FEAT_AUTOCMD
  	    if (!buf_valid(buf))
  		/* Autocommand deleted buffer, oops!  It's not changed now. */
  		return FALSE;
! #endif
  	    return bufIsChanged(buf);
  	}
  #endif
--- 724,740 ----
  # endif
  					))
  			++count;
! # ifdef FEAT_AUTOCMD
  	    if (!buf_valid(buf))
  		/* Autocommand deleted buffer, oops!  It's not changed now. */
  		return FALSE;
! # endif
  	    dialog_changed(buf, count > 1);
! # ifdef FEAT_AUTOCMD
  	    if (!buf_valid(buf))
  		/* Autocommand deleted buffer, oops!  It's not changed now. */
  		return FALSE;
! # endif
  	    return bufIsChanged(buf);
  	}
  #endif
***************
*** 2678,2684 ****
      struct source_cookie	*sp;
      char_u			*name;
  
!     if (eap->getline != getsourceline)
      {
  	EMSG(_("E167: :scriptencoding used outside of a sourced file"));
  	return;
--- 2678,2684 ----
      struct source_cookie	*sp;
      char_u			*name;
  
!     if (!getline_equal(eap->getline, eap->cookie, getsourceline))
      {
  	EMSG(_("E167: :scriptencoding used outside of a sourced file"));
  	return;
***************
*** 2694,2700 ****
  	name = eap->arg;
  
      /* Setup for conversion from the specified encoding to 'encoding'. */
!     sp = (struct source_cookie *)eap->cookie;
      convert_setup(&sp->conv, name, p_enc);
  
      if (name != eap->arg)
--- 2694,2700 ----
  	name = eap->arg;
  
      /* Setup for conversion from the specified encoding to 'encoding'. */
!     sp = (struct source_cookie *)getline_cookie(eap->getline, eap->cookie);
      convert_setup(&sp->conv, name, p_enc);
  
      if (name != eap->arg)
***************
*** 2710,2716 ****
  ex_finish(eap)
      exarg_T	*eap;
  {
!     if (eap->getline == getsourceline)
  	do_finish(eap, FALSE);
      else
  	EMSG(_("E168: :finish used outside of a sourced file"));
--- 2710,2716 ----
  ex_finish(eap)
      exarg_T	*eap;
  {
!     if (getline_equal(eap->getline, eap->cookie, getsourceline))
  	do_finish(eap, FALSE);
      else
  	EMSG(_("E168: :finish used outside of a sourced file"));
***************
*** 2729,2735 ****
      int		idx;
  
      if (reanimate)
! 	((struct source_cookie *)eap->cookie)->finished = FALSE;
  
      /*
       * Cleanup (and inactivate) conditionals, but stop when a try conditional
--- 2729,2736 ----
      int		idx;
  
      if (reanimate)
! 	((struct source_cookie *)getline_cookie(eap->getline,
! 					      eap->cookie))->finished = FALSE;
  
      /*
       * Cleanup (and inactivate) conditionals, but stop when a try conditional
***************
*** 2744,2762 ****
  	report_make_pending(CSTP_FINISH, NULL);
      }
      else
! 	((struct source_cookie *)eap->cookie)->finished = TRUE;
  }
  
  
  /*
   * Return TRUE when a sourced file had the ":finish" command: Don't give error
   * message for missing ":endif".
   */
      int
! source_finished(cookie)
      void	*cookie;
  {
!     return ((struct source_cookie *)cookie)->finished == TRUE;
  }
  #endif
  
--- 2745,2768 ----
  	report_make_pending(CSTP_FINISH, NULL);
      }
      else
! 	((struct source_cookie *)getline_cookie(eap->getline,
! 					       eap->cookie))->finished = TRUE;
  }
  
  
  /*
   * Return TRUE when a sourced file had the ":finish" command: Don't give error
   * message for missing ":endif".
+  * Return FALSE when not sourcing a file.
   */
      int
! source_finished(getline, cookie)
!     char_u	*(*getline) __ARGS((int, void *, int));
      void	*cookie;
  {
!     return (getline_equal(getline, cookie, getsourceline)
! 	    && ((struct source_cookie *)getline_cookie(
! 						 getline, cookie))->finished);
  }
  #endif
  
*** ../vim-6.2.237/src/ex_docmd.c	Sun Jan 25 19:32:46 2004
--- src/ex_docmd.c	Wed Feb  4 19:27:50 2004
***************
*** 57,63 ****
  #endif
  
  #ifdef FEAT_EVAL
- static void	free_cmdlines __ARGS((garray_T *gap));
  static char_u	*do_one_cmd __ARGS((char_u **, int, struct condstack *, char_u *(*getline)(int, void *, int), void *cookie));
  #else
  static char_u	*do_one_cmd __ARGS((char_u **, int, char_u *(*getline)(int, void *, int), void *cookie));
--- 57,62 ----
***************
*** 455,460 ****
--- 454,488 ----
  static char_u dollar_command[2] = {'$', 0};
  
  
+ #ifdef FEAT_EVAL
+ /* Struct for storing a line inside a while loop */
+ typedef struct
+ {
+     char_u	*line;		/* command line */
+     linenr_T	lnum;		/* sourcing_lnum of the line */
+ } wcmd_T;
+ 
+ /*
+  * Structure used to store info for line position in a while loop.
+  * This is required, because do_one_cmd() may invoke ex_function(), which
+  * reads more lines that may come from the while loop.
+  */
+ struct while_cookie
+ {
+     garray_T	*lines_gap;		/* growarray with line info */
+     int		current_line;		/* last read line from growarray */
+     int		repeating;		/* TRUE when looping a second time */
+     /* When "repeating" is FALSE use "getline" and "cookie" to get lines */
+     char_u	*(*getline) __ARGS((int, void *, int));
+     void	*cookie;
+ };
+ 
+ static char_u	*get_while_line __ARGS((int c, void *cookie, int indent));
+ static int	store_while_line __ARGS((garray_T *gap, char_u *line));
+ static void	free_cmdlines __ARGS((garray_T *gap));
+ #endif
+ 
+ 
  /*
   * do_exmode(): Repeatedly get commands for the "Ex" mode, until the ":vi"
   * command is given.
***************
*** 549,561 ****
  				   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);
  }
  
- /* Struct for storing a line inside a while loop */
- typedef struct
- {
-     char_u	*line;		/* command line */
-     linenr_T	lnum;		/* sourcing_lnum of the line */
- } wcmd_T;
- 
  /*
   * do_cmdline(): execute one Ex command line
   *
--- 577,582 ----
***************
*** 610,615 ****
--- 631,645 ----
      int		initial_trylevel;
      struct msglist	**saved_msg_list = NULL;
      struct msglist	*private_msg_list;
+ 
+     /* "getline" and "cookie" passed to do_one_cmd() */
+     char_u	*(*cmd_getline) __ARGS((int, void *, int));
+     void	*cmd_cookie;
+     struct while_cookie cmd_while_cookie;
+     void	*real_cookie;
+ #else
+ # define cmd_getline getline
+ # define cmd_cookie cookie
  #endif
      static int	call_depth = 0;		/* recursiveness */
  
***************
*** 650,672 ****
      cstack.cs_had_finally = FALSE;
      ga_init2(&lines_ga, (int)sizeof(wcmd_T), 10);
  
      /* Inside a function use a higher nesting level. */
!     if (getline == get_func_line && ex_nesting_level == func_level(cookie))
  	++ex_nesting_level;
  
      /* Get the function or script name and the address where the next breakpoint
       * line and the debug tick for a function or script are stored. */
!     if (getline == get_func_line)
      {
! 	fname = func_name(cookie);
! 	breakpoint = func_breakpoint(cookie);
! 	dbg_tick = func_dbg_tick(cookie);
      }
!     else if (getline == getsourceline)
      {
  	fname = sourcing_name;
! 	breakpoint = source_breakpoint(cookie);
! 	dbg_tick = source_dbg_tick(cookie);
      }
  
      /*
--- 680,705 ----
      cstack.cs_had_finally = FALSE;
      ga_init2(&lines_ga, (int)sizeof(wcmd_T), 10);
  
+     real_cookie = getline_cookie(getline, cookie);
+ 
      /* Inside a function use a higher nesting level. */
!     if (getline_equal(getline, cookie, get_func_line)
! 			       && ex_nesting_level == func_level(real_cookie))
  	++ex_nesting_level;
  
      /* Get the function or script name and the address where the next breakpoint
       * line and the debug tick for a function or script are stored. */
!     if (getline_equal(getline, cookie, get_func_line))
      {
! 	fname = func_name(real_cookie);
! 	breakpoint = func_breakpoint(real_cookie);
! 	dbg_tick = func_dbg_tick(real_cookie);
      }
!     else if (getline_equal(getline, cookie, getsourceline))
      {
  	fname = sourcing_name;
! 	breakpoint = source_breakpoint(real_cookie);
! 	dbg_tick = source_dbg_tick(real_cookie);
      }
  
      /*
***************
*** 717,723 ****
       * KeyTyped is only set when calling vgetc().  Reset it here when not
       * calling vgetc() (sourced command lines).
       */
!     if (!(flags & DOCMD_KEYTYPED) && getline != getexline)
  	KeyTyped = FALSE;
  
      /*
--- 750,756 ----
       * KeyTyped is only set when calling vgetc().  Reset it here when not
       * calling vgetc() (sourced command lines).
       */
!     if (!(flags & DOCMD_KEYTYPED) && !getline_equal(getline, cookie, getexline))
  	KeyTyped = FALSE;
  
      /*
***************
*** 734,740 ****
  #ifdef FEAT_EVAL
  		&& !force_abort
  		&& cstack.cs_idx < 0
! 		&& !(getline == get_func_line && func_has_abort(cookie))
  #endif
  							)
  	    did_emsg = FALSE;
--- 767,774 ----
  #ifdef FEAT_EVAL
  		&& !force_abort
  		&& cstack.cs_idx < 0
! 		&& !(getline_equal(getline, cookie, get_func_line)
! 					       && func_has_abort(real_cookie))
  #endif
  							)
  	    did_emsg = FALSE;
***************
*** 756,769 ****
  
  	    /* Check if a function has returned or, unless it has an unclosed
  	     * try conditional, aborted. */
! 	    if (getline == get_func_line && func_has_ended(cookie))
  	    {
  		retval = FAIL;
  		break;
  	    }
  
  	    /* Check if a sourced file hit a ":finish" command. */
! 	    if (getline == getsourceline && source_finished(cookie))
  	    {
  		retval = FAIL;
  		break;
--- 790,804 ----
  
  	    /* Check if a function has returned or, unless it has an unclosed
  	     * try conditional, aborted. */
! 	    if (getline_equal(getline, cookie, get_func_line)
! 					       && func_has_ended(real_cookie))
  	    {
  		retval = FAIL;
  		break;
  	    }
  
  	    /* Check if a sourced file hit a ":finish" command. */
! 	    if (source_finished(getline, cookie))
  	    {
  		retval = FAIL;
  		break;
***************
*** 773,779 ****
  	    if (breakpoint != NULL && dbg_tick != NULL
  						   && *dbg_tick != debug_tick)
  	    {
! 		*breakpoint = dbg_find_breakpoint((getline == getsourceline),
  							fname, sourcing_lnum);
  		*dbg_tick = debug_tick;
  	    }
--- 808,815 ----
  	    if (breakpoint != NULL && dbg_tick != NULL
  						   && *dbg_tick != debug_tick)
  	    {
! 		*breakpoint = dbg_find_breakpoint(
! 				getline_equal(getline, cookie, getsourceline),
  							fname, sourcing_lnum);
  		*dbg_tick = debug_tick;
  	    }
***************
*** 787,797 ****
  	    {
  		dbg_breakpoint(fname, sourcing_lnum);
  		/* Find next breakpoint. */
! 		*breakpoint = dbg_find_breakpoint((getline == getsourceline),
  							fname, sourcing_lnum);
  		*dbg_tick = debug_tick;
  	    }
  	}
  #endif
  
  	/* 2. If no line given, get an allocated line with getline(). */
--- 823,855 ----
  	    {
  		dbg_breakpoint(fname, sourcing_lnum);
  		/* Find next breakpoint. */
! 		*breakpoint = dbg_find_breakpoint(
! 				getline_equal(getline, cookie, getsourceline),
  							fname, sourcing_lnum);
  		*dbg_tick = debug_tick;
  	    }
  	}
+ 
+ 	if (cstack.cs_whilelevel)
+ 	{
+ 	    /* Inside a while loop we need to store the lines and use them
+ 	     * again.  Pass a different "getline" function to do_one_cmd()
+ 	     * below, so that it stores lines in or reads them from
+ 	     * "lines_ga".  Makes it possible to define a function inside a
+ 	     * while loop. */
+ 	    cmd_getline = get_while_line;
+ 	    cmd_cookie = (void *)&cmd_while_cookie;
+ 	    cmd_while_cookie.lines_gap = &lines_ga;
+ 	    cmd_while_cookie.current_line = current_line;
+ 	    cmd_while_cookie.getline = getline;
+ 	    cmd_while_cookie.cookie = cookie;
+ 	    cmd_while_cookie.repeating = (current_line < lines_ga.ga_len);
+ 	}
+ 	else
+ 	{
+ 	    cmd_getline = getline;
+ 	    cmd_cookie = cookie;
+ 	}
  #endif
  
  	/* 2. If no line given, get an allocated line with getline(). */
***************
*** 801,807 ****
  	     * Need to set msg_didout for the first line after an ":if",
  	     * otherwise the ":if" will be overwritten.
  	     */
! 	    if (count == 1 && getline == getexline)
  		msg_didout = TRUE;
  	    if (getline == NULL || (next_cmdline = getline(':', cookie,
  #ifdef FEAT_EVAL
--- 859,865 ----
  	     * Need to set msg_didout for the first line after an ":if",
  	     * otherwise the ":if" will be overwritten.
  	     */
! 	    if (count == 1 && getline_equal(getline, cookie, getexline))
  		msg_didout = TRUE;
  	    if (getline == NULL || (next_cmdline = getline(':', cookie,
  #ifdef FEAT_EVAL
***************
*** 856,872 ****
  	if (	   current_line == lines_ga.ga_len
  		&& (cstack.cs_whilelevel || has_while_cmd(next_cmdline)))
  	{
! 	    if (ga_grow(&lines_ga, 1) == FAIL)
  	    {
- 		EMSG(_(e_outofmem));
  		retval = FAIL;
  		break;
  	    }
- 	    ((wcmd_T *)(lines_ga.ga_data))[current_line].line =
- 						    vim_strsave(next_cmdline);
- 	    ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum = sourcing_lnum;
- 	    ++lines_ga.ga_len;
- 	    --lines_ga.ga_room;
  	}
  	did_endif = FALSE;
  #endif
--- 914,924 ----
  	if (	   current_line == lines_ga.ga_len
  		&& (cstack.cs_whilelevel || has_while_cmd(next_cmdline)))
  	{
! 	    if (store_while_line(&lines_ga, next_cmdline) == FAIL)
  	    {
  		retval = FAIL;
  		break;
  	    }
  	}
  	did_endif = FALSE;
  #endif
***************
*** 922,929 ****
  #ifdef FEAT_EVAL
  				&cstack,
  #endif
! 				getline, cookie);
  	--recursive;
  	if (next_cmdline == NULL)
  	{
  	    vim_free(cmdline_copy);
--- 974,989 ----
  #ifdef FEAT_EVAL
  				&cstack,
  #endif
! 				cmd_getline, cmd_cookie);
  	--recursive;
+ 
+ #ifdef FEAT_EVAL
+ 	if (cmd_cookie == (void *)&cmd_while_cookie)
+ 	    /* Use "current_line" from "cmd_while_cookie", it may have been
+ 	     * incremented when defining a function. */
+ 	    current_line = cmd_while_cookie.current_line;
+ #endif
+ 
  	if (next_cmdline == NULL)
  	{
  	    vim_free(cmdline_copy);
***************
*** 933,939 ****
  	     * If the command was typed, remember it for the ':' register.
  	     * Do this AFTER executing the command to make :@: work.
  	     */
! 	    if (getline == getexline && new_last_cmdline != NULL)
  	    {
  		vim_free(last_cmdline);
  		last_cmdline = new_last_cmdline;
--- 993,1000 ----
  	     * If the command was typed, remember it for the ':' register.
  	     * Do this AFTER executing the command to make :@: work.
  	     */
! 	    if (getline_equal(getline, cookie, getexline)
! 						  && new_last_cmdline != NULL)
  	    {
  		vim_free(last_cmdline);
  		last_cmdline = new_last_cmdline;
***************
*** 953,959 ****
  #ifdef FEAT_EVAL
  	/* reset did_emsg for a function that is not aborted by an error */
  	if (did_emsg && !force_abort
! 		&& getline == get_func_line && !func_has_abort(cookie))
  	    did_emsg = FALSE;
  
  	if (cstack.cs_whilelevel)
--- 1014,1021 ----
  #ifdef FEAT_EVAL
  	/* reset did_emsg for a function that is not aborted by an error */
  	if (did_emsg && !force_abort
! 		&& getline_equal(getline, cookie, get_func_line)
! 					      && !func_has_abort(real_cookie))
  	    did_emsg = FALSE;
  
  	if (cstack.cs_whilelevel)
***************
*** 989,995 ****
  		    if (breakpoint != NULL)
  		    {
  			*breakpoint = dbg_find_breakpoint(
! 					    (getline == getsourceline), fname,
  			   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);
  			*dbg_tick = debug_tick;
  		    }
--- 1051,1058 ----
  		    if (breakpoint != NULL)
  		    {
  			*breakpoint = dbg_find_breakpoint(
! 				getline_equal(getline, cookie, getsourceline),
! 									fname,
  			   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);
  			*dbg_tick = debug_tick;
  		    }
***************
*** 1080,1086 ****
  		&& cstack.cs_trylevel == 0
  #endif
  	    )
! 	    && !(did_emsg && (getline == getexmodeline || getline == getexline))
  	    && (next_cmdline != NULL
  #ifdef FEAT_EVAL
  			|| cstack.cs_idx >= 0
--- 1143,1150 ----
  		&& cstack.cs_trylevel == 0
  #endif
  	    )
! 	    && !(did_emsg && (getline_equal(getline, cookie, getexmodeline)
! 				|| getline_equal(getline, cookie, getexline)))
  	    && (next_cmdline != NULL
  #ifdef FEAT_EVAL
  			|| cstack.cs_idx >= 0
***************
*** 1099,1106 ****
  	 * unclosed conditional.
  	 */
  	if (!got_int && !did_throw
! 		&& ((getline == getsourceline && !source_finished(cookie))
! 		    || (getline == get_func_line && !func_has_ended(cookie))))
  	{
  	    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)
  		EMSG(_(e_endtry));
--- 1163,1172 ----
  	 * unclosed conditional.
  	 */
  	if (!got_int && !did_throw
! 		&& ((getline_equal(getline, cookie, getsourceline)
! 			&& !source_finished(getline, cookie))
! 		    || (getline_equal(getline, cookie, get_func_line)
! 					    && !func_has_ended(real_cookie))))
  	{
  	    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)
  		EMSG(_(e_endtry));
***************
*** 1125,1131 ****
      /* If a missing ":endtry", ":endwhile", or ":endif" or a memory lack
       * was reported above and the error message is to be converted to an
       * exception, do this now after rewinding the cstack. */
!     do_errthrow(&cstack, getline == get_func_line
  				  ? (char_u *)"endfunction" : (char_u *)NULL);
  
      if (trylevel == 0)
--- 1191,1197 ----
      /* If a missing ":endtry", ":endwhile", or ":endif" or a memory lack
       * was reported above and the error message is to be converted to an
       * exception, do this now after rewinding the cstack. */
!     do_errthrow(&cstack, getline_equal(getline, cookie, get_func_line)
  				  ? (char_u *)"endfunction" : (char_u *)NULL);
  
      if (trylevel == 0)
***************
*** 1218,1227 ****
       */
      if (did_throw)
  	need_rethrow = TRUE;
!     if ((getline == getsourceline
! 		&& ex_nesting_level > source_level(cookie))
! 	    || (getline == get_func_line
! 		&& ex_nesting_level > func_level(cookie) + 1))
      {
  	if (!did_throw)
  	    check_cstack = TRUE;
--- 1284,1293 ----
       */
      if (did_throw)
  	need_rethrow = TRUE;
!     if ((getline_equal(getline, cookie, getsourceline)
! 		&& ex_nesting_level > source_level(real_cookie))
! 	    || (getline_equal(getline, cookie, get_func_line)
! 		&& ex_nesting_level > func_level(real_cookie) + 1))
      {
  	if (!did_throw)
  	    check_cstack = TRUE;
***************
*** 1229,1243 ****
      else
      {
  	/* When leaving a function, reduce nesting level. */
! 	if (getline == get_func_line)
  	    --ex_nesting_level;
  	/*
  	 * Go to debug mode when returning from a function in which we are
  	 * single-stepping.
  	 */
! 	if ((getline == getsourceline || getline == get_func_line)
  		&& ex_nesting_level + 1 <= debug_break_level)
! 	    do_debug(getline == getsourceline
  		    ? (char_u *)_("End of sourced file")
  		    : (char_u *)_("End of function"));
      }
--- 1295,1310 ----
      else
      {
  	/* When leaving a function, reduce nesting level. */
! 	if (getline_equal(getline, cookie, get_func_line))
  	    --ex_nesting_level;
  	/*
  	 * Go to debug mode when returning from a function in which we are
  	 * single-stepping.
  	 */
! 	if ((getline_equal(getline, cookie, getsourceline)
! 		    || getline_equal(getline, cookie, get_func_line))
  		&& ex_nesting_level + 1 <= debug_break_level)
! 	    do_debug(getline_equal(getline, cookie, getsourceline)
  		    ? (char_u *)_("End of sourced file")
  		    : (char_u *)_("End of function"));
      }
***************
*** 1316,1321 ****
--- 1383,1444 ----
  }
  
  #ifdef FEAT_EVAL
+ /*
+  * Obtain a line when inside a ":while" loop.
+  */
+     static char_u *
+ get_while_line(c, cookie, indent)
+     int		c;
+     void	*cookie;
+     int		indent;
+ {
+     struct while_cookie *cp = (struct while_cookie *)cookie;
+     wcmd_T		*wp;
+     char_u		*line;
+ 
+     if (cp->current_line + 1 >= cp->lines_gap->ga_len)
+     {
+ 	if (cp->repeating)
+ 	    return NULL;	/* trying to read past the ":endwhile" */
+ 
+ 	/* First time inside the ":while": get line normally. */
+ 	if (cp->getline == NULL)
+ 	    line = getcmdline(c, 0L, indent);
+ 	else
+ 	    line = cp->getline(c, cp->cookie, indent);
+ 	if (store_while_line(cp->lines_gap, line) == OK)
+ 	    ++cp->current_line;
+ 
+ 	return line;
+     }
+ 
+     KeyTyped = FALSE;
+     ++cp->current_line;
+     wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line;
+     sourcing_lnum = wp->lnum;
+     return vim_strsave(wp->line);
+ }
+ 
+ /*
+  * Store a line in "gap" so that a ":while" loop can execute it again.
+  */
+     static int
+ store_while_line(gap, line)
+     garray_T	*gap;
+     char_u	*line;
+ {
+     if (ga_grow(gap, 1) == FAIL)
+ 	return FAIL;
+     ((wcmd_T *)(gap->ga_data))[gap->ga_len].line = vim_strsave(line);
+     ((wcmd_T *)(gap->ga_data))[gap->ga_len].lnum = sourcing_lnum;
+     ++gap->ga_len;
+     --gap->ga_room;
+     return OK;
+ }
+ 
+ /*
+  * Free the lines stored for a ":while" loop.
+  */
      static void
  free_cmdlines(gap)
      garray_T	*gap;
***************
*** 1330,1335 ****
--- 1453,1521 ----
  #endif
  
  /*
+  * If "getline" is get_while_line(), return TRUE if the getline it uses equals
+  * "func".  * Otherwise return TRUE when "getline" equals "func".
+  */
+ /*ARGSUSED*/
+     int
+ getline_equal(getline, cookie, func)
+     char_u	*(*getline) __ARGS((int, void *, int));
+     void	*cookie;		/* argument for getline() */
+     char_u	*(*func) __ARGS((int, void *, int));
+ {
+ #ifdef FEAT_EVAL
+     char_u		*(*gp) __ARGS((int, void *, int));
+     struct while_cookie *cp;
+ 
+     /* When "getline" is "get_while_line()" use the "cookie" to find the
+      * function that's orignally used to obtain the lines.  This may be nested
+      * several levels. */
+     gp = getline;
+     cp = (struct while_cookie *)cookie;
+     while (gp == get_while_line)
+     {
+ 	gp = cp->getline;
+ 	cp = cp->cookie;
+     }
+     return gp == func;
+ #else
+     return getline == func;
+ #endif
+ }
+ 
+ #if defined(FEAT_EVAL) || defined(FEAT_MBYTE) || defined(PROTO)
+ /*
+  * If "getline" is get_while_line(), return the cookie used by the original
+  * getline function.  Otherwise return "cookie".
+  */
+ /*ARGSUSED*/
+     void *
+ getline_cookie(getline, cookie)
+     char_u	*(*getline) __ARGS((int, void *, int));
+     void	*cookie;		/* argument for getline() */
+ {
+ # ifdef FEAT_EVAL
+     char_u		*(*gp) __ARGS((int, void *, int));
+     struct while_cookie *cp;
+ 
+     /* When "getline" is "get_while_line()" use the "cookie" to find the
+      * cookie that's orignally used to obtain the lines.  This may be nested
+      * several levels. */
+     gp = getline;
+     cp = (struct while_cookie *)cookie;
+     while (gp == get_while_line)
+     {
+ 	gp = cp->getline;
+ 	cp = cp->cookie;
+     }
+     return cp;
+ # else
+     return cookie;
+ # endif
+ }
+ #endif
+ 
+ /*
   * Execute one Ex command.
   *
   * If 'sourcing' is TRUE, the command will be included in the error message.
***************
*** 1389,1395 ****
      if (quitmore
  #ifdef FEAT_EVAL
  	    /* avoid that a function call in 'statusline' does this */
! 	    && getline != get_func_line
  #endif
  	    )
  	--quitmore;
--- 1575,1581 ----
      if (quitmore
  #ifdef FEAT_EVAL
  	    /* avoid that a function call in 'statusline' does this */
! 	    && !getline_equal(getline, cookie, get_func_line)
  #endif
  	    )
  	--quitmore;
***************
*** 1415,1421 ****
  
  	/* in ex mode, an empty line works like :+ */
  	if (*ea.cmd == NUL && exmode_active
! 			&& (getline == getexmodeline || getline == getexline))
  	{
  	    ea.cmd = (char_u *)"+";
  	    ex_pressedreturn = TRUE;
--- 1601,1608 ----
  
  	/* in ex mode, an empty line works like :+ */
  	if (*ea.cmd == NUL && exmode_active
! 			&& (getline_equal(getline, cookie, getexmodeline)
! 			    || getline_equal(getline, cookie, getexline)))
  	{
  	    ea.cmd = (char_u *)"+";
  	    ex_pressedreturn = TRUE;
***************
*** 2271,2279 ****
  	do_throw(cstack);
      else if (check_cstack)
      {
! 	if (getline == getsourceline && source_finished(cookie))
  	    do_finish(&ea, TRUE);
! 	else if (getline == get_func_line && current_func_returned())
  	    do_return(&ea, TRUE, FALSE, NULL);
      }
      need_rethrow = check_cstack = FALSE;
--- 2458,2467 ----
  	do_throw(cstack);
      else if (check_cstack)
      {
! 	if (source_finished(getline, cookie))
  	    do_finish(&ea, TRUE);
! 	else if (getline_equal(getline, cookie, get_func_line)
! 						   && current_func_returned())
  	    do_return(&ea, TRUE, FALSE, NULL);
      }
      need_rethrow = check_cstack = FALSE;
*** ../vim-6.2.237/src/ex_eval.c	Tue Feb  3 17:25:35 2004
--- src/ex_eval.c	Mon Feb  2 22:04:59 2004
***************
*** 1256,1262 ****
  	 * End the current script or function.  The exception will be rethrown
  	 * in the caller.
  	 */
! 	if (eap->getline == get_func_line)
  	    current_funccal->returned = TRUE;
  	elseif (eap->get_func_line == getsourceline)
  	    ((struct source_cookie *)eap->cookie)->finished = TRUE;
--- 1256,1262 ----
  	 * End the current script or function.  The exception will be rethrown
  	 * in the caller.
  	 */
! 	if (getline_equal(eap->getline, eap->cookie, get_func_line))
  	    current_funccal->returned = TRUE;
  	elseif (eap->get_func_line == getsourceline)
  	    ((struct source_cookie *)eap->cookie)->finished = TRUE;
*** ../vim-6.2.237/src/proto/ex_cmds2.pro	Sun Oct 12 20:20:38 2003
--- src/proto/ex_cmds2.pro	Mon Feb  2 21:43:56 2004
***************
*** 49,55 ****
  void ex_scriptencoding __ARGS((exarg_T *eap));
  void ex_finish __ARGS((exarg_T *eap));
  void do_finish __ARGS((exarg_T *eap, int reanimate));
! int source_finished __ARGS((void *cookie));
  void ex_checktime __ARGS((exarg_T *eap));
  int get_printer_page_num __ARGS((void));
  int prt_header_height __ARGS((void));
--- 49,55 ----
  void ex_scriptencoding __ARGS((exarg_T *eap));
  void ex_finish __ARGS((exarg_T *eap));
  void do_finish __ARGS((exarg_T *eap, int reanimate));
! int source_finished __ARGS((char_u *(*getline)(int, void *, int), void *cookie));
  void ex_checktime __ARGS((exarg_T *eap));
  int get_printer_page_num __ARGS((void));
  int prt_header_height __ARGS((void));
*** ../vim-6.2.237/src/proto/ex_docmd.pro	Sun Jun  1 12:26:08 2003
--- src/proto/ex_docmd.pro	Mon Feb  2 22:11:34 2004
***************
*** 2,7 ****
--- 2,9 ----
  void do_exmode __ARGS((int improved));
  int do_cmdline_cmd __ARGS((char_u *cmd));
  int do_cmdline __ARGS((char_u *cmdline, char_u *(*getline)(int, void *, int), void *cookie, int flags));
+ int getline_equal __ARGS((char_u *(*getline)(int, void *, int), void *cookie, char_u *(*func)(int, void *, int)));
+ void *getline_cookie __ARGS((char_u *(*getline)(int, void *, int), void *cookie));
  int cmd_exists __ARGS((char_u *name));
  char_u *set_one_cmd_context __ARGS((expand_T *xp, char_u *buff));
  char_u *skip_range __ARGS((char_u *cmd, int *ctx));
*** ../vim-6.2.237/src/testdir/test49.in	Fri Apr 18 17:14:29 2003
--- src/testdir/test49.in	Thu Feb  5 15:33:35 2004
***************
*** 7,13 ****
  :so small.vim
  :se nocp nomore
  :so test49.vim
! GGGGGGGGG"rp:.-,$wq! test.out
  ENDTEST
  
  Results of test49.vim:
--- 7,13 ----
  :so small.vim
  :se nocp nomore
  :so test49.vim
! GGGGGGGGGG"rp:.-,$wq! test.out
  ENDTEST
  
  Results of test49.vim:
*** ../vim-6.2.237/src/testdir/test49.ok	Tue Feb  3 17:25:35 2004
--- src/testdir/test49.ok	Thu Feb  5 15:33:35 2004
***************
*** 4,91 ****
  *** Test   3: OK (1384648195)
  *** Test   4: OK (32883)
  *** Test   5: OK (32883)
! *** Test   6: OK (90563)
! *** Test   7: OK (562493431)
! *** Test   8: OK (363)
! *** Test   9: OK (559615)
! *** Test  10: OK (2049)
! *** Test  11: OK (352256)
! *** Test  12: OK (145)
! *** Test  13: OK (42413)
  *** Test  14: OK (42413)
! *** Test  15: OK (8722)
! *** Test  16: OK (285127993)
! *** Test  17: OK (67224583)
! *** Test  18: OK (69275973)
! *** Test  19: OK (1874575085)
! *** Test  20: OK (147932225)
! *** Test  21: OK (4161)
! *** Test  22: OK (49)
! *** Test  23: OK (41)
! *** Test  24: OK (260177811)
! *** Test  25: OK (1681500476)
! *** Test  26: OK (1996459)
  *** Test  27: OK (1996459)
! *** Test  28: OK (170428555)
! *** Test  29: OK (190905173)
  *** Test  30: OK (190905173)
! *** Test  31: OK (354833067)
! --- Test  32: sum = 178275600 (ok)
! *** Test  32: OK (1216907538)
! *** Test  33: OK (2146584868)
  *** Test  34: OK (2146584868)
! *** Test  35: OK (1071644672)
  *** Test  36: OK (1071644672)
! *** Test  37: OK (357908480)
  *** Test  38: OK (357908480)
  *** Test  39: OK (357908480)
! *** Test  40: OK (3076095)
! *** Test  41: OK (1505155949)
! *** Test  42: OK (1157763329)
! *** Test  43: OK (1031761407)
! *** Test  44: OK (1157763329)
! *** Test  45: OK (739407)
! *** Test  46: OK (371213935)
! *** Test  47: OK (756255461)
! *** Test  48: OK (179000669)
! *** Test  49: OK (363550045)
! *** Test  50: OK (40744667)
! *** Test  51: OK (1247112011)
! *** Test  52: OK (131071)
! *** Test  53: OK (2047)
! *** Test  54: OK (1023)
! *** Test  55: OK (511)
! *** Test  56: OK (2147450880)
! *** Test  57: OK (624945)
! *** Test  58: OK (2038431743)
! *** Test  59: OK (311511339)
! *** Test  60: OK (374889517)
! *** Test  61: OK (286331153)
! *** Test  62: OK (236978127)
! *** Test  63: OK (1499645335)
! *** Test  64: OK (70187)
! *** Test  65: OK (5464)
! *** Test  66: OK (212514423)
  *** Test  67: OK (212514423)
! *** Test  68: OK (8995471)
! *** Test  69: OK (69544277)
! *** Test  70: OK (34886997)
! *** Test  71: OK (1789569365)
! *** Test  72: OK (9032615)
! *** Test  73: OK (224907669)
! *** Test  74: OK (2000403408)
! *** Test  75: OK (1610087935)
! *** Test  76: OK (1388671)
! *** Test  77: OK (134217728)
! *** Test  78: OK (70288929)
! *** Test  79: OK (17895765)
! *** Test  80: OK (387)
! *** Test  81: OK (8454401)
! *** Test  82: OK (2835)
! *** Test  83: OK (934782101)
! *** Test  84: OK (198689)
! --- Test  85: All tests were run with throwing exceptions on error.
  	      The $VIMNOERRTHROW control is not configured.
! --- Test  85: All tests were run with throwing exceptions on interrupt.
  	      The $VIMNOINTTHROW control is not configured.
! *** Test  85: OK (50443995)
--- 4,92 ----
  *** Test   3: OK (1384648195)
  *** Test   4: OK (32883)
  *** Test   5: OK (32883)
! *** Test   6: OK (603978947)
! *** Test   7: OK (90563)
! *** Test   8: OK (562493431)
! *** Test   9: OK (363)
! *** Test  10: OK (559615)
! *** Test  11: OK (2049)
! *** Test  12: OK (352256)
! *** Test  13: OK (145)
  *** Test  14: OK (42413)
! *** Test  15: OK (42413)
! *** Test  16: OK (8722)
! *** Test  17: OK (285127993)
! *** Test  18: OK (67224583)
! *** Test  19: OK (69275973)
! *** Test  20: OK (1874575085)
! *** Test  21: OK (147932225)
! *** Test  22: OK (4161)
! *** Test  23: OK (49)
! *** Test  24: OK (41)
! *** Test  25: OK (260177811)
! *** Test  26: OK (1681500476)
  *** Test  27: OK (1996459)
! *** Test  28: OK (1996459)
! *** Test  29: OK (170428555)
  *** Test  30: OK (190905173)
! *** Test  31: OK (190905173)
! *** Test  32: OK (354833067)
! --- Test  33: sum = 178275600 (ok)
! *** Test  33: OK (1216907538)
  *** Test  34: OK (2146584868)
! *** Test  35: OK (2146584868)
  *** Test  36: OK (1071644672)
! *** Test  37: OK (1071644672)
  *** Test  38: OK (357908480)
  *** Test  39: OK (357908480)
! *** Test  40: OK (357908480)
! *** Test  41: OK (3076095)
! *** Test  42: OK (1505155949)
! *** Test  43: OK (1157763329)
! *** Test  44: OK (1031761407)
! *** Test  45: OK (1157763329)
! *** Test  46: OK (739407)
! *** Test  47: OK (371213935)
! *** Test  48: OK (756255461)
! *** Test  49: OK (179000669)
! *** Test  50: OK (363550045)
! *** Test  51: OK (40744667)
! *** Test  52: OK (1247112011)
! *** Test  53: OK (131071)
! *** Test  54: OK (2047)
! *** Test  55: OK (1023)
! *** Test  56: OK (511)
! *** Test  57: OK (2147450880)
! *** Test  58: OK (624945)
! *** Test  59: OK (2038431743)
! *** Test  60: OK (311511339)
! *** Test  61: OK (374889517)
! *** Test  62: OK (286331153)
! *** Test  63: OK (236978127)
! *** Test  64: OK (1499645335)
! *** Test  65: OK (70187)
! *** Test  66: OK (5464)
  *** Test  67: OK (212514423)
! *** Test  68: OK (212514423)
! *** Test  69: OK (8995471)
! *** Test  70: OK (69544277)
! *** Test  71: OK (34886997)
! *** Test  72: OK (1789569365)
! *** Test  73: OK (9032615)
! *** Test  74: OK (224907669)
! *** Test  75: OK (2000403408)
! *** Test  76: OK (1610087935)
! *** Test  77: OK (1388671)
! *** Test  78: OK (134217728)
! *** Test  79: OK (70288929)
! *** Test  80: OK (17895765)
! *** Test  81: OK (387)
! *** Test  82: OK (8454401)
! *** Test  83: OK (2835)
! *** Test  84: OK (934782101)
! *** Test  85: OK (198689)
! --- Test  86: All tests were run with throwing exceptions on error.
  	      The $VIMNOERRTHROW control is not configured.
! --- Test  86: All tests were run with throwing exceptions on interrupt.
  	      The $VIMNOINTTHROW control is not configured.
! *** Test  86: OK (50443995)
*** ../vim-6.2.237/src/testdir/test49.vim	Tue Feb  3 17:25:35 2004
--- src/testdir/test49.vim	Thu Feb  5 15:33:35 2004
***************
*** 95,101 ****
  	    " that it is not read away by the call to "input()" below.  Restore
  	    " afterwards.
  	    call inputsave()
! 	    let loops = input("Number of loops? ")
  	    call inputrestore()
  	    while (loops > 0)
  		let num = num * factor
--- 95,101 ----
  	    " that it is not read away by the call to "input()" below.  Restore
  	    " afterwards.
  	    call inputsave()
! 	    let loops = input("Number of iterations in previous loop? ")
  	    call inputrestore()
  	    while (loops > 0)
  		let num = num * factor
***************
*** 817,823 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 6:   Continuing on errors outside functions			    {{{1
  "
  "	    On an error outside a function, the script processing continues
  "	    at the line following the outermost :endif or :endwhile.  When not
--- 817,970 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 6:   Defining functions in :while loops				    {{{1
! "
! "	     Functions can be defined inside other functions.  An inner function
! "	     gets defined when the outer function is executed.  Functions may
! "	     also be defined inside while loops.  Expressions in braces for
! "	     defining the function name are allowed.
! "-------------------------------------------------------------------------------
! 
! XpathINIT
! 
! if ExtraVim()
! 
!     " The command CALL collects the argument of all its invocations in "calls"
!     " when used from a function (that is, when the global variable "calls" needs
!     " the "g:" prefix).  This is to check that the function code is skipped when
!     " the function is defined.  For inner functions, do so only if the outer
!     " function is not being executed.
!     "
!     let calls = ""
!     com! -nargs=1 CALL
! 		\ if !exists("calls") && !exists("outer") |
! 		\ let g:calls = g:calls . <args> |
! 		\ endif
! 
! 
!     XloopINIT! 1 16
! 
!     let i = 0
!     while i < 3
! 
! 	XloopNEXT
! 	let i = i + 1
! 
! 	if i == 1
! 	    Xloop 1				" X: 1
! 	    function! F1(arg)
! 		CALL a:arg
! 		let outer = 1
! 
! 		XloopINIT! 4096 4
! 		let j = 0
! 		while j < 1
! 		    XloopNEXT
! 		    Xloop 1			" X: 4096
! 		    let j = j + 1
! 		    function! G1(arg)
! 			CALL a:arg
! 		    endfunction
! 		    Xloop 2			" X: 8192
! 		endwhile
! 	    endfunction
! 	    Xloop 2				" X: 2
! 
! 	    continue
! 	endif
! 
! 	Xloop 4					" X: 4 * (16 + 256)
! 	function! F{i}(i, arg)
! 	    CALL a:arg
! 	    let outer = 1
! 
! 	    XloopINIT! 16384 4
! 	    if a:i == 3
! 		XloopNEXT
! 		XloopNEXT
! 		XloopNEXT
! 	    endif
! 	    let k = 0
! 	    while k < 3
! 		XloopNEXT
! 		Xloop 1				" X: 16384*(1+4+16+64+256+1024)
! 		let k = k + 1
! 		function! G{a:i}{k}(arg)
! 		    CALL a:arg
! 		endfunction
! 		Xloop 2				" X: 32768*(1+4+16+64+256+1024)
! 	    endwhile
! 	endfunction
! 	Xloop 8					" X: 8 * (16 + 256)
! 
!     endwhile
! 
!     if exists("*G1")
! 	Xpath 67108864				" X: 0
!     endif
!     if exists("*F1")
! 	call F1("F1")
! 	if exists("*G1")
! 	    call G1("G1")
! 	endif
!     endif
! 
!     if exists("G21") || exists("G21") || exists("G21")
! 	Xpath 134217728				" X: 0
!     endif
!     if exists("*F2")
! 	call F2(2, "F2")
! 	if exists("*G21")
! 	    call G21("G21")
! 	endif
! 	if exists("*G22")
! 	    call G22("G22")
! 	endif
! 	if exists("*G23")
! 	    call G23("G23")
! 	endif
!     endif
! 
!     if exists("G31") || exists("G31") || exists("G31")
! 	Xpath 268435456				" X: 0
!     endif
!     if exists("*F3")
! 	call F3(3, "F3")
! 	if exists("*G31")
! 	    call G31("G31")
! 	endif
! 	if exists("*G32")
! 	    call G32("G32")
! 	endif
! 	if exists("*G33")
! 	    call G33("G33")
! 	endif
!     endif
! 
!     Xpath 536870912				" X: 536870912
! 
!     if calls != "F1G1F2G21G22G23F3G31G32G33"
! 	Xpath 1073741824			" X: 0
! 	Xout "calls is" calls
!     endif
! 
!     delfunction F1
!     delfunction G1
!     delfunction F2
!     delfunction G21
!     delfunction G22
!     delfunction G23
!     delfunction G31
!     delfunction G32
!     delfunction G33
! 
! endif
! 
! Xcheck 603978947
! 
! 
! "-------------------------------------------------------------------------------
! " Test 7:   Continuing on errors outside functions			    {{{1
  "
  "	    On an error outside a function, the script processing continues
  "	    at the line following the outermost :endif or :endwhile.  When not
***************
*** 861,867 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 7:   Aborting and continuing on errors inside functions		    {{{1
  "
  "	    On an error inside a function without the "abort" attribute, the
  "	    script processing continues at the next line (unless the error was
--- 1008,1014 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 8:   Aborting and continuing on errors inside functions		    {{{1
  "
  "	    On an error inside a function without the "abort" attribute, the
  "	    script processing continues at the next line (unless the error was
***************
*** 955,961 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 8:   Continuing after aborted functions				    {{{1
  "
  "	    When a function with the "abort" attribute is aborted due to an
  "	    error, the next function back in the call hierarchy without an
--- 1102,1108 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 9:   Continuing after aborted functions				    {{{1
  "
  "	    When a function with the "abort" attribute is aborted due to an
  "	    error, the next function back in the call hierarchy without an
***************
*** 1010,1016 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 9:   :if, :elseif, :while argument parsing			    {{{1
  "
  "	    A '"' or '|' in an argument expression must not be mixed up with
  "	    a comment or a next command after a bar.  Parsing errors should
--- 1157,1163 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 10:  :if, :elseif, :while argument parsing			    {{{1
  "
  "	    A '"' or '|' in an argument expression must not be mixed up with
  "	    a comment or a next command after a bar.  Parsing errors should
***************
*** 1090,1096 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 10:  :if, :elseif, :while argument evaluation after abort	    {{{1
  "
  "	    When code is skipped over due to an error, the boolean argument to
  "	    an :if, :elseif, or :while must not be evaluated.
--- 1237,1243 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 11:  :if, :elseif, :while argument evaluation after abort	    {{{1
  "
  "	    When code is skipped over due to an error, the boolean argument to
  "	    an :if, :elseif, or :while must not be evaluated.
***************
*** 1141,1147 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 11:  Expressions in braces in skipped code			    {{{1
  "
  "	    In code skipped over due to an error or inactive conditional,
  "	    an expression in braces as part of a variable or function name
--- 1288,1294 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 12:  Expressions in braces in skipped code			    {{{1
  "
  "	    In code skipped over due to an error or inactive conditional,
  "	    an expression in braces as part of a variable or function name
***************
*** 1202,1208 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 12:  Failure in argument evaluation for :while			    {{{1
  "
  "	    A failure in the expression evaluation for the condition of a :while
  "	    causes the whole :while loop until the matching :endwhile being
--- 1349,1355 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 13:  Failure in argument evaluation for :while			    {{{1
  "
  "	    A failure in the expression evaluation for the condition of a :while
  "	    causes the whole :while loop until the matching :endwhile being
***************
*** 1230,1236 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 13:  Failure in argument evaluation for :if			    {{{1
  "
  "	    A failure in the expression evaluation for the condition of an :if
  "	    does not cause the corresponding :else or :endif being matched to
--- 1377,1383 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 14:  Failure in argument evaluation for :if			    {{{1
  "
  "	    A failure in the expression evaluation for the condition of an :if
  "	    does not cause the corresponding :else or :endif being matched to
***************
*** 1274,1280 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 14:  Failure in argument evaluation for :if (bar)		    {{{1
  "
  "	    Like previous test, except that the failing :if ... | ... | :endif
  "	    is in a single line.
--- 1421,1427 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 15:  Failure in argument evaluation for :if (bar)		    {{{1
  "
  "	    Like previous test, except that the failing :if ... | ... | :endif
  "	    is in a single line.
***************
*** 1312,1318 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 15:  Double :else or :elseif after :else				    {{{1
  "
  "	    Multiple :elses or an :elseif after an :else are forbidden.
  "-------------------------------------------------------------------------------
--- 1459,1465 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 16:  Double :else or :elseif after :else				    {{{1
  "
  "	    Multiple :elses or an :elseif after an :else are forbidden.
  "-------------------------------------------------------------------------------
***************
*** 1381,1387 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 16:  Nesting of unmatched :if or :endif inside a :while		    {{{1
  "
  "	    The :while/:endwhile takes precedence in nesting over an unclosed
  "	    :if or an unopened :endif.
--- 1528,1534 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 17:  Nesting of unmatched :if or :endif inside a :while		    {{{1
  "
  "	    The :while/:endwhile takes precedence in nesting over an unclosed
  "	    :if or an unopened :endif.
***************
*** 1500,1506 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 17:  Interrupt (Ctrl-C pressed)					    {{{1
  "
  "	    On an interrupt, the script processing is terminated immediately.
  "-------------------------------------------------------------------------------
--- 1647,1653 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 18:  Interrupt (Ctrl-C pressed)					    {{{1
  "
  "	    On an interrupt, the script processing is terminated immediately.
  "-------------------------------------------------------------------------------
***************
*** 1579,1585 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 18:  Aborting on errors inside :try/:endtry			    {{{1
  "
  "	    An error in a command dynamically enclosed in a :try/:endtry region
  "	    aborts script processing immediately.  It does not matter whether
--- 1726,1732 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 19:  Aborting on errors inside :try/:endtry			    {{{1
  "
  "	    An error in a command dynamically enclosed in a :try/:endtry region
  "	    aborts script processing immediately.  It does not matter whether
***************
*** 1664,1670 ****
  
  Xcheck 69275973
  "-------------------------------------------------------------------------------
! " Test 19:  Aborting on errors after :try/:endtry			    {{{1
  "
  "	    When an error occurs after the last active :try/:endtry region has
  "	    been left, termination behavior is as if no :try/:endtry has been
--- 1811,1817 ----
  
  Xcheck 69275973
  "-------------------------------------------------------------------------------
! " Test 20:  Aborting on errors after :try/:endtry			    {{{1
  "
  "	    When an error occurs after the last active :try/:endtry region has
  "	    been left, termination behavior is as if no :try/:endtry has been
***************
*** 1781,1787 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 20:  :finally for :try after :continue/:break/:return/:finish	    {{{1
  "
  "	    If a :try conditional stays inactive due to a preceding :continue,
  "	    :break, :return, or :finish, its :finally clause should not be
--- 1928,1934 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 21:  :finally for :try after :continue/:break/:return/:finish	    {{{1
  "
  "	    If a :try conditional stays inactive due to a preceding :continue,
  "	    :break, :return, or :finish, its :finally clause should not be
***************
*** 1855,1861 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 21:  :finally for a :try after an error/interrupt/:throw		    {{{1
  "
  "	    If a :try conditional stays inactive due to a preceding error or
  "	    interrupt or :throw, its :finally clause should not be executed.
--- 2002,2008 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 22:  :finally for a :try after an error/interrupt/:throw		    {{{1
  "
  "	    If a :try conditional stays inactive due to a preceding error or
  "	    interrupt or :throw, its :finally clause should not be executed.
***************
*** 1943,1949 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 22:  :catch clauses for a :try after a :throw			    {{{1
  "
  "	    If a :try conditional stays inactive due to a preceding :throw,
  "	    none of its :catch clauses should be executed.
--- 2090,2096 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 23:  :catch clauses for a :try after a :throw			    {{{1
  "
  "	    If a :try conditional stays inactive due to a preceding :throw,
  "	    none of its :catch clauses should be executed.
***************
*** 1983,1989 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 23:  :endtry for a :try after a :throw				    {{{1
  "
  "	    If a :try conditional stays inactive due to a preceding :throw,
  "	    its :endtry should not rethrow the exception to the next surrounding
--- 2130,2136 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 24:  :endtry for a :try after a :throw				    {{{1
  "
  "	    If a :try conditional stays inactive due to a preceding :throw,
  "	    its :endtry should not rethrow the exception to the next surrounding
***************
*** 2015,2021 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 24:  Executing :finally clauses on normal control flow		    {{{1
  "
  "	    Control flow in a :try conditional should always fall through to its
  "	    :finally clause.  A :finally clause of a :try conditional inside an
--- 2162,2168 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 25:  Executing :finally clauses on normal control flow		    {{{1
  "
  "	    Control flow in a :try conditional should always fall through to its
  "	    :finally clause.  A :finally clause of a :try conditional inside an
***************
*** 2079,2085 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 25:  Executing :finally clauses after :continue or :break	    {{{1
  "
  "	    For a :continue or :break dynamically enclosed in a :try/:endtry
  "	    region inside the next surrounding :while/:endwhile, if the
--- 2226,2232 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 26:  Executing :finally clauses after :continue or :break	    {{{1
  "
  "	    For a :continue or :break dynamically enclosed in a :try/:endtry
  "	    region inside the next surrounding :while/:endwhile, if the
***************
*** 2150,2156 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 26:  Executing :finally clauses after :return			    {{{1
  "
  "	    For a :return command dynamically enclosed in a :try/:endtry region,
  "	    :finally clauses are executed and the called function is ended.
--- 2297,2303 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 27:  Executing :finally clauses after :return			    {{{1
  "
  "	    For a :return command dynamically enclosed in a :try/:endtry region,
  "	    :finally clauses are executed and the called function is ended.
***************
*** 2216,2222 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 27:  Executing :finally clauses after :finish			    {{{1
  "
  "	    For a :finish command dynamically enclosed in a :try/:endtry region,
  "	    :finally clauses are executed and the sourced file is finished.
--- 2363,2369 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 28:  Executing :finally clauses after :finish			    {{{1
  "
  "	    For a :finish command dynamically enclosed in a :try/:endtry region,
  "	    :finally clauses are executed and the sourced file is finished.
***************
*** 2252,2258 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 28:  Executing :finally clauses on errors			    {{{1
  "
  "	    After an error in a command dynamically enclosed in a :try/:endtry
  "	    region, :finally clauses are executed and the script processing is
--- 2399,2405 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 29:  Executing :finally clauses on errors			    {{{1
  "
  "	    After an error in a command dynamically enclosed in a :try/:endtry
  "	    region, :finally clauses are executed and the script processing is
***************
*** 2333,2339 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 29:  Executing :finally clauses on interrupt			    {{{1
  "
  "	    After an interrupt in a command dynamically enclosed in
  "	    a :try/:endtry region, :finally clauses are executed and the
--- 2480,2486 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 30:  Executing :finally clauses on interrupt			    {{{1
  "
  "	    After an interrupt in a command dynamically enclosed in
  "	    a :try/:endtry region, :finally clauses are executed and the
***************
*** 2409,2415 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 30:  Executing :finally clauses after :throw			    {{{1
  "
  "	    After a :throw dynamically enclosed in a :try/:endtry region,
  "	    :finally clauses are executed and the script processing is
--- 2556,2562 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 31:  Executing :finally clauses after :throw			    {{{1
  "
  "	    After a :throw dynamically enclosed in a :try/:endtry region,
  "	    :finally clauses are executed and the script processing is
***************
*** 2485,2491 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 31:  Remembering the :return value on :finally			    {{{1
  "
  "	    If a :finally clause is executed due to a :return specifying
  "	    a value, this is the value visible to the caller if not overwritten
--- 2632,2638 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 32:  Remembering the :return value on :finally			    {{{1
  "
  "	    If a :finally clause is executed due to a :return specifying
  "	    a value, this is the value visible to the caller if not overwritten
***************
*** 2587,2593 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 32:  :return under :execute or user command and :finally		    {{{1
  "
  "	    A :return command may be executed under an ":execute" or from
  "	    a user command.  Executing of :finally clauses and passing through
--- 2734,2740 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 33:  :return under :execute or user command and :finally		    {{{1
  "
  "	    A :return command may be executed under an ":execute" or from
  "	    a user command.  Executing of :finally clauses and passing through
***************
*** 2732,2738 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 33:  :finally reason discarded by :continue			    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
--- 2879,2885 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 34:  :finally reason discarded by :continue			    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
***************
*** 2811,2817 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 34:  :finally reason discarded by :break				    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
--- 2958,2964 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 35:  :finally reason discarded by :break				    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
***************
*** 2890,2896 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 35:  :finally reason discarded by :return			    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
--- 3037,3043 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 36:  :finally reason discarded by :return			    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
***************
*** 2972,2978 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 36:  :finally reason discarded by :finish			    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
--- 3119,3125 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 37:  :finally reason discarded by :finish			    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
***************
*** 3061,3067 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 37:  :finally reason discarded by an error			    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
--- 3208,3214 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 38:  :finally reason discarded by an error			    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
***************
*** 3159,3165 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 38:  :finally reason discarded by an interrupt			    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
--- 3306,3312 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 39:  :finally reason discarded by an interrupt			    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
***************
*** 3258,3264 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 39:  :finally reason discarded by :throw				    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
--- 3405,3411 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 40:  :finally reason discarded by :throw				    {{{1
  "
  "	    When a :finally clause is executed due to a :continue, :break,
  "	    :return, :finish, error, interrupt or :throw, the jump reason is
***************
*** 3356,3362 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 40:  Skipped :throw finding next command				    {{{1
  "
  "	    A :throw in an inactive conditional must not hide a following
  "	    command.
--- 3503,3509 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 41:  Skipped :throw finding next command				    {{{1
  "
  "	    A :throw in an inactive conditional must not hide a following
  "	    command.
***************
*** 3425,3431 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 41:  Catching number and string exceptions			    {{{1
  "
  "	    When a number is thrown, it is converted to a string exception.
  "	    Numbers and strings may be caught by specifying a regular exception
--- 3572,3578 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 42:  Catching number and string exceptions			    {{{1
  "
  "	    When a number is thrown, it is converted to a string exception.
  "	    Numbers and strings may be caught by specifying a regular exception
***************
*** 3530,3536 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 42:  Selecting the correct :catch clause				    {{{1
  "
  "	    When an exception is thrown and there are multiple :catch clauses,
  "	    the first matching one is taken.
--- 3677,3683 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 43:  Selecting the correct :catch clause				    {{{1
  "
  "	    When an exception is thrown and there are multiple :catch clauses,
  "	    the first matching one is taken.
***************
*** 3576,3582 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 43:  Missing or empty :catch patterns				    {{{1
  "
  "	    A missing or empty :catch pattern means the same as /.*/, that is,
  "	    catches everything.  To catch only empty exceptions, /^$/ must be
--- 3723,3729 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 44:  Missing or empty :catch patterns				    {{{1
  "
  "	    A missing or empty :catch pattern means the same as /.*/, that is,
  "	    catches everything.  To catch only empty exceptions, /^$/ must be
***************
*** 3707,3713 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 44:  Catching exceptions from nested :try blocks			    {{{1
  "
  "	    When :try blocks are nested, an exception is caught by the innermost
  "	    try conditional that has a matching :catch clause.
--- 3854,3860 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 45:  Catching exceptions from nested :try blocks			    {{{1
  "
  "	    When :try blocks are nested, an exception is caught by the innermost
  "	    try conditional that has a matching :catch clause.
***************
*** 3759,3765 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 45:  Executing :finally after a :throw in nested :try		    {{{1
  "
  "	    When an exception is thrown from within nested :try blocks, the
  "	    :finally clauses of the non-catching try conditionals should be
--- 3906,3912 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 46:  Executing :finally after a :throw in nested :try		    {{{1
  "
  "	    When an exception is thrown from within nested :try blocks, the
  "	    :finally clauses of the non-catching try conditionals should be
***************
*** 3836,3842 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 46:  Throwing exceptions from a :catch clause			    {{{1
  "
  "	    When an exception is thrown from a :catch clause, it should not be
  "	    caught by a :catch of the same :try conditional.  After executing
--- 3983,3989 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 47:  Throwing exceptions from a :catch clause			    {{{1
  "
  "	    When an exception is thrown from a :catch clause, it should not be
  "	    caught by a :catch of the same :try conditional.  After executing
***************
*** 3909,3915 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 47:  Throwing exceptions from a :finally clause			    {{{1
  "
  "	    When an exception is thrown from a :finally clause, it should not be
  "	    caught by a :catch of the same :try conditional.  Surrounding try
--- 4056,4062 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 48:  Throwing exceptions from a :finally clause			    {{{1
  "
  "	    When an exception is thrown from a :finally clause, it should not be
  "	    caught by a :catch of the same :try conditional.  Surrounding try
***************
*** 3994,4000 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 48:  Throwing exceptions accross functions			    {{{1
  "
  "	    When an exception is thrown but not caught inside a function, the
  "	    caller is checked for a matching :catch clause.
--- 4141,4147 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 49:  Throwing exceptions accross functions			    {{{1
  "
  "	    When an exception is thrown but not caught inside a function, the
  "	    caller is checked for a matching :catch clause.
***************
*** 4076,4082 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 49:  Throwing exceptions accross script files			    {{{1
  "
  "	    When an exception is thrown but not caught inside a script file,
  "	    the sourcing script or function is checked for a matching :catch
--- 4223,4229 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 50:  Throwing exceptions accross script files			    {{{1
  "
  "	    When an exception is thrown but not caught inside a script file,
  "	    the sourcing script or function is checked for a matching :catch
***************
*** 4145,4151 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 50:  Throwing exceptions accross :execute and user commands	    {{{1
  "
  "	    A :throw command may be executed under an ":execute" or from
  "	    a user command.
--- 4292,4298 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 51:  Throwing exceptions accross :execute and user commands	    {{{1
  "
  "	    A :throw command may be executed under an ":execute" or from
  "	    a user command.
***************
*** 4264,4270 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 51:  Uncaught exceptions						    {{{1
  "
  "	    When an exception is thrown but not caught, an error message is
  "	    displayed when the script is terminated.  In case of an interrupt
--- 4411,4417 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 52:  Uncaught exceptions						    {{{1
  "
  "	    When an exception is thrown but not caught, an error message is
  "	    displayed when the script is terminated.  In case of an interrupt
***************
*** 4431,4437 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 52:  Nesting errors: :endif/:else/:elseif			    {{{1
  "
  "	    For nesting errors of :if conditionals the correct error messages
  "	    should be given.
--- 4578,4584 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 53:  Nesting errors: :endif/:else/:elseif			    {{{1
  "
  "	    For nesting errors of :if conditionals the correct error messages
  "	    should be given.
***************
*** 4611,4617 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 53:  Nesting errors: :while/:endwhile				    {{{1
  "
  "	    For nesting errors of :while conditionals the correct error messages
  "	    should be given.
--- 4758,4764 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 54:  Nesting errors: :while/:endwhile				    {{{1
  "
  "	    For nesting errors of :while conditionals the correct error messages
  "	    should be given.
***************
*** 4745,4751 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 54:  Nesting errors: :continue/:break				    {{{1
  "
  "	    For nesting errors of :continue and :break commands the correct
  "	    error messages should be given.
--- 4892,4898 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 55:  Nesting errors: :continue/:break				    {{{1
  "
  "	    For nesting errors of :continue and :break commands the correct
  "	    error messages should be given.
***************
*** 4859,4865 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 55:  Nesting errors: :endtry					    {{{1
  "
  "	    For nesting errors of :try conditionals the correct error messages
  "	    should be given.
--- 5006,5012 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 56:  Nesting errors: :endtry					    {{{1
  "
  "	    For nesting errors of :try conditionals the correct error messages
  "	    should be given.
***************
*** 4966,4972 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 56:  v:exception and v:throwpoint for user exceptions		    {{{1
  "
  "	    v:exception evaluates to the value of the exception that was caught
  "	    most recently and is not finished.  (A caught exception is finished
--- 5113,5119 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 57:  v:exception and v:throwpoint for user exceptions		    {{{1
  "
  "	    v:exception evaluates to the value of the exception that was caught
  "	    most recently and is not finished.  (A caught exception is finished
***************
*** 5151,5157 ****
  
  "-------------------------------------------------------------------------------
  "
! " Test 57:  v:exception and v:throwpoint for error/interrupt exceptions	    {{{1
  "
  "	    v:exception and v:throwpoint work also for error and interrupt
  "	    exceptions.
--- 5298,5304 ----
  
  "-------------------------------------------------------------------------------
  "
! " Test 58:  v:exception and v:throwpoint for error/interrupt exceptions	    {{{1
  "
  "	    v:exception and v:throwpoint work also for error and interrupt
  "	    exceptions.
***************
*** 5254,5260 ****
  
  "-------------------------------------------------------------------------------
  "
! " Test 58:  v:exception and v:throwpoint when discarding exceptions	    {{{1
  "
  "	    When a :catch clause is left by a ":break" etc or an error or
  "	    interrupt exception, v:exception and v:throwpoint are reset.  They
--- 5401,5407 ----
  
  "-------------------------------------------------------------------------------
  "
! " Test 59:  v:exception and v:throwpoint when discarding exceptions	    {{{1
  "
  "	    When a :catch clause is left by a ":break" etc or an error or
  "	    interrupt exception, v:exception and v:throwpoint are reset.  They
***************
*** 5565,5571 ****
  
  "-------------------------------------------------------------------------------
  "
! " Test 59:  (Re)throwing v:exception; :echoerr.				    {{{1
  "
  "	    A user exception can be rethrown after catching by throwing
  "	    v:exception.  An error or interrupt exception cannot be rethrown
--- 5712,5718 ----
  
  "-------------------------------------------------------------------------------
  "
! " Test 60:  (Re)throwing v:exception; :echoerr.				    {{{1
  "
  "	    A user exception can be rethrown after catching by throwing
  "	    v:exception.  An error or interrupt exception cannot be rethrown
***************
*** 5721,5727 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 60:  Catching interrupt exceptions				    {{{1
  "
  "	    When an interrupt occurs inside a :try/:endtry region, an
  "	    interrupt exception is thrown and can be caught.  Its value is
--- 5868,5874 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 61:  Catching interrupt exceptions				    {{{1
  "
  "	    When an interrupt occurs inside a :try/:endtry region, an
  "	    interrupt exception is thrown and can be caught.  Its value is
***************
*** 5857,5863 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 61:  Catching error exceptions					    {{{1
  "
  "	    An error inside a :try/:endtry region is converted to an exception
  "	    and can be caught.  The error exception has a "Vim(cmdname):" prefix
--- 6004,6010 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 62:  Catching error exceptions					    {{{1
  "
  "	    An error inside a :try/:endtry region is converted to an exception
  "	    and can be caught.  The error exception has a "Vim(cmdname):" prefix
***************
*** 6093,6099 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 62:  Suppressing error exceptions by :silent!.			    {{{1
  "
  "	    A :silent! command inside a :try/:endtry region suppresses the
  "	    conversion of errors to an exception and the immediate abortion on
--- 6240,6246 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 63:  Suppressing error exceptions by :silent!.			    {{{1
  "
  "	    A :silent! command inside a :try/:endtry region suppresses the
  "	    conversion of errors to an exception and the immediate abortion on
***************
*** 6211,6217 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 63:  Error exceptions after error, interrupt or :throw		    {{{1
  "
  "	    When an error occurs after an interrupt or a :throw but before
  "	    a matching :catch is reached, all following :catches of that try
--- 6358,6364 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 64:  Error exceptions after error, interrupt or :throw		    {{{1
  "
  "	    When an error occurs after an interrupt or a :throw but before
  "	    a matching :catch is reached, all following :catches of that try
***************
*** 6379,6385 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 64:  Errors in the /pattern/ argument of a :catch		    {{{1
  "
  "	    On an error in the /pattern/ argument of a :catch, the :catch does
  "	    not match.  Any following :catches of the same :try/:endtry don't
--- 6526,6532 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 65:  Errors in the /pattern/ argument of a :catch		    {{{1
  "
  "	    On an error in the /pattern/ argument of a :catch, the :catch does
  "	    not match.  Any following :catches of the same :try/:endtry don't
***************
*** 6474,6480 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 65:  Stop range :call on error, interrupt, or :throw		    {{{1
  "
  "	    When a function which is multiply called for a range since it
  "	    doesn't handle the range itself has an error in a command
--- 6621,6627 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 66:  Stop range :call on error, interrupt, or :throw		    {{{1
  "
  "	    When a function which is multiply called for a range since it
  "	    doesn't handle the range itself has an error in a command
***************
*** 6572,6578 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 66:  :throw accross :call command				    {{{1
  "
  "	    On a call command, an exception might be thrown when evaluating the
  "	    function name, during evaluation of the arguments, or when the
--- 6719,6725 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 67:  :throw accross :call command				    {{{1
  "
  "	    On a call command, an exception might be thrown when evaluating the
  "	    function name, during evaluation of the arguments, or when the
***************
*** 6690,6696 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 67:  :throw accross function calls in expressions		    {{{1
  "
  "	    On a function call within an expression, an exception might be
  "	    thrown when evaluating the function name, during evaluation of the
--- 6837,6843 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 68:  :throw accross function calls in expressions		    {{{1
  "
  "	    On a function call within an expression, an exception might be
  "	    thrown when evaluating the function name, during evaluation of the
***************
*** 6799,6805 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 68:  :throw accross :if, :elseif, :while				    {{{1
  "
  "	    On an :if, :elseif, or :while command, an exception might be thrown
  "	    during evaluation of the expression to test.  The exception can be
--- 6946,6952 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 69:  :throw accross :if, :elseif, :while				    {{{1
  "
  "	    On an :if, :elseif, or :while command, an exception might be thrown
  "	    during evaluation of the expression to test.  The exception can be
***************
*** 6880,6886 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 69:  :throw accross :return or :throw				    {{{1
  "
  "	    On a :return or :throw command, an exception might be thrown during
  "	    evaluation of the expression to return or throw, respectively.  The
--- 7027,7033 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 70:  :throw accross :return or :throw				    {{{1
  "
  "	    On a :return or :throw command, an exception might be thrown during
  "	    evaluation of the expression to return or throw, respectively.  The
***************
*** 6998,7004 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 70:  :throw accross :echo variants and :execute			    {{{1
  "
  "	    On an :echo, :echon, :echomsg, :echoerr, or :execute command, an
  "	    exception might be thrown during evaluation of the arguments to
--- 7145,7151 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 71:  :throw accross :echo variants and :execute			    {{{1
  "
  "	    On an :echo, :echon, :echomsg, :echoerr, or :execute command, an
  "	    exception might be thrown during evaluation of the arguments to
***************
*** 7105,7111 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 71:  :throw accross :let or :unlet				    {{{1
  "
  "	    On a :let command, an exception might be thrown during evaluation
  "	    of the expression to assign.  On an :let or :unlet command, the
--- 7252,7258 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 72:  :throw accross :let or :unlet				    {{{1
  "
  "	    On a :let command, an exception might be thrown during evaluation
  "	    of the expression to assign.  On an :let or :unlet command, the
***************
*** 7264,7270 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 72:  :throw accross :function, :delfunction			    {{{1
  "
  "	    The :function and :delfunction commands may cause an expression
  "	    specified in braces to be evaluated.  During evaluation, an
--- 7411,7417 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 73:  :throw accross :function, :delfunction			    {{{1
  "
  "	    The :function and :delfunction commands may cause an expression
  "	    specified in braces to be evaluated.  During evaluation, an
***************
*** 7368,7374 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 73:  :throw accross builtin functions and commands		    {{{1
  "
  "	    Some functions like exists(), searchpair() take expression
  "	    arguments, other functions or commands like substitute() or
--- 7515,7521 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 74:  :throw accross builtin functions and commands		    {{{1
  "
  "	    Some functions like exists(), searchpair() take expression
  "	    arguments, other functions or commands like substitute() or
***************
*** 7567,7573 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 74:  Errors in builtin functions.				    {{{1
  "
  "	    On an error in a builtin function called inside a :try/:endtry
  "	    region, the evaluation of the expression calling that function and
--- 7714,7720 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 75:  Errors in builtin functions.				    {{{1
  "
  "	    On an error in a builtin function called inside a :try/:endtry
  "	    region, the evaluation of the expression calling that function and
***************
*** 7748,7754 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 75:  Errors, interupts, :throw during expression evaluation	    {{{1
  "
  "	    When a function call made during expression evaluation is aborted
  "	    due to an error inside a :try/:endtry region or due to an interrupt
--- 7895,7901 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 76:  Errors, interupts, :throw during expression evaluation	    {{{1
  "
  "	    When a function call made during expression evaluation is aborted
  "	    due to an error inside a :try/:endtry region or due to an interrupt
***************
*** 7798,7811 ****
  
      let v:errmsg = ""
  
-     " Vim bug: functions cannot be defined inside while loops.  Use workaround:
-     function! WA_t5()
-     endfunction
-     " Vim bug: functions using {} names cannot be defined inside functions.  Use
-     " workaround:
-     let WA_t5 = MakeScript("WA_t5")
-     exec '!echo "function F{ERR(5) + CONT(5)}()" >>' . WA_t5
-     exec '!echo "endfunction" >> ' . WA_t5
      try
  	let t = 1
  	XloopINIT 1 2
--- 7945,7950 ----
***************
*** 7821,7829 ****
  		elseif t == 4
  		    unlet v{ERR(t) + CONT(t)}
  		elseif t == 5
! 		    "function F{ERR(t) + CONT(t)}()
! 		    "endfunction
! 		    exec "source" WA_t5
  		elseif t == 6
  		    function F{ERR(t) + CONT(t)}
  		elseif t == 7
--- 7960,7967 ----
  		elseif t == 4
  		    unlet v{ERR(t) + CONT(t)}
  		elseif t == 5
! 		    function F{ERR(t) + CONT(t)}()
! 		    endfunction
  		elseif t == 6
  		    function F{ERR(t) + CONT(t)}
  		elseif t == 7
***************
*** 7852,7865 ****
  	Xout v:exception "in" ExtraVimThrowpoint()
      endtry
  
-     " Vim bug: functions cannot be defined inside while loops.  Use workaround:
-     function! WA_t14()
-     endfunction
-     " Vim bug: functions using {} names cannot be defined inside functions.  Use
-     " workaround:
-     let WA_t14 = MakeScript("WA_t14")
-     exec '!echo "function F{INT(14) + CONT(14)}()" >>' . WA_t14
-     exec '!echo "endfunction" >> ' . WA_t14
      try
  	let t = 10
  	XloopINIT 1024 2
--- 7990,7995 ----
***************
*** 7875,7883 ****
  		elseif t == 13
  		    unlet v{INT(t) + CONT(t)}
  		elseif t == 14
! 		    "function F{INT(t) + CONT(t)}()
! 		    "endfunction
! 		    exec "source" WA_t14
  		elseif t == 15
  		    function F{INT(t) + CONT(t)}
  		elseif t == 16
--- 8005,8012 ----
  		elseif t == 13
  		    unlet v{INT(t) + CONT(t)}
  		elseif t == 14
! 		    function F{INT(t) + CONT(t)}()
! 		    endfunction
  		elseif t == 15
  		    function F{INT(t) + CONT(t)}
  		elseif t == 16
***************
*** 7903,7916 ****
  	Xout v:exception "in" ExtraVimThrowpoint()
      endtry
  
-     " Vim bug: functions cannot be defined inside while loops.  Use workaround:
-     function! WA_t23()
-     endfunction
-     " Vim bug: functions using {} names cannot be defined inside functions.  Use
-     " workaround:
-     let WA_t23 = MakeScript("WA_t23")
-     exec '!echo "function F{THR(23) + CONT(23)}()" >>' . WA_t23
-     exec '!echo "endfunction" >> ' . WA_t23
      try
  	let t = 19
  	XloopINIT 1048576 2
--- 8032,8037 ----
***************
*** 7926,7934 ****
  		elseif t == 22
  		    unlet v{THR(t) + CONT(t)}
  		elseif t == 23
! 		    "function F{THR(t) + CONT(t)}()
! 		    "endfunction
! 		    exec "source" WA_t23
  		elseif t == 24
  		    function F{THR(t) + CONT(t)}
  		elseif t == 25
--- 8047,8054 ----
  		elseif t == 22
  		    unlet v{THR(t) + CONT(t)}
  		elseif t == 23
! 		    function F{THR(t) + CONT(t)}()
! 		    endfunction
  		elseif t == 24
  		    function F{THR(t) + CONT(t)}
  		elseif t == 25
***************
*** 8034,8040 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 76:  Errors, interupts, :throw in name{brace-expression}		    {{{1
  "
  "	    When a function call made during evaluation of an expression in
  "	    braces as part of a function name after ":function" is aborted due
--- 8154,8160 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 77:  Errors, interupts, :throw in name{brace-expression}		    {{{1
  "
  "	    When a function call made during evaluation of an expression in
  "	    braces as part of a function name after ":function" is aborted due
***************
*** 8046,8053 ****
  "	    called and deleted.
  "-------------------------------------------------------------------------------
  
- " Get this right:
- 
  XpathINIT
  
  XloopINIT 1 4
--- 8166,8171 ----
***************
*** 8164,8170 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 77:  Messages on parsing errors in expression evaluation		    {{{1
  "
  "	    When an expression evaluation detects a parsing error, an error
  "	    message is given and converted to an exception, and the expression
--- 8282,8288 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 78:  Messages on parsing errors in expression evaluation		    {{{1
  "
  "	    When an expression evaluation detects a parsing error, an error
  "	    message is given and converted to an exception, and the expression
***************
*** 8207,8220 ****
      let v:errmsg = ""
      XloopINIT 1 2
  
-     " Vim bug: functions cannot be defined inside while loops.  Use workaround:
-     function! WA_t5()
-     endfunction
-     " Vim bug: functions using {} names cannot be defined inside functions.  Use
-     " workaround:
-     let WA_t5 = MakeScript("WA_t5")
-     exec '!echo "function F{novar + CONT(5)}()" >>' . WA_t5
-     exec '!echo "endfunction" >> ' . WA_t5
      try
  	let t = 1
  	while t <= 14
--- 8325,8330 ----
***************
*** 8231,8239 ****
  		elseif t == 4
  		    unlet v{novar + CONT(t)}
  		elseif t == 5
! 		    "function F{novar + CONT(t)}()
! 		    "endfunction
! 		    exec "source" WA_t5
  		elseif t == 6
  		    function F{novar + CONT(t)}
  		elseif t == 7
--- 8341,8348 ----
  		elseif t == 4
  		    unlet v{novar + CONT(t)}
  		elseif t == 5
! 		    function F{novar + CONT(t)}()
! 		    endfunction
  		elseif t == 6
  		    function F{novar + CONT(t)}
  		elseif t == 7
***************
*** 8353,8359 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 78:  Throwing one of several errors for the same command		    {{{1
  "
  "	    When several errors appear in a row (for instance during expression
  "	    evaluation), the first as the most specific one is used when
--- 8462,8468 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 79:  Throwing one of several errors for the same command		    {{{1
  "
  "	    When several errors appear in a row (for instance during expression
  "	    evaluation), the first as the most specific one is used when
***************
*** 8548,8554 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 79:  Syntax error in expression for illegal :elseif		    {{{1
  "
  "	    If there is a syntax error in the expression after an illegal
  "	    :elseif, an error message is given (or an error exception thrown)
--- 8657,8663 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 80:  Syntax error in expression for illegal :elseif		    {{{1
  "
  "	    If there is a syntax error in the expression after an illegal
  "	    :elseif, an error message is given (or an error exception thrown)
***************
*** 8733,8739 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 80:  Discarding exceptions after an error or interrupt		    {{{1
  "
  "	    When an exception is thrown from inside a :try conditional without
  "	    :catch and :finally clauses and an error or interrupt occurs before
--- 8842,8848 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 81:  Discarding exceptions after an error or interrupt		    {{{1
  "
  "	    When an exception is thrown from inside a :try conditional without
  "	    :catch and :finally clauses and an error or interrupt occurs before
***************
*** 8779,8785 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 81:  Ignoring :catch clauses after an error or interrupt		    {{{1
  "
  "	    When an exception is thrown and an error or interrupt occurs before
  "	    the matching :catch clause is reached, the exception is discarded
--- 8888,8894 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 82:  Ignoring :catch clauses after an error or interrupt		    {{{1
  "
  "	    When an exception is thrown and an error or interrupt occurs before
  "	    the matching :catch clause is reached, the exception is discarded
***************
*** 8887,8893 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 82:  Executing :finally clauses after an error or interrupt	    {{{1
  "
  "	    When an exception is thrown and an error or interrupt occurs before
  "	    the :finally of the innermost :try is reached, the exception is
--- 8996,9002 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 83:  Executing :finally clauses after an error or interrupt	    {{{1
  "
  "	    When an exception is thrown and an error or interrupt occurs before
  "	    the :finally of the innermost :try is reached, the exception is
***************
*** 8937,8943 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 83:  Exceptions in autocommand sequences.			    {{{1
  "
  "	    When an exception occurs in a sequence of autocommands for
  "	    a specific event, the rest of the sequence is not executed.  The
--- 9046,9052 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 84:  Exceptions in autocommand sequences.			    {{{1
  "
  "	    When an exception occurs in a sequence of autocommands for
  "	    a specific event, the rest of the sequence is not executed.  The
***************
*** 9112,9118 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 84:  Error exceptions in autocommands for I/O command events	    {{{1
  "
  "	    When an I/O command is inside :try/:endtry, autocommands to be
  "	    executed after it should be skipped on an error (exception) in the
--- 9221,9227 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 85:  Error exceptions in autocommands for I/O command events	    {{{1
  "
  "	    When an I/O command is inside :try/:endtry, autocommands to be
  "	    executed after it should be skipped on an error (exception) in the
***************
*** 9359,9365 ****
  
  
  "-------------------------------------------------------------------------------
! " Test 85:  $VIMNOERRTHROW and $VIMNOINTTHROW support			    {{{1
  "
  "	    It is possible to configure Vim for throwing exceptions on error
  "	    or interrupt, controlled by variables $VIMNOERRTHROW and
--- 9468,9474 ----
  
  
  "-------------------------------------------------------------------------------
! " Test 86:  $VIMNOERRTHROW and $VIMNOINTTHROW support			    {{{1
  "
  "	    It is possible to configure Vim for throwing exceptions on error
  "	    or interrupt, controlled by variables $VIMNOERRTHROW and
*** ../vim-6.2.237/src/version.c	Thu Feb  5 15:28:32 2004
--- src/version.c	Thu Feb  5 15:52:53 2004
***************
*** 639,640 ****
--- 639,642 ----
  {   /* Add new patch number below this line */
+ /**/
+     238,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
40. You tell the cab driver you live at
    http://123.elm.street/house/bluetrim.html
41. You actually try that 123.elm.street address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        Sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\              Project leader for A-A-P -- http://www.A-A-P.org        ///
 \\\  Help AIDS victims, buy here: http://ICCF-Holland.org/click1.html  ///
