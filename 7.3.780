diff -up vim73/runtime/doc/eval.txt.780 vim73/runtime/doc/eval.txt
--- vim73/runtime/doc/eval.txt.780	2013-01-28 13:41:04.000000000 +0100
+++ runtime/doc/eval.txt	2013-01-28 13:44:58.000000000 +0100
@@ -1705,7 +1705,7 @@ call( {func}, {arglist} [, {dict}])
 				any	call {func} with arguments {arglist}
 ceil( {expr})			Float	round {expr} up
 changenr()			Number	current change number
-char2nr( {expr})		Number	ASCII value of first char in {expr}
+char2nr( {expr}[, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
 cindent( {lnum})		Number	C indent for line {lnum}
 clearmatches()			none	clear all matches
 col( {expr})			Number	column nr of cursor or mark
@@ -1862,7 +1862,7 @@ mkdir( {name} [, {path} [, {prot}]])
 mode( [expr])			String	current editing mode
 mzeval( {expr})			any	evaluate |MzScheme| expression
 nextnonblank( {lnum})		Number	line nr of non-blank line >= {lnum}
-nr2char( {expr})		String	single char with ASCII value {expr}
+nr2char( {expr}[, {utf8}])	String	single char with ASCII/UTF8 value {expr}
 or( {expr}, {expr})		Number  bitwise OR
 pathshorten( {expr})		String	shorten directory names in a path
 pow( {x}, {y})			Float	{x} to the power of {y}
@@ -2282,13 +2282,17 @@ changenr()						*changenr()*
 		redo it is the number of the redone change.  After undo it is
 		one less than the number of the undone change.
 
-char2nr({expr})						*char2nr()*
+char2nr({expr}[, {utf8}])				**char2nr()*
 		Return number value of the first char in {expr}.  Examples: >
 			char2nr(" ")		returns 32
 			char2nr("ABC")		returns 65
-<		The current 'encoding' is used.  Example for "utf-8": >
+<		When {utf8} is omitted or zero, the current 'encoding' is
+used.
+		Example for "utf-8": >
 			char2nr("á")		returns 225
 			char2nr("á"[0])		returns 195
+		With {utf8} set to 1, always treat as utf-8 characters.
+		A combining character is a separate character.
 <		|nr2char()| does the opposite.
 
 cindent({lnum})						*cindent()*
diff -up vim73/src/eval.c.780 vim73/src/eval.c
--- vim73/src/eval.c.780	2013-01-28 13:41:04.000000000 +0100
+++ src/eval.c	2013-01-28 13:41:04.000000000 +0100
@@ -7854,7 +7854,7 @@ static struct fst
     {"ceil",		1, 1, f_ceil},
 #endif
     {"changenr",	0, 0, f_changenr},
-    {"char2nr",		1, 1, f_char2nr},
+    {"char2nr",		1, 2, f_char2nr},
     {"cindent",		1, 1, f_cindent},
     {"clearmatches",	0, 0, f_clearmatches},
     {"col",		1, 1, f_col},
@@ -8003,7 +8003,7 @@ static struct fst
     {"mzeval",		1, 1, f_mzeval},
 #endif
     {"nextnonblank",	1, 1, f_nextnonblank},
-    {"nr2char",		1, 1, f_nr2char},
+    {"nr2char",		1, 2, f_nr2char},
     {"or",		2, 2, f_or},
     {"pathshorten",	1, 1, f_pathshorten},
 #ifdef FEAT_FLOAT
@@ -9303,7 +9303,17 @@ f_char2nr(argvars, rettv)
 {
 #ifdef FEAT_MBYTE
     if (has_mbyte)
-	rettv->vval.v_number = (*mb_ptr2char)(get_tv_string(&argvars[0]));
+    {
+	int	utf8 = 0;
+
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	    utf8 = get_tv_number_chk(&argvars[1], NULL);
+
+	if (utf8)
+	    rettv->vval.v_number = (*utf_ptr2char)(get_tv_string(&argvars[0]));
+	else
+	    rettv->vval.v_number = (*mb_ptr2char)(get_tv_string(&argvars[0]));
+    }
     else
 #endif
     rettv->vval.v_number = get_tv_string(&argvars[0])[0];
@@ -14360,7 +14370,16 @@ f_nr2char(argvars, rettv)
 
 #ifdef FEAT_MBYTE
     if (has_mbyte)
-	buf[(*mb_char2bytes)((int)get_tv_number(&argvars[0]), buf)] = NUL;
+    {
+	int	utf8 = 0;
+
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	    utf8 = get_tv_number_chk(&argvars[1], NULL);
+	if (utf8)
+	    buf[(*utf_char2bytes)((int)get_tv_number(&argvars[0]), buf)] = NUL;
+	else
+	    buf[(*mb_char2bytes)((int)get_tv_number(&argvars[0]), buf)] = NUL;
+    }
     else
 #endif
     {
diff -up vim73/src/version.c.780 vim73/src/version.c
--- vim73/src/version.c.780	2013-01-28 13:41:04.000000000 +0100
+++ src/version.c	2013-01-28 13:41:04.000000000 +0100
@@ -726,6 +726,8 @@ static char *(features[]) =
 static int included_patches[] =
 {   /* Add new patch number below this line */
 /**/
+    780,
+/**/
     779,
 /**/
     778,
