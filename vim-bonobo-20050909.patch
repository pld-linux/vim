diff -Nur vim63/runtime/doc/gui.txt.orig vim63-bonobo/runtime/doc/gui.txt.orig
--- vim63/runtime/doc/gui.txt.orig	2004-06-07 11:05:18.000000000 +0200
+++ vim63-bonobo/runtime/doc/gui.txt.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,951 +0,0 @@
-*gui.txt*       For Vim version 6.3.  Last change: 2004 Jun 02
-
-
-		  VIM REFERENCE MANUAL    by Bram Moolenaar
-
-
-Vim's Graphical User Interface				*gui* *GUI*
-
-1. Starting the GUI		|gui-start|
-2. Scrollbars			|gui-scrollbars|
-3. Mouse Control		|gui-mouse|
-4. Making GUI Selections	|gui-selections|
-5. Menus			|menus|
-6. Extras			|gui-extras|
-7. Shell Commands		|gui-shell|
-
-Other GUI documentation:
-|gui_x11.txt|	For specific items of the X11 GUI.
-|gui_w32.txt|	For specific items of the Win32 GUI.
-
-{Vi does not have any of these commands}
-
-==============================================================================
-1. Starting the GUI				*gui-start* *E229* *E233*
-
-First you must make sure you actually have a version of Vim with the GUI code
-included.  You can check this with the ":version" command, it should include
-"+GUI_Athena", "+GUI_BeOS", "+GUI_GTK", "+GUI_Motif" or "MS-Windows ... bit
-GUI version".
-
-How to start the GUI depends on the system used.  Mostly you can run the
-GUI version of Vim with:
-    gvim [options] [files...]
-
-The X11 version of Vim can run both in GUI and in non-GUI mode.  See
-|gui-x11-start|.
-
-					*gui-init* *gvimrc* *.gvimrc* *_gvimrc*
-When the GUI starts up initializations are carried out, in this order:
-- The termcap options are reset to their default value for the GUI.
-- If the system menu file exists, it is sourced.  The name of this file is
-  normally "$VIMRUNTIME/menu.vim".  You can check this with ":version".  Also
-  see |$VIMRUNTIME|.  To skip loading the system menu include 'M' in
-  'guioptions'.				*buffers-menu* *no_buffers_menu*
-  The system menu file includes a "Buffers" menu.  If you don't want this, set
-  the "no_buffers_menu" variable in your .vimrc (not .gvimrc!): >
-	:let no_buffers_menu = 1
-< NOTE: Switching on syntax highlighting also loads the menu file, thus
-  disabling the Buffers menu must be done before ":syntax on".
-  The path names are truncated to 35 characters.  You can truncate them at a
-  different length, for example 50, like this: >
-	:let bmenu_max_pathlen = 50
-- If the "-U {gvimrc}" command-line option has been used when starting Vim,
-  the {gvimrc} file will be read for initializations.  The following
-  initializations are skipped.
-- For Unix and MS-Windows, if the system gvimrc exists, it is sourced.  The
-  name of this file is normally "$VIM/gvimrc".  You can check this with
-  ":version".  Also see |$VIM|.
-- The following are tried, and only the first one that exists is used:
-  - If the GVIMINIT environment variable exists and is not empty, it is
-    executed as an Ex command.
-  - If the user gvimrc file exists, it is sourced.  The name of this file is
-    normally "$HOME/.gvimrc".  You can check this with ":version".
-  - For Win32, when $HOME is not set, "$VIM\_gvimrc" is used.
-  - When a "_gvimrc" file is not found, ".gvimrc" is tried too.  And vice
-    versa.
-- If the 'exrc' option is set (which is NOT the default) the file ./.gvimrc
-  is sourced, if it exists and isn't the same file as the system or user
-  gvimrc file.  If this file is not owned by you, some security restrictions
-  apply.  When ".gvimrc" is not found, "_gvimrc" is tried too.  For Macintosh
-  and DOS/Win32 "_gvimrc" is tried first.
-
-NOTE: All but the first one are not carried out if Vim was started with
-"-u NONE" and no "-U" argument was given, or when started with "-U NONE".
-
-All this happens AFTER the normal Vim initializations, like reading your
-.vimrc file.  See |initialization|.
-But the GUI window is only opened after all the initializations have been
-carried out.  If you want some commands to be executed just after opening the
-GUI window, use the |GUIEnter| autocommand event.  Example: >
-	:autocommand GUIEnter * winpos 100 50
-
-You can use the gvimrc files to set up your own customized menus (see |:menu|)
-and initialize other things that you may want to set up differently from the
-terminal version.
-
-Recommended place for your personal GUI initializations:
-	Unix		    $HOME/.gvimrc
-	OS/2		    $HOME/.gvimrc or $VIM/.gvimrc
-	MS-DOS and Win32    $HOME/_gvimrc or $VIM/_gvimrc
-	Amiga		    s:.gvimrc or $VIM/.gvimrc
-
-There are a number of options which only have meaning in the GUI version of
-Vim.  These are 'guicursor', 'guifont', 'guipty' and 'guioptions'.  They are
-documented in |options.txt| with all the other options.
-
-If using the Motif or Athena version of the GUI (but not for the GTK+ or Win32
-version), a number of X resources are available.  See |gui-resources|.
-
-Another way to set the colors for different occasions is with highlight
-groups.  The "Normal" group is used to set the background and foreground
-colors.  Example (which looks nice): >
-
-	:highlight Normal guibg=grey90
-
-The "guibg" and "guifg" settings override the normal background and
-foreground settings.  The other settings for the Normal highlight group are
-not used.  Use the 'guifont' option to set the font.
-
-Also check out the 'guicursor' option, to set the colors for the cursor in
-various modes.
-
-Vim tries to make the window fit on the screen when it starts up.  This avoids
-that you can't see part of it.  On the X Window System this requires a bit of
-guesswork.  You can change the height that is used for the window title and a
-task bar with the 'guiheadroom' option.
-
-						*:winp* *:winpos* *E188*
-:winp[os]
-		Display current position of the top left corner of the GUI vim
-		window in pixels.  Does not work in all versions.
-
-:winp[os] {X} {Y}							*E466*
-		Put the GUI vim window at the given {X} and {Y} coordinates.
-		The coordinates should specify the position in pixels of the
-		top left corner of the window.  Does not work in all versions.
-		Does work in an (new) xterm |xterm-color|.
-		When the GUI window has not been opened yet, the values are
-		remembered until the window is opened.  The position is
-		adjusted to make the window fit on the screen (if possible).
-
-						    *:win* *:winsize* *E465*
-:win[size] {width} {height}
-		Set the window height to {width} by {height} characters.
-		Obsolete, use ":set lines=11 columns=22".
-		If you get less lines than expected, check the 'guiheadroom'
-		option.
-
-If you are running the X Window System, you can get information about the
-window Vim is running in with this command: >
-	:!xwininfo -id $WINDOWID
-
-==============================================================================
-2. Scrollbars						*gui-scrollbars*
-
-There are vertical scrollbars and a horizontal scrollbars.  You may
-configure which ones appear with the 'guioptions' option.
-
-The interface looks like this (with ":set guioptions=mlrb"):
-
-		       +------------------------------+
-		       | File  Edit		 Help | <- Menu bar (m)
-		       +-+--------------------------+-+
-		       |^|			    |^|
-		       |#| Text area.		    |#|
-		       | |			    | |
-		       |v|__________________________|v|
- Normal status line -> |-+ File.c	       5,2  +-|
- between Vim windows   |^|""""""""""""""""""""""""""|^|
-		       | |			    | |
-		       | | Another file buffer.     | |
-		       | |			    | |
-		       |#|			    |#|
- Left scrollbar (l) -> |#|			    |#| <- Right
-		       |#|			    |#|    scrollbar (r)
-		       | |			    | |
-		       |v|			    |v|
-		       +-+--------------------------+-+
-		       | |< ####		   >| | <- Bottom
-		       +-+--------------------------+-+    scrollbar (b)
-
-Any of the scrollbar or menu components may be turned off by not putting the
-appropriate letter in the 'guioptions' string.  The bottom scrollbar is
-only useful when 'nowrap' is set.
-
-
-VERTICAL SCROLLBARS					*gui-vert-scroll*
-
-Each Vim window has a scrollbar next to it which may be scrolled up and down
-to move through the text in that buffer.  The size of the scrollbar-thumb
-indicates the fraction of the buffer which can be seen in the window.
-When the scrollbar is dragged all the way down, the last line of the file
-will appear in the top of the window.
-
-If a window is shrunk to zero height (by the growth of another window) its
-scrollbar disappears. It reappears when the window is restored.
-
-If a window is vertically split, it will get a scrollbar when it is the
-current window and when, taking the middle of the current window and drawing a
-vertical line, this line goes through the window.
-When there are scrollbars on both sides, and the middle of the current window
-is on the left half, the right scrollbar column will contain scrollbars for
-the rightmost windows.  The same happens on the other side.
-
-
-HORIZONTAL SCROLLBARS					*gui-horiz-scroll*
-
-The horizontal scrollbar (at the bottom of the Vim GUI) may be used to
-scroll text sideways when the 'wrap' option is turned off.  The
-scrollbar-thumb size is such that the text of the longest visible line may be
-scrolled as far as possible left and right.  The cursor is moved when
-necessary, it must remain on a visible character (unless 'virtualedit' is
-set).
-
-Computing the length of the longest visible takes quite a bit of computation,
-and it has to be done every time something changes.  If this takes too much
-time or you don't like the cursor jumping to another line, include the 'h'
-flag in 'guioptions'.  Then the scrolling is limited by the text of the
-current cursor line.
-
-							*athena-intellimouse*
-If you have an Intellimouse and an X server that supports using the wheel,
-then you can use the wheel to scroll the text up and down in gvim.  This works
-with XFree86 4.0 and later, and with some older versions when you add patches.
-See |scroll-mouse-wheel|.
-
-For older versions of XFree86 you must patch your X server.  The following
-page has a bit of information about using the Intellimouse on Linux as well as
-links to the patches and X server binaries (may not have the one you need
-though):
-    http://www.inria.fr/koala/colas/mouse-wheel-scroll/
-
-==============================================================================
-3. Mouse Control					*gui-mouse*
-
-The mouse only works if the appropriate flag in the 'mouse' option is set.
-When the GUI is switched on, and 'mouse' wasn't set yet, the 'mouse' option is
-automatically set to "a", enabling it for all modes except for the
-|hit-enter| prompt.  If you don't want this, a good place to change the
-'mouse' option is the "gvimrc" file.
-
-Other options that are relevant:
-'mousefocus'	window focus follows mouse pointer |gui-mouse-focus|
-'mousemodel'	what mouse button does which action
-'mousehide'	hide mouse pointer while typing text
-'selectmode'	whether to start Select mode or Visual mode
-
-A quick way to set these is with the ":behave" command.
-							*:behave* *:be*
-:be[have] {model}	Set behavior for mouse and selection.  Valid
-			arguments are:
-			   mswin	MS-Windows behavior
-			   xterm	Xterm behavior
-
-			Using ":behave" changes these options:
-			option		mswin			xterm	~
-			'selectmode'	"mouse,key"		""
-			'mousemodel'	"popup"			"extend"
-			'keymodel'	"startsel,stopsel"	""
-			'selection'	"exclusive"		"inclusive"
-
-In the $VIMRUNTIME directory, there is a script called |mswin.vim|, which will
-also map a few keys to the MS-Windows cut/copy/paste commands.  This is NOT
-compatible, since it uses the CTRL-V, CTRL-X and CTRL-C keys.  If you don't
-mind, use this command: >
-	:so $VIMRUNTIME/mswin.vim
-
-For scrolling with a wheel on a mouse, see |scroll-mouse-wheel|.
-
-
-3.1 Moving Cursor with Mouse				*gui-mouse-move*
-
-Click the left mouse button somewhere in a text buffer where you want the
-cursor to go, and it does!
-This works in	    when 'mouse' contains ~
-Normal mode	    'n' or 'a'
-Visual mode	    'v' or 'a'
-Insert mode	    'i' or 'a'
-
-Select mode is handled like Visual mode.
-
-You may use this with an operator such as 'd' to delete text from the current
-cursor position to the position you point to with the mouse.  That is, you hit
-'d' and then click the mouse somewhere.
-
-							*gui-mouse-focus*
-The 'mousefocus' option can be set to make the keyboard focus follow the
-mouse pointer.  This means that the window where the mouse pointer is, is the
-active window.  Warning: this doesn't work very well when using a menu,
-because the menu command will always be applied to the top window.
-
-If you are on the ':' line (or '/' or '?'), then clicking the left or right
-mouse button will position the cursor on the ':' line (if 'mouse' contains
-'c', 'a' or 'A').
-
-In any situation the middle mouse button may be clicked to paste the current
-selection.
-
-
-3.2 Selection with Mouse				*gui-mouse-select*
-
-The mouse can be used to start a selection.  How depends on the 'mousemodel'
-option:
-'mousemodel' is "extend": use the right mouse button
-'mousemodel' is "popup":  use the left mouse button, while keeping the Shift
-key pressed.
-
-If there was no selection yet, this starts a selection from the old cursor
-position to the position pointed to with the mouse.  If there already is a
-selection then the closest end will be extended.
-
-If 'selectmode' contains "mouse", then the selection will be in Select mode.
-This means that typing normal text will replace the selection.  See
-|Select-mode|.  Otherwise, the selection will be in Visual mode.
-
-Double clicking may be done to make the selection word-wise, triple clicking
-makes it line-wise, and quadruple clicking makes it rectangular block-wise.
-
-See |gui-selections| on how the selection is used.
-
-
-3.3 Other Text Selection with Mouse		*gui-mouse-modeless*
-						*modeless-selection*
-A different kind of selection is used when:
-- in Command-line mode
-- in the Command-line window and pointing in another window
-- at the |hit-enter| prompt
-- whenever the current mode is not in the 'mouse' option
-- when holding the CTRL and SHIFT keys in the GUI
-Since Vim continues like the selection isn't there, and there is no mode
-associated with the selection, this is called modeless selection.  Any text in
-the Vim window can be selected.  Select the text by pressing the left mouse
-button at the start, drag to the end and release.  To extend the selection,
-use the right mouse button when 'mousemodel' is "extend", or the left mouse
-button with the shift key pressed when 'mousemodel' is "popup".
-The middle mouse button pastes the text.
-The selection is removed when the selected text is scrolled or changed.
-On the command line CTRL-Y can be used to copy the selection into the
-clipboard.  To do this from Insert mode, use CTRL-O : CTRL-Y <CR>.
-
-
-3.4 Using Mouse on Status Lines				*gui-mouse-status*
-
-Clicking the left or right mouse button on the status line below a Vim
-window makes that window the current window.  This actually happens on button
-release (to be able to distinguish a click from a drag action).
-
-With the left mouse button a status line can be dragged up and down, thus
-resizing the windows above and below it.  This does not change window focus.
-
-The same can be used on the vertical separator: click to give the window left
-of it focus, drag left and right to make windows wider and narrower.
-
-
-3.5 Various Mouse Clicks				*gui-mouse-various*
-
-    <S-LeftMouse>	Search forward for the word under the mouse click.
-			When 'mousemodel' is "popup" this starts or extends a
-			selection.
-    <S-RightMouse>	Search backward for the word under the mouse click.
-    <C-LeftMouse>	Jump to the tag name under the mouse click.
-    <C-RightMouse>	Jump back to position before the previous tag jump
-			(same as "CTRL-T")
-
-
-3.6 Mouse Mappings					*gui-mouse-mapping*
-
-The mouse events, complete with modifiers, may be mapped.  Eg: >
-   :map <S-LeftMouse>     <RightMouse>
-   :map <S-LeftDrag>      <RightDrag>
-   :map <S-LeftRelease>   <RightRelease>
-   :map <2-S-LeftMouse>   <2-RightMouse>
-   :map <2-S-LeftDrag>    <2-RightDrag>
-   :map <2-S-LeftRelease> <2-RightRelease>
-   :map <3-S-LeftMouse>   <3-RightMouse>
-   :map <3-S-LeftDrag>    <3-RightDrag>
-   :map <3-S-LeftRelease> <3-RightRelease>
-   :map <4-S-LeftMouse>   <4-RightMouse>
-   :map <4-S-LeftDrag>    <4-RightDrag>
-   :map <4-S-LeftRelease> <4-RightRelease>
-These mappings make selection work the way it probably should in a Motif
-application, with shift-left mouse allowing for extending the visual area
-rather than the right mouse button.
-
-Mouse mapping with modifiers does not work for modeless selection.
-
-
-3.7 Drag and drop						*drag-n-drop*
-
-You can drag and drop one or more files into the Vim window, where they will
-be opened as if a |:drop| command was used.
-
-If you hold down Shift while doing this, Vim changes to the first dropped
-file's directory.  If you hold Ctrl Vim will always split a new window for the
-file.  Otherwise it's only done if the current buffer has been changed.
-
-You can also drop a directory on Vim.  This starts the explorer plugin for
-that directory (assuming it was enabled, otherwise you'll get an error
-message).  Keep Shift pressed to change to the directory instead.
-
-If Vim happens to be editing a command line, the names of the dropped files
-and directories will be inserted at the cursor.  This allows you to use these
-names with any Ex command.  Special characters (space, tab, double quote and
-'|'; backslash on non-MS-Windows systems) will be escaped.
-
-==============================================================================
-4. Making GUI Selections				*gui-selections*
-
-							*quotestar*
-You may make selections with the mouse (see |gui-mouse-select|), or by using
-Vim's Visual mode (see |v|).  If 'a' is present in 'guioptions', then
-whenever a selection is started (Visual or Select mode), or when the selection
-is changed, Vim becomes the owner of the windowing system's primary selection
-(on MS-Windows the |gui-clipboard| is used; under X11, the |x11-selection| is
-used - you should read whichever of these is appropriate now).
-
-							*clipboard*
-There is a special register for storing this selection, it is the "*
-register.  Nothing is put in here unless the information about what text is
-selected is about to change (eg with a left mouse click somewhere), or when
-another application wants to paste the selected text.  Then the text is put
-in the "* register.  For example, to cut a line and make it the current
-selection/put it on the clipboard: >
-
-	"*dd
-
-Similarly, when you want to paste a selection from another application, e.g.,
-by clicking the middle mouse button, the selection is put in the "* register
-first, and then 'put' like any other register.  For example, to put the
-selection (contents of the clipboard): >
-
-	"*p
-
-When using this register under X11, also see |x11-selection|.  This also
-explains the related "+ register.
-
-Note that when pasting text from one Vim into another separate Vim, the type
-of selection (character, line, or block) will also be copied.  For other
-applications the type is always character.  However, if the text gets
-transferred via the |x11-cut-buffer|, the selection type is ALWAYS lost.
-
-When the "unnamed" string is included in the 'clipboard' option, the unnamed
-register is the same as the "* register.  Thus you can yank to and paste the
-selection without prepending "* to commands.
-
-==============================================================================
-5. Menus						*menus*
-
-For an introduction see |usr_42.txt| in the user manual.
-
-
-5.1 Using Menus						*using-menus*
-
-Basically, menus can be used just like mappings.  You can define your own
-menus, as many as you like.
-Long-time Vim users won't use menus much.  But the power is in adding your own
-menus and menu items.  They are most useful for things that you can't remember
-what the key sequence was.
-
-For creating menus in a different language, see |:menutrans|.
-
-							*menu.vim*
-The default menus are read from the file "$VIMRUNTIME/menu.vim".  See
-|$VIMRUNTIME| for where the path comes from.  You can set up your own menus.
-Starting off with the default set is a good idea.  You can add more items, or,
-if you don't like the defaults at all, start with removing all menus
-|:unmenu-all|.  You can also avoid the default menus being loaded by adding
-this line to your .vimrc file (NOT your .gvimrc file!): >
-	:let did_install_default_menus = 1
-If you also want to avoid the Syntax menu: >
-	:let did_install_syntax_menu = 1
-If you do want the Syntax menu but not all the entries for each available
-syntax file (which take quite a bit of time to load): >
-	:let skip_syntax_sel_menu = 1
-<
-							*console-menus*
-Although this documentation is in the GUI section, you can actually use menus
-in console mode too.  You will have to load |menu.vim| explicitly then, it is
-not done by default.  You can use the |:emenu| command and command-line
-completion with 'wildmenu' to access the menu entries almost like a real menu
-system.  To do this, put these commands in your .vimrc file: >
-	:source $VIMRUNTIME/menu.vim
-	:set wildmenu
-	:set cpo-=<
-	:set wcm=<C-Z>
-	:map <F4> :emenu <C-Z>
-Pressing <F4> will start the menu.  You can now use the cursor keys to select
-a menu entry.  Hit <Enter> to execute it.  Hit <Esc> if you want to cancel.
-This does require the |+menu| feature enabled at compile time.
-
-							*tear-off-menus*
-GTK+ and Motif support Tear-off menus.  These are sort of sticky menus or
-pop-up menus that are present all the time.  If the resizing does not work
-correctly, this may be caused by using something like "Vim*geometry" in the
-defaults.  Use "Vim.geometry" instead.
-
-The Win32 GUI version emulates Motif's tear-off menus.  Actually, a Motif user
-will spot the differences easily, but hopefully they're just as useful.  You
-can also use the |:tearoff| command together with |hidden-menus| to create
-floating menus that do not appear on the main menu bar.
-
-
-5.2 Creating New Menus					*creating-menus*
-
-				*:me*  *:menu*  *:noreme*  *:noremenu*
-				*:am*  *:amenu* *:an*      *:anoremenu*
-				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
-				*:ome* *:omenu* *:onoreme* *:onoremenu*
-				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
-				*:ime* *:imenu* *:inoreme* *:inoremenu*
-				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
-				*E330* *E327* *E331* *E336* *E333*
-				*E328* *E329* *E337*
-To create a new menu item, use the ":menu" commands.  They are mostly like
-the ":map" set of commands but the first argument is a menu item name, given
-as a path of menus and submenus with a '.' between them. eg: >
-
-   :menu File.Save  :w<CR>
-   :inoremenu File.Save  <C-O>:w<CR>
-   :menu Edit.Big\ Changes.Delete\ All\ Spaces  :%s/[ ^I]//g<CR>
-
-This last one will create a new item in the menu bar called "Edit", holding
-the mouse button down on this will pop up a menu containing the item
-"Big Changes", which is a sub-menu containing the item "Delete All Spaces",
-which when selected, performs the operation.
-
-Special characters in a menu name:
-
-	&	The next character is the shortcut key.  Make sure each
-		shortcut key is only used once in a (sub)menu.  If you want to
-		insert a literal "&" in the menu name use "&&".
-	<Tab>	Separates the menu name from right-aligned text.  This can be
-		used to show the equivalent typed command.  The text "<Tab>"
-		can be used here for convenience.  If you are using a real
-		Tab, don't forget to put a backslash before it!
-Example: >
-
-   :amenu &File.&Open<Tab>:e  :browse e<CR>
-
-[typed literally]
-With the shortcut "F" (while keeping the <Alt> key pressed), and then "O",
-this menu can be used.  The second part is shown as "Open     :e".  The ":e"
-is right aligned, and the "O" is underlined, to indicate it is the shortcut.
-
-The ":amenu" command can be used to define menu entries for all modes at once.
-To make the command work correctly, a character is automatically inserted for
-some modes:
-	mode		inserted	appended	~
-	Normal		nothing		nothing
-	Visual		<C-C>		<C-\><C-G>
-	Insert		<C-O>
-	Cmdline		<C-C>		<C-\><C-G>
-	Op-pending	<C-C>		<C-\><C-G>
-
-Appending CTRL-\ CTRL-G is for going back to insert mode when 'insertmode' is
-set. |CTRL-\_CTRL-G|
-
-Example: >
-
-   :amenu File.Next	:next^M
-
-is equal to: >
-
-   :nmenu File.Next	:next^M
-   :vmenu File.Next	^C:next^M^\^G
-   :imenu File.Next	^O:next^M
-   :cmenu File.Next	^C:next^M^\^G
-   :omenu File.Next	^C:next^M^\^G
-
-Careful: In Insert mode this only works for a SINGLE Normal mode command,
-because of the CTRL-O.  If you have two or more commands, you will need to use
-the ":imenu" command.  For inserting text in any mode, you can use the
-expression register: >
-
-   :amenu Insert.foobar   "='foobar'<CR>P
-
-Note that the '<' and 'k' flags in 'cpoptions' also apply here (when
-included they make the <> form and raw key codes not being recognized).
-
-Note that <Esc> in Cmdline mode executes the command, like in a mapping.  This
-is Vi compatible.  Use CTRL-C to quit Cmdline mode.
-
-						*:menu-<silent>* *:menu-silent*
-To define a menu which will not be echoed on the command line, add
-"<silent>" as the first argument.  Example: >
-	:menu <silent> Settings.Ignore\ case  :set ic<CR>
-The ":set ic" will not be echoed when using this menu.  Messages from the
-executed command are still given though.  To shut them up too, add a ":silent"
-in the executed command: >
-	:menu <silent> Search.Header :exe ":silent normal /Header\r"<CR>
-<
-						*:menu-<script>* *:menu-script*
-The "to" part of the menu will be inspected for mappings.  If you don't want
-this, use the ":noremenu" command (or the similar one for a specific mode).
-If you do want to use script-local mappings, add "<script>" as the very first
-argument to the ":menu" command or after "<silent>".
-
-							*menu-priority*
-You can give a priority to a menu.  Menus with a higher priority go more to
-the right.  The priority is given as a number before the ":menu" command.
-Example: >
-	:80menu Buffer.next :bn<CR>
-
-The default menus have these priorities:
-	File		10
-	Edit		20
-	Tools		40
-	Syntax		50
-	Buffers		60
-	Window		70
-	Help		9999
-
-When no or zero priority is given, 500 is used.
-The priority for the PopUp menu is not used.
-
-The Help menu will be placed on the far right side of the menu bar on systems
-which support this (Motif and GTK+).  For GTK+ 2, this is not done anymore
-because right-aligning the Help menu is now discouraged UI design.
-
-You can use a priority higher than 9999, to make it go after the Help menu,
-but that is non-standard and is discouraged.  The highest possible priority is
-about 32000.  The lowest is 1.
-
-							*sub-menu-priority*
-The same mechanism can be used to position a sub-menu.  The priority is then
-given as a dot-separated list of priorities, before the menu name: >
-	:menu 80.500 Buffer.next :bn<CR>
-Giving the sub-menu priority is only needed when the item is not to be put
-in a normal position.  For example, to put a sub-menu before the other items: >
-	:menu 80.100 Buffer.first :brew<CR>
-Or to put a sub-menu after the other items, and further items with default
-priority will be put before it: >
-	:menu 80.900 Buffer.last :blast<CR>
-When a number is missing, the default value 500 will be used: >
-	:menu .900 myMenu.test :echo "text"<CR>
-The menu priority is only used when creating a new menu.  When it already
-existed, e.g., in another mode, the priority will not change.  Thus, the
-priority only needs to be given the first time a menu is used.
-An exception is the PopUp menu.  There is a separate menu for each mode
-(Normal, Op-pending, Visual, Insert, Cmdline).  The order in each of these
-menus can be different.  This is different from menu-bar menus, which have
-the same order for all modes.
-NOTE: sub-menu priorities currently don't work for all versions of the GUI.
-
-							*menu-separator* *E332*
-Menu items can be separated by a special item that inserts some space between
-items.  Depending on the system this is displayed as a line or a dotted line.
-These items must start with a '-' and end in a '-'.  The part in between is
-used to give it a unique name.  Priorities can be used as with normal items.
-Example: >
-	:menu Example.item1	:do something
-	:menu Example.-Sep-	:
-	:menu Example.item2	:do something different
-Note that the separator also requires a rhs.  It doesn't matter what it is,
-because the item will never be selected.  Use a single colon to keep it
-simple.
-
-							*gui-toolbar*
-The toolbar is currently available in the Win32, Athena, Motif, GTK+ (X11) and
-Photon GUI.  It should turn up in other GUIs in due course.  The default
-toolbar is setup in menu.vim.
-The display of the toolbar is controlled by the 'guioptions' letter 'T'. You
-can thus have menu & toolbar together, or either on its own, or neither.
-The appearance is controlled by the 'toolbar' option.  You can chose between
-an image, text or both.
-
-							*toolbar-icon*
-The toolbar is defined as a special menu called ToolBar, which only has one
-level.  Vim interprets the items in this menu as follows:
-1)  If an "icon=" argument was specified, the file with this name is used.
-    The file can either be specified with the full path or with the base name.
-    In the last case it is searched for in the "bitmaps" directory in
-    'runtimepath', like in point 3).  Examples: >
-	:amenu icon=/usr/local/pixmaps/foo_icon.xpm ToolBar.Foo :echo "Foo"<CR>
-	:amenu icon=FooIcon ToolBar.Foo :echo "Foo"<CR>
-<   Note that in the first case the extension is included, while in the second
-    case it is omitted.
-    If the file cannot be opened the next points are tried.
-    A space in the file name must be escaped with a backslash.
-    A menu priority must come _after_ the icon argument: >
-	:amenu icon=foo 1.42 ToolBar.Foo :echo "42!"<CR>
-2)  An item called 'BuiltIn##', where ## is a number, is taken as number ## of
-    the built-in bitmaps available in Vim. Currently there are 31 numbered
-    from 0 to 30 which cover most common editing operations |builtin-tools|. >
-	:amenu ToolBar.BuiltIn22 :call SearchNext("back")<CR>
-3)  An item with another name is first searched for in the directory
-    "bitmaps" in 'runtimepath'.  If found, the bitmap file is used as the
-    toolbar button image.  Note that the exact filename is OS-specific: For
-    example, under Win32 the command >
-	:amenu ToolBar.Hello :echo "hello"<CR>
-<   would find the file 'hello.bmp'.  Under GTK+/X11 it is 'Hello.xpm'.  With
-    GTK+ 2 the files 'Hello.png', 'Hello.xpm' and 'Hello.bmp' are checked for
-    existence, and the first one found would be used.
-    For MS-Windows and GTK+ 2 the bitmap is scaled to fit the button.  For
-    MS-Windows a size of 18 by 18 pixels works best.
-    For MS-Windows the bitmap should have 16 colors with the standard palette.
-    The light grey pixels will be changed to the Window frame color and the
-    dark grey pixels to the window shadow color.  More colors might also work,
-    depending on your system.
-4)  If the bitmap is still not found, Vim checks for a match against its list
-    of built-in names.  Each built-in button image has a name.
-    So the command >
-	:amenu ToolBar.Open :e
-<   will show the built-in "open a file" button image if no open.bmp exists.
-    All the built-in names can be seen used in menu.vim.
-5)  If all else fails, a blank, but functioning, button is displayed.
-
-							*builtin-tools*
-nr  Name		Normal action  ~
-00  New			open new window
-01  Open		browse for file to open in current window
-02  Save		write buffer to file
-03  Undo		undo last change
-04  Redo		redo last undone change
-05  Cut			delete selected text to clipboard
-06  Copy		copy selected text to clipboard
-07  Paste		paste text from clipboard
-08  Print		print current buffer
-09  Help		open a buffer on Vim's builtin help
-10  Find		start a search command
-11  SaveAll		write all modified buffers to file
-12  SaveSesn		write session file for current situation
-13  NewSesn		write new session file
-14  LoadSesn		load session file
-15  RunScript		browse for file to run as a Vim script
-16  Replace		prompt for substitute command
-17  WinClose		close current window
-18  WinMax		make current window use many lines
-19  WinMin		make current window use few lines
-20  WinSplit		split current window
-21  Shell		start a shell
-22  FindPrev		search again, backward
-23  FindNext		search again, forward
-24  FindHelp		prompt for word to search help for
-25  Make		run make and jump to first error
-26  TagJump		jump to tag under the cursor
-27  RunCtags		build tags for files in current directory
-28  WinVSplit		split current window vertically
-29  WinMaxWidth		make current window use many columns
-30  WinMinWidth		make current window use few columns
-
-					*hidden-menus* *win32-hidden-menus*
-In the Win32 and GTK+ GUI, starting a menu name with ']' excludes that menu
-from the main menu bar.  You must then use the |:popup| or |:tearoff| command
-to display it.
-
-							*popup-menu*
-In the Win32, GTK+, Motif, Athena and Photon GUI, you can define the special
-menu "PopUp".  This is the menu that is displayed when the right mouse button
-is pressed, if 'mousemodel' is set to popup or popup_setpos.
-
-
-5.3 Showing What Menus Are Mapped To			*showing-menus*
-
-To see what an existing menu is mapped to, use just one argument after the
-menu commands (just like you would with the ":map" commands).  If the menu
-specified is a submenu, then all menus under that hierarchy will be shown.
-If no argument is given after :menu at all, then ALL menu items are shown
-for the appropriate mode (eg, Command-line mode for :cmenu).
-
-Special characters in the list, just before the rhs:
-*	The menu was defined with "nore" to disallow remapping.
-&	The menu was defined with "<script>" to allow remapping script-local
-	mappings only.
--	The menu was disabled.
-
-Note that hitting <Tab> while entering a menu name after a menu command may
-be used to complete the name of the menu item.
-
-
-5.4 Executing Menus					*execute-menus*
-
-						*:em*  *:emenu* *E334* *E335*
-:[range]em[enu] {menu}		Execute {menu} from the command line.
-				The default is to execute the Normal mode
-				menu.  If a range is specified, it executes
-				the Visual mode menu.
-				If used from <c-o>, it executes the
-				insert-mode menu Eg: >
-	:emenu File.Exit
-
-If the console-mode vim has been compiled with WANT_MENU defined, you can
-use :emenu to access useful menu items you may have got used to from GUI
-mode.  See 'wildmenu' for an option that works well with this.  See
-|console-menus| for an example.
-
-When using a range, if the lines match with '<,'>, then the menu is executed
-using the last visual selection.
-
-
-5.5 Deleting Menus					*delete-menus*
-
-						*:unme*  *:unmenu*
-						*:aun*   *:aunmenu*
-						*:nunme* *:nunmenu*
-						*:ounme* *:ounmenu*
-						*:vunme* *:vunmenu*
-						*:iunme* *:iunmenu*
-						*:cunme* *:cunmenu*
-To delete a menu item or a whole submenu, use the unmenu commands, which are
-analogous to the unmap commands.  Eg: >
-    :unmenu! Edit.Paste
-
-This will remove the Paste item from the Edit menu for Insert and
-Command-line modes.
-
-Note that hitting <Tab> while entering a menu name after an umenu command
-may be used to complete the name of the menu item for the appropriate mode.
-
-To remove all menus use:			*:unmenu-all*  >
-	:unmenu *	" remove all menus in Normal and visual mode
-	:unmenu! *	" remove all menus in Insert and Command-line mode
-	:aunmenu *	" remove all menus in all modes
-
-If you want to get rid of the menu bar: >
-	:set guioptions-=m
-
-
-5.6 Disabling Menus					*disable-menus*
-
-						*:menu-disable* *:menu-enable*
-If you do not want to remove a menu, but disable it for a moment, this can be
-done by adding the "enable" or "disable" keyword to a ":menu" command.
-Examples: >
-	:menu disable &File.&Open\.\.\.
-	:amenu enable *
-	:amenu disable &Tools.*
-
-The command applies to the modes as used with all menu commands.  Note that
-characters like "&" need to be included for translated names to be found.
-When the argument is "*", all menus are affected.  Otherwise the given menu
-name and all existing submenus below it are affected.
-
-
-5.7 Examples for Menus					*menu-examples*
-
-Here is an example on how to add menu items with menu's!  You can add a menu
-item for the keyword under the cursor.  The register "z" is used. >
-
-  :nmenu Words.Add\ Var		wb"zye:menu! Words.<C-R>z <C-R>z<CR>
-  :nmenu Words.Remove\ Var	wb"zye:unmenu! Words.<C-R>z<CR>
-  :vmenu Words.Add\ Var		"zy:menu! Words.<C-R>z <C-R>z <CR>
-  :vmenu Words.Remove\ Var	"zy:unmenu! Words.<C-R>z<CR>
-  :imenu Words.Add\ Var		<Esc>wb"zye:menu! Words.<C-R>z <C-R>z<CR>a
-  :imenu Words.Remove\ Var	<Esc>wb"zye:unmenu! Words.<C-R>z<CR>a
-
-(the rhs is in <> notation, you can copy/paste this text to try out the
-mappings, or put these lines in your gvimrc; "<C-R>" is CTRL-R, "<CR>" is
-the <CR> key.  |<>|)
-
-
-5.8 Tooltips & Menu tips
-
-See section |42.4| in the user manual.
-
-							*:tmenu* *:tm*
-:tm[enu] {menupath} {rhs}	Define a tip for a menu or tool.  {only in
-				X11 and Win32 GUI}
-
-:tm[enu] [menupath]		List menu tips. {only in X11 and Win32 GUI}
-
-							*:tunmenu* *:tu*
-:tu[nmenu] {menupath}		Remove a tip for a menu or tool.
-				{only in X11 and Win32 GUI}
-
-When a tip is defined for a menu item, it appears in the command-line area
-when the mouse is over that item, much like a standard Windows menu hint in
-the status bar. (Except when Vim is in Command-line mode, when of course
-nothing is displayed.)
-When a tip is defined for a ToolBar item, it appears as a tooltip when the
-mouse pauses over that button, in the usual fashion.  Use the |hl-Tooltip|
-highlight group to change its colors.
-
-A "tip" can be defined for each menu item.  For example, when defining a menu
-item like this: >
-	:amenu MyMenu.Hello :echo "Hello"<CR>
-The tip is defined like this: >
-	:tmenu MyMenu.Hello Displays a greeting.
-And delete it with: >
-	:tunmenu MyMenu.Hello
-
-Tooltips are currently only supported for the X11 and Win32 GUI. However, they
-should appear for the other gui platforms in the not too distant future.
-
-The ":tmenu" command works just like other menu commands, it uses the same
-arguments.  ":tunmenu" deletes an existing menu tip, in the same way as the
-other unmenu commands.
-
-If a menu item becomes invalid (i.e. its actions in all modes are deleted) Vim
-deletes the menu tip (and the item) for you.  This means that :aunmenu deletes
-a menu item - you don't need to do a :tunmenu as well.
-
-
-5.9 Popup Menus
-
-In the Win32 and GTK+ GUI, you can cause a menu to popup at the cursor.
-This behaves similarly to the PopUp menus except that any menu tree can
-be popped up.
-
-This command is for backwards compatibility, using it is discouraged, because
-it behaves in a strange way.
-
-							*:popup* *:popu*
-:popu[p] {name}			Popup the menu {name}.  The menu named must
-				have at least one subentry, but need not
-				appear on the menu-bar (see |hidden-menus|).
-				{only available for Win32 and GTK GUI}
-
-Example: >
-	:popup File
-will make the "File" menu (if there is one) appear at the text cursor. >
-
-	:amenu ]Toolbar.Make	:make<CR>
-	:popup ]Toolbar
-This creates a popup menu that doesn't exist on the main menu-bar.
-
-Note that a menu that starts with ']' will not be displayed.
-
-==============================================================================
-6. Extras						*gui-extras*
-
-This section describes other features which are related to the GUI.
-
-- With the GUI, there is no wait for one second after hitting escape, because
-  the key codes don't start with <Esc>.
-
-- Typing ^V followed by a special key in the GUI will insert "<Key>", since
-  the internal string used is meaningless.  Modifiers may also be held down to
-  get "<Modifiers-Key>".
-
-- In the GUI, the modifiers SHIFT, CTRL, and ALT (or META) may be used within
-  mappings of special keys and mouse events.  eg: :map <M-LeftDrag> <LeftDrag>
-
-- In the GUI, several normal keys may have modifiers in mappings etc, these
-  are <Space>, <Tab>, <NL>, <CR>, <Esc>.
-
-- To check in a Vim script if the GUI is being used, you can use something
-  like this: >
-
-	if has("gui_running")
-	   echo "yes, we have a GUI"
-	else
-	   echo "Boring old console"
-	endif
-
-==============================================================================
-7. Shell Commands					*gui-shell*
-
-For the X11 GUI the external commands are executed inside the gvim window.
-See |gui-pty|.
-
-WARNING: Executing an external command from the X11 GUI will not always
-work.  "normal" commands like "ls", "grep" and "make" mostly work fine.
-Commands that require an intelligent terminal like "less" and "ispell" won't
-work.  Some may even hang and need to be killed from another terminal.  So be
-careful!
-
-For the Win32 GUI the external commands are executed in a separate window.
-See |gui-shell-win32|.
-
- vim:tw=78:sw=4:ts=8:ft=help:norl:
diff -Nur vim63/runtime/menu.vim.orig vim63-bonobo/runtime/menu.vim.orig
--- vim63/runtime/menu.vim.orig	2004-05-26 17:11:21.000000000 +0200
+++ vim63-bonobo/runtime/menu.vim.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,974 +0,0 @@
-" Vim support file to define the default menus
-" You can also use this as a start for your own set of menus.
-"
-" Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2004 May 26
-
-" Note that ":an" (short for ":anoremenu") is often used to make a menu work
-" in all modes and avoid side effects from mappings defined by the user.
-
-" Make sure the '<' and 'C' flags are not included in 'cpoptions', otherwise
-" <CR> would not be recognized.  See ":help 'cpoptions'".
-let s:cpo_save = &cpo
-set cpo&vim
-
-" Avoid installing the menus twice
-if !exists("did_install_default_menus")
-let did_install_default_menus = 1
-
-
-if exists("v:lang") || &langmenu != ""
-  " Try to find a menu translation file for the current language.
-  if &langmenu != ""
-    if &langmenu =~ "none"
-      let s:lang = ""
-    else
-      let s:lang = &langmenu
-    endif
-  else
-    let s:lang = v:lang
-  endif
-  " A language name must be at least two characters, don't accept "C"
-  if strlen(s:lang) > 1
-    " When the language does not include the charset add 'encoding'
-    if s:lang =~ '^\a\a$\|^\a\a_\a\a$'
-      let s:lang = s:lang . '.' . &enc
-    endif
-
-    " We always use a lowercase name.
-    " Change "iso-8859" to "iso_8859" and "iso8859" to "iso_8859", some
-    " systems appear to use this.
-    " Change spaces to underscores.
-    let s:lang = substitute(tolower(s:lang), '\.iso-', ".iso_", "")
-    let s:lang = substitute(s:lang, '\.iso8859', ".iso_8859", "")
-    let s:lang = substitute(s:lang, " ", "_", "g")
-    " Remove "@euro", otherwise "LC_ALL=de_DE@euro gvim" will show English menus
-    let s:lang = substitute(s:lang, "@euro", "", "")
-    " Change "iso_8859-1" and "iso_8859-15" to "latin1", we always use the
-    " same menu file for them.
-    let s:lang = substitute(s:lang, 'iso_8859-15\=$', "latin1", "")
-    menutrans clear
-    exe "runtime! lang/menu_" . s:lang . ".vim"
-
-    if !exists("did_menu_trans")
-      " There is no exact match, try matching with a wildcard added
-      " (e.g. find menu_de_de.iso_8859-1.vim if s:lang == de_DE).
-      let s:lang = substitute(s:lang, '\.[^.]*', "", "")
-      exe "runtime! lang/menu_" . s:lang . "*.vim"
-
-      if !exists("did_menu_trans") && strlen($LANG) > 1
-	" On windows locale names are complicated, try using $LANG, it might
-	" have been set by set_init_1().
-	exe "runtime! lang/menu_" . tolower($LANG) . "*.vim"
-      endif
-    endif
-  endif
-endif
-
-
-" Help menu
-an 9999.10 &Help.&Overview<Tab><F1>	:help<CR>
-an 9999.20 &Help.&User\ Manual		:help usr_toc<CR>
-an 9999.30 &Help.&How-to\ links		:help how-to<CR>
-an <silent> 9999.40 &Help.&Find\.\.\.	:call <SID>Helpfind()<CR>
-an 9999.45 &Help.-sep1-			<Nop>
-an 9999.50 &Help.&Credits		:help credits<CR>
-an 9999.60 &Help.Co&pying		:help copying<CR>
-an 9999.70 &Help.&Sponsor/Register	:help sponsor<CR>
-an 9999.70 &Help.O&rphans		:help kcc<CR>
-an 9999.75 &Help.-sep2-			<Nop>
-an 9999.80 &Help.&Version		:version<CR>
-an 9999.90 &Help.&About			:intro<CR>
-
-fun! s:Helpfind()
-  if !exists("g:menutrans_help_dialog")
-    let g:menutrans_help_dialog = "Enter a command or word to find help on:\n\nPrepend i_ for Input mode commands (e.g.: i_CTRL-X)\nPrepend c_ for command-line editing commands (e.g.: c_<Del>)\nPrepend ' for an option name (e.g.: 'shiftwidth')"
-  endif
-  let h = inputdialog(g:menutrans_help_dialog)
-  if h != ""
-    let v:errmsg = ""
-    silent! exe "help " . h
-    if v:errmsg != ""
-      echo v:errmsg
-    endif
-  endif
-endfun
-
-" File menu
-an 10.310 &File.&Open\.\.\.<Tab>:e		:browse confirm e<CR>
-an 10.320 &File.Sp&lit-Open\.\.\.<Tab>:sp	:browse sp<CR>
-an 10.325 &File.&New<Tab>:enew			:confirm enew<CR>
-an <silent> 10.330 &File.&Close<Tab>:close
-	\ :if winheight(2) < 0 <Bar>
-	\   confirm enew <Bar>
-	\ else <Bar>
-	\   confirm close <Bar>
-	\ endif<CR>
-an 10.335 &File.-SEP1-				<Nop>
-an <silent> 10.340 &File.&Save<Tab>:w		:if expand("%") == ""<Bar>browse confirm w<Bar>else<Bar>confirm w<Bar>endif<CR>
-an 10.350 &File.Save\ &As\.\.\.<Tab>:sav	:browse confirm saveas<CR>
-
-if has("diff")
-  an 10.400 &File.-SEP2-			<Nop>
-  an 10.410 &File.Split\ &Diff\ with\.\.\.	:browse vert diffsplit<CR>
-  an 10.420 &File.Split\ Patched\ &By\.\.\.	:browse vert diffpatch<CR>
-endif
-
-if has("printer")
-  an 10.500 &File.-SEP3-			<Nop>
-  an 10.510 &File.&Print			:hardcopy<CR>
-  vunmenu   &File.&Print
-  vnoremenu &File.&Print			:hardcopy<CR>
-elseif has("unix")
-  an 10.500 &File.-SEP3-			<Nop>
-  an 10.510 &File.&Print			:w !lpr<CR>
-  vunmenu   &File.&Print
-  vnoremenu &File.&Print			:w !lpr<CR>
-endif
-an 10.600 &File.-SEP4-				<Nop>
-an 10.610 &File.Sa&ve-Exit<Tab>:wqa		:confirm wqa<CR>
-an 10.620 &File.E&xit<Tab>:qa			:confirm qa<CR>
-
-" Pasting blockwise and linewise selections is not possible in Insert and
-" Visual mode without the +virtualedit feature.  They are pasted as if they
-" were characterwise instead.  Add to that some tricks to leave the cursor in
-" the right position, also for "gi".
-" Note: the same stuff appears in mswin.vim.
-if has("virtualedit")
-  nnoremap <silent> <script> <SID>Paste :call <SID>Paste()<CR>
-  func! <SID>Paste()
-    let ove = &ve
-    set ve=all
-    normal `^
-    if @+ != ''
-      normal "+gP
-    endif
-    let c = col(".")
-    normal i
-    if col(".") < c	" compensate for i<ESC> moving the cursor left
-      normal l
-    endif
-    let &ve = ove
-  endfunc
-else
-  nnoremap <silent> <script> <SID>Paste "=@+.'xy'<CR>gPFx"_2x
-endif
-
-" Use maps for items that are present both in Edit, Popup and Toolbar menu.
-if has("virtualedit")
-  vnoremap <script> <SID>vPaste	"-c<Esc><SID>Paste
-  inoremap <script> <SID>iPaste	<Esc><SID>Pastegi
-else
-  vnoremap <script> <SID>vPaste	"-c<Esc>gix<Esc><SID>Paste"_x
-  inoremap <script> <SID>iPaste	x<Esc><SID>Paste"_s
-endif
-
-func! <SID>SelectAll()
-  exe "norm gg" . (&slm == "" ? "VG" : "gH\<C-O>G")
-endfunc
-
-
-" Edit menu
-an 20.310 &Edit.&Undo<Tab>u			u
-an 20.320 &Edit.&Redo<Tab>^R			<C-R>
-an 20.330 &Edit.Rep&eat<Tab>\.			.
-
-an 20.335 &Edit.-SEP1-				<Nop>
-vnoremenu 20.340 &Edit.Cu&t<Tab>"+x		"+x
-vnoremenu 20.350 &Edit.&Copy<Tab>"+y		"+y
-cnoremenu 20.350 &Edit.&Copy<Tab>"+y		<C-Y>
-nnoremenu 20.360 &Edit.&Paste<Tab>"+gP		"+gP
-cnoremenu	 &Edit.&Paste<Tab>"+gP		<C-R>+
-vnoremenu <script> &Edit.&Paste<Tab>"+gP	<SID>vPaste
-inoremenu <script> &Edit.&Paste<Tab>"+gP	<SID>iPaste
-nnoremenu 20.370 &Edit.Put\ &Before<Tab>[p	[p
-inoremenu	 &Edit.Put\ &Before<Tab>[p	<C-O>[p
-nnoremenu 20.380 &Edit.Put\ &After<Tab>]p	]p
-inoremenu	 &Edit.Put\ &After<Tab>]p	<C-O>]p
-if has("win32") || has("win16")
-  vnoremenu 20.390 &Edit.&Delete<Tab>x		x
-endif
-noremenu  <script> <silent> 20.400 &Edit.&Select\ All<Tab>ggVG	:<C-U>call <SID>SelectAll()<CR>
-inoremenu <script> <silent> 20.400 &Edit.&Select\ All<Tab>ggVG	<C-O>:call <SID>SelectAll()<CR>
-cnoremenu <script> <silent> 20.400 &Edit.&Select\ All<Tab>ggVG	<C-U>call <SID>SelectAll()<CR>
-
-an 20.405	 &Edit.-SEP2-				<Nop>
-if has("win32")  || has("win16") || has("gui_gtk") || has("gui_motif")
-  an 20.410	 &Edit.&Find\.\.\.			:promptfind<CR>
-  vunmenu	 &Edit.&Find\.\.\.
-  vnoremenu	 &Edit.&Find\.\.\.			y:promptfind <C-R>"<CR>
-  an 20.420	 &Edit.Find\ and\ Rep&lace\.\.\.	:promptrepl<CR>
-  vunmenu	 &Edit.Find\ and\ Rep&lace\.\.\.
-  vnoremenu	 &Edit.Find\ and\ Rep&lace\.\.\.	y:promptrepl <C-R>"<CR>
-else
-  an 20.410	 &Edit.&Find<Tab>/			/
-  an 20.420	 &Edit.Find\ and\ Rep&lace<Tab>:%s	:%s/
-  vunmenu	 &Edit.Find\ and\ Rep&lace<Tab>:%s
-  vnoremenu	 &Edit.Find\ and\ Rep&lace<Tab>:s	:s/
-endif
-
-an 20.425	 &Edit.-SEP3-				<Nop>
-an 20.430	 &Edit.Settings\ &Window		:options<CR>
-
-" Edit/Global Settings
-an 20.440.100 &Edit.&Global\ Settings.Toggle\ Pattern\ &Highlight<Tab>:set\ hls!	:set hls! hls?<CR>
-an 20.440.110 &Edit.&Global\ Settings.Toggle\ &Ignore-case<Tab>:set\ ic!	:set ic! ic?<CR>
-an 20.440.110 &Edit.&Global\ Settings.Toggle\ &Showmatch<Tab>:set\ sm!	:set sm! sm?<CR>
-
-an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 1\  :set so=1<CR>
-an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 2\  :set so=2<CR>
-an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 3\  :set so=3<CR>
-an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 4\  :set so=4<CR>
-an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 5\  :set so=5<CR>
-an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 7\  :set so=7<CR>
-an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 10\  :set so=10<CR>
-an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 100\  :set so=100<CR>
-
-an 20.440.130.40 &Edit.&Global\ Settings.&Virtual\ Edit.Never :set ve=<CR>
-an 20.440.130.50 &Edit.&Global\ Settings.&Virtual\ Edit.Block\ Selection :set ve=block<CR>
-an 20.440.130.60 &Edit.&Global\ Settings.&Virtual\ Edit.Insert\ mode :set ve=insert<CR>
-an 20.440.130.70 &Edit.&Global\ Settings.&Virtual\ Edit.Block\ and\ Insert :set ve=block,insert<CR>
-an 20.440.130.80 &Edit.&Global\ Settings.&Virtual\ Edit.Always :set ve=all<CR>
-an 20.440.140 &Edit.&Global\ Settings.Toggle\ Insert\ &Mode<Tab>:set\ im!	:set im!<CR>
-an 20.440.145 &Edit.&Global\ Settings.Toggle\ Vi\ C&ompatible<Tab>:set\ cp!	:set cp!<CR>
-an <silent> 20.440.150 &Edit.&Global\ Settings.Search\ &Path\.\.\.  :call <SID>SearchP()<CR>
-an <silent> 20.440.160 &Edit.&Global\ Settings.Ta&g\ Files\.\.\.  :call <SID>TagFiles()<CR>
-"
-" GUI options
-an 20.440.300 &Edit.&Global\ Settings.-SEP1-				<Nop>
-an <silent> 20.440.310 &Edit.&Global\ Settings.Toggle\ &Toolbar		:call <SID>ToggleGuiOption("T")<CR>
-an <silent> 20.440.320 &Edit.&Global\ Settings.Toggle\ &Bottom\ Scrollbar :call <SID>ToggleGuiOption("b")<CR>
-an <silent> 20.440.330 &Edit.&Global\ Settings.Toggle\ &Left\ Scrollbar	:call <SID>ToggleGuiOption("l")<CR>
-an <silent> 20.440.340 &Edit.&Global\ Settings.Toggle\ &Right\ Scrollbar :call <SID>ToggleGuiOption("r")<CR>
-
-fun! s:SearchP()
-  if !exists("g:menutrans_path_dialog")
-    let g:menutrans_path_dialog = "Enter search path for files.\nSeparate directory names with a comma."
-  endif
-  let n = inputdialog(g:menutrans_path_dialog, substitute(&path, '\\ ', ' ', 'g'))
-  if n != ""
-    let &path = substitute(n, ' ', '\\ ', 'g')
-  endif
-endfun
-
-fun! s:TagFiles()
-  if !exists("g:menutrans_tags_dialog")
-    let g:menutrans_tags_dialog = "Enter names of tag files.\nSeparate the names with a comma."
-  endif
-  let n = inputdialog(g:menutrans_tags_dialog, substitute(&tags, '\\ ', ' ', 'g'))
-  if n != ""
-    let &tags = substitute(n, ' ', '\\ ', 'g')
-  endif
-endfun
-
-fun! s:ToggleGuiOption(option)
-    " If a:option is already set in guioptions, then we want to remove it
-    if match(&guioptions, "\\C" . a:option) > -1
-	exec "set go-=" . a:option
-    else
-	exec "set go+=" . a:option
-    endif
-endfun
-
-" Edit/File Settings
-
-" Boolean options
-an 20.440.100 &Edit.F&ile\ Settings.Toggle\ Line\ &Numbering<Tab>:set\ nu!	:set nu! nu?<CR>
-an 20.440.110 &Edit.F&ile\ Settings.Toggle\ &List\ Mode<Tab>:set\ list!	:set list! list?<CR>
-an 20.440.120 &Edit.F&ile\ Settings.Toggle\ Line\ &Wrap<Tab>:set\ wrap!	:set wrap! wrap?<CR>
-an 20.440.130 &Edit.F&ile\ Settings.Toggle\ W&rap\ at\ word<Tab>:set\ lbr!	:set lbr! lbr?<CR>
-an 20.440.160 &Edit.F&ile\ Settings.Toggle\ &expand-tab<Tab>:set\ et!	:set et! et?<CR>
-an 20.440.170 &Edit.F&ile\ Settings.Toggle\ &auto-indent<Tab>:set\ ai!	:set ai! ai?<CR>
-an 20.440.180 &Edit.F&ile\ Settings.Toggle\ &C-indenting<Tab>:set\ cin!	:set cin! cin?<CR>
-
-" other options
-an 20.440.600 &Edit.F&ile\ Settings.-SEP2-		<Nop>
-an 20.440.610.20 &Edit.F&ile\ Settings.&Shiftwidth.2	:set sw=2 sw?<CR>
-an 20.440.610.30 &Edit.F&ile\ Settings.&Shiftwidth.3	:set sw=3 sw?<CR>
-an 20.440.610.40 &Edit.F&ile\ Settings.&Shiftwidth.4	:set sw=4 sw?<CR>
-an 20.440.610.50 &Edit.F&ile\ Settings.&Shiftwidth.5	:set sw=5 sw?<CR>
-an 20.440.610.60 &Edit.F&ile\ Settings.&Shiftwidth.6	:set sw=6 sw?<CR>
-an 20.440.610.80 &Edit.F&ile\ Settings.&Shiftwidth.8	:set sw=8 sw?<CR>
-
-an 20.440.620.20 &Edit.F&ile\ Settings.Soft\ &Tabstop.2	:set sts=2 sts?<CR>
-an 20.440.620.30 &Edit.F&ile\ Settings.Soft\ &Tabstop.3	:set sts=3 sts?<CR>
-an 20.440.620.40 &Edit.F&ile\ Settings.Soft\ &Tabstop.4	:set sts=4 sts?<CR>
-an 20.440.620.50 &Edit.F&ile\ Settings.Soft\ &Tabstop.5	:set sts=5 sts?<CR>
-an 20.440.620.60 &Edit.F&ile\ Settings.Soft\ &Tabstop.6	:set sts=6 sts?<CR>
-an 20.440.620.80 &Edit.F&ile\ Settings.Soft\ &Tabstop.8	:set sts=8 sts?<CR>
-
-an <silent> 20.440.630 &Edit.F&ile\ Settings.Te&xt\ Width\.\.\.  :call <SID>TextWidth()<CR>
-an <silent> 20.440.640 &Edit.F&ile\ Settings.&File\ Format\.\.\.  :call <SID>FileFormat()<CR>
-fun! s:TextWidth()
-  if !exists("g:menutrans_textwidth_dialog")
-    let g:menutrans_textwidth_dialog = "Enter new text width (0 to disable formatting): "
-  endif
-  let n = inputdialog(g:menutrans_textwidth_dialog, &tw)
-  if n != ""
-    " remove leading zeros to avoid it being used as an octal number
-    let &tw = substitute(n, "^0*", "", "")
-  endif
-endfun
-
-fun! s:FileFormat()
-  if !exists("g:menutrans_fileformat_dialog")
-    let g:menutrans_fileformat_dialog = "Select format for writing the file"
-  endif
-  if !exists("g:menutrans_fileformat_choices")
-    let g:menutrans_fileformat_choices = "&Unix\n&Dos\n&Mac\n&Cancel"
-  endif
-  if &ff == "dos"
-    let def = 2
-  elseif &ff == "mac"
-    let def = 3
-  else
-    let def = 1
-  endif
-  let n = confirm(g:menutrans_fileformat_dialog, g:menutrans_fileformat_choices, def, "Question")
-  if n == 1
-    set ff=unix
-  elseif n == 2
-    set ff=dos
-  elseif n == 3
-    set ff=mac
-  endif
-endfun
-
-" Setup the Edit.Color Scheme submenu
-let s:n = globpath(&runtimepath, "colors/*.vim")
-let s:idx = 100
-while strlen(s:n) > 0
-  let s:i = stridx(s:n, "\n")
-  if s:i < 0
-    let s:name = s:n
-    let s:n = ""
-  else
-    let s:name = strpart(s:n, 0, s:i)
-    let s:n = strpart(s:n, s:i + 1, 19999)
-  endif
-  " Ignore case for VMS and windows
-  let s:name = substitute(s:name, '\c.*[/\\:\]]\([^/\\:]*\)\.vim', '\1', '')
-  exe "an 20.450." . s:idx . ' &Edit.C&olor\ Scheme.' . s:name . " :colors " . s:name . "<CR>"
-  unlet s:name
-  unlet s:i
-  let s:idx = s:idx + 10
-endwhile
-unlet s:n
-unlet s:idx
-
-" Setup the Edit.Keymap submenu
-if has("keymap")
-  let s:n = globpath(&runtimepath, "keymap/*.vim")
-  if s:n != ""
-    let s:idx = 100
-    an 20.460.90 &Edit.&Keymap.None :set keymap=<CR>
-    while strlen(s:n) > 0
-      let s:i = stridx(s:n, "\n")
-      if s:i < 0
-	let s:name = s:n
-	let s:n = ""
-      else
-	let s:name = strpart(s:n, 0, s:i)
-	let s:n = strpart(s:n, s:i + 1, 19999)
-      endif
-      " Ignore case for VMS and windows
-      let s:name = substitute(s:name, '\c.*[/\\:\]]\([^/\\:_]*\)\(_[0-9a-zA-Z-]*\)\=\.vim', '\1', '')
-      exe "an 20.460." . s:idx . ' &Edit.&Keymap.' . s:name . " :set keymap=" . s:name . "<CR>"
-      unlet s:name
-      unlet s:i
-      let s:idx = s:idx + 10
-    endwhile
-    unlet s:idx
-  endif
-  unlet s:n
-endif
-if has("win32") || has("win16") || has("gui_gtk") || has("gui_photon")
-  an 20.470 &Edit.Select\ Fo&nt\.\.\.	:set guifont=*<CR>
-endif
-
-" Programming menu
-if !exists("g:ctags_command")
-  if has("vms")
-    let g:ctags_command = "mc vim:ctags ."
-  else
-    let g:ctags_command = "ctags -R ."
-  endif
-endif
-
-an 40.300 &Tools.&Jump\ to\ this\ tag<Tab>g^]	g<C-]>
-vunmenu &Tools.&Jump\ to\ this\ tag<Tab>g^]
-vnoremenu &Tools.&Jump\ to\ this\ tag<Tab>g^]	g<C-]>
-an 40.310 &Tools.Jump\ &back<Tab>^T		<C-T>
-an 40.320 &Tools.Build\ &Tags\ File		:exe "!" . g:ctags_command<CR>
-
-" Tools.Fold Menu
-if has("folding")
-  an 40.330 &Tools.-SEP1-						<Nop>
-  " open close folds
-  an 40.340.110 &Tools.&Folding.&Enable/Disable\ folds<Tab>zi		zi
-  an 40.340.120 &Tools.&Folding.&View\ Cursor\ Line<Tab>zv		zv
-  an 40.340.120 &Tools.&Folding.Vie&w\ Cursor\ Line\ only<Tab>zMzx	zMzx
-  an 40.340.130 &Tools.&Folding.C&lose\ more\ folds<Tab>zm		zm
-  an 40.340.140 &Tools.&Folding.&Close\ all\ folds<Tab>zM		zM
-  an 40.340.150 &Tools.&Folding.O&pen\ more\ folds<Tab>zr		zr
-  an 40.340.160 &Tools.&Folding.&Open\ all\ folds<Tab>zR		zR
-  " fold method
-  an 40.340.200 &Tools.&Folding.-SEP1-			<Nop>
-  an 40.340.210 &Tools.&Folding.Fold\ Met&hod.M&anual	:set fdm=manual<CR>
-  an 40.340.210 &Tools.&Folding.Fold\ Met&hod.I&ndent	:set fdm=indent<CR>
-  an 40.340.210 &Tools.&Folding.Fold\ Met&hod.E&xpression :set fdm=expr<CR>
-  an 40.340.210 &Tools.&Folding.Fold\ Met&hod.S&yntax	:set fdm=syntax<CR>
-  an 40.340.210 &Tools.&Folding.Fold\ Met&hod.&Diff	:set fdm=diff<CR>
-  an 40.340.210 &Tools.&Folding.Fold\ Met&hod.Ma&rker	:set fdm=marker<CR>
-  " create and delete folds
-  vnoremenu 40.340.220 &Tools.&Folding.Create\ &Fold<Tab>zf	zf
-  an 40.340.230 &Tools.&Folding.&Delete\ Fold<Tab>zd		zd
-  an 40.340.240 &Tools.&Folding.Delete\ &All\ Folds<Tab>zD	zD
-  " moving around in folds
-  an 40.340.300 &Tools.&Folding.-SEP2-				<Nop>
-  an 40.340.310.10 &Tools.&Folding.Fold\ col&umn\ width.\ &0\ 	:set fdc=0<CR>
-  an 40.340.310.20 &Tools.&Folding.Fold\ col&umn\ width.\ &2\ 	:set fdc=2<CR>
-  an 40.340.310.30 &Tools.&Folding.Fold\ col&umn\ width.\ &3\ 	:set fdc=3<CR>
-  an 40.340.310.40 &Tools.&Folding.Fold\ col&umn\ width.\ &4\ 	:set fdc=4<CR>
-  an 40.340.310.50 &Tools.&Folding.Fold\ col&umn\ width.\ &5\ 	:set fdc=5<CR>
-  an 40.340.310.60 &Tools.&Folding.Fold\ col&umn\ width.\ &6\ 	:set fdc=6<CR>
-  an 40.340.310.70 &Tools.&Folding.Fold\ col&umn\ width.\ &7\ 	:set fdc=7<CR>
-  an 40.340.310.80 &Tools.&Folding.Fold\ col&umn\ width.\ &8\ 	:set fdc=8<CR>
-endif  " has folding
-
-if has("diff")
-  an 40.350.100 &Tools.&Diff.&Update		:diffupdate<CR>
-  an 40.350.110 &Tools.&Diff.&Get\ Block	:diffget<CR>
-  vunmenu &Tools.&Diff.&Get\ Block
-  vnoremenu &Tools.&Diff.&Get\ Block		:diffget<CR>
-  an 40.350.120 &Tools.&Diff.&Put\ Block	:diffput<CR>
-  vunmenu &Tools.&Diff.&Put\ Block
-  vnoremenu &Tools.&Diff.&Put\ Block		:diffput<CR>
-endif
-
-an 40.358 &Tools.-SEP2-					<Nop>
-an 40.360 &Tools.&Make<Tab>:make			:make<CR>
-an 40.370 &Tools.&List\ Errors<Tab>:cl			:cl<CR>
-an 40.380 &Tools.L&ist\ Messages<Tab>:cl!		:cl!<CR>
-an 40.390 &Tools.&Next\ Error<Tab>:cn			:cn<CR>
-an 40.400 &Tools.&Previous\ Error<Tab>:cp		:cp<CR>
-an 40.410 &Tools.&Older\ List<Tab>:cold			:colder<CR>
-an 40.420 &Tools.N&ewer\ List<Tab>:cnew			:cnewer<CR>
-an 40.430.50 &Tools.Error\ &Window.&Update<Tab>:cwin	:cwin<CR>
-an 40.430.60 &Tools.Error\ &Window.&Open<Tab>:copen	:copen<CR>
-an 40.430.70 &Tools.Error\ &Window.&Close<Tab>:cclose	:cclose<CR>
-
-an 40.520 &Tools.-SEP3-					<Nop>
-an <silent> 40.530 &Tools.&Convert\ to\ HEX<Tab>:%!xxd
-	\ :call <SID>XxdConv()<CR>
-an <silent> 40.540 &Tools.Conve&rt\ back<Tab>:%!xxd\ -r
-	\ :call <SID>XxdBack()<CR>
-
-" Use a function to do the conversion, so that it also works with 'insertmode'
-" set.
-func! s:XxdConv()
-  let mod = &mod
-  if has("vms")
-    %!mc vim:xxd
-  else
-    call s:XxdFind()
-    exe '%!"' . g:xxdprogram . '"'
-  endif
-  if getline(1) =~ "^0000000:"		" only if it worked
-    set ft=xxd
-  endif
-  let &mod = mod
-endfun
-
-func! s:XxdBack()
-  let mod = &mod
-  if has("vms")
-    %!mc vim:xxd -r
-  else
-    call s:XxdFind()
-    exe '%!"' . g:xxdprogram . '" -r'
-  endif
-  set ft=
-  doautocmd filetypedetect BufReadPost
-  let &mod = mod
-endfun
-
-func! s:XxdFind()
-  if !exists("g:xxdprogram")
-    " On the PC xxd may not be in the path but in the install directory
-    if (has("win32") || has("dos32")) && !executable("xxd")
-      let g:xxdprogram = $VIMRUNTIME . (&shellslash ? '/' : '\') . "xxd.exe"
-    else
-      let g:xxdprogram = "xxd"
-    endif
-  endif
-endfun
-
-" Setup the Tools.Compiler submenu
-let s:n = globpath(&runtimepath, "compiler/*.vim")
-let s:idx = 100
-while strlen(s:n) > 0
-  let s:i = stridx(s:n, "\n")
-  if s:i < 0
-    let s:name = s:n
-    let s:n = ""
-  else
-    let s:name = strpart(s:n, 0, s:i)
-    let s:n = strpart(s:n, s:i + 1, 19999)
-  endif
-  " Ignore case for VMS and windows
-  let s:name = substitute(s:name, '\c.*[/\\:\]]\([^/\\:]*\)\.vim', '\1', '')
-  exe "an 30.440." . s:idx . ' &Tools.&Set\ Compiler.' . s:name . " :compiler " . s:name . "<CR>"
-  unlet s:name
-  unlet s:i
-  let s:idx = s:idx + 10
-endwhile
-unlet s:n
-unlet s:idx
-
-if !exists("no_buffers_menu")
-
-" Buffer list menu -- Setup functions & actions
-
-" wait with building the menu until after loading 'session' files. Makes
-" startup faster.
-let s:bmenu_wait = 1
-
-if !exists("bmenu_priority")
-  let bmenu_priority = 60
-endif
-
-func! s:BMAdd()
-  if s:bmenu_wait == 0
-    " when adding too many buffers, redraw in short format
-    if s:bmenu_count == &menuitems && s:bmenu_short == 0
-      call s:BMShow()
-    else
-      call <SID>BMFilename(expand("<afile>"), expand("<abuf>"))
-      let s:bmenu_count = s:bmenu_count + 1
-    endif
-  endif
-endfunc
-
-func! s:BMRemove()
-  if s:bmenu_wait == 0
-    let name = expand("<afile>")
-    if isdirectory(name)
-      return
-    endif
-    let munge = <SID>BMMunge(name, expand("<abuf>"))
-
-    if s:bmenu_short == 0
-      exe 'silent! aun &Buffers.' . munge
-    else
-      exe 'silent! aun &Buffers.' . <SID>BMHash2(munge) . munge
-    endif
-    let s:bmenu_count = s:bmenu_count - 1
-  endif
-endfunc
-
-" Create the buffer menu (delete an existing one first).
-func! s:BMShow(...)
-  let s:bmenu_wait = 1
-  let s:bmenu_short = 1
-  let s:bmenu_count = 0
-  "
-  " get new priority, if exists
-  if a:0 == 1
-    let g:bmenu_priority = a:1
-  endif
-
-  " remove old menu, if exists; keep one entry to avoid a torn off menu to
-  " disappear.
-  silent! unmenu &Buffers
-  exe 'noremenu ' . g:bmenu_priority . ".1 &Buffers.Dummy l"
-  silent! unmenu! &Buffers
-
-  " create new menu; set 'cpo' to include the <CR>
-  let cpo_save = &cpo
-  set cpo&vim
-  exe 'an <silent> ' . g:bmenu_priority . ".2 &Buffers.&Refresh\\ menu :call <SID>BMShow()<CR>"
-  exe 'an ' . g:bmenu_priority . ".4 &Buffers.&Delete :confirm bd<CR>"
-  exe 'an ' . g:bmenu_priority . ".6 &Buffers.&Alternate :confirm b #<CR>"
-  exe 'an ' . g:bmenu_priority . ".7 &Buffers.&Next :confirm bnext<CR>"
-  exe 'an ' . g:bmenu_priority . ".8 &Buffers.&Previous :confirm bprev<CR>"
-  exe 'an ' . g:bmenu_priority . ".9 &Buffers.-SEP- :"
-  let &cpo = cpo_save
-  unmenu &Buffers.Dummy
-
-  " figure out how many buffers there are
-  let buf = 1
-  while buf <= bufnr('$')
-    if bufexists(buf) && !isdirectory(bufname(buf)) && buflisted(buf)
-					    \ && !getbufvar(buf, "&bufsecret")
-      let s:bmenu_count = s:bmenu_count + 1
-    endif
-    let buf = buf + 1
-  endwhile
-  if s:bmenu_count <= &menuitems
-    let s:bmenu_short = 0
-  endif
-
-  " iterate through buffer list, adding each buffer to the menu:
-  let buf = 1
-  while buf <= bufnr('$')
-    if bufexists(buf) && !isdirectory(bufname(buf)) && buflisted(buf)
-					    \ && !getbufvar(buf, "&bufsecret")
-      call <SID>BMFilename(bufname(buf), buf)
-    endif
-    let buf = buf + 1
-  endwhile
-  let s:bmenu_wait = 0
-  aug buffer_list
-  au!
-  au BufCreate,BufFilePost * call <SID>BMAdd()
-  au BufDelete,BufFilePre * call <SID>BMRemove()
-  aug END
-endfunc
-
-func! s:BMHash(name)
-  " Make name all upper case, so that chars are between 32 and 96
-  let nm = substitute(a:name, ".*", '\U\0', "")
-  if has("ebcdic")
-    " HACK: Replace all non alphabetics with 'Z'
-    "       Just to make it work for now.
-    let nm = substitute(nm, "[^A-Z]", 'Z', "g")
-    let sp = char2nr('A') - 1
-  else
-    let sp = char2nr(' ')
-  endif
-  " convert first six chars into a number for sorting:
-  return (char2nr(nm[0]) - sp) * 0x800000 + (char2nr(nm[1]) - sp) * 0x20000 + (char2nr(nm[2]) - sp) * 0x1000 + (char2nr(nm[3]) - sp) * 0x80 + (char2nr(nm[4]) - sp) * 0x20 + (char2nr(nm[5]) - sp)
-endfunc
-
-func! s:BMHash2(name)
-  let nm = substitute(a:name, ".", '\L\0', "")
-  " Not exactly right for EBCDIC...
-  if nm[0] < 'a' || nm[0] > 'z'
-    return '&others.'
-  elseif nm[0] <= 'd'
-    return '&abcd.'
-  elseif nm[0] <= 'h'
-    return '&efgh.'
-  elseif nm[0] <= 'l'
-    return '&ijkl.'
-  elseif nm[0] <= 'p'
-    return '&mnop.'
-  elseif nm[0] <= 't'
-    return '&qrst.'
-  else
-    return '&u-z.'
-  endif
-endfunc
-
-" insert a buffer name into the buffer menu:
-func! s:BMFilename(name, num)
-  if isdirectory(a:name)
-    return
-  endif
-  let munge = <SID>BMMunge(a:name, a:num)
-  let hash = <SID>BMHash(munge)
-  if s:bmenu_short == 0
-    let name = 'an ' . g:bmenu_priority . '.' . hash . ' &Buffers.' . munge
-  else
-    let name = 'an ' . g:bmenu_priority . '.' . hash . '.' . hash . ' &Buffers.' . <SID>BMHash2(munge) . munge
-  endif
-  " set 'cpo' to include the <CR>
-  let cpo_save = &cpo
-  set cpo&vim
-  exe name . ' :confirm b' . a:num . '<CR>'
-  let &cpo = cpo_save
-endfunc
-
-" Truncate a long path to fit it in a menu item.
-if !exists("g:bmenu_max_pathlen")
-  let g:bmenu_max_pathlen = 35
-endif
-func! s:BMTruncName(fname)
-  let name = a:fname
-  if g:bmenu_max_pathlen < 5
-    let name = ""
-  else
-    let len = strlen(name)
-    if len > g:bmenu_max_pathlen
-      let amountl = (g:bmenu_max_pathlen / 2) - 2
-      let amountr = g:bmenu_max_pathlen - amountl - 3
-      let pattern = '^\(.\{,' . amountl . '}\).\{-}\(.\{,' . amountr . '}\)$'
-      let left = substitute(name, pattern, '\1', '')
-      let right = substitute(name, pattern, '\2', '')
-      if strlen(left) + strlen(right) < len
-	let name = left . '...' . right
-      endif
-    endif
-  endif
-  return name
-endfunc
-
-func! s:BMMunge(fname, bnum)
-  let name = a:fname
-  if name == ''
-    if !exists("g:menutrans_no_file")
-      let g:menutrans_no_file = "[No file]"
-    endif
-    let name = g:menutrans_no_file
-  else
-    let name = fnamemodify(name, ':p:~')
-  endif
-  " detach file name and separate it out:
-  let name2 = fnamemodify(name, ':t')
-  if a:bnum >= 0
-    let name2 = name2 . ' (' . a:bnum . ')'
-  endif
-  let name = name2 . "\t" . <SID>BMTruncName(fnamemodify(name,':h'))
-  let name = escape(name, "\\. \t|")
-  let name = substitute(name, "&", "&&", "g")
-  let name = substitute(name, "\n", "^@", "g")
-  return name
-endfunc
-
-" When just starting Vim, load the buffer menu later
-if has("vim_starting")
-  augroup LoadBufferMenu
-    au! VimEnter * if !exists("no_buffers_menu") | call <SID>BMShow() | endif
-    au  VimEnter * au! LoadBufferMenu
-  augroup END
-else
-  call <SID>BMShow()
-endif
-
-endif " !exists("no_buffers_menu")
-
-" Window menu
-an 70.300 &Window.&New<Tab>^Wn			<C-W>n
-an 70.310 &Window.S&plit<Tab>^Ws		<C-W>s
-an 70.320 &Window.Sp&lit\ To\ #<Tab>^W^^	<C-W><C-^>
-an 70.330 &Window.Split\ &Vertically<Tab>^Wv	<C-W>v
-if has("vertsplit")
-  an <silent> 70.332 &Window.Split\ File\ E&xplorer	:call MenuExplOpen()<CR>
-  if !exists("*MenuExplOpen")
-    fun MenuExplOpen()
-      if @% == ""
-	20vsp .
-      else
-	exe "20vsp " . expand("%:p:h")
-      endif
-    endfun
-  endif
-endif
-an 70.335 &Window.-SEP1-				<Nop>
-an 70.340 &Window.&Close<Tab>^Wc			:confirm close<CR>
-an 70.345 &Window.Close\ &Other(s)<Tab>^Wo		:confirm only<CR>
-an 70.350 &Window.-SEP2-				<Nop>
-an 70.355 &Window.Move\ &To.&Top<Tab>^WK		<C-W>K
-an 70.355 &Window.Move\ &To.&Bottom<Tab>^WJ		<C-W>J
-an 70.355 &Window.Move\ &To.&Left\ side<Tab>^WH		<C-W>H
-an 70.355 &Window.Move\ &To.&Right\ side<Tab>^WL	<C-W>L
-an 70.360 &Window.Rotate\ &Up<Tab>^WR			<C-W>R
-an 70.362 &Window.Rotate\ &Down<Tab>^Wr			<C-W>r
-an 70.365 &Window.-SEP3-				<Nop>
-an 70.370 &Window.&Equal\ Size<Tab>^W=			<C-W>=
-an 70.380 &Window.&Max\ Height<Tab>^W_			<C-W>_
-an 70.390 &Window.M&in\ Height<Tab>^W1_			<C-W>1_
-an 70.400 &Window.Max\ &Width<Tab>^W\|			<C-W>\|
-an 70.410 &Window.Min\ Widt&h<Tab>^W1\|			<C-W>1\|
-
-" The popup menu
-an 1.10 PopUp.&Undo			u
-an 1.15 PopUp.-SEP1-			<Nop>
-vnoremenu 1.20 PopUp.Cu&t		"+x
-vnoremenu 1.30 PopUp.&Copy		"+y
-cnoremenu 1.30 PopUp.&Copy		<C-Y>
-nnoremenu 1.40 PopUp.&Paste		"+gP
-cnoremenu 1.40 PopUp.&Paste		<C-R>+
-vnoremenu <script> 1.40 PopUp.&Paste	<SID>vPaste
-inoremenu <script> 1.40 PopUp.&Paste	<SID>iPaste
-vnoremenu 1.50 PopUp.&Delete		x
-an 1.55 PopUp.-SEP2-			<Nop>
-vnoremenu 1.60 PopUp.Select\ Blockwise	<C-V>
-an 1.70 PopUp.Select\ &Word		vaw
-an 1.80 PopUp.Select\ &Line		V
-an 1.90 PopUp.Select\ &Block		<C-V>
-noremenu  <script> <silent> 1.100 PopUp.Select\ &All	:<C-U>call <SID>SelectAll()<CR>
-inoremenu <script> <silent> 1.100 PopUp.Select\ &All	<C-O>:call <SID>SelectAll()<CR>
-cnoremenu <script> <silent> 1.100 PopUp.Select\ &All	<C-U>call <SID>SelectAll()<CR>
-
-
-" The GUI toolbar (for MS-Windows and GTK)
-if has("toolbar")
-  an 1.10 ToolBar.Open			:browse confirm e<CR>
-  an <silent> 1.20 ToolBar.Save		:if expand("%") == ""<Bar>browse confirm w<Bar>else<Bar>confirm w<Bar>endif<CR>
-  an 1.30 ToolBar.SaveAll		:browse confirm wa<CR>
-
-  if has("printer")
-    an 1.40   ToolBar.Print		:hardcopy<CR>
-    vunmenu   ToolBar.Print
-    vnoremenu ToolBar.Print		:hardcopy<CR>
-  elseif has("unix")
-    an 1.40   ToolBar.Print		:w !lpr<CR>
-    vunmenu   ToolBar.Print
-    vnoremenu ToolBar.Print		:w !lpr<CR>
-  endif
-
-  an 1.45 ToolBar.-sep1-		<Nop>
-  an 1.50 ToolBar.Undo			u
-  an 1.60 ToolBar.Redo			<C-R>
-
-  an 1.65 ToolBar.-sep2-		<Nop>
-  vnoremenu 1.70 ToolBar.Cut		"+x
-  vnoremenu 1.80 ToolBar.Copy		"+y
-  cnoremenu 1.80 ToolBar.Copy		<C-Y>
-  nnoremenu 1.90 ToolBar.Paste		"+gP
-  cnoremenu	 ToolBar.Paste		<C-R>+
-  vnoremenu <script>	 ToolBar.Paste	<SID>vPaste
-  inoremenu <script>	 ToolBar.Paste	<SID>iPaste
-
-  if !has("gui_athena")
-    an 1.95   ToolBar.-sep3-		<Nop>
-    an 1.100  ToolBar.Find		:promptfind<CR>
-    vunmenu   ToolBar.Find
-    vnoremenu ToolBar.Find		y:promptfind <C-R>"<CR>
-    an 1.110  ToolBar.FindNext		n
-    an 1.120  ToolBar.FindPrev		N
-    an 1.130  ToolBar.Replace		:promptrepl<CR>
-    vunmenu   ToolBar.Replace
-    vnoremenu ToolBar.Replace		y:promptrepl <C-R>"<CR>
-  endif
-
-if 0	" disabled; These are in the Windows menu
-  an 1.135 ToolBar.-sep4-		<Nop>
-  an 1.140 ToolBar.New			<C-W>n
-  an 1.150 ToolBar.WinSplit		<C-W>s
-  an 1.160 ToolBar.WinMax		:resize 200<CR>
-  an 1.170 ToolBar.WinMin		:resize 1<CR>
-  an 1.180 ToolBar.WinVSplit		<C-W>v
-  an 1.190 ToolBar.WinMaxWidth		<C-W>500>
-  an 1.200 ToolBar.WinMinWidth		<C-W>1\|
-  an 1.210 ToolBar.WinClose		:close<CR>
-endif
-
-  an 1.215 ToolBar.-sep5-		<Nop>
-  an <silent> 1.220 ToolBar.LoadSesn	:call <SID>LoadVimSesn()<CR>
-  an <silent> 1.230 ToolBar.SaveSesn	:call <SID>SaveVimSesn()<CR>
-  an 1.240 ToolBar.RunScript		:browse so<CR>
-
-  an 1.245 ToolBar.-sep6-		<Nop>
-  an 1.250 ToolBar.Make			:make<CR>
-  an 1.270 ToolBar.RunCtags		:exe "!" . g:ctags_command<CR>
-  an 1.280 ToolBar.TagJump		g<C-]>
-
-  an 1.295 ToolBar.-sep7-		<Nop>
-  an 1.300 ToolBar.Help			:help<CR>
-  an <silent> 1.310 ToolBar.FindHelp	:call <SID>Helpfind()<CR>
-
-" Only set the tooltips here if not done in a language menu file
-if exists("*Do_toolbar_tmenu")
-  call Do_toolbar_tmenu()
-else
-  let did_toolbar_tmenu = 1
-  tmenu ToolBar.Open		Open file
-  tmenu ToolBar.Save		Save current file
-  tmenu ToolBar.SaveAll		Save all files
-  tmenu ToolBar.Print		Print
-  tmenu ToolBar.Undo		Undo
-  tmenu ToolBar.Redo		Redo
-  tmenu ToolBar.Cut		Cut to clipboard
-  tmenu ToolBar.Copy		Copy to clipboard
-  tmenu ToolBar.Paste		Paste from Clipboard
-  if !has("gui_athena")
-    tmenu ToolBar.Find		Find...
-    tmenu ToolBar.FindNext	Find Next
-    tmenu ToolBar.FindPrev	Find Previous
-    tmenu ToolBar.Replace		Find / Replace...
-  endif
- if 0	" disabled; These are in the Windows menu
-  tmenu ToolBar.New		New Window
-  tmenu ToolBar.WinSplit	Split Window
-  tmenu ToolBar.WinMax		Maximise Window
-  tmenu ToolBar.WinMin		Minimise Window
-  tmenu ToolBar.WinVSplit	Split Window Vertically
-  tmenu ToolBar.WinMaxWidth	Maximise Window Width
-  tmenu ToolBar.WinMinWidth	Minimise Window Width
-  tmenu ToolBar.WinClose	Close Window
- endif
-  tmenu ToolBar.LoadSesn	Load session
-  tmenu ToolBar.SaveSesn	Save current session
-  tmenu ToolBar.RunScript	Run a Vim Script
-  tmenu ToolBar.Make		Make current project
-  tmenu ToolBar.RunCtags	Build tags in current directory tree
-  tmenu ToolBar.TagJump		Jump to tag under cursor
-  tmenu ToolBar.Help		Vim Help
-  tmenu ToolBar.FindHelp	Search Vim Help
-endif
-
-" Select a session to load; default to current session name if present
-fun! s:LoadVimSesn()
-  if strlen(v:this_session) > 0
-    let name = v:this_session
-  else
-    let name = "Session.vim"
-  endif
-  execute "browse so " . name
-endfun
-
-" Select a session to save; default to current session name if present
-fun! s:SaveVimSesn()
-  if strlen(v:this_session) == 0
-    let v:this_session = "Session.vim"
-  endif
-  execute "browse mksession! " . v:this_session
-endfun
-
-endif
-
-endif " !exists("did_install_default_menus")
-
-" Define these items always, so that syntax can be switched on when it wasn't.
-" But skip them when the Syntax menu was disabled by the user.
-if !exists("did_install_syntax_menu")
-  an 50.212 &Syntax.&Manual		:syn manual<CR>
-  an 50.214 &Syntax.A&utomatic		:syn on<CR>
-  an <silent> 50.216 &Syntax.on/off\ for\ &This\ file :call <SID>SynOnOff()<CR>
-  if !exists("*s:SynOnOff")
-    fun s:SynOnOff()
-      if has("syntax_items")
-	syn clear
-      else
-	if !exists("g:syntax_on")
-	  syn manual
-	endif
-	set syn=ON
-      endif
-    endfun
-  endif
-endif
-
-
-" Install the Syntax menu only when filetype.vim has been loaded or when
-" manual syntax highlighting is enabled.
-" Avoid installing the Syntax menu twice.
-if (exists("did_load_filetypes") || exists("syntax_on"))
-	\ && !exists("did_install_syntax_menu")
-  let did_install_syntax_menu = 1
-
-" Skip setting up the individual syntax selection menus unless
-" do_syntax_sel_menu is defined (it takes quite a bit of time).
-if exists("do_syntax_sel_menu")
-  runtime! synmenu.vim
-else
-  an 50.10 &Syntax.&Show\ filetypes\ in\ menu	:let do_syntax_sel_menu = 1<Bar>runtime! synmenu.vim<Bar>aunmenu &Syntax.&Show\ filetypes\ in\ menu<CR>
-  an 50.195 &Syntax.-SEP1-		<Nop>
-endif
-
-an 50.210 &Syntax.&Off			:syn off<CR>
-an 50.700 &Syntax.-SEP3-		<Nop>
-an 50.710 &Syntax.Co&lor\ test		:sp $VIMRUNTIME/syntax/colortest.vim<Bar>so %<CR>
-an 50.720 &Syntax.&Highlight\ test	:runtime syntax/hitest.vim<CR>
-an 50.730 &Syntax.&Convert\ to\ HTML	:runtime syntax/2html.vim<CR>
-
-endif " !exists("did_install_syntax_menu")
-
-" Restore the previous value of 'cpoptions'.
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
-" vim: set sw=2 :
diff -Nur vim63/src/buffer.c vim63-bonobo/src/buffer.c
--- vim63/src/buffer.c	2005-09-09 20:11:09.929854000 +0200
+++ vim63-bonobo/src/buffer.c	2005-09-09 20:14:02.699589864 +0200
@@ -28,6 +28,10 @@
 
 #include "vim.h"
 
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+#include "vim_bonobo_control.h"
+#endif
+
 #if defined(FEAT_CMDL_COMPL) || defined(FEAT_LISTCMDS) || defined(FEAT_EVAL) || defined(FEAT_PERL)
 static char_u	*buflist_match __ARGS((regprog_T *prog, buf_T *buf));
 # define HAVE_BUFLIST_MATCH
@@ -137,10 +141,20 @@
 	if (curbuf->b_help)
 	    fix_help_buffer();
     }
-    else if (read_stdin)
+    else if (read_stdin
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+                || read_from_container
+#endif
+            )
     {
 	int		save_bin = curbuf->b_p_bin;
 	linenr_T	line_count;
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+        int flags = READ_NEW + READ_EMB_STREAM;
+	curbuf->emb_buffer = TRUE;
+#else
+        int flags = READ_NEW + READ_STDIN;
+#endif
 
 	/*
 	 * First read the text in binary mode into the buffer.
@@ -150,7 +164,7 @@
 	 */
 	curbuf->b_p_bin = TRUE;
 	retval = readfile(NULL, NULL, (linenr_T)0,
-		  (linenr_T)0, (linenr_T)MAXLNUM, NULL, READ_NEW + READ_STDIN);
+ 		  (linenr_T)0, (linenr_T)MAXLNUM, eap, flags);
 	curbuf->b_p_bin = save_bin;
 	if (retval == OK)
 	{
@@ -172,14 +186,21 @@
 	    /* Put the cursor on the first line. */
 	    curwin->w_cursor.lnum = 1;
 	    curwin->w_cursor.col = 0;
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+            if (read_stdin) 
+            {
+#endif
 #ifdef FEAT_AUTOCMD
 # ifdef FEAT_EVAL
-	    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,
+                apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,
 							curbuf, &retval);
 # else
-	    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);
+                apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);
 # endif
 #endif
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+            }
+#endif
 	}
     }
 
@@ -4634,6 +4655,11 @@
 	return "[Scratch]";
     }
 #endif
+#if defined(FEAT_QUICKFIX) && defined(FEAT_GUI_COMPONENT)
+    if ( buf->emb_buffer ) {
+	return "[Embedded File]";
+    }
+#endif
     if (buf->b_fname == NULL)
 	return _("[No File]");
     return NULL;
diff -Nur vim63/src/config.h.in vim63-bonobo/src/config.h.in
--- vim63/src/config.h.in	2005-09-09 20:11:10.543761000 +0200
+++ vim63-bonobo/src/config.h.in	2005-09-09 20:14:02.700589712 +0200
@@ -321,6 +321,9 @@
 /* Define if GTK+ multihead support is available (requires GTK+ >= 2.1.1). */
 #undef HAVE_GTK_MULTIHEAD
 
+/* Define if you want component (i.e. Bonobo) support. */
+#undef FEAT_GUI_COMPONENT
+ 
 /* Define if your X has own locale library */
 #undef X_LOCALE
 
diff -Nur vim63/src/config.mk.in vim63-bonobo/src/config.mk.in
--- vim63/src/config.mk.in	2005-09-09 20:11:10.543761000 +0200
+++ vim63-bonobo/src/config.mk.in	2005-09-09 20:14:02.700589712 +0200
@@ -106,6 +106,9 @@
 ### Prefix for location of man pages
 MANDIR		= @mandir@
 
+### Extra targets to be built by default
+EXTRA_TARGETS = @EXTRA_TARGETS@
+
 ### Do we have a GUI
 GUI_INC_LOC	= @GUI_INC_LOC@
 GUI_LIB_LOC	= @GUI_LIB_LOC@
diff -Nur vim63/src/configure.in vim63-bonobo/src/configure.in
--- vim63/src/configure.in	2005-09-09 20:11:10.546761000 +0200
+++ vim63-bonobo/src/configure.in	2005-09-09 20:14:02.703589256 +0200
@@ -56,6 +56,7 @@
   sh ./toolcheck 1>&AC_FD_MSG
 fi
 
+EXTRA_TARGETS="";
 OS_EXTRA_SRC=""; OS_EXTRA_OBJ=""
 
 dnl Check for BeOS, which needs an extra source file
@@ -123,6 +124,7 @@
 
 AC_SUBST(OS_EXTRA_SRC)
 AC_SUBST(OS_EXTRA_OBJ)
+AC_SUBST(EXTRA_TARGETS)
 
 dnl Add /usr/local/lib to $LDFLAGS and /usr/local/include to CFLAGS.
 dnl Only when the directory exists and it wasn't there yet.
@@ -1831,6 +1833,23 @@
 	  AC_DEFINE(FEAT_GUI_GNOME)
 	  GUI_INC_LOC="$GUI_INC_LOC $GNOME_INCLUDEDIR"
 	  GTK_LIBNAME="$GTK_LIBNAME $GNOME_LIBDIR $GNOME_LIBS"
+          AC_MSG_CHECKING(whether or not to include bonobo support)
+          AC_ARG_ENABLE(bonobo,
+            [  --enable-bonobo         If using GNOME, enable bonobo support [default=no]],
+            , enable_bonobo="no")
+          if test "x$enable_bonobo" = "xno"; then
+            AC_MSG_RESULT($enable_bonobo);
+          else
+            if test "x$SKIP_BONOBO" != "xYES" -a $gtk_major_version -ge 2; then
+              AC_MSG_RESULT(yes);
+              AC_DEFINE(FEAT_GUI_COMPONENT) 
+              GUITYPE=BONOBO
+              VIMNAME="vim-component"
+              EXTRA_TARGETS="vim-factory Vim_Control.server"
+            else
+              AC_MSG_RESULT(no (Bonobo requires Gnome 2));
+            fi
+          fi
 	fi
       }
       fi
diff -Nur vim63/src/container.c vim63-bonobo/src/container.c
--- vim63/src/container.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/container.c	2005-09-09 20:14:02.704589104 +0200
@@ -0,0 +1,266 @@
+
+#include <bonobo.h>
+#include <glib.h>
+
+BonoboControlFrame  *ctrl_frame;
+BonoboUIComponent   *ui_comp;
+
+/* vbox */
+GtkWidget           *box;
+GtkWidget           *ctrl_widget;
+
+char * filename;
+
+static Bonobo_Control
+instantiate_control()
+{
+	Bonobo_Control control;
+	Bonobo_PersistFile pfile;
+	Bonobo_PersistStream pstream;
+	CORBA_Environment ev;
+    Bonobo_Stream stream;
+
+	CORBA_exception_init (&ev);
+
+	/* get control component */
+	control = bonobo_get_object ("OAFIID:Vim_Control",
+				     "Bonobo/Control", &ev);
+	if (BONOBO_EX (&ev) || (control == CORBA_OBJECT_NIL))
+    {
+		CORBA_exception_free (&ev);
+        return NULL;
+    }
+	
+#if 0
+	/* get PersistFile interface */
+    pfile = Bonobo_Unknown_queryInterface (control, "IDL:Bonobo/PersistFile:1.0", &ev);
+    if (BONOBO_EX (&ev) || (pfile == CORBA_OBJECT_NIL))
+    exit(1);
+	
+	/* load the file */
+    Bonobo_PersistFile_load (pfile, filename, &ev);
+	bonobo_object_release_unref (pfile, NULL);
+#endif
+
+	/* get PersistStream interface */
+    pstream = Bonobo_Unknown_queryInterface (control, "IDL:Bonobo/PersistStream:1.0", &ev);
+    if (BONOBO_EX (&ev) || (pstream == CORBA_OBJECT_NIL))
+    {
+		CORBA_exception_free (&ev);
+        return NULL;
+    }
+	
+	/* load the file */
+    stream = bonobo_get_object(filename, "IDL:Bonobo/Stream:1.0", &ev);
+	if (ev._major != CORBA_NO_EXCEPTION) {
+        g_warning("Error getting stream interface");
+		bonobo_object_unref (BONOBO_OBJECT (stream));
+		CORBA_exception_free (&ev);
+		return NULL;
+	}
+    Bonobo_PersistStream_load (pstream, stream, "text/plain", &ev);
+	if (ev._major != CORBA_NO_EXCEPTION) {
+        g_warning("Error loading stream!");
+		bonobo_object_unref (BONOBO_OBJECT (stream));
+		CORBA_exception_free (&ev);
+		return NULL;
+	}
+	bonobo_object_release_unref (pstream, NULL);
+    return control;
+}
+
+static void
+verb_FileNewWindow (BonoboUIComponent *uic, gpointer user_data, const char *cname)
+{
+    printf("Got New Window!\n");
+}
+
+static void
+verb_DoNothing (BonoboUIComponent *uic, gpointer user_data, const char *cname)
+{
+}
+
+static BonoboUIVerb app_verbs[] = {
+	BONOBO_UI_VERB ("FileNewWindow", verb_FileNewWindow),
+	BONOBO_UI_VERB ("FileOpen",      verb_DoNothing),
+	BONOBO_UI_VERB ("FileCloseWindow", verb_DoNothing),
+	BONOBO_UI_VERB ("FileExit",      verb_DoNothing),
+	BONOBO_UI_VERB ("Preferences",   verb_DoNothing),
+	BONOBO_UI_VERB ("HelpAbout",     verb_DoNothing),
+	BONOBO_UI_VERB ("Help",          verb_DoNothing),
+	BONOBO_UI_VERB ("DnDNewWindow",  verb_DoNothing),
+	BONOBO_UI_VERB ("DnDSameWindow", verb_DoNothing),
+	BONOBO_UI_VERB ("DnDCancel",     verb_DoNothing),
+	BONOBO_UI_VERB_END
+};
+
+static void 
+add_control_to_ui (BonoboWindow *window, Bonobo_Control control)
+{
+	CORBA_Environment ev;
+	Bonobo_PropertyControl prop_control;
+	BonoboUIContainer *ui_container;
+    char *curdir;
+
+	g_return_if_fail (window != NULL);
+	g_return_if_fail (BONOBO_IS_WINDOW (window));
+	
+	CORBA_exception_init (&ev);
+
+	ui_container = bonobo_window_get_ui_container (BONOBO_WINDOW (window));
+	ctrl_frame = bonobo_control_frame_new (BONOBO_OBJREF (ui_container));
+
+	/* bind and view new control widget */
+	bonobo_control_frame_bind_to_control (ctrl_frame, control, &ev);
+	bonobo_control_frame_control_activate (ctrl_frame);
+	if (control != CORBA_OBJECT_NIL && ctrl_widget == NULL) {
+		ctrl_widget = bonobo_control_frame_get_widget (ctrl_frame);
+		if (!ctrl_widget)
+			g_assert_not_reached ();
+
+        bonobo_window_set_contents (BONOBO_WINDOW(window), GTK_WIDGET(ctrl_widget));
+		gtk_widget_show (ctrl_widget);
+	}
+
+	ui_comp = bonobo_ui_component_new ("vim-container");
+	bonobo_ui_component_set_container (ui_comp, BONOBO_OBJREF (ui_container), NULL);
+
+    curdir = (char *)getcwd(NULL, 0);
+	bonobo_ui_util_set_ui (ui_comp, curdir, "vim-container.xml", "Vim", NULL);
+    free( curdir );
+    bonobo_ui_component_add_verb_list_with_data (ui_comp, app_verbs, window);
+
+	/* update sensitivity of the properties menu item */
+	prop_control = Bonobo_Unknown_queryInterface (control, 
+						      "IDL:Bonobo/PropertyControl:1.0", &ev);
+	bonobo_ui_component_set_prop (ui_comp,
+				      "/commands/Preferences",
+				      "sensitive",
+				      prop_control == CORBA_OBJECT_NIL ? "0" : "1",
+				      &ev);
+	
+	bonobo_object_release_unref (prop_control, &ev);
+
+	/* enable view menu */
+	/* FIXME: We should check if the component adds anything to 
+	 *        the menu, so that we don't view an empty menu.
+	 */
+	/*bonobo_ui_component_set_prop (ui_comp, "/menu/View", "hidden", "0", &ev);*/
+
+	CORBA_exception_free (&ev);
+
+	/* retrieve control properties and install listeners */
+	//check_for_control_properties (window);
+}
+
+static void write_stream_to_file(Bonobo_Control control)
+{
+    Bonobo_Storage storage;
+    gchar * dirname;
+    gchar * basename;
+	CORBA_Environment ev;
+	Bonobo_PersistStream pstream;
+    Bonobo_Stream stream;
+
+    g_warning("write stream to file!");
+	CORBA_exception_init (&ev);
+
+    dirname = g_path_get_dirname(filename);
+    storage = bonobo_get_object(dirname, "IDL:Bonobo/Storage:1.0", &ev);
+    g_free(dirname);
+    if (BONOBO_EX (&ev) || (storage == CORBA_OBJECT_NIL))
+    {
+		CORBA_exception_free (&ev);
+        return;
+    }
+
+    pstream = Bonobo_Unknown_queryInterface (control, "IDL:Bonobo/PersistStream:1.0", &ev);
+    if (BONOBO_EX (&ev) || (pstream == CORBA_OBJECT_NIL))
+    {
+        bonobo_object_release_unref(storage, NULL);
+		CORBA_exception_free (&ev);
+        return;
+    }
+
+    basename = g_path_get_basename(filename);
+    stream = Bonobo_Storage_openStream(storage, basename, Bonobo_Storage_WRITE, &ev );
+    g_free(basename);
+    if (BONOBO_EX (&ev) || (stream == CORBA_OBJECT_NIL))
+    {
+        bonobo_object_release_unref(pstream, NULL);
+        bonobo_object_release_unref(storage, NULL);
+		CORBA_exception_free (&ev);
+        return;
+    }
+
+    Bonobo_PersistStream_save (pstream, stream, "text/plain", &ev);
+	if (ev._major != CORBA_NO_EXCEPTION) {
+        g_warning("Error saving stream!");
+		bonobo_object_unref (BONOBO_OBJECT (stream));
+        bonobo_object_release_unref(pstream, NULL);
+        bonobo_object_release_unref(storage, NULL);
+		CORBA_exception_free (&ev);
+		return;
+	}
+    bonobo_object_release_unref(stream, NULL);
+    bonobo_object_release_unref(pstream, NULL);
+    bonobo_object_release_unref(storage, NULL);
+    return;
+}
+
+static void
+window_destroyed (GtkWindow *window, char * data)
+{
+    Bonobo_Control control;
+
+    control = bonobo_control_frame_get_control(ctrl_frame);
+    write_stream_to_file(control);
+    bonobo_control_frame_control_deactivate(ctrl_frame);
+    bonobo_object_release_unref( control, NULL );
+    bonobo_main_quit();
+}
+
+int main(int argc, char * argv[] ) 
+{
+    BonoboWidget * bw;
+    BonoboWindow      *window;
+	BonoboUIEngine    *engine;
+	BonoboUIContainer *container;
+    Bonobo_Control    control;
+    gchar             *cwd;
+
+    if( argc <= 1 ) { 
+        fprintf(stderr, "%s: not enough args\n", argv[0] );
+        fprintf(stderr, "Usage: %s <text file>\n", argv[0]);
+        exit(1);
+    }
+    cwd = g_get_current_dir();
+    filename = g_build_filename( "file:", cwd, argv[1], NULL );
+    g_free(cwd);
+
+    bonobo_ui_init ("container", "1.0", &argc, argv);
+
+	if(gnome_vfs_init () == FALSE)
+		g_error (_("Could not initialize GnomeVFS!\n"));
+
+	window = BONOBO_WINDOW ( bonobo_window_new ("Window", "Vim Test Container"));
+
+    // instantiate a control
+    control = instantiate_control();
+    if( control == NULL )
+        return 1;
+    
+    // put it into our window
+    add_control_to_ui (window, control);
+
+    g_signal_connect (window, "destroy",
+          G_CALLBACK (window_destroyed),
+          &window);
+
+
+    gtk_widget_show_all( GTK_WIDGET( window ));
+
+    bonobo_main();
+
+    return 0;
+}
diff -Nur vim63/src/ex_cmds2.c vim63-bonobo/src/ex_cmds2.c
--- vim63/src/ex_cmds2.c	2005-09-09 20:11:09.884861000 +0200
+++ vim63-bonobo/src/ex_cmds2.c	2005-09-09 20:14:02.707588648 +0200
@@ -709,6 +709,12 @@
     int		forceit;
     int		allbuf;		/* may write all buffers */
 {
+#ifdef FEAT_GUI_COMPONENT
+    if ( buf->emb_buffer ) {
+	EMSG(_("E467: Cannot close embedded file"));
+        return TRUE;
+    }
+#endif
     if (       !forceit
 	    && bufIsChanged(buf)
 	    && (mult_win || buf->b_nwindows <= 1)
diff -Nur vim63/src/ex_docmd.c vim63-bonobo/src/ex_docmd.c
--- vim63/src/ex_docmd.c	2005-09-09 20:11:10.556759000 +0200
+++ vim63-bonobo/src/ex_docmd.c	2005-09-09 20:14:02.712587888 +0200
@@ -5729,8 +5729,13 @@
     }
     else
     {
+#ifdef FEAT_GUI_COMPONENT
+        EMSG(_(e_compnoquit));
+        not_exiting();
+        return;
+#endif
 #ifdef FEAT_WINDOWS
-	if (only_one_window())	    /* quit last window */
+        if (only_one_window()) 	    /* quit last window */
 #endif
 	    getout(0);
 #ifdef FEAT_WINDOWS
@@ -5751,8 +5756,12 @@
 ex_cquit(eap)
     exarg_T	*eap;
 {
+#ifdef FEAT_GUI_COMPONENT
+    EMSG(_(e_compnoquit));
+    return;
+#endif
     getout(1);	/* this does not always pass on the exit code to the Manx
-		   compiler. why? */
+                   compiler. why? */
 }
 
 /*
@@ -5772,6 +5781,10 @@
 	return;
     }
 # endif
+#ifdef FEAT_GUI_COMPONENT
+    EMSG(_(e_compnoquit));
+    return;
+#endif
     exiting = TRUE;
     if (eap->forceit || !check_changed_any(FALSE))
 	getout(0);
@@ -5966,8 +5979,13 @@
     }
     else
     {
+#ifdef FEAT_GUI_COMPONENT
+        EMSG(_(e_compnoquit));
+        not_exiting();
+        return;
+#endif
 #ifdef FEAT_WINDOWS
-	if (only_one_window())	    /* quit last window, exit Vim */
+        if ( only_one_window())	    /* quit last window, exit Vim */
 #endif
 	    getout(0);
 #ifdef FEAT_WINDOWS
diff -Nur vim63/src/ex_docmd.c.orig vim63-bonobo/src/ex_docmd.c.orig
--- vim63/src/ex_docmd.c.orig	2005-09-09 20:11:10.033839000 +0200
+++ vim63-bonobo/src/ex_docmd.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,9733 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-
-/*
- * ex_docmd.c: functions for executing an Ex command line.
- */
-
-#include "vim.h"
-
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>	    /* for chdir() */
-#endif
-
-static int	quitmore = 0;
-static int	ex_pressedreturn = FALSE;
-#ifndef FEAT_PRINTER
-# define ex_hardcopy	ex_ni
-#endif
-
-#ifdef FEAT_USR_CMDS
-typedef struct ucmd
-{
-    char_u	*uc_name;	/* The command name */
-    long_u	uc_argt;	/* The argument type */
-    char_u	*uc_rep;	/* The command's replacement string */
-    long	uc_def;		/* The default value for a range/count */
-    scid_T	uc_scriptID;	/* SID where the command was defined */
-    int		uc_compl;	/* completion type */
-# if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
-    char_u	*uc_compl_arg;	/* completion argument if any */
-# endif
-} ucmd_T;
-
-#define UC_BUFFER	1	/* -buffer: local to current buffer */
-
-garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};
-
-#define USER_CMD(i) (&((ucmd_T *)(ucmds.ga_data))[i])
-#define USER_CMD_GA(gap, i) (&((ucmd_T *)((gap)->ga_data))[i])
-
-static void do_ucmd __ARGS((exarg_T *eap));
-static void ex_command __ARGS((exarg_T *eap));
-static void ex_comclear __ARGS((exarg_T *eap));
-static void ex_delcommand __ARGS((exarg_T *eap));
-# ifdef FEAT_CMDL_COMPL
-static char_u *get_user_command_name __ARGS((int idx));
-# endif
-
-#else
-# define ex_command	ex_ni
-# define ex_comclear	ex_ni
-# define ex_delcommand	ex_ni
-#endif
-
-#ifdef FEAT_EVAL
-static char_u	*do_one_cmd __ARGS((char_u **, int, struct condstack *, char_u *(*getline)(int, void *, int), void *cookie));
-#else
-static char_u	*do_one_cmd __ARGS((char_u **, int, char_u *(*getline)(int, void *, int), void *cookie));
-static int	if_level = 0;		/* depth in :if */
-#endif
-static int	checkforcmd __ARGS((char_u **pp, char *cmd, int len));
-static char_u	*find_command __ARGS((exarg_T *eap, int *full));
-
-static void	ex_abbreviate __ARGS((exarg_T *eap));
-static void	ex_map __ARGS((exarg_T *eap));
-static void	ex_unmap __ARGS((exarg_T *eap));
-static void	ex_mapclear __ARGS((exarg_T *eap));
-static void	ex_abclear __ARGS((exarg_T *eap));
-#ifndef FEAT_MENU
-# define ex_emenu		ex_ni
-# define ex_menu		ex_ni
-# define ex_menutranslate	ex_ni
-#endif
-#ifdef FEAT_AUTOCMD
-static void	ex_autocmd __ARGS((exarg_T *eap));
-static void	ex_doautocmd __ARGS((exarg_T *eap));
-#else
-# define ex_autocmd		ex_ni
-# define ex_doautocmd		ex_ni
-# define ex_doautoall		ex_ni
-#endif
-#ifdef FEAT_LISTCMDS
-static void	ex_bunload __ARGS((exarg_T *eap));
-static void	ex_buffer __ARGS((exarg_T *eap));
-static void	ex_bmodified __ARGS((exarg_T *eap));
-static void	ex_bnext __ARGS((exarg_T *eap));
-static void	ex_bprevious __ARGS((exarg_T *eap));
-static void	ex_brewind __ARGS((exarg_T *eap));
-static void	ex_blast __ARGS((exarg_T *eap));
-#else
-# define ex_bunload		ex_ni
-# define ex_buffer		ex_ni
-# define ex_bmodified		ex_ni
-# define ex_bnext		ex_ni
-# define ex_bprevious		ex_ni
-# define ex_brewind		ex_ni
-# define ex_blast		ex_ni
-# define buflist_list		ex_ni
-# define ex_checktime		ex_ni
-#endif
-#if !defined(FEAT_LISTCMDS) || !defined(FEAT_WINDOWS)
-# define ex_buffer_all		ex_ni
-#endif
-static char_u	*getargcmd __ARGS((char_u **));
-static char_u	*skip_cmd_arg __ARGS((char_u *p, int rembs));
-static int	getargopt __ARGS((exarg_T *eap));
-#ifndef FEAT_QUICKFIX
-# define ex_make		ex_ni
-# define ex_cc			ex_ni
-# define ex_cnext		ex_ni
-# define ex_cfile		ex_ni
-# define qf_list		ex_ni
-# define qf_age			ex_ni
-# define ex_helpgrep		ex_ni
-#endif
-#if !defined(FEAT_QUICKFIX) || !defined(FEAT_WINDOWS)
-# define ex_cclose		ex_ni
-# define ex_copen		ex_ni
-# define ex_cwindow		ex_ni
-#endif
-
-static int	check_more __ARGS((int, int));
-static linenr_T get_address __ARGS((char_u **, int skip, int to_other_file));
-#if !defined(FEAT_PERL) || !defined(FEAT_PYTHON) || !defined(FEAT_TCL) \
-	|| !defined(FEAT_RUBY)
-static void	ex_script_ni __ARGS((exarg_T *eap));
-#endif
-static char_u	*invalid_range __ARGS((exarg_T *eap));
-static void	correct_range __ARGS((exarg_T *eap));
-static char_u	*repl_cmdline __ARGS((exarg_T *eap, char_u *src, int srclen, char_u *repl, char_u **cmdlinep));
-static void	ex_highlight __ARGS((exarg_T *eap));
-static void	ex_colorscheme __ARGS((exarg_T *eap));
-static void	ex_quit __ARGS((exarg_T *eap));
-static void	ex_cquit __ARGS((exarg_T *eap));
-static void	ex_quit_all __ARGS((exarg_T *eap));
-#ifdef FEAT_WINDOWS
-static void	ex_close __ARGS((exarg_T *eap));
-static void	ex_win_close __ARGS((exarg_T *eap, win_T *win));
-static void	ex_only __ARGS((exarg_T *eap));
-static void	ex_all __ARGS((exarg_T *eap));
-static void	ex_resize __ARGS((exarg_T *eap));
-static void	ex_stag __ARGS((exarg_T *eap));
-#else
-# define ex_close		ex_ni
-# define ex_only		ex_ni
-# define ex_all			ex_ni
-# define ex_resize		ex_ni
-# define ex_splitview		ex_ni
-# define ex_stag		ex_ni
-#endif
-#if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-static void	ex_pclose __ARGS((exarg_T *eap));
-static void	ex_ptag __ARGS((exarg_T *eap));
-static void	ex_pedit __ARGS((exarg_T *eap));
-#else
-# define ex_pclose		ex_ni
-# define ex_ptag		ex_ni
-# define ex_pedit		ex_ni
-#endif
-static void	ex_hide __ARGS((exarg_T *eap));
-static void	ex_stop __ARGS((exarg_T *eap));
-static void	ex_exit __ARGS((exarg_T *eap));
-static void	ex_print __ARGS((exarg_T *eap));
-#ifdef FEAT_BYTEOFF
-static void	ex_goto __ARGS((exarg_T *eap));
-#else
-# define ex_goto		ex_ni
-#endif
-static void	ex_shell __ARGS((exarg_T *eap));
-static void	ex_preserve __ARGS((exarg_T *eap));
-static void	ex_recover __ARGS((exarg_T *eap));
-#ifndef FEAT_LISTCMDS
-# define ex_argedit		ex_ni
-# define ex_argadd		ex_ni
-# define ex_argdelete		ex_ni
-# define ex_listdo		ex_ni
-#endif
-static void	ex_mode __ARGS((exarg_T *eap));
-static void	ex_wrongmodifier __ARGS((exarg_T *eap));
-static void	ex_find __ARGS((exarg_T *eap));
-static void	ex_edit __ARGS((exarg_T *eap));
-#if !defined(FEAT_GUI) && !defined(FEAT_CLIENTSERVER)
-# define ex_drop		ex_ni
-#endif
-#ifndef FEAT_GUI
-# define ex_gui			ex_nogui
-static void	ex_nogui __ARGS((exarg_T *eap));
-#endif
-#if defined(FEAT_GUI_W32) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)
-static void	ex_tearoff __ARGS((exarg_T *eap));
-#else
-# define ex_tearoff		ex_ni
-#endif
-#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK)) && defined(FEAT_MENU)
-static void	ex_popup __ARGS((exarg_T *eap));
-#else
-# define ex_popup		ex_ni
-#endif
-#ifndef FEAT_GUI_MSWIN
-# define ex_simalt		ex_ni
-#endif
-#if !defined(FEAT_GUI_MSWIN) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)
-# define gui_mch_find_dialog	ex_ni
-# define gui_mch_replace_dialog ex_ni
-#endif
-#ifndef FEAT_GUI_GTK
-# define ex_helpfind		ex_ni
-#endif
-#ifndef FEAT_CSCOPE
-# define do_cscope		ex_ni
-# define do_scscope		ex_ni
-# define do_cstag		ex_ni
-#endif
-#ifndef FEAT_SYN_HL
-# define ex_syntax		ex_ni
-#endif
-#ifndef FEAT_PERL
-# define ex_perl		ex_script_ni
-# define ex_perldo		ex_ni
-#endif
-#ifndef FEAT_PYTHON
-# define ex_python		ex_script_ni
-# define ex_pyfile		ex_ni
-#endif
-#ifndef FEAT_TCL
-# define ex_tcl			ex_script_ni
-# define ex_tcldo		ex_ni
-# define ex_tclfile		ex_ni
-#endif
-#ifndef FEAT_RUBY
-# define ex_ruby		ex_script_ni
-# define ex_rubydo		ex_ni
-# define ex_rubyfile		ex_ni
-#endif
-#ifndef FEAT_SNIFF
-# define ex_sniff		ex_ni
-#endif
-#ifndef FEAT_KEYMAP
-# define ex_loadkeymap		ex_ni
-#endif
-static void	ex_swapname __ARGS((exarg_T *eap));
-static void	ex_syncbind __ARGS((exarg_T *eap));
-static void	ex_read __ARGS((exarg_T *eap));
-static void	ex_cd __ARGS((exarg_T *eap));
-static void	ex_pwd __ARGS((exarg_T *eap));
-static void	ex_equal __ARGS((exarg_T *eap));
-static void	ex_sleep __ARGS((exarg_T *eap));
-static void	do_exmap __ARGS((exarg_T *eap, int isabbrev));
-static void	ex_winsize __ARGS((exarg_T *eap));
-#ifdef FEAT_WINDOWS
-static void	ex_wincmd __ARGS((exarg_T *eap));
-#else
-# define ex_wincmd	    ex_ni
-#endif
-#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS)
-static void	ex_winpos __ARGS((exarg_T *eap));
-#else
-# define ex_winpos	    ex_ni
-#endif
-static void	ex_operators __ARGS((exarg_T *eap));
-static void	ex_put __ARGS((exarg_T *eap));
-static void	ex_copymove __ARGS((exarg_T *eap));
-static void	ex_submagic __ARGS((exarg_T *eap));
-static void	ex_join __ARGS((exarg_T *eap));
-static void	ex_at __ARGS((exarg_T *eap));
-static void	ex_bang __ARGS((exarg_T *eap));
-static void	ex_undo __ARGS((exarg_T *eap));
-static void	ex_redo __ARGS((exarg_T *eap));
-static void	ex_redir __ARGS((exarg_T *eap));
-static void	ex_redraw __ARGS((exarg_T *eap));
-static void	ex_redrawstatus __ARGS((exarg_T *eap));
-static void	close_redir __ARGS((void));
-static void	ex_mkrc __ARGS((exarg_T *eap));
-static void	ex_mark __ARGS((exarg_T *eap));
-#ifdef FEAT_USR_CMDS
-static char_u	*uc_fun_cmd __ARGS((void));
-#endif
-#ifdef FEAT_EX_EXTRA
-static void	ex_normal __ARGS((exarg_T *eap));
-static void	ex_startinsert __ARGS((exarg_T *eap));
-static void	ex_stopinsert __ARGS((exarg_T *eap));
-#else
-# define ex_normal		ex_ni
-# define ex_align		ex_ni
-# define ex_retab		ex_ni
-# define ex_startinsert		ex_ni
-# define ex_stopinsert		ex_ni
-# define ex_helptags		ex_ni
-#endif
-#ifdef FEAT_FIND_ID
-static void	ex_checkpath __ARGS((exarg_T *eap));
-static void	ex_findpat __ARGS((exarg_T *eap));
-#else
-# define ex_findpat		ex_ni
-# define ex_checkpath		ex_ni
-#endif
-#if defined(FEAT_FIND_ID) && defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-static void	ex_psearch __ARGS((exarg_T *eap));
-#else
-# define ex_psearch		ex_ni
-#endif
-static void	ex_tag __ARGS((exarg_T *eap));
-static void	ex_tag_cmd __ARGS((exarg_T *eap, char_u *name));
-#ifndef FEAT_EVAL
-# define ex_scriptnames		ex_ni
-# define ex_finish		ex_ni
-# define ex_echo		ex_ni
-# define ex_echohl		ex_ni
-# define ex_execute		ex_ni
-# define ex_call		ex_ni
-# define ex_if			ex_ni
-# define ex_endif		ex_ni
-# define ex_else		ex_ni
-# define ex_while		ex_ni
-# define ex_continue		ex_ni
-# define ex_break		ex_ni
-# define ex_endwhile		ex_ni
-# define ex_throw		ex_ni
-# define ex_try			ex_ni
-# define ex_catch		ex_ni
-# define ex_finally		ex_ni
-# define ex_endtry		ex_ni
-# define ex_endfunction		ex_ni
-# define ex_let			ex_ni
-# define ex_unlet		ex_ni
-# define ex_function		ex_ni
-# define ex_delfunction		ex_ni
-# define ex_return		ex_ni
-#endif
-static char_u	*arg_all __ARGS((void));
-#ifdef FEAT_SESSION
-static int	makeopens __ARGS((FILE *fd, char_u *dirnow));
-static int	put_view __ARGS((FILE *fd, win_T *wp, int add_edit, unsigned *flagp));
-static void	ex_loadview __ARGS((exarg_T *eap));
-static char_u	*get_view_file __ARGS((int c));
-#else
-# define ex_loadview		ex_ni
-#endif
-#ifndef FEAT_EVAL
-# define ex_compiler		ex_ni
-#endif
-#ifdef FEAT_VIMINFO
-static void	ex_viminfo __ARGS((exarg_T *eap));
-#else
-# define ex_viminfo		ex_ni
-#endif
-static void	ex_behave __ARGS((exarg_T *eap));
-#ifdef FEAT_AUTOCMD
-static void	ex_filetype __ARGS((exarg_T *eap));
-static void	ex_setfiletype  __ARGS((exarg_T *eap));
-#else
-# define ex_filetype		ex_ni
-# define ex_setfiletype		ex_ni
-#endif
-#ifndef FEAT_DIFF
-# define ex_diffpatch		ex_ni
-# define ex_diffgetput		ex_ni
-# define ex_diffsplit		ex_ni
-# define ex_diffthis		ex_ni
-# define ex_diffupdate		ex_ni
-#endif
-static void	ex_digraphs __ARGS((exarg_T *eap));
-static void	ex_set __ARGS((exarg_T *eap));
-#if !defined(FEAT_EVAL) || !defined(FEAT_AUTOCMD)
-# define ex_options		ex_ni
-#endif
-#ifdef FEAT_SEARCH_EXTRA
-static void	ex_nohlsearch __ARGS((exarg_T *eap));
-static void	ex_match __ARGS((exarg_T *eap));
-#else
-# define ex_nohlsearch		ex_ni
-# define ex_match		ex_ni
-#endif
-#ifdef FEAT_CRYPT
-static void	ex_X __ARGS((exarg_T *eap));
-#else
-# define ex_X			ex_ni
-#endif
-#ifdef FEAT_FOLDING
-static void	ex_fold __ARGS((exarg_T *eap));
-static void	ex_foldopen __ARGS((exarg_T *eap));
-static void	ex_folddo __ARGS((exarg_T *eap));
-#else
-# define ex_fold		ex_ni
-# define ex_foldopen		ex_ni
-# define ex_folddo		ex_ni
-#endif
-#if !((defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
-	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE)))
-# define ex_language		ex_ni
-#endif
-#ifndef FEAT_SIGNS
-# define ex_sign		ex_ni
-#endif
-#ifndef FEAT_SUN_WORKSHOP
-# define ex_wsverb		ex_ni
-#endif
-
-#ifndef FEAT_EVAL
-# define ex_debug		ex_ni
-# define ex_breakadd		ex_ni
-# define ex_debuggreedy		ex_ni
-# define ex_breakdel		ex_ni
-# define ex_breaklist		ex_ni
-#endif
-
-#ifndef FEAT_CMDHIST
-# define ex_history		ex_ni
-#endif
-#ifndef FEAT_JUMPLIST
-# define ex_jumps		ex_ni
-# define ex_changes		ex_ni
-#endif
-
-/*
- * Declare cmdnames[].
- */
-#define DO_DECLARE_EXCMD
-#include "ex_cmds.h"
-
-/*
- * Table used to quickly search for a command, based on its first character.
- */
-cmdidx_T cmdidxs[27] =
-{
-	CMD_append,
-	CMD_buffer,
-	CMD_change,
-	CMD_delete,
-	CMD_edit,
-	CMD_file,
-	CMD_global,
-	CMD_help,
-	CMD_insert,
-	CMD_join,
-	CMD_k,
-	CMD_list,
-	CMD_move,
-	CMD_next,
-	CMD_open,
-	CMD_print,
-	CMD_quit,
-	CMD_read,
-	CMD_substitute,
-	CMD_t,
-	CMD_undo,
-	CMD_vglobal,
-	CMD_write,
-	CMD_xit,
-	CMD_yank,
-	CMD_z,
-	CMD_bang
-};
-
-static char_u dollar_command[2] = {'$', 0};
-
-
-#ifdef FEAT_EVAL
-/* Struct for storing a line inside a while loop */
-typedef struct
-{
-    char_u	*line;		/* command line */
-    linenr_T	lnum;		/* sourcing_lnum of the line */
-} wcmd_T;
-
-/*
- * Structure used to store info for line position in a while loop.
- * This is required, because do_one_cmd() may invoke ex_function(), which
- * reads more lines that may come from the while loop.
- */
-struct while_cookie
-{
-    garray_T	*lines_gap;		/* growarray with line info */
-    int		current_line;		/* last read line from growarray */
-    int		repeating;		/* TRUE when looping a second time */
-    /* When "repeating" is FALSE use "getline" and "cookie" to get lines */
-    char_u	*(*getline) __ARGS((int, void *, int));
-    void	*cookie;
-};
-
-static char_u	*get_while_line __ARGS((int c, void *cookie, int indent));
-static int	store_while_line __ARGS((garray_T *gap, char_u *line));
-static void	free_cmdlines __ARGS((garray_T *gap));
-#endif
-
-
-/*
- * do_exmode(): Repeatedly get commands for the "Ex" mode, until the ":vi"
- * command is given.
- */
-    void
-do_exmode(improved)
-    int		improved;	    /* TRUE for "improved Ex" mode */
-{
-    int		save_msg_scroll;
-    int		prev_msg_row;
-    linenr_T	prev_line;
-
-    save_msg_scroll = msg_scroll;
-    ++RedrawingDisabled;	    /* don't redisplay the window */
-    ++no_wait_return;		    /* don't wait for return */
-    if (improved)
-	exmode_active = EXMODE_VIM;
-    else
-    {
-	settmode(TMODE_COOK);
-	exmode_active = EXMODE_NORMAL;
-    }
-
-    State = NORMAL;
-#ifdef FEAT_GUI
-    /* Ignore scrollbar and mouse events in Ex mode */
-    ++hold_gui_events;
-#endif
-#ifdef FEAT_SNIFF
-    want_sniff_request = 0;    /* No K_SNIFF wanted */
-#endif
-
-    MSG(_("Entering Ex mode.  Type \"visual\" to go to Normal mode."));
-    while (exmode_active)
-    {
-#ifdef FEAT_EX_EXTRA
-	/* Check for a ":normal" command and no more characters left. */
-	if (ex_normal_busy > 0 && typebuf.tb_len == 0)
-	{
-	    exmode_active = FALSE;
-	    break;
-	}
-#endif
-	msg_scroll = TRUE;
-	need_wait_return = FALSE;
-	ex_pressedreturn = FALSE;
-	ex_no_reprint = FALSE;
-	prev_msg_row = msg_row;
-	prev_line = curwin->w_cursor.lnum;
-#ifdef FEAT_SNIFF
-	ProcessSniffRequests();
-#endif
-	if (improved)
-	{
-	    cmdline_row = msg_row;
-	    do_cmdline(NULL, getexline, NULL, 0);
-	}
-	else
-	    do_cmdline(NULL, getexmodeline, NULL, DOCMD_NOWAIT);
-	lines_left = Rows - 1;
-
-	if (prev_line != curwin->w_cursor.lnum && !ex_no_reprint)
-	{
-	    if (ex_pressedreturn)
-	    {
-		/* go up one line, to overwrite the ":<CR>" line, so the
-		 * output doensn't contain empty lines. */
-		msg_row = prev_msg_row;
-		if (prev_msg_row == Rows - 1)
-		    msg_row--;
-	    }
-	    msg_col = 0;
-	    print_line_no_prefix(curwin->w_cursor.lnum, FALSE);
-	    msg_clr_eos();
-	}
-	else if (ex_pressedreturn)	/* must be at EOF */
-	    EMSG(_("E501: At end-of-file"));
-    }
-
-#ifdef FEAT_GUI
-    --hold_gui_events;
-#endif
-    if (!improved)
-	settmode(TMODE_RAW);
-    --RedrawingDisabled;
-    --no_wait_return;
-    update_screen(CLEAR);
-    need_wait_return = FALSE;
-    msg_scroll = save_msg_scroll;
-}
-
-/*
- * Execute a simple command line.  Used for translated commands like "*".
- */
-    int
-do_cmdline_cmd(cmd)
-    char_u	*cmd;
-{
-    return do_cmdline(cmd, NULL, NULL,
-				   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);
-}
-
-/*
- * do_cmdline(): execute one Ex command line
- *
- * 1. Execute "cmdline" when it is not NULL.
- *    If "cmdline" is NULL, or more lines are needed, getline() is used.
- * 2. Split up in parts separated with '|'.
- *
- * This function can be called recursively!
- *
- * flags:
- * DOCMD_VERBOSE  - The command will be included in the error message.
- * DOCMD_NOWAIT   - Don't call wait_return() and friends.
- * DOCMD_REPEAT   - Repeat execution until getline() returns NULL.
- * DOCMD_KEYTYPED - Don't reset KeyTyped.
- * DOCMD_EXCRESET - Reset the exception environment (used for debugging).
- * DOCMD_KEEPLINE - Store first typed line (for repeating with ".").
- *
- * return FAIL if cmdline could not be executed, OK otherwise
- */
-    int
-do_cmdline(cmdline, getline, cookie, flags)
-    char_u	*cmdline;
-    char_u	*(*getline) __ARGS((int, void *, int));
-    void	*cookie;		/* argument for getline() */
-    int		flags;
-{
-    char_u	*next_cmdline;		/* next cmd to execute */
-    char_u	*cmdline_copy = NULL;	/* copy of cmd line */
-    int		used_getline = FALSE;	/* used "getline" to obtain command */
-    static int	recursive = 0;		/* recursive depth */
-    int		msg_didout_before_start = 0;
-    int		count = 0;		/* line number count */
-    int		did_inc = FALSE;	/* incremented RedrawingDisabled */
-    int		retval = OK;
-#ifdef FEAT_EVAL
-    struct condstack cstack;		/* conditional stack */
-    garray_T	lines_ga;		/* keep lines for ":while" */
-    int		current_line = 0;	/* active line in lines_ga */
-    char_u	*fname = NULL;		/* function or script name */
-    linenr_T	*breakpoint = NULL;	/* ptr to breakpoint field in cookie */
-    int		*dbg_tick = NULL;	/* ptr to dbg_tick field in cookie */
-    int		saved_trylevel = 0;
-    int		saved_force_abort = 0;
-    except_T	*saved_caught_stack = NULL;
-    char_u	*saved_vv_exception = NULL;
-    char_u	*saved_vv_throwpoint = NULL;
-    int		saved_did_emsg = 0;
-    int		saved_got_int = 0;
-    int		saved_did_throw = 0;
-    int		saved_need_rethrow = 0;
-    int		saved_check_cstack = 0;
-    except_T	*saved_current_exception = NULL;
-    int		initial_trylevel;
-    struct msglist	**saved_msg_list = NULL;
-    struct msglist	*private_msg_list;
-
-    /* "getline" and "cookie" passed to do_one_cmd() */
-    char_u	*(*cmd_getline) __ARGS((int, void *, int));
-    void	*cmd_cookie;
-    struct while_cookie cmd_while_cookie;
-    void	*real_cookie;
-#else
-# define cmd_getline getline
-# define cmd_cookie cookie
-#endif
-    static int	call_depth = 0;		/* recursiveness */
-
-#ifdef FEAT_EVAL
-    /* For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory
-     * location for storing error messages to be converted to an exception.
-     * This ensures that the do_errthrow() call in do_one_cmd() does not combine
-     * the messages stored by an earlier invocation of do_one_cmd() with the
-     * command name of the later one.  This would happen when BufWritePost
-     * autocommands are executed after a write error. */
-    saved_msg_list = msg_list;
-    msg_list = &private_msg_list;
-    private_msg_list = NULL;
-#endif
-
-    /* It's possible to create an endless loop with ":execute", catch that
-     * here.  The value of 200 allows nested function calls, ":source", etc. */
-    if (call_depth == 200)
-    {
-	EMSG(_("E169: Command too recursive"));
-#ifdef FEAT_EVAL
-	/* When converting to an exception, we do not include the command name
-	 * since this is not an error of the specific command. */
-	do_errthrow((struct condstack *)NULL, (char_u *)NULL);
-	msg_list = saved_msg_list;
-#endif
-	return FAIL;
-    }
-    ++call_depth;
-
-#ifdef FEAT_EVAL
-    cstack.cs_idx = -1;
-    cstack.cs_whilelevel = 0;
-    cstack.cs_trylevel = 0;
-    cstack.cs_emsg_silent_list = NULL;
-    cstack.cs_had_while = FALSE;
-    cstack.cs_had_endwhile = FALSE;
-    cstack.cs_had_continue = FALSE;
-    cstack.cs_had_finally = FALSE;
-    ga_init2(&lines_ga, (int)sizeof(wcmd_T), 10);
-
-    real_cookie = getline_cookie(getline, cookie);
-
-    /* Inside a function use a higher nesting level. */
-    if (getline_equal(getline, cookie, get_func_line)
-			       && ex_nesting_level == func_level(real_cookie))
-	++ex_nesting_level;
-
-    /* Get the function or script name and the address where the next breakpoint
-     * line and the debug tick for a function or script are stored. */
-    if (getline_equal(getline, cookie, get_func_line))
-    {
-	fname = func_name(real_cookie);
-	breakpoint = func_breakpoint(real_cookie);
-	dbg_tick = func_dbg_tick(real_cookie);
-    }
-    else if (getline_equal(getline, cookie, getsourceline))
-    {
-	fname = sourcing_name;
-	breakpoint = source_breakpoint(real_cookie);
-	dbg_tick = source_dbg_tick(real_cookie);
-    }
-
-    /*
-     * Initialize "force_abort"  and "suppress_errthrow" at the top level.
-     */
-    if (!recursive)
-    {
-	force_abort = FALSE;
-	suppress_errthrow = FALSE;
-    }
-
-    /*
-     * If requested, store and reset the global values controlling the
-     * exception handling (used when debugging).
-     */
-    else if (flags & DOCMD_EXCRESET)
-    {
-	saved_trylevel		= trylevel;		trylevel = 0;
-	saved_force_abort	= force_abort;		force_abort = FALSE;
-	saved_caught_stack	= caught_stack;		caught_stack = NULL;
-	saved_vv_exception	= v_exception(NULL);
-	saved_vv_throwpoint	= v_throwpoint(NULL);
-	/* Necessary for debugging an inactive ":catch", ":finally", or
-	 * ":endtry": */
-	saved_did_emsg		= did_emsg,		did_emsg     = FALSE;
-	saved_got_int		= got_int,		got_int	     = FALSE;
-	saved_did_throw		= did_throw,		did_throw    = FALSE;
-	saved_need_rethrow	= need_rethrow,		need_rethrow = FALSE;
-	saved_check_cstack	= check_cstack,		check_cstack = FALSE;
-	saved_current_exception = current_exception;	current_exception=NULL;
-    }
-
-    initial_trylevel = trylevel;
-
-    /*
-     * "did_throw" will be set to TRUE when an exception is being thrown.
-     */
-    did_throw = FALSE;
-#endif
-    /*
-     * "did_emsg" will be set to TRUE when emsg() is used, in which case we
-     * cancel the whole command line, and any if/endif while/endwhile loop.
-     * If force_abort is set, we cancel everything.
-     */
-    did_emsg = FALSE;
-
-    /*
-     * KeyTyped is only set when calling vgetc().  Reset it here when not
-     * calling vgetc() (sourced command lines).
-     */
-    if (!(flags & DOCMD_KEYTYPED) && !getline_equal(getline, cookie, getexline))
-	KeyTyped = FALSE;
-
-    /*
-     * Continue executing command lines:
-     * - when inside an ":if" or ":while"
-     * - for multiple commands on one line, separated with '|'
-     * - when repeating until there are no more lines (for ":source")
-     */
-    next_cmdline = cmdline;
-    do
-    {
-	/* stop skipping cmds for an error msg after all endifs and endwhiles */
-	if (next_cmdline == NULL
-#ifdef FEAT_EVAL
-		&& !force_abort
-		&& cstack.cs_idx < 0
-		&& !(getline_equal(getline, cookie, get_func_line)
-					       && func_has_abort(real_cookie))
-#endif
-							)
-	    did_emsg = FALSE;
-
-	/*
-	 * 1. If repeating a line with ":while", get a line from lines_ga.
-	 * 2. If no line given: Get an allocated line with getline().
-	 * 3. If a line is given: Make a copy, so we can mess with it.
-	 */
-
-#ifdef FEAT_EVAL
-	/* 1. If repeating, get a previous line from lines_ga. */
-	if (cstack.cs_whilelevel && current_line < lines_ga.ga_len)
-	{
-	    /* Each '|' separated command is stored separately in lines_ga, to
-	     * be able to jump to it.  Don't use next_cmdline now. */
-	    vim_free(cmdline_copy);
-	    cmdline_copy = NULL;
-
-	    /* Check if a function has returned or, unless it has an unclosed
-	     * try conditional, aborted. */
-	    if (getline_equal(getline, cookie, get_func_line)
-					       && func_has_ended(real_cookie))
-	    {
-		retval = FAIL;
-		break;
-	    }
-
-	    /* Check if a sourced file hit a ":finish" command. */
-	    if (source_finished(getline, cookie))
-	    {
-		retval = FAIL;
-		break;
-	    }
-
-	    /* If breakpoints have been added/deleted need to check for it. */
-	    if (breakpoint != NULL && dbg_tick != NULL
-						   && *dbg_tick != debug_tick)
-	    {
-		*breakpoint = dbg_find_breakpoint(
-				getline_equal(getline, cookie, getsourceline),
-							fname, sourcing_lnum);
-		*dbg_tick = debug_tick;
-	    }
-
-	    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;
-	    sourcing_lnum = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;
-
-	    /* Did we encounter a breakpoint? */
-	    if (breakpoint != NULL && *breakpoint != 0
-					      && *breakpoint <= sourcing_lnum)
-	    {
-		dbg_breakpoint(fname, sourcing_lnum);
-		/* Find next breakpoint. */
-		*breakpoint = dbg_find_breakpoint(
-				getline_equal(getline, cookie, getsourceline),
-							fname, sourcing_lnum);
-		*dbg_tick = debug_tick;
-	    }
-	}
-
-	if (cstack.cs_whilelevel)
-	{
-	    /* Inside a while loop we need to store the lines and use them
-	     * again.  Pass a different "getline" function to do_one_cmd()
-	     * below, so that it stores lines in or reads them from
-	     * "lines_ga".  Makes it possible to define a function inside a
-	     * while loop. */
-	    cmd_getline = get_while_line;
-	    cmd_cookie = (void *)&cmd_while_cookie;
-	    cmd_while_cookie.lines_gap = &lines_ga;
-	    cmd_while_cookie.current_line = current_line;
-	    cmd_while_cookie.getline = getline;
-	    cmd_while_cookie.cookie = cookie;
-	    cmd_while_cookie.repeating = (current_line < lines_ga.ga_len);
-	}
-	else
-	{
-	    cmd_getline = getline;
-	    cmd_cookie = cookie;
-	}
-#endif
-
-	/* 2. If no line given, get an allocated line with getline(). */
-	if (next_cmdline == NULL)
-	{
-	    /*
-	     * Need to set msg_didout for the first line after an ":if",
-	     * otherwise the ":if" will be overwritten.
-	     */
-	    if (count == 1 && getline_equal(getline, cookie, getexline))
-		msg_didout = TRUE;
-	    if (getline == NULL || (next_cmdline = getline(':', cookie,
-#ifdef FEAT_EVAL
-		    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2
-#else
-		    0
-#endif
-			    )) == NULL)
-	    {
-		/* Don't call wait_return for aborted command line.  The NULL
-		 * returned for the end of a sourced file or executed function
-		 * doesn't do this. */
-		if (KeyTyped && !(flags & DOCMD_REPEAT))
-		    need_wait_return = FALSE;
-		retval = FAIL;
-		break;
-	    }
-	    used_getline = TRUE;
-
-	    /*
-	     * Keep the first typed line.  Clear it when more lines are typed.
-	     */
-	    if (flags & DOCMD_KEEPLINE)
-	    {
-		vim_free(repeat_cmdline);
-		if (count == 0)
-		    repeat_cmdline = vim_strsave(next_cmdline);
-		else
-		    repeat_cmdline = NULL;
-	    }
-	}
-
-	/* 3. Make a copy of the command so we can mess with it. */
-	else if (cmdline_copy == NULL)
-	{
-	    next_cmdline = vim_strsave(next_cmdline);
-	    if (next_cmdline == NULL)
-	    {
-		EMSG(_(e_outofmem));
-		retval = FAIL;
-		break;
-	    }
-	}
-	cmdline_copy = next_cmdline;
-
-#ifdef FEAT_EVAL
-	/*
-	 * Save the current line when inside a ":while", and when the command
-	 * looks like a ":while", because we may need it later.
-	 * When there is a '|' and another command, it is stored separately,
-	 * because we need to be able to jump back to it from an :endwhile.
-	 */
-	if (	   current_line == lines_ga.ga_len
-		&& (cstack.cs_whilelevel || has_while_cmd(next_cmdline)))
-	{
-	    if (store_while_line(&lines_ga, next_cmdline) == FAIL)
-	    {
-		retval = FAIL;
-		break;
-	    }
-	}
-	did_endif = FALSE;
-#endif
-
-	if (count++ == 0)
-	{
-	    /*
-	     * All output from the commands is put below each other, without
-	     * waiting for a return. Don't do this when executing commands
-	     * from a script or when being called recursive (e.g. for ":e
-	     * +command file").
-	     */
-	    if (!(flags & DOCMD_NOWAIT) && !recursive)
-	    {
-		msg_didout_before_start = msg_didout;
-		msg_didany = FALSE; /* no output yet */
-		msg_start();
-		msg_scroll = TRUE;  /* put messages below each other */
-		++no_wait_return;   /* dont wait for return until finished */
-		++RedrawingDisabled;
-		did_inc = TRUE;
-	    }
-	}
-
-	if (p_verbose >= 15 && sourcing_name != NULL)
-	{
-	    int	c = -1;
-
-	    ++no_wait_return;
-	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
-	    /* Truncate long lines, smsg() can't handle that. */
-	    if (STRLEN(cmdline_copy) > 200)
-	    {
-		c = cmdline_copy[200];
-		cmdline_copy[200] = NUL;
-	    }
-	    smsg((char_u *)_("line %ld: %s"),
-					   (long)sourcing_lnum, cmdline_copy);
-	    msg_puts((char_u *)"\n");   /* don't overwrite this either */
-	    if (c >= 0)
-		cmdline_copy[200] = c;
-	    cmdline_row = msg_row;
-	    --no_wait_return;
-	}
-
-	/*
-	 * 2. Execute one '|' separated command.
-	 *    do_one_cmd() will return NULL if there is no trailing '|'.
-	 *    "cmdline_copy" can change, e.g. for '%' and '#' expansion.
-	 */
-	++recursive;
-	next_cmdline = do_one_cmd(&cmdline_copy, flags & DOCMD_VERBOSE,
-#ifdef FEAT_EVAL
-				&cstack,
-#endif
-				cmd_getline, cmd_cookie);
-	--recursive;
-
-#ifdef FEAT_EVAL
-	if (cmd_cookie == (void *)&cmd_while_cookie)
-	    /* Use "current_line" from "cmd_while_cookie", it may have been
-	     * incremented when defining a function. */
-	    current_line = cmd_while_cookie.current_line;
-#endif
-
-	if (next_cmdline == NULL)
-	{
-	    vim_free(cmdline_copy);
-	    cmdline_copy = NULL;
-#ifdef FEAT_CMDHIST
-	    /*
-	     * If the command was typed, remember it for the ':' register.
-	     * Do this AFTER executing the command to make :@: work.
-	     */
-	    if (getline_equal(getline, cookie, getexline)
-						  && new_last_cmdline != NULL)
-	    {
-		vim_free(last_cmdline);
-		last_cmdline = new_last_cmdline;
-		new_last_cmdline = NULL;
-	    }
-#endif
-	}
-	else
-	{
-	    /* need to copy the command after the '|' to cmdline_copy, for the
-	     * next do_one_cmd() */
-	    mch_memmove(cmdline_copy, next_cmdline, STRLEN(next_cmdline) + 1);
-	    next_cmdline = cmdline_copy;
-	}
-
-
-#ifdef FEAT_EVAL
-	/* reset did_emsg for a function that is not aborted by an error */
-	if (did_emsg && !force_abort
-		&& getline_equal(getline, cookie, get_func_line)
-					      && !func_has_abort(real_cookie))
-	    did_emsg = FALSE;
-
-	if (cstack.cs_whilelevel)
-	{
-	    ++current_line;
-
-	    /*
-	     * An ":endwhile" and ":continue" is handled here.
-	     * If we were executing commands, jump back to the ":while".
-	     * If we were not executing commands, decrement whilelevel.
-	     */
-	    if (cstack.cs_had_endwhile || cstack.cs_had_continue)
-	    {
-		if (cstack.cs_had_endwhile)
-		    cstack.cs_had_endwhile = FALSE;
-		else
-		    cstack.cs_had_continue = FALSE;
-
-		/* Jump back to the matching ":while".  Be careful not to use
-		 * a cs_line[] from an entry that isn't a ":while": It would
-		 * make "current_line" invalid and can cause a crash. */
-		if (!did_emsg && !got_int && !did_throw
-			&& cstack.cs_idx >= 0
-			&& (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)
-			&& cstack.cs_line[cstack.cs_idx] >= 0
-			&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE))
-		{
-		    current_line = cstack.cs_line[cstack.cs_idx];
-		    cstack.cs_had_while = TRUE;	/* note we jumped there */
-		    line_breakcheck();		/* check if CTRL-C typed */
-
-		    /* Check for the next breakpoint at or after the ":while".*/
-		    if (breakpoint != NULL)
-		    {
-			*breakpoint = dbg_find_breakpoint(
-				getline_equal(getline, cookie, getsourceline),
-									fname,
-			   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);
-			*dbg_tick = debug_tick;
-		    }
-		}
-		else /* can only get here with ":endwhile" */
-		{
-		    --cstack.cs_whilelevel;
-		    if (cstack.cs_idx >= 0)
-			--cstack.cs_idx;
-		}
-	    }
-
-	    /*
-	     * For a ":while" we need to remember the line number.
-	     */
-	    else if (cstack.cs_had_while)
-	    {
-		cstack.cs_had_while = FALSE;
-		cstack.cs_line[cstack.cs_idx] = current_line - 1;
-	    }
-	}
-
-	/*
-	 * When not inside any ":while" loop, clear remembered lines.
-	 */
-	if (!cstack.cs_whilelevel)
-	{
-	    if (lines_ga.ga_len > 0)
-	    {
-		sourcing_lnum =
-		       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;
-		free_cmdlines(&lines_ga);
-	    }
-	    current_line = 0;
-	}
-
-	/*
-	 * A ":finally" makes did_emsg, got_int, and did_throw pending for being
-	 * restored at the ":endtry".  Reset them here and set the ACTIVE and
-	 * FINALLY flags, so that the finally clause gets executed.  This
-	 * includes the case where a missing ":endif" or ":endwhile" was
-	 * detected by the ":finally" itself.
-	 */
-	if (cstack.cs_had_finally)
-	{
-	    cstack.cs_had_finally = FALSE;
-	    report_make_pending(cstack.cs_pending[cstack.cs_idx] &
-		    (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),
-		    did_throw ? (void *)current_exception : NULL);
-	    did_emsg = got_int = did_throw = FALSE;
-	    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;
-	}
-
-	/* Update global "trylevel" for recursive calls to do_cmdline() from
-	 * within this loop. */
-	trylevel = initial_trylevel + cstack.cs_trylevel;
-
-	/*
-	 * If the outermost try conditional (accross function calls and sourced
-	 * files) is aborted because of an error, an interrupt, or an uncaught
-	 * exception, cancel everything.  If it is left normally, reset
-	 * force_abort to get the non-EH compatible abortion behavior for
-	 * the rest of the script.
-	 */
-	if (trylevel == 0 && !did_emsg && !got_int && !did_throw)
-	    force_abort = FALSE;
-
-	/* Convert an interrupt to an exception if appropriate. */
-	(void)do_intthrow(&cstack);
-#endif /* FEAT_EVAL */
-
-    }
-    /*
-     * Continue executing command lines when:
-     * - no CTRL-C typed, no aborting error, no exception thrown or try
-     *   conditionals need to be checked for executing finally clauses or
-     *   catching an interrupt exception
-     * - didn't get an error message or lines are not typed
-     * - there is a command after '|', inside a :if, :while, or :try, or
-     *   looping for ":source" command or function call.
-     */
-    while (!((got_int
-#ifdef FEAT_EVAL
-		    || (did_emsg && force_abort) || did_throw
-#endif
-	     )
-#ifdef FEAT_EVAL
-		&& cstack.cs_trylevel == 0
-#endif
-	    )
-	    && !(did_emsg && used_getline
-			  && (getline_equal(getline, cookie, getexmodeline)
-				|| getline_equal(getline, cookie, getexline)))
-	    && (next_cmdline != NULL
-#ifdef FEAT_EVAL
-			|| cstack.cs_idx >= 0
-#endif
-			|| (flags & DOCMD_REPEAT)));
-
-    vim_free(cmdline_copy);
-#ifdef FEAT_EVAL
-    free_cmdlines(&lines_ga);
-    ga_clear(&lines_ga);
-
-    if (cstack.cs_idx >= 0)
-    {
-	/*
-	 * If a sourced file or executed function ran to its end, report the
-	 * unclosed conditional.
-	 */
-	if (!got_int && !did_throw
-		&& ((getline_equal(getline, cookie, getsourceline)
-			&& !source_finished(getline, cookie))
-		    || (getline_equal(getline, cookie, get_func_line)
-					    && !func_has_ended(real_cookie))))
-	{
-	    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)
-		EMSG(_(e_endtry));
-	    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)
-		EMSG(_(e_endwhile));
-	    else
-		EMSG(_(e_endif));
-	}
-
-	/*
-	 * Reset "trylevel" in case of a ":finish" or ":return" or a missing
-	 * ":endtry" in a sourced file or executed function.  If the try
-	 * conditional is in its finally clause, ignore anything pending.
-	 * If it is in a catch clause, finish the caught exception.
-	 */
-	do
-	    cstack.cs_idx = cleanup_conditionals(&cstack, 0, TRUE);
-	while (--cstack.cs_idx >= 0);
-	trylevel = initial_trylevel;
-    }
-
-    /* If a missing ":endtry", ":endwhile", or ":endif" or a memory lack
-     * was reported above and the error message is to be converted to an
-     * exception, do this now after rewinding the cstack. */
-    do_errthrow(&cstack, getline_equal(getline, cookie, get_func_line)
-				  ? (char_u *)"endfunction" : (char_u *)NULL);
-
-    if (trylevel == 0)
-    {
-	/*
-	 * When an exception is being thrown out of the outermost try
-	 * conditional, discard the uncaught exception, disable the conversion
-	 * of interrupts or errors to exceptions, and ensure that no more
-	 * commands are executed.
-	 */
-	if (did_throw)
-	{
-	    void	*p = NULL;
-	    char_u	*saved_sourcing_name;
-	    int		saved_sourcing_lnum;
-	    struct msglist	*messages = NULL, *next;
-
-	    /*
-	     * If the uncaught exception is a user exception, report it as an
-	     * error.  If it is an error exception, display the saved error
-	     * message now.  For an interrupt exception, do nothing; the
-	     * interrupt message is given elsewhere.
-	     */
-	    switch (current_exception->type)
-	    {
-		case ET_USER:
-		    sprintf((char *)IObuff, _("E605: Exception not caught: %s"),
-			    current_exception->value);
-		    p = vim_strsave(IObuff);
-		    break;
-		case ET_ERROR:
-		    messages = current_exception->messages;
-		    current_exception->messages = NULL;
-		    break;
-		case ET_INTERRUPT:
-		    break;
-		default:
-		    p = vim_strsave((char_u *)_(e_internal));
-	    }
-
-	    saved_sourcing_name = sourcing_name;
-	    saved_sourcing_lnum = sourcing_lnum;
-	    sourcing_name = current_exception->throw_name;
-	    sourcing_lnum = current_exception->throw_lnum;
-	    current_exception->throw_name = NULL;
-
-	    discard_current_exception();	/* uses IObuff if 'verbose' */
-	    suppress_errthrow = TRUE;
-	    force_abort = TRUE;
-
-	    if (messages != NULL)
-	    {
-		do
-		{
-		    next = messages->next;
-		    emsg(messages->msg);
-		    vim_free(messages->msg);
-		    vim_free(messages);
-		    messages = next;
-		}
-		while (messages != NULL);
-	    }
-	    else if (p != NULL)
-	    {
-		emsg(p);
-		vim_free(p);
-	    }
-	    vim_free(sourcing_name);
-	    sourcing_name = saved_sourcing_name;
-	    sourcing_lnum = saved_sourcing_lnum;
-	}
-
-	/*
-	 * On an interrupt or an aborting error not converted to an exception,
-	 * disable the conversion of errors to exceptions.  (Interrupts are not
-	 * converted any more, here.) This enables also the interrupt message
-	 * when force_abort is set and did_emsg unset in case of an interrupt
-	 * from a finally clause after an error.
-	 */
-	else if (got_int || (did_emsg && force_abort))
-	    suppress_errthrow = TRUE;
-    }
-
-    /*
-     * The current cstack will be freed when do_cmdline() returns.  An uncaught
-     * exception will have to be rethrown in the previous cstack.  If a function
-     * has just returned or a script file was just finished and the previous
-     * cstack belongs to the same function or, respectively, script file, it
-     * will have to be checked for finally clauses to be executed due to the
-     * ":return" or ":finish".  This is done in do_one_cmd().
-     */
-    if (did_throw)
-	need_rethrow = TRUE;
-    if ((getline_equal(getline, cookie, getsourceline)
-		&& ex_nesting_level > source_level(real_cookie))
-	    || (getline_equal(getline, cookie, get_func_line)
-		&& ex_nesting_level > func_level(real_cookie) + 1))
-    {
-	if (!did_throw)
-	    check_cstack = TRUE;
-    }
-    else
-    {
-	/* When leaving a function, reduce nesting level. */
-	if (getline_equal(getline, cookie, get_func_line))
-	    --ex_nesting_level;
-	/*
-	 * Go to debug mode when returning from a function in which we are
-	 * single-stepping.
-	 */
-	if ((getline_equal(getline, cookie, getsourceline)
-		    || getline_equal(getline, cookie, get_func_line))
-		&& ex_nesting_level + 1 <= debug_break_level)
-	    do_debug(getline_equal(getline, cookie, getsourceline)
-		    ? (char_u *)_("End of sourced file")
-		    : (char_u *)_("End of function"));
-    }
-
-    /*
-     * Restore the exception environment (done after returning from the
-     * debugger).
-     */
-    if (flags & DOCMD_EXCRESET)
-    {
-	suppress_errthrow = FALSE;
-	trylevel = saved_trylevel;
-	force_abort = saved_force_abort;
-	caught_stack = saved_caught_stack;
-	(void)v_exception(saved_vv_exception);
-	(void)v_throwpoint(saved_vv_throwpoint);
-	/* Necessary for debugging an inactive ":catch", ":finally", or
-	 * ":endtry": */
-	did_emsg = saved_did_emsg;
-	got_int = saved_got_int;
-	did_throw = saved_did_throw;
-	need_rethrow = saved_need_rethrow;
-	check_cstack = saved_check_cstack;
-	current_exception = saved_current_exception;
-    }
-
-    msg_list = saved_msg_list;
-#endif /* FEAT_EVAL */
-
-    /*
-     * If there was too much output to fit on the command line, ask the user to
-     * hit return before redrawing the screen. With the ":global" command we do
-     * this only once after the command is finished.
-     */
-    if (did_inc)
-    {
-	--RedrawingDisabled;
-	--no_wait_return;
-	msg_scroll = FALSE;
-
-	/*
-	 * When just finished an ":if"-":else" which was typed, no need to
-	 * wait for hit-return.  Also for an error situation.
-	 */
-	if (retval == FAIL
-#ifdef FEAT_EVAL
-		|| (did_endif && KeyTyped && !did_emsg)
-#endif
-					    )
-	{
-	    need_wait_return = FALSE;
-	    msg_didany = FALSE;		/* don't wait when restarting edit */
-	}
-	else if (need_wait_return)
-	{
-	    /*
-	     * The msg_start() above clears msg_didout. The wait_return we do
-	     * here should not overwrite the command that may be shown before
-	     * doing that.
-	     */
-	    msg_didout |= msg_didout_before_start;
-	    wait_return(FALSE);
-	}
-    }
-
-#ifndef FEAT_EVAL
-    /*
-     * Reset if_level, in case a sourced script file contains more ":if" than
-     * ":endif" (could be ":if x | foo | endif").
-     */
-    if_level = 0;
-#endif
-
-    --call_depth;
-    return retval;
-}
-
-#ifdef FEAT_EVAL
-/*
- * Obtain a line when inside a ":while" loop.
- */
-    static char_u *
-get_while_line(c, cookie, indent)
-    int		c;
-    void	*cookie;
-    int		indent;
-{
-    struct while_cookie *cp = (struct while_cookie *)cookie;
-    wcmd_T		*wp;
-    char_u		*line;
-
-    if (cp->current_line + 1 >= cp->lines_gap->ga_len)
-    {
-	if (cp->repeating)
-	    return NULL;	/* trying to read past the ":endwhile" */
-
-	/* First time inside the ":while": get line normally. */
-	if (cp->getline == NULL)
-	    line = getcmdline(c, 0L, indent);
-	else
-	    line = cp->getline(c, cp->cookie, indent);
-	if (store_while_line(cp->lines_gap, line) == OK)
-	    ++cp->current_line;
-
-	return line;
-    }
-
-    KeyTyped = FALSE;
-    ++cp->current_line;
-    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line;
-    sourcing_lnum = wp->lnum;
-    return vim_strsave(wp->line);
-}
-
-/*
- * Store a line in "gap" so that a ":while" loop can execute it again.
- */
-    static int
-store_while_line(gap, line)
-    garray_T	*gap;
-    char_u	*line;
-{
-    if (ga_grow(gap, 1) == FAIL)
-	return FAIL;
-    ((wcmd_T *)(gap->ga_data))[gap->ga_len].line = vim_strsave(line);
-    ((wcmd_T *)(gap->ga_data))[gap->ga_len].lnum = sourcing_lnum;
-    ++gap->ga_len;
-    --gap->ga_room;
-    return OK;
-}
-
-/*
- * Free the lines stored for a ":while" loop.
- */
-    static void
-free_cmdlines(gap)
-    garray_T	*gap;
-{
-    while (gap->ga_len > 0)
-    {
-	vim_free(((wcmd_T *)(gap->ga_data))[gap->ga_len - 1].line);
-	--gap->ga_len;
-	++gap->ga_room;
-    }
-}
-#endif
-
-/*
- * If "getline" is get_while_line(), return TRUE if the getline it uses equals
- * "func".  * Otherwise return TRUE when "getline" equals "func".
- */
-/*ARGSUSED*/
-    int
-getline_equal(getline, cookie, func)
-    char_u	*(*getline) __ARGS((int, void *, int));
-    void	*cookie;		/* argument for getline() */
-    char_u	*(*func) __ARGS((int, void *, int));
-{
-#ifdef FEAT_EVAL
-    char_u		*(*gp) __ARGS((int, void *, int));
-    struct while_cookie *cp;
-
-    /* When "getline" is "get_while_line()" use the "cookie" to find the
-     * function that's orignally used to obtain the lines.  This may be nested
-     * several levels. */
-    gp = getline;
-    cp = (struct while_cookie *)cookie;
-    while (gp == get_while_line)
-    {
-	gp = cp->getline;
-	cp = cp->cookie;
-    }
-    return gp == func;
-#else
-    return getline == func;
-#endif
-}
-
-#if defined(FEAT_EVAL) || defined(FEAT_MBYTE) || defined(PROTO)
-/*
- * If "getline" is get_while_line(), return the cookie used by the original
- * getline function.  Otherwise return "cookie".
- */
-/*ARGSUSED*/
-    void *
-getline_cookie(getline, cookie)
-    char_u	*(*getline) __ARGS((int, void *, int));
-    void	*cookie;		/* argument for getline() */
-{
-# ifdef FEAT_EVAL
-    char_u		*(*gp) __ARGS((int, void *, int));
-    struct while_cookie *cp;
-
-    /* When "getline" is "get_while_line()" use the "cookie" to find the
-     * cookie that's orignally used to obtain the lines.  This may be nested
-     * several levels. */
-    gp = getline;
-    cp = (struct while_cookie *)cookie;
-    while (gp == get_while_line)
-    {
-	gp = cp->getline;
-	cp = cp->cookie;
-    }
-    return cp;
-# else
-    return cookie;
-# endif
-}
-#endif
-
-/*
- * Execute one Ex command.
- *
- * If 'sourcing' is TRUE, the command will be included in the error message.
- *
- * 1. skip comment lines and leading space
- * 2. handle command modifiers
- * 3. parse range
- * 4. parse command
- * 5. parse arguments
- * 6. switch on command name
- *
- * Note: "getline" can be NULL.
- *
- * This function may be called recursively!
- */
-#if (_MSC_VER == 1200)
-/*
- * Optimisation bug in VC++ version 6.0
- * TODO: check this is still present after each service pack
- */
-# pragma optimize( "g", off )
-#endif
-    static char_u *
-do_one_cmd(cmdlinep, sourcing,
-#ifdef FEAT_EVAL
-			    cstack,
-#endif
-				    getline, cookie)
-    char_u		**cmdlinep;
-    int			sourcing;
-#ifdef FEAT_EVAL
-    struct condstack	*cstack;
-#endif
-    char_u		*(*getline) __ARGS((int, void *, int));
-    void		*cookie;		/* argument for getline() */
-{
-    char_u		*p;
-    linenr_T		lnum;
-    long		n;
-    char_u		*errormsg = NULL;	/* error message */
-    exarg_T		ea;			/* Ex command arguments */
-    long		verbose_save = -1;
-    int			save_msg_scroll = 0;
-    int			did_silent = 0;
-    int			did_esilent = 0;
-    cmdmod_T		save_cmdmod;
-    int			ni;			/* set when Not Implemented */
-
-    vim_memset(&ea, 0, sizeof(ea));
-    ea.line1 = 1;
-    ea.line2 = 1;
-#ifdef FEAT_EVAL
-    ++ex_nesting_level;
-#endif
-
-	/* when not editing the last file :q has to be typed twice */
-    if (quitmore
-#ifdef FEAT_EVAL
-	    /* avoid that a function call in 'statusline' does this */
-	    && !getline_equal(getline, cookie, get_func_line)
-#endif
-	    )
-	--quitmore;
-
-    /*
-     * Reset browse, confirm, etc..  They are restored when returning, for
-     * recursive calls.
-     */
-    save_cmdmod = cmdmod;
-    vim_memset(&cmdmod, 0, sizeof(cmdmod));
-
-    /*
-     * Repeat until no more command modifiers are found.
-     */
-    ea.cmd = *cmdlinep;
-    for (;;)
-    {
-/*
- * 1. skip comment lines and leading white space and colons
- */
-	while (*ea.cmd == ' ' || *ea.cmd == '\t' || *ea.cmd == ':')
-	    ++ea.cmd;
-
-	/* in ex mode, an empty line works like :+ */
-	if (*ea.cmd == NUL && exmode_active
-			&& (getline_equal(getline, cookie, getexmodeline)
-			    || getline_equal(getline, cookie, getexline)))
-	{
-	    ea.cmd = (char_u *)"+";
-	    ex_pressedreturn = TRUE;
-	}
-
-	/* ignore comment and empty lines */
-	if (*ea.cmd == '"' || *ea.cmd == NUL)
-	    goto doend;
-
-/*
- * 2. handle command modifiers.
- */
-	p = ea.cmd;
-	if (VIM_ISDIGIT(*ea.cmd))
-	    p = skipwhite(skipdigits(ea.cmd));
-	switch (*p)
-	{
-	    /* When adding an entry, also modify cmd_exists(). */
-	    case 'a':	if (!checkforcmd(&ea.cmd, "aboveleft", 3))
-			    break;
-#ifdef FEAT_WINDOWS
-			cmdmod.split |= WSP_ABOVE;
-#endif
-			continue;
-
-	    case 'b':	if (checkforcmd(&ea.cmd, "belowright", 3))
-			{
-#ifdef FEAT_WINDOWS
-			    cmdmod.split |= WSP_BELOW;
-#endif
-			    continue;
-			}
-			if (checkforcmd(&ea.cmd, "browse", 3))
-			{
-#ifdef FEAT_BROWSE
-			    cmdmod.browse = TRUE;
-#endif
-			    continue;
-			}
-			if (!checkforcmd(&ea.cmd, "botright", 2))
-			    break;
-#ifdef FEAT_WINDOWS
-			cmdmod.split |= WSP_BOT;
-#endif
-			continue;
-
-	    case 'c':	if (!checkforcmd(&ea.cmd, "confirm", 4))
-			    break;
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-			cmdmod.confirm = TRUE;
-#endif
-			continue;
-
-	    case 'k':	if (checkforcmd(&ea.cmd, "keepmarks", 3))
-			{
-			    cmdmod.keepmarks = TRUE;
-			    continue;
-			}
-			if (!checkforcmd(&ea.cmd, "keepjumps", 5))
-			    break;
-			cmdmod.keepjumps = TRUE;
-			continue;
-
-			/* ":hide" and ":hide | cmd" are not modifiers */
-	    case 'h':	if (p != ea.cmd || !checkforcmd(&p, "hide", 3)
-					       || *p == NUL || ends_excmd(*p))
-			    break;
-			ea.cmd = p;
-			cmdmod.hide = TRUE;
-			continue;
-
-	    case 'l':	if (checkforcmd(&ea.cmd, "lockmarks", 3))
-			{
-			    cmdmod.lockmarks = TRUE;
-			    continue;
-			}
-
-			if (!checkforcmd(&ea.cmd, "leftabove", 5))
-			    break;
-#ifdef FEAT_WINDOWS
-			cmdmod.split |= WSP_ABOVE;
-#endif
-			continue;
-
-	    case 'r':	if (!checkforcmd(&ea.cmd, "rightbelow", 6))
-			    break;
-#ifdef FEAT_WINDOWS
-			cmdmod.split |= WSP_BELOW;
-#endif
-			continue;
-
-	    case 's':	if (!checkforcmd(&ea.cmd, "silent", 3))
-			    break;
-			++did_silent;
-			++msg_silent;
-			save_msg_scroll = msg_scroll;
-			if (*ea.cmd == '!' && !vim_iswhite(ea.cmd[-1]))
-			{
-			    /* ":silent!", but not "silent !cmd" */
-			    ea.cmd = skipwhite(ea.cmd + 1);
-			    ++emsg_silent;
-			    ++did_esilent;
-			}
-			continue;
-
-	    case 't':	if (!checkforcmd(&ea.cmd, "topleft", 2))
-			    break;
-#ifdef FEAT_WINDOWS
-			cmdmod.split |= WSP_TOP;
-#endif
-			continue;
-
-	    case 'v':	if (checkforcmd(&ea.cmd, "vertical", 4))
-			{
-#ifdef FEAT_VERTSPLIT
-			    cmdmod.split |= WSP_VERT;
-#endif
-			    continue;
-			}
-			if (!checkforcmd(&p, "verbose", 4))
-			    break;
-			if (verbose_save < 0)
-			    verbose_save = p_verbose;
-			p_verbose = atoi((char *)ea.cmd);
-			if (p_verbose == 0)
-			    p_verbose = 1;
-			ea.cmd = p;
-			continue;
-	}
-	break;
-    }
-
-#ifdef FEAT_EVAL
-    ea.skip = did_emsg || got_int || did_throw || (cstack->cs_idx >= 0
-			 && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE));
-#else
-    ea.skip = (if_level > 0);
-#endif
-
-#ifdef FEAT_EVAL
-    /* May go to debug mode.  If this happens and the ">quit" debug command is
-     * used, throw an interrupt exception and skip the next command. */
-    dbg_check_breakpoint(&ea);
-    if (!ea.skip && got_int)
-    {
-	ea.skip = TRUE;
-	(void)do_intthrow(cstack);
-    }
-#endif
-
-/*
- * 3. parse a range specifier of the form: addr [,addr] [;addr] ..
- *
- * where 'addr' is:
- *
- * %	      (entire file)
- * $  [+-NUM]
- * 'x [+-NUM] (where x denotes a currently defined mark)
- * .  [+-NUM]
- * [+-NUM]..
- * NUM
- *
- * The ea.cmd pointer is updated to point to the first character following the
- * range spec. If an initial address is found, but no second, the upper bound
- * is equal to the lower.
- */
-
-    /* repeat for all ',' or ';' separated addresses */
-    for (;;)
-    {
-	ea.line1 = ea.line2;
-	ea.line2 = curwin->w_cursor.lnum;   /* default is current line number */
-	ea.cmd = skipwhite(ea.cmd);
-	lnum = get_address(&ea.cmd, ea.skip, ea.addr_count == 0);
-	if (ea.cmd == NULL)		    /* error detected */
-	    goto doend;
-	if (lnum == MAXLNUM)
-	{
-	    if (*ea.cmd == '%')		    /* '%' - all lines */
-	    {
-		++ea.cmd;
-		ea.line1 = 1;
-		ea.line2 = curbuf->b_ml.ml_line_count;
-		++ea.addr_count;
-	    }
-					    /* '*' - visual area */
-	    else if (*ea.cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)
-	    {
-		pos_T	    *fp;
-
-		++ea.cmd;
-		if (!ea.skip)
-		{
-		    fp = getmark('<', FALSE);
-		    if (check_mark(fp) == FAIL)
-			goto doend;
-		    ea.line1 = fp->lnum;
-		    fp = getmark('>', FALSE);
-		    if (check_mark(fp) == FAIL)
-			goto doend;
-		    ea.line2 = fp->lnum;
-		    ++ea.addr_count;
-		}
-	    }
-	}
-	else
-	    ea.line2 = lnum;
-	ea.addr_count++;
-
-	if (*ea.cmd == ';')
-	{
-	    if (!ea.skip)
-		curwin->w_cursor.lnum = ea.line2;
-	}
-	else if (*ea.cmd != ',')
-	    break;
-	++ea.cmd;
-    }
-
-    /* One address given: set start and end lines */
-    if (ea.addr_count == 1)
-    {
-	ea.line1 = ea.line2;
-	    /* ... but only implicit: really no address given */
-	if (lnum == MAXLNUM)
-	    ea.addr_count = 0;
-    }
-
-    /* Don't leave the cursor on an illegal line (caused by ';') */
-    check_cursor_lnum();
-
-/*
- * 4. parse command
- */
-
-    /*
-     * Skip ':' and any white space
-     */
-    ea.cmd = skipwhite(ea.cmd);
-    while (*ea.cmd == ':')
-	ea.cmd = skipwhite(ea.cmd + 1);
-
-    /*
-     * If we got a line, but no command, then go to the line.
-     * If we find a '|' or '\n' we set ea.nextcmd.
-     */
-    if (*ea.cmd == NUL || *ea.cmd == '"' ||
-			       (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL)
-    {
-	/*
-	 * strange vi behaviour:
-	 * ":3"		jumps to line 3
-	 * ":3|..."	prints line 3
-	 * ":|"		prints current line
-	 */
-	if (ea.skip)	    /* skip this if inside :if */
-	    goto doend;
-	if (*ea.cmd == '|')
-	{
-	    ea.cmdidx = CMD_print;
-	    ea.argt = RANGE+COUNT+TRLBAR;
-	    if ((errormsg = invalid_range(&ea)) == NULL)
-	    {
-		correct_range(&ea);
-		ex_print(&ea);
-	    }
-	}
-	else if (ea.addr_count != 0)
-	{
-	    if (ea.line2 < 0)
-		errormsg = invalid_range(&ea);
-	    else
-	    {
-		if (ea.line2 == 0)
-		    curwin->w_cursor.lnum = 1;
-		else if (ea.line2 > curbuf->b_ml.ml_line_count)
-		    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
-		else
-		    curwin->w_cursor.lnum = ea.line2;
-		beginline(BL_SOL | BL_FIX);
-	    }
-	}
-	goto doend;
-    }
-
-    /* Find the command and let "p" point to after it. */
-    p = find_command(&ea, NULL);
-
-#ifdef FEAT_USR_CMDS
-    if (p == NULL)
-    {
-	if (!ea.skip)
-	    errormsg = (char_u *)_("E464: Ambiguous use of user-defined command");
-	goto doend;
-    }
-    /* Check for wrong commands. */
-    if (*p == '!' && ea.cmd[1] == 0151 && ea.cmd[0] == 78)
-    {
-	errormsg = uc_fun_cmd();
-	goto doend;
-    }
-#endif
-    if (ea.cmdidx == CMD_SIZE)
-    {
-	if (!ea.skip)
-	{
-	    STRCPY(IObuff, _("E492: Not an editor command"));
-	    if (!sourcing)
-	    {
-		STRCAT(IObuff, ": ");
-		STRNCAT(IObuff, *cmdlinep, 40);
-	    }
-	    errormsg = IObuff;
-	}
-	goto doend;
-    }
-
-    ni = (
-#ifdef FEAT_USR_CMDS
-	    !USER_CMDIDX(ea.cmdidx) &&
-#endif
-	    cmdnames[ea.cmdidx].cmd_func == ex_ni);
-
-#ifndef FEAT_EVAL
-    /*
-     * When the expression evaluation is disabled, recognize the ":if" and
-     * ":endif" commands and ignore everything in between it.
-     */
-    if (ea.cmdidx == CMD_if)
-	++if_level;
-    if (if_level)
-    {
-	if (ea.cmdidx == CMD_endif)
-	    --if_level;
-	goto doend;
-    }
-
-#endif
-
-    if (*p == '!' && ea.cmdidx != CMD_substitute)    /* forced commands */
-    {
-	++p;
-	ea.forceit = TRUE;
-    }
-    else
-	ea.forceit = FALSE;
-
-/*
- * 5. parse arguments
- */
-#ifdef FEAT_USR_CMDS
-    if (!USER_CMDIDX(ea.cmdidx))
-#endif
-	ea.argt = cmdnames[(int)ea.cmdidx].cmd_argt;
-
-    if (!ea.skip)
-    {
-#ifdef HAVE_SANDBOX
-	if (sandbox != 0 && !(ea.argt & SBOXOK))
-	{
-	    /* Command not allowed in sandbox. */
-	    errormsg = (char_u *)_(e_sandbox);
-	    goto doend;
-	}
-#endif
-	if (!curbuf->b_p_ma && (ea.argt & MODIFY))
-	{
-	    /* Command not allowed in non-'modifiable' buffer */
-	    errormsg = (char_u *)_(e_modifiable);
-	    goto doend;
-	}
-#ifdef FEAT_CMDWIN
-	if (cmdwin_type != 0 && !(ea.argt & CMDWIN)
-# ifdef FEAT_USR_CMDS
-		&& !USER_CMDIDX(ea.cmdidx)
-# endif
-	   )
-	{
-	    /* Command not allowed in cmdline window. */
-	    errormsg = (char_u *)_(e_cmdwin);
-	    goto doend;
-	}
-#endif
-
-	if (!ni && !(ea.argt & RANGE) && ea.addr_count > 0)
-	{
-	    /* no range allowed */
-	    errormsg = (char_u *)_(e_norange);
-	    goto doend;
-	}
-    }
-
-    if (!ni && !(ea.argt & BANG) && ea.forceit)	/* no <!> allowed */
-    {
-	errormsg = (char_u *)_(e_nobang);
-	goto doend;
-    }
-
-    /*
-     * Don't complain about the range if it is not used
-     * (could happen if line_count is accidentally set to 0).
-     */
-    if (!ea.skip && !ni)
-    {
-	/*
-	 * If the range is backwards, ask for confirmation and, if given, swap
-	 * ea.line1 & ea.line2 so it's forwards again.
-	 * When global command is busy, don't ask, will fail below.
-	 */
-	if (!global_busy && ea.line1 > ea.line2)
-	{
-	    if (sourcing)
-	    {
-		errormsg = (char_u *)_("E493: Backwards range given");
-		goto doend;
-	    }
-	    else
-	    {
-		int	msg_silent_save = msg_silent;
-
-		msg_silent = 0;
-		if (ask_yesno((char_u *)
-			_("Backwards range given, OK to swap"), FALSE) != 'y')
-		goto doend;
-		msg_silent = msg_silent_save;
-	    }
-	    lnum = ea.line1;
-	    ea.line1 = ea.line2;
-	    ea.line2 = lnum;
-	}
-	if ((errormsg = invalid_range(&ea)) != NULL)
-	    goto doend;
-    }
-
-    if ((ea.argt & NOTADR) && ea.addr_count == 0) /* default is 1, not cursor */
-	ea.line2 = 1;
-
-    correct_range(&ea);
-
-#ifdef FEAT_FOLDING
-    if (((ea.argt & WHOLEFOLD) || ea.addr_count >= 2) && !global_busy)
-    {
-	/* Put the first line at the start of a closed fold, put the last line
-	 * at the end of a closed fold. */
-	(void)hasFolding(ea.line1, &ea.line1, NULL);
-	(void)hasFolding(ea.line2, NULL, &ea.line2);
-    }
-#endif
-
-#ifdef FEAT_QUICKFIX
-    /*
-     * For the :make and :grep commands we insert the 'makeprg'/'grepprg'
-     * option here, so things like % get expanded.
-     */
-    if (ea.cmdidx == CMD_make || ea.cmdidx == CMD_grep
-						  || ea.cmdidx == CMD_grepadd)
-    {
-	char_u		*new_cmdline;
-	char_u		*program;
-	char_u		*pos;
-	char_u		*ptr;
-	int		len;
-	int		i;
-
-	if (ea.cmdidx == CMD_grep || ea.cmdidx == CMD_grepadd)
-	{
-	    if (*curbuf->b_p_gp == NUL)
-		program = p_gp;
-	    else
-		program = curbuf->b_p_gp;
-	}
-	else
-	{
-	    if (*curbuf->b_p_mp == NUL)
-		program = p_mp;
-	    else
-		program = curbuf->b_p_mp;
-	}
-
-	p = skipwhite(p);
-
-	if ((pos = (char_u *)strstr((char *)program, "$*")) != NULL)
-	{				/* replace $* by given arguments */
-	    i = 1;
-	    while ((pos = (char_u *)strstr((char *)pos + 2, "$*")) != NULL)
-		++i;
-	    len = (int)STRLEN(p);
-	    new_cmdline = alloc((int)(STRLEN(program) + i * (len - 2) + 1));
-	    if (new_cmdline == NULL)
-		goto doend;		    /* out of memory */
-	    ptr = new_cmdline;
-	    while ((pos = (char_u *)strstr((char *)program, "$*")) != NULL)
-	    {
-		i = (int)(pos - program);
-		STRNCPY(ptr, program, i);
-		STRCPY(ptr += i, p);
-		ptr += len;
-		program = pos + 2;
-	    }
-	    STRCPY(ptr, program);
-	}
-	else
-	{
-	    new_cmdline = alloc((int)(STRLEN(program) + STRLEN(p) + 2));
-	    if (new_cmdline == NULL)
-		goto doend;		    /* out of memory */
-	    STRCPY(new_cmdline, program);
-	    STRCAT(new_cmdline, " ");
-	    STRCAT(new_cmdline, p);
-	}
-	msg_make(p);
-	/* 'ea.cmd' is not set here, because it is not used at CMD_make */
-	vim_free(*cmdlinep);
-	*cmdlinep = new_cmdline;
-	p = new_cmdline;
-    }
-#endif
-
-    /*
-     * Skip to start of argument.
-     * Don't do this for the ":!" command, because ":!! -l" needs the space.
-     */
-    if (ea.cmdidx == CMD_bang)
-	ea.arg = p;
-    else
-	ea.arg = skipwhite(p);
-
-    /*
-     * Check for "++opt=val" argument.
-     * Must be first, allow ":w ++enc=utf8 !cmd"
-     */
-    if (ea.argt & ARGOPT)
-	while (ea.arg[0] == '+' && ea.arg[1] == '+')
-	    if (getargopt(&ea) == FAIL && !ni)
-	    {
-		errormsg = (char_u *)_(e_invarg);
-		goto doend;
-	    }
-
-    if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update)
-    {
-	if (*ea.arg == '>')			/* append */
-	{
-	    if (*++ea.arg != '>')		/* typed wrong */
-	    {
-		errormsg = (char_u *)_("E494: Use w or w>>");
-		goto doend;
-	    }
-	    ea.arg = skipwhite(ea.arg + 1);
-	    ea.append = TRUE;
-	}
-	else if (*ea.arg == '!' && ea.cmdidx == CMD_write)  /* :w !filter */
-	{
-	    ++ea.arg;
-	    ea.usefilter = TRUE;
-	}
-    }
-
-    if (ea.cmdidx == CMD_read)
-    {
-	if (ea.forceit)
-	{
-	    ea.usefilter = TRUE;		/* :r! filter if ea.forceit */
-	    ea.forceit = FALSE;
-	}
-	else if (*ea.arg == '!')		/* :r !filter */
-	{
-	    ++ea.arg;
-	    ea.usefilter = TRUE;
-	}
-    }
-
-    if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift)
-    {
-	ea.amount = 1;
-	while (*ea.arg == *ea.cmd)		/* count number of '>' or '<' */
-	{
-	    ++ea.arg;
-	    ++ea.amount;
-	}
-	ea.arg = skipwhite(ea.arg);
-    }
-
-    /*
-     * Check for "+command" argument, before checking for next command.
-     * Don't do this for ":read !cmd" and ":write !cmd".
-     */
-    if ((ea.argt & EDITCMD) && !ea.usefilter)
-	ea.do_ecmd_cmd = getargcmd(&ea.arg);
-
-    /*
-     * Check for '|' to separate commands and '"' to start comments.
-     * Don't do this for ":read !cmd" and ":write !cmd".
-     */
-    if ((ea.argt & TRLBAR) && !ea.usefilter)
-	separate_nextcmd(&ea);
-
-    /*
-     * Check for <newline> to end a shell command.
-     * Also do this for ":read !cmd" and ":write !cmd".
-     */
-    else if (ea.cmdidx == CMD_bang || ea.usefilter)
-    {
-	for (p = ea.arg; *p; ++p)
-	{
-	    /* Remove one backslash before a newline, so that it's possible to
-	     * pass a newline to the shell and also a newline that is preceded
-	     * with a backslash.  This makes it impossible to end a shell
-	     * command in a backslash, but that doesn't appear useful.
-	     * Halving the number of backslashes is incompatible with previous
-	     * versions. */
-	    if (*p == '\\' && p[1] == '\n')
-		mch_memmove(p, p + 1, STRLEN(p));
-	    else if (*p == '\n')
-	    {
-		ea.nextcmd = p + 1;
-		*p = NUL;
-		break;
-	    }
-	}
-    }
-
-    if ((ea.argt & DFLALL) && ea.addr_count == 0)
-    {
-	ea.line1 = 1;
-	ea.line2 = curbuf->b_ml.ml_line_count;
-    }
-
-    /* accept numbered register only when no count allowed (:put) */
-    if (       (ea.argt & REGSTR)
-	    && *ea.arg != NUL
-#ifdef FEAT_USR_CMDS
-	    && valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put
-						   && USER_CMDIDX(ea.cmdidx)))
-	    /* Do not allow register = for user commands */
-	    && (!USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')
-#else
-	    && valid_yank_reg(*ea.arg, ea.cmdidx != CMD_put)
-#endif
-	    && !((ea.argt & COUNT) && VIM_ISDIGIT(*ea.arg)))
-    {
-	ea.regname = *ea.arg++;
-#ifdef FEAT_EVAL
-	/* for '=' register: accept the rest of the line as an expression */
-	if (ea.arg[-1] == '=' && ea.arg[0] != NUL)
-	{
-	    set_expr_line(vim_strsave(ea.arg));
-	    ea.arg += STRLEN(ea.arg);
-	}
-#endif
-	ea.arg = skipwhite(ea.arg);
-    }
-
-    /*
-     * Check for a count.  When accepting a BUFNAME, don't use "123foo" as a
-     * count, it's a buffer name.
-     */
-    if ((ea.argt & COUNT) && VIM_ISDIGIT(*ea.arg)
-	    && (!(ea.argt & BUFNAME) || *(p = skipdigits(ea.arg)) == NUL
-							  || vim_iswhite(*p)))
-    {
-	n = getdigits(&ea.arg);
-	ea.arg = skipwhite(ea.arg);
-	if (n <= 0 && !ni)
-	{
-	    errormsg = (char_u *)_(e_zerocount);
-	    goto doend;
-	}
-	if (ea.argt & NOTADR)	/* e.g. :buffer 2, :sleep 3 */
-	{
-	    ea.line2 = n;
-	    if (ea.addr_count == 0)
-		ea.addr_count = 1;
-	}
-	else
-	{
-	    ea.line1 = ea.line2;
-	    ea.line2 += n - 1;
-	    ++ea.addr_count;
-	    /*
-	     * Be vi compatible: no error message for out of range.
-	     */
-	    if (ea.line2 > curbuf->b_ml.ml_line_count)
-		ea.line2 = curbuf->b_ml.ml_line_count;
-	}
-    }
-						/* no arguments allowed */
-    if (!ni && !(ea.argt & EXTRA) && *ea.arg != NUL &&
-				 vim_strchr((char_u *)"|\"", *ea.arg) == NULL)
-    {
-	errormsg = (char_u *)_(e_trailing);
-	goto doend;
-    }
-
-    if (!ni && (ea.argt & NEEDARG) && *ea.arg == NUL)
-    {
-	errormsg = (char_u *)_(e_argreq);
-	goto doend;
-    }
-
-#ifdef FEAT_EVAL
-    /*
-     * Skip the command when it's not going to be executed.
-     * The commands like :if, :endif, etc. always need to be executed.
-     * Also make an exception for commands that handle a trailing command
-     * themselves.
-     */
-    if (ea.skip)
-    {
-	switch (ea.cmdidx)
-	{
-	    /* commands that need evaluation */
-	    case CMD_while:
-	    case CMD_endwhile:
-	    case CMD_if:
-	    case CMD_elseif:
-	    case CMD_else:
-	    case CMD_endif:
-	    case CMD_try:
-	    case CMD_catch:
-	    case CMD_finally:
-	    case CMD_endtry:
-	    case CMD_function:
-				break;
-
-	    /* Commands that handle '|' themselves.  Check: A command should
-	     * either have the TRLBAR flag, appear in this list or appear in
-	     * the list at ":help :bar". */
-	    case CMD_aboveleft:
-	    case CMD_and:
-	    case CMD_belowright:
-	    case CMD_botright:
-	    case CMD_browse:
-	    case CMD_call:
-	    case CMD_confirm:
-	    case CMD_delfunction:
-	    case CMD_djump:
-	    case CMD_dlist:
-	    case CMD_dsearch:
-	    case CMD_dsplit:
-	    case CMD_echo:
-	    case CMD_echoerr:
-	    case CMD_echomsg:
-	    case CMD_echon:
-	    case CMD_execute:
-	    case CMD_help:
-	    case CMD_hide:
-	    case CMD_ijump:
-	    case CMD_ilist:
-	    case CMD_isearch:
-	    case CMD_isplit:
-	    case CMD_keepjumps:
-	    case CMD_keepmarks:
-	    case CMD_leftabove:
-	    case CMD_let:
-	    case CMD_lockmarks:
-	    case CMD_match:
-	    case CMD_perl:
-	    case CMD_psearch:
-	    case CMD_python:
-	    case CMD_return:
-	    case CMD_rightbelow:
-	    case CMD_ruby:
-	    case CMD_silent:
-	    case CMD_smagic:
-	    case CMD_snomagic:
-	    case CMD_substitute:
-	    case CMD_syntax:
-	    case CMD_tcl:
-	    case CMD_throw:
-	    case CMD_tilde:
-	    case CMD_topleft:
-	    case CMD_unlet:
-	    case CMD_verbose:
-	    case CMD_vertical:
-				break;
-
-	    default:		goto doend;
-	}
-    }
-#endif
-
-    if (ea.argt & XFILE)
-    {
-	if (expand_filename(&ea, cmdlinep, &errormsg) == FAIL)
-	    goto doend;
-    }
-
-#ifdef FEAT_LISTCMDS
-    /*
-     * Accept buffer name.  Cannot be used at the same time with a buffer
-     * number.  Don't do this for a user command.
-     */
-    if ((ea.argt & BUFNAME) && *ea.arg != NUL && ea.addr_count == 0
-# ifdef FEAT_USR_CMDS
-	    && !USER_CMDIDX(ea.cmdidx)
-# endif
-	    )
-    {
-	/*
-	 * :bdelete, :bwipeout and :bunload take several arguments, separated
-	 * by spaces: find next space (skipping over escaped characters).
-	 * The others take one argument: ignore trailing spaces.
-	 */
-	if (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout
-						  || ea.cmdidx == CMD_bunload)
-	    p = skiptowhite_esc(ea.arg);
-	else
-	{
-	    p = ea.arg + STRLEN(ea.arg);
-	    while (p > ea.arg && vim_iswhite(p[-1]))
-		--p;
-	}
-	ea.line2 = buflist_findpat(ea.arg, p, (ea.argt & BUFUNL) != 0, FALSE);
-	if (ea.line2 < 0)	    /* failed */
-	    goto doend;
-	ea.addr_count = 1;
-	ea.arg = skipwhite(p);
-    }
-#endif
-
-/*
- * 6. switch on command name
- *
- * The "ea" structure holds the arguments that can be used.
- */
-    ea.cmdlinep = cmdlinep;
-    ea.getline = getline;
-    ea.cookie = cookie;
-#ifdef FEAT_EVAL
-    ea.cstack = cstack;
-#endif
-
-#ifdef FEAT_USR_CMDS
-    if (USER_CMDIDX(ea.cmdidx))
-    {
-	/*
-	 * Execute a user-defined command.
-	 */
-	do_ucmd(&ea);
-    }
-    else
-#endif
-    {
-	/*
-	 * Call the function to execute the command.
-	 */
-	ea.errmsg = NULL;
-	(cmdnames[ea.cmdidx].cmd_func)(&ea);
-	if (ea.errmsg != NULL)
-	    errormsg = (char_u *)_(ea.errmsg);
-    }
-
-#ifdef FEAT_EVAL
-    /*
-     * If the command just executed called do_cmdline(), any throw or ":return"
-     * or ":finish" encountered there must also check the cstack of the still
-     * active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught
-     * exception, or reanimate a returned function or finished script file and
-     * return or finish it again.
-     */
-    if (need_rethrow)
-	do_throw(cstack);
-    else if (check_cstack)
-    {
-	if (source_finished(getline, cookie))
-	    do_finish(&ea, TRUE);
-	else if (getline_equal(getline, cookie, get_func_line)
-						   && current_func_returned())
-	    do_return(&ea, TRUE, FALSE, NULL);
-    }
-    need_rethrow = check_cstack = FALSE;
-#endif
-
-doend:
-    if (curwin->w_cursor.lnum == 0)	/* can happen with zero line number */
-	curwin->w_cursor.lnum = 1;
-
-    if (errormsg != NULL && *errormsg != NUL && !did_emsg)
-    {
-	if (sourcing)
-	{
-	    if (errormsg != IObuff)
-	    {
-		STRCPY(IObuff, errormsg);
-		errormsg = IObuff;
-	    }
-	    STRCAT(errormsg, ": ");
-	    STRNCAT(errormsg, *cmdlinep, IOSIZE - STRLEN(IObuff));
-	}
-	emsg(errormsg);
-    }
-#ifdef FEAT_EVAL
-    do_errthrow(cstack,
-	    (ea.cmdidx != CMD_SIZE
-# ifdef FEAT_USR_CMDS
-	     && !USER_CMDIDX(ea.cmdidx)
-# endif
-	    ) ? cmdnames[(int)ea.cmdidx].cmd_name : (char_u *)NULL);
-#endif
-
-    if (verbose_save >= 0)
-	p_verbose = verbose_save;
-
-    cmdmod = save_cmdmod;
-
-    if (did_silent > 0)
-    {
-	/* messages could be enabled for a serious error, need to check if the
-	 * counters don't become negative */
-	msg_silent -= did_silent;
-	if (msg_silent < 0)
-	    msg_silent = 0;
-	emsg_silent -= did_esilent;
-	if (emsg_silent < 0)
-	    emsg_silent = 0;
-	/* Restore msg_scroll, it's set by file I/O commands, even when no
-	 * message is actually displayed. */
-	msg_scroll = save_msg_scroll;
-    }
-
-    if (ea.nextcmd && *ea.nextcmd == NUL)	/* not really a next command */
-	ea.nextcmd = NULL;
-
-#ifdef FEAT_EVAL
-    --ex_nesting_level;
-#endif
-
-    return ea.nextcmd;
-}
-#if (_MSC_VER == 1200)
-# pragma optimize( "", on )
-#endif
-
-/*
- * Check for a command modifier command with optional tail.
- * If there is a match advance "pp" to the argument and return TRUE.
- */
-    static int
-checkforcmd(pp, cmd, len)
-    char_u	**pp;		/* start of command line */
-    char	*cmd;		/* name of command */
-    int		len;		/* required length */
-{
-    int		i;
-
-    for (i = 0; cmd[i] != NUL; ++i)
-	if (cmd[i] != (*pp)[i])
-	    break;
-    if (i >= len && !isalpha((*pp)[i]))
-    {
-	*pp = skipwhite(*pp + i);
-	return TRUE;
-    }
-    return FALSE;
-}
-
-/*
- * Find an Ex command by its name, either built-in or user.
- * Name can be found at eap->cmd.
- * Returns pointer to char after the command name.
- * Returns NULL for an ambiguous user command.
- */
-/*ARGSUSED*/
-    static char_u *
-find_command(eap, full)
-    exarg_T	*eap;
-    int		*full;
-{
-    int		len;
-    char_u	*p;
-
-    /*
-     * Isolate the command and search for it in the command table.
-     * Exeptions:
-     * - the 'k' command can directly be followed by any character.
-     * - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'
-     *	    but :sre[wind] is another command, as are :scrip[tnames],
-     *	    :scs[cope], :sim[alt], :sig[ns] and :sil[ent].
-     */
-    p = eap->cmd;
-    if (*p == 'k')
-    {
-	eap->cmdidx = CMD_k;
-	++p;
-    }
-    else if (p[0] == 's'
-	    && ((p[1] == 'c' && p[2] != 's' && p[2] != 'r' && p[3] != 'i' && p[4] != 'p')
-		|| p[1] == 'g'
-		|| (p[1] == 'i' && p[2] != 'm' && p[2] != 'l' && p[2] != 'g')
-		|| p[1] == 'I'
-		|| (p[1] == 'r' && p[2] != 'e')))
-    {
-	eap->cmdidx = CMD_substitute;
-	++p;
-    }
-    else
-    {
-	while (ASCII_ISALPHA(*p))
-	    ++p;
-	/* check for non-alpha command */
-	if (p == eap->cmd && vim_strchr((char_u *)"@*!=><&~#", *p) != NULL)
-	    ++p;
-	len = (int)(p - eap->cmd);
-
-	if (ASCII_ISLOWER(*eap->cmd))
-	    eap->cmdidx = cmdidxs[CharOrdLow(*eap->cmd)];
-	else
-	    eap->cmdidx = cmdidxs[26];
-
-	for ( ; (int)eap->cmdidx < (int)CMD_SIZE;
-			       eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))
-	    if (STRNCMP(cmdnames[(int)eap->cmdidx].cmd_name, (char *)eap->cmd,
-							    (size_t)len) == 0)
-	    {
-#ifdef FEAT_EVAL
-		if (full != NULL
-			   && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL)
-		    *full = TRUE;
-#endif
-		break;
-	    }
-
-#ifdef FEAT_USR_CMDS
-	/* Look for a user defined command as a last resort */
-	if (eap->cmdidx == CMD_SIZE && *eap->cmd >= 'A' && *eap->cmd <= 'Z')
-	{
-	    ucmd_T	*cmd;
-	    int		j, k, matchlen = 0;
-	    int		found = FALSE, possible = FALSE;
-	    char_u	*cp, *np;	/* Point into typed cmd and test name */
-	    garray_T	*gap;
-	    int		amb_local = FALSE; /* Found ambiguous buffer-local
-					      command, only full match global
-					      is accepted. */
-
-	    /* User defined commands may contain numbers */
-	    while (ASCII_ISALNUM(*p))
-		++p;
-	    len = (int)(p - eap->cmd);
-
-	    /*
-	     * Look for buffer-local user commands first, then global ones.
-	     */
-	    gap = &curbuf->b_ucmds;
-	    for (;;)
-	    {
-		for (j = 0; j < gap->ga_len; ++j)
-		{
-		    cmd = USER_CMD_GA(gap, j);
-		    cp = eap->cmd;
-		    np = cmd->uc_name;
-		    k = 0;
-		    while (k < len && *np != NUL && *cp++ == *np++)
-			k++;
-		    if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))
-		    {
-			/* If finding a second match, the command is
-			 * ambiguous.  But not if a buffer-local command
-			 * wasn't a full match and a global command is a full
-			 * match. */
-			if (k == len && found && *np != NUL)
-			{
-			    if (gap == &ucmds)
-				return NULL;
-			    amb_local = TRUE;
-			}
-
-			if (!found || (k == len && *np == NUL))
-			{
-			    /* If we matched up to a digit, then there could
-			     * be another command including the digit that we
-			     * should use instead.
-			     */
-			    if (k == len)
-				found = TRUE;
-			    else
-				possible = TRUE;
-
-			    if (gap == &ucmds)
-				eap->cmdidx = CMD_USER;
-			    else
-				eap->cmdidx = CMD_USER_BUF;
-			    eap->argt = cmd->uc_argt;
-			    eap->useridx = j;
-
-			    /* Do not search for further abbreviations
-			     * if this is an exact match. */
-			    matchlen = k;
-			    if (k == len && *np == NUL)
-			    {
-				if (full != NULL)
-				    *full = TRUE;
-				amb_local = FALSE;
-				break;
-			    }
-			}
-		    }
-		}
-
-		/* Stop if we found a full match or searched all. */
-		if (j < gap->ga_len || gap == &ucmds)
-		    break;
-		gap = &ucmds;
-	    }
-
-	    /* Only found ambiguous matches. */
-	    if (amb_local)
-		return NULL;
-
-	    /* The match we found may be followed immediately by a
-	     * number.  Move *p back to point to it.
-	     */
-	    if (found || possible)
-		p += matchlen - len;
-	}
-#endif
-
-	if (len == 0)
-	    eap->cmdidx = CMD_SIZE;
-    }
-
-    return p;
-}
-
-#if defined(FEAT_EVAL) || defined(PROTO)
-/*
- * Return > 0 if an Ex command "name" exists.
- * Return 2 if there is an exact match.
- * Return 3 if there is an ambiguous match.
- */
-    int
-cmd_exists(name)
-    char_u	*name;
-{
-    exarg_T	ea;
-    int		full = FALSE;
-    int		i;
-    int		j;
-    static struct cmdmod
-    {
-	char	*name;
-	int	minlen;
-    } cmdmods[] = {
-	{"aboveleft", 3},
-	{"belowright", 3},
-	{"botright", 2},
-	{"browse", 3},
-	{"confirm", 4},
-	{"hide", 3},
-	{"keepjumps", 5},
-	{"keepmarks", 3},
-	{"leftabove", 5},
-	{"lockmarks", 3},
-	{"rightbelow", 6},
-	{"silent", 3},
-	{"topleft", 2},
-	{"verbose", 4},
-	{"vertical", 4},
-    };
-
-    /* Check command modifiers. */
-    for (i = 0; i < sizeof(cmdmods) / sizeof(struct cmdmod); ++i)
-    {
-	for (j = 0; name[j] != NUL; ++j)
-	    if (name[j] != cmdmods[i].name[j])
-		break;
-	if (name[j] == NUL && j >= cmdmods[i].minlen)
-	    return (cmdmods[i].name[j] == NUL ? 2 : 1);
-    }
-
-    /* Check built-in commands and user defined commands. */
-    ea.cmd = name;
-    ea.cmdidx = (cmdidx_T)0;
-    if (find_command(&ea, &full) == NULL)
-	return 3;
-    return (ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1));
-}
-#endif
-
-/*
- * This is all pretty much copied from do_one_cmd(), with all the extra stuff
- * we don't need/want deleted.	Maybe this could be done better if we didn't
- * repeat all this stuff.  The only problem is that they may not stay
- * perfectly compatible with each other, but then the command line syntax
- * probably won't change that much -- webb.
- */
-    char_u *
-set_one_cmd_context(xp, buff)
-    expand_T	*xp;
-    char_u	*buff;	    /* buffer for command string */
-{
-    char_u		*p;
-    char_u		*cmd, *arg;
-    int			i = 0;
-    cmdidx_T		cmdidx;
-    long_u		argt = 0;
-#if defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)
-    int			compl = EXPAND_NOTHING;
-#endif
-#ifdef FEAT_CMDL_COMPL
-    int			delim;
-#endif
-    int			forceit = FALSE;
-    int			usefilter = FALSE;  /* filter instead of file name */
-
-    xp->xp_pattern = buff;
-    xp->xp_context = EXPAND_COMMANDS;	/* Default until we get past command */
-    xp->xp_backslash = XP_BS_NONE;
-#if defined(FEAT_USR_CMDS) && defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
-    xp->xp_arg = NULL;
-#endif
-
-/*
- * 2. skip comment lines and leading space, colons or bars
- */
-    for (cmd = buff; vim_strchr((char_u *)" \t:|", *cmd) != NULL; cmd++)
-	;
-    xp->xp_pattern = cmd;
-
-    if (*cmd == NUL)
-	return NULL;
-    if (*cmd == '"')	    /* ignore comment lines */
-    {
-	xp->xp_context = EXPAND_NOTHING;
-	return NULL;
-    }
-
-/*
- * 3. parse a range specifier of the form: addr [,addr] [;addr] ..
- */
-    cmd = skip_range(cmd, &xp->xp_context);
-
-/*
- * 4. parse command
- */
-
-    cmd = skipwhite(cmd);
-    xp->xp_pattern = cmd;
-    if (*cmd == NUL)
-	return NULL;
-    if (*cmd == '"')
-    {
-	xp->xp_context = EXPAND_NOTHING;
-	return NULL;
-    }
-
-    if (*cmd == '|' || *cmd == '\n')
-	return cmd + 1;			/* There's another command */
-
-    /*
-     * Isolate the command and search for it in the command table.
-     * Exceptions:
-     * - the 'k' command can directly be followed by any character, but
-     *   do accept "keepmarks" and "keepjumps".
-     * - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'
-     */
-    if (*cmd == 'k' && cmd[1] != 'e')
-    {
-	cmdidx = CMD_k;
-	p = cmd + 1;
-    }
-    else
-    {
-	p = cmd;
-	while (ASCII_ISALPHA(*p) || *p == '*')    /* Allow * wild card */
-	    ++p;
-	/* check for non-alpha command */
-	if (p == cmd && vim_strchr((char_u *)"@*!=><&~#", *p) != NULL)
-	    ++p;
-	i = (int)(p - cmd);
-
-	if (i == 0)
-	{
-	    xp->xp_context = EXPAND_UNSUCCESSFUL;
-	    return NULL;
-	}
-	for (cmdidx = (cmdidx_T)0; (int)cmdidx < (int)CMD_SIZE;
-					 cmdidx = (cmdidx_T)((int)cmdidx + 1))
-	    if (STRNCMP(cmdnames[(int)cmdidx].cmd_name, cmd, (size_t)i) == 0)
-		break;
-
-#ifdef FEAT_USR_CMDS
-	if (cmd[0] >= 'A' && cmd[0] <= 'Z')
-	{
-	    while (ASCII_ISALNUM(*p) || *p == '*')	/* Allow * wild card */
-		++p;
-	    i = (int)(p - cmd);
-	}
-#endif
-    }
-
-    /*
-     * If the cursor is touching the command, and it ends in an alpha-numeric
-     * character, complete the command name.
-     */
-    if (*p == NUL && ASCII_ISALNUM(p[-1]))
-	return NULL;
-
-    if (cmdidx == CMD_SIZE)
-    {
-	if (*cmd == 's' && vim_strchr((char_u *)"cgriI", cmd[1]) != NULL)
-	{
-	    cmdidx = CMD_substitute;
-	    p = cmd + 1;
-	}
-#ifdef FEAT_USR_CMDS
-	else if (cmd[0] >= 'A' && cmd[0] <= 'Z')
-	{
-	    /* Look for a user defined command as a last resort */
-	    ucmd_T	*uc;
-	    int		j, k, matchlen = 0;
-	    int		found = FALSE, possible = FALSE;
-	    char_u	*cp, *np;	/* Point into typed cmd and test name */
-	    garray_T	*gap;
-
-	    gap = &curbuf->b_ucmds;
-	    for (;;)
-	    {
-		uc = USER_CMD_GA(gap, 0);
-		for (j = 0; j < gap->ga_len; ++j, ++uc)
-		{
-		    cp = cmd;
-		    np = uc->uc_name;
-		    k = 0;
-		    while (k < i && *np != NUL && *cp++ == *np++)
-			k++;
-		    if (k == i || (*np == NUL && VIM_ISDIGIT(cmd[k])))
-		    {
-			if (k == i && found)
-			{
-			    /* Ambiguous abbreviation */
-			    xp->xp_context = EXPAND_UNSUCCESSFUL;
-			    return NULL;
-			}
-			if (!found)
-			{
-			    /* If we matched up to a digit, then there could
-			     * be another command including the digit that we
-			     * should use instead.
-			     */
-			    if (k == i)
-				found = TRUE;
-			    else
-				possible = TRUE;
-
-			    if (gap == &ucmds)
-				cmdidx = CMD_USER;
-			    else
-				cmdidx = CMD_USER_BUF;
-			    argt = uc->uc_argt;
-#ifdef FEAT_CMDL_COMPL
-			    compl = uc->uc_compl;
-# ifdef FEAT_EVAL
-			    xp->xp_arg = uc->uc_compl_arg;
-			    xp->xp_scriptID = uc->uc_scriptID;
-# endif
-#endif
-			    /* Do not search for further abbreviations
-			     * if this is an exact match
-			     */
-			    matchlen = k;
-			    if (k == i && *np == NUL)
-				break;
-			}
-		    }
-		}
-		if (gap == &ucmds || j < gap->ga_len)
-		    break;
-		gap = &ucmds;
-	    }
-
-	    /* The match we found may be followed immediately by a
-	     * number.  Move *p back to point to it.
-	     */
-	    if (found || possible)
-		p += matchlen - i;
-	}
-#endif
-    }
-    if (cmdidx == CMD_SIZE)
-    {
-	/* Not still touching the command and it was an illegal one */
-	xp->xp_context = EXPAND_UNSUCCESSFUL;
-	return NULL;
-    }
-
-    xp->xp_context = EXPAND_NOTHING; /* Default now that we're past command */
-
-    if (*p == '!')		    /* forced commands */
-    {
-	forceit = TRUE;
-	++p;
-    }
-
-/*
- * 5. parse arguments
- */
-#ifdef FEAT_USR_CMDS
-    if (!USER_CMDIDX(cmdidx))
-#endif
-	argt = cmdnames[(int)cmdidx].cmd_argt;
-
-    arg = skipwhite(p);
-
-    if (cmdidx == CMD_write || cmdidx == CMD_update)
-    {
-	if (*arg == '>')			/* append */
-	{
-	    if (*++arg == '>')
-		++arg;
-	    arg = skipwhite(arg);
-	}
-	else if (*arg == '!' && cmdidx == CMD_write)	/* :w !filter */
-	{
-	    ++arg;
-	    usefilter = TRUE;
-	}
-    }
-
-    if (cmdidx == CMD_read)
-    {
-	usefilter = forceit;			/* :r! filter if forced */
-	if (*arg == '!')			/* :r !filter */
-	{
-	    ++arg;
-	    usefilter = TRUE;
-	}
-    }
-
-    if (cmdidx == CMD_lshift || cmdidx == CMD_rshift)
-    {
-	while (*arg == *cmd)	    /* allow any number of '>' or '<' */
-	    ++arg;
-	arg = skipwhite(arg);
-    }
-
-    /* Does command allow "+command"? */
-    if ((argt & EDITCMD) && !usefilter && *arg == '+')
-    {
-	/* Check if we're in the +command */
-	p = arg + 1;
-	arg = skip_cmd_arg(arg, FALSE);
-
-	/* Still touching the command after '+'? */
-	if (*arg == NUL)
-	    return p;
-
-	/* Skip space(s) after +command to get to the real argument */
-	arg = skipwhite(arg);
-    }
-
-    /*
-     * Check for '|' to separate commands and '"' to start comments.
-     * Don't do this for ":read !cmd" and ":write !cmd".
-     */
-    if ((argt & TRLBAR) && !usefilter)
-    {
-	p = arg;
-	/* ":redir @" is not the start of a comment */
-	if (cmdidx == CMD_redir && p[0] == '@' && p[1] == '"')
-	    p += 2;
-	while (*p)
-	{
-	    if (*p == Ctrl_V)
-	    {
-		if (p[1] != NUL)
-		    ++p;
-	    }
-	    else if ( (*p == '"' && !(argt & NOTRLCOM))
-		    || *p == '|' || *p == '\n')
-	    {
-		if (*(p - 1) != '\\')
-		{
-		    if (*p == '|' || *p == '\n')
-			return p + 1;
-		    return NULL;    /* It's a comment */
-		}
-	    }
-#ifdef FEAT_MBYTE
-	    if (has_mbyte)
-		p += (*mb_ptr2len_check)(p);
-	    else
-#endif
-		++p;
-	}
-    }
-
-						/* no arguments allowed */
-    if (!(argt & EXTRA) && *arg != NUL &&
-				    vim_strchr((char_u *)"|\"", *arg) == NULL)
-	return NULL;
-
-    /* Find start of last argument (argument just before cursor): */
-    p = buff + STRLEN(buff);
-    while (p != arg && *p != ' ' && *p != TAB)
-	p--;
-    if (*p == ' ' || *p == TAB)
-	p++;
-    xp->xp_pattern = p;
-
-    if (argt & XFILE)
-    {
-	int in_quote = FALSE;
-	char_u *bow = NULL;	/* Beginning of word */
-
-	/*
-	 * Allow spaces within back-quotes to count as part of the argument
-	 * being expanded.
-	 */
-	xp->xp_pattern = skipwhite(arg);
-	for (p = xp->xp_pattern; *p; )
-	{
-	    if (*p == '\\' && p[1])
-		++p;
-#ifdef SPACE_IN_FILENAME
-	    else if (vim_iswhite(*p) && (!(argt & NOSPC) || usefilter))
-#else
-	    else if (vim_iswhite(*p))
-#endif
-	    {
-		p = skipwhite(p);
-		if (in_quote)
-		    bow = p;
-		else
-		    xp->xp_pattern = p;
-		--p;
-	    }
-	    else if (*p == '`')
-	    {
-		if (!in_quote)
-		{
-		    xp->xp_pattern = p;
-		    bow = p + 1;
-		}
-		in_quote = !in_quote;
-	    }
-#ifdef FEAT_MBYTE
-	    if (has_mbyte)
-		p += (*mb_ptr2len_check)(p);
-	    else
-#endif
-		++p;
-	}
-
-	/*
-	 * If we are still inside the quotes, and we passed a space, just
-	 * expand from there.
-	 */
-	if (bow != NULL && in_quote)
-	    xp->xp_pattern = bow;
-	xp->xp_context = EXPAND_FILES;
-
-	/* Check for environment variable */
-	if (*xp->xp_pattern == '$'
-#if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-		|| *xp->xp_pattern == '%'
-#endif
-		)
-	{
-	    for (p = xp->xp_pattern + 1; *p != NUL; ++p)
-		if (!vim_isIDc(*p))
-		    break;
-	    if (*p == NUL)
-	    {
-		xp->xp_context = EXPAND_ENV_VARS;
-		++xp->xp_pattern;
-	    }
-	}
-    }
-
-/*
- * 6. switch on command name
- */
-    switch (cmdidx)
-    {
-	case CMD_cd:
-	case CMD_chdir:
-	case CMD_lcd:
-	case CMD_lchdir:
-	    if (xp->xp_context == EXPAND_FILES)
-		xp->xp_context = EXPAND_DIRECTORIES;
-	    break;
-	case CMD_help:
-	    xp->xp_context = EXPAND_HELP;
-	    xp->xp_pattern = arg;
-	    break;
-
-	/* Command modifiers: return the argument. */
-	case CMD_aboveleft:
-	case CMD_belowright:
-	case CMD_botright:
-	case CMD_browse:
-	case CMD_confirm:
-	case CMD_folddoclosed:
-	case CMD_folddoopen:
-	case CMD_hide:
-	case CMD_keepjumps:
-	case CMD_keepmarks:
-	case CMD_leftabove:
-	case CMD_lockmarks:
-	case CMD_rightbelow:
-	case CMD_silent:
-	case CMD_topleft:
-	case CMD_verbose:
-	case CMD_vertical:
-	    return arg;
-
-#ifdef FEAT_SEARCH_EXTRA
-	case CMD_match:
-	    if (*arg == NUL || !ends_excmd(*arg))
-	    {
-		/* Dummy call to clear variables. */
-		set_context_in_highlight_cmd(xp, (char_u *)"link n");
-		xp->xp_context = EXPAND_HIGHLIGHT;
-		xp->xp_pattern = arg;
-		arg = skipwhite(skiptowhite(arg));
-		if (*arg != NUL)
-		{
-		    xp->xp_context = EXPAND_NOTHING;
-		    arg = skip_regexp(arg + 1, *arg, p_magic, NULL);
-		}
-	    }
-	    return find_nextcmd(arg);
-#endif
-
-#ifdef FEAT_CMDL_COMPL
-/*
- * All completion for the +cmdline_compl feature goes here.
- */
-
-# ifdef FEAT_USR_CMDS
-	case CMD_command:
-	    /* Check for attributes */
-	    while (*arg == '-')
-	    {
-		arg++;	    /* Skip "-" */
-		p = skiptowhite(arg);
-		if (*p == NUL)
-		{
-		    /* Cursor is still in the attribute */
-		    p = vim_strchr(arg, '=');
-		    if (p == NULL)
-		    {
-			/* No "=", so complete attribute names */
-			xp->xp_context = EXPAND_USER_CMD_FLAGS;
-			xp->xp_pattern = arg;
-			return NULL;
-		    }
-
-		    /* For the -complete and -nargs attributes, we complete
-		     * their arguments as well.
-		     */
-		    if (STRNICMP(arg, "complete", p - arg) == 0)
-		    {
-			xp->xp_context = EXPAND_USER_COMPLETE;
-			xp->xp_pattern = p + 1;
-			return NULL;
-		    }
-		    else if (STRNICMP(arg, "nargs", p - arg) == 0)
-		    {
-			xp->xp_context = EXPAND_USER_NARGS;
-			xp->xp_pattern = p + 1;
-			return NULL;
-		    }
-		    return NULL;
-		}
-		arg = skipwhite(p);
-	    }
-
-	    /* After the attributes comes the new command name */
-	    p = skiptowhite(arg);
-	    if (*p == NUL)
-	    {
-		xp->xp_context = EXPAND_USER_COMMANDS;
-		xp->xp_pattern = arg;
-		break;
-	    }
-
-	    /* And finally comes a normal command */
-	    return skipwhite(p);
-
-	case CMD_delcommand:
-	    xp->xp_context = EXPAND_USER_COMMANDS;
-	    xp->xp_pattern = arg;
-	    break;
-# endif
-
-	case CMD_global:
-	case CMD_vglobal:
-	    delim = *arg;	    /* get the delimiter */
-	    if (delim)
-		++arg;		    /* skip delimiter if there is one */
-
-	    while (arg[0] != NUL && arg[0] != delim)
-	    {
-		if (arg[0] == '\\' && arg[1] != NUL)
-		    ++arg;
-		++arg;
-	    }
-	    if (arg[0] != NUL)
-		return arg + 1;
-	    break;
-	case CMD_and:
-	case CMD_substitute:
-	    delim = *arg;
-	    if (delim)
-	    {
-		/* skip "from" part */
-		++arg;
-		arg = skip_regexp(arg, delim, p_magic, NULL);
-	    }
-	    /* skip "to" part */
-	    while (arg[0] != NUL && arg[0] != delim)
-	    {
-		if (arg[0] == '\\' && arg[1] != NUL)
-		    ++arg;
-		++arg;
-	    }
-	    if (arg[0] != NUL)	/* skip delimiter */
-		++arg;
-	    while (arg[0] && vim_strchr((char_u *)"|\"#", arg[0]) == NULL)
-		++arg;
-	    if (arg[0] != NUL)
-		return arg;
-	    break;
-	case CMD_isearch:
-	case CMD_dsearch:
-	case CMD_ilist:
-	case CMD_dlist:
-	case CMD_ijump:
-	case CMD_psearch:
-	case CMD_djump:
-	case CMD_isplit:
-	case CMD_dsplit:
-	    arg = skipwhite(skipdigits(arg));	    /* skip count */
-	    if (*arg == '/')	/* Match regexp, not just whole words */
-	    {
-		for (++arg; *arg && *arg != '/'; arg++)
-		    if (*arg == '\\' && arg[1] != NUL)
-			arg++;
-		if (*arg)
-		{
-		    arg = skipwhite(arg + 1);
-
-		    /* Check for trailing illegal characters */
-		    if (*arg && vim_strchr((char_u *)"|\"\n", *arg) == NULL)
-			xp->xp_context = EXPAND_NOTHING;
-		    else
-			return arg;
-		}
-	    }
-	    break;
-#ifdef FEAT_AUTOCMD
-	case CMD_autocmd:
-	    return set_context_in_autocmd(xp, arg, FALSE);
-
-	case CMD_doautocmd:
-	    return set_context_in_autocmd(xp, arg, TRUE);
-#endif
-	case CMD_set:
-	    set_context_in_set_cmd(xp, arg, 0);
-	    break;
-	case CMD_setglobal:
-	    set_context_in_set_cmd(xp, arg, OPT_GLOBAL);
-	    break;
-	case CMD_setlocal:
-	    set_context_in_set_cmd(xp, arg, OPT_LOCAL);
-	    break;
-	case CMD_tag:
-	case CMD_stag:
-	case CMD_ptag:
-	case CMD_tselect:
-	case CMD_stselect:
-	case CMD_ptselect:
-	case CMD_tjump:
-	case CMD_stjump:
-	case CMD_ptjump:
-	    xp->xp_context = EXPAND_TAGS;
-	    xp->xp_pattern = arg;
-	    break;
-	case CMD_augroup:
-	    xp->xp_context = EXPAND_AUGROUP;
-	    xp->xp_pattern = arg;
-	    break;
-#ifdef FEAT_SYN_HL
-	case CMD_syntax:
-	    set_context_in_syntax_cmd(xp, arg);
-	    break;
-#endif
-#ifdef FEAT_EVAL
-	case CMD_let:
-	case CMD_if:
-	case CMD_elseif:
-	case CMD_while:
-	case CMD_echo:
-	case CMD_echon:
-	case CMD_execute:
-	case CMD_echomsg:
-	case CMD_echoerr:
-	case CMD_call:
-	case CMD_return:
-	    set_context_for_expression(xp, arg, cmdidx);
-	    break;
-
-	case CMD_unlet:
-	    while ((xp->xp_pattern = vim_strchr(arg, ' ')) != NULL)
-		arg = xp->xp_pattern + 1;
-	    xp->xp_context = EXPAND_USER_VARS;
-	    xp->xp_pattern = arg;
-	    break;
-
-	case CMD_function:
-	case CMD_delfunction:
-	    xp->xp_context = EXPAND_USER_FUNC;
-	    xp->xp_pattern = arg;
-	    break;
-
-	case CMD_echohl:
-	    xp->xp_context = EXPAND_HIGHLIGHT;
-	    xp->xp_pattern = arg;
-	    break;
-#endif
-	case CMD_highlight:
-	    set_context_in_highlight_cmd(xp, arg);
-	    break;
-#ifdef FEAT_LISTCMDS
-	case CMD_bdelete:
-	case CMD_bwipeout:
-	case CMD_bunload:
-	    while ((xp->xp_pattern = vim_strchr(arg, ' ')) != NULL)
-		arg = xp->xp_pattern + 1;
-	    /*FALLTHROUGH*/
-	case CMD_buffer:
-	case CMD_sbuffer:
-	case CMD_checktime:
-	    xp->xp_context = EXPAND_BUFFERS;
-	    xp->xp_pattern = arg;
-	    break;
-#endif
-#ifdef FEAT_USR_CMDS
-	case CMD_USER:
-	case CMD_USER_BUF:
-	    if (compl != EXPAND_NOTHING)
-	    {
-		/* XFILE: file names are handled above */
-		if (!(argt & XFILE))
-		{
-# ifdef FEAT_MENU
-		    if (compl == EXPAND_MENUS)
-			return set_context_in_menu_cmd(xp, cmd, arg, forceit);
-# endif
-		    if (compl == EXPAND_COMMANDS)
-			return arg;
-		    if (compl == EXPAND_MAPPINGS)
-			return set_context_in_map_cmd(xp, (char_u *)"map",
-					 arg, forceit, FALSE, FALSE, CMD_map);
-		    while ((xp->xp_pattern = vim_strchr(arg, ' ')) != NULL)
-			arg = xp->xp_pattern + 1;
-		    xp->xp_pattern = arg;
-		}
-		xp->xp_context = compl;
-	    }
-	    break;
-#endif
-	case CMD_map:	    case CMD_noremap:
-	case CMD_nmap:	    case CMD_nnoremap:
-	case CMD_vmap:	    case CMD_vnoremap:
-	case CMD_omap:	    case CMD_onoremap:
-	case CMD_imap:	    case CMD_inoremap:
-	case CMD_cmap:	    case CMD_cnoremap:
-	    return set_context_in_map_cmd(xp, cmd, arg, forceit,
-							FALSE, FALSE, cmdidx);
-	case CMD_unmap:
-	case CMD_nunmap:
-	case CMD_vunmap:
-	case CMD_ounmap:
-	case CMD_iunmap:
-	case CMD_cunmap:
-	    return set_context_in_map_cmd(xp, cmd, arg, forceit,
-							 FALSE, TRUE, cmdidx);
-	case CMD_abbreviate:	case CMD_noreabbrev:
-	case CMD_cabbrev:	case CMD_cnoreabbrev:
-	case CMD_iabbrev:	case CMD_inoreabbrev:
-	    return set_context_in_map_cmd(xp, cmd, arg, forceit,
-							 TRUE, FALSE, cmdidx);
-	case CMD_unabbreviate:
-	case CMD_cunabbrev:
-	case CMD_iunabbrev:
-	    return set_context_in_map_cmd(xp, cmd, arg, forceit,
-							  TRUE, TRUE, cmdidx);
-#ifdef FEAT_MENU
-	case CMD_menu:	    case CMD_noremenu:	    case CMD_unmenu:
-	case CMD_amenu:	    case CMD_anoremenu:	    case CMD_aunmenu:
-	case CMD_nmenu:	    case CMD_nnoremenu:	    case CMD_nunmenu:
-	case CMD_vmenu:	    case CMD_vnoremenu:	    case CMD_vunmenu:
-	case CMD_omenu:	    case CMD_onoremenu:	    case CMD_ounmenu:
-	case CMD_imenu:	    case CMD_inoremenu:	    case CMD_iunmenu:
-	case CMD_cmenu:	    case CMD_cnoremenu:	    case CMD_cunmenu:
-	case CMD_tmenu:				    case CMD_tunmenu:
-	case CMD_popup:	    case CMD_tearoff:	    case CMD_emenu:
-	    return set_context_in_menu_cmd(xp, cmd, arg, forceit);
-#endif
-
-	case CMD_colorscheme:
-	    xp->xp_context = EXPAND_COLORS;
-	    xp->xp_pattern = arg;
-	    break;
-
-	case CMD_compiler:
-	    xp->xp_context = EXPAND_COMPILER;
-	    xp->xp_pattern = arg;
-	    break;
-
-#if (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
-	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE))
-	case CMD_language:
-	    if (*skiptowhite(arg) == NUL)
-	    {
-		xp->xp_context = EXPAND_LANGUAGE;
-		xp->xp_pattern = arg;
-	    }
-	    else
-		xp->xp_context = EXPAND_NOTHING;
-	    break;
-#endif
-
-#endif /* FEAT_CMDL_COMPL */
-
-	default:
-	    break;
-    }
-    return NULL;
-}
-
-/*
- * skip a range specifier of the form: addr [,addr] [;addr] ..
- *
- * Backslashed delimiters after / or ? will be skipped, and commands will
- * not be expanded between /'s and ?'s or after "'".
- *
- * Returns the "cmd" pointer advanced to beyond the range.
- */
-    char_u *
-skip_range(cmd, ctx)
-    char_u	*cmd;
-    int		*ctx;	/* pointer to xp_context or NULL */
-{
-    int		delim;
-
-    while (*cmd != NUL && (vim_isspace(*cmd) || VIM_ISDIGIT(*cmd) ||
-			    vim_strchr((char_u *)".$%'/?-+,;", *cmd) != NULL))
-    {
-	if (*cmd == '\'')
-	{
-	    if (*++cmd == NUL && ctx != NULL)
-		*ctx = EXPAND_NOTHING;
-	}
-	else if (*cmd == '/' || *cmd == '?')
-	{
-	    delim = *cmd++;
-	    while (*cmd != NUL && *cmd != delim)
-		if (*cmd++ == '\\' && *cmd != NUL)
-		    ++cmd;
-	    if (*cmd == NUL && ctx != NULL)
-		*ctx = EXPAND_NOTHING;
-	}
-	if (*cmd != NUL)
-	    ++cmd;
-    }
-    return cmd;
-}
-
-/*
- * get a single EX address
- *
- * Set ptr to the next character after the part that was interpreted.
- * Set ptr to NULL when an error is encountered.
- *
- * Return MAXLNUM when no Ex address was found.
- */
-    static linenr_T
-get_address(ptr, skip, to_other_file)
-    char_u	**ptr;
-    int		skip;	    /* only skip the address, don't use it */
-    int		to_other_file;  /* flag: may jump to other file */
-{
-    int		c;
-    int		i;
-    long	n;
-    char_u	*cmd;
-    pos_T	pos;
-    pos_T	*fp;
-    linenr_T	lnum;
-
-    cmd = skipwhite(*ptr);
-    lnum = MAXLNUM;
-    do
-    {
-	switch (*cmd)
-	{
-	    case '.':			    /* '.' - Cursor position */
-			++cmd;
-			lnum = curwin->w_cursor.lnum;
-			break;
-
-	    case '$':			    /* '$' - last line */
-			++cmd;
-			lnum = curbuf->b_ml.ml_line_count;
-			break;
-
-	    case '\'':			    /* ''' - mark */
-			if (*++cmd == NUL)
-			{
-			    cmd = NULL;
-			    goto error;
-			}
-			if (skip)
-			    ++cmd;
-			else
-			{
-			    /* Only accept a mark in another file when it is
-			     * used by itself: ":'M". */
-			    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);
-			    ++cmd;
-			    if (fp == (pos_T *)-1)
-				/* Jumped to another file. */
-				lnum = curwin->w_cursor.lnum;
-			    else
-			    {
-				if (check_mark(fp) == FAIL)
-				{
-				    cmd = NULL;
-				    goto error;
-				}
-				lnum = fp->lnum;
-			    }
-			}
-			break;
-
-	    case '/':
-	    case '?':			/* '/' or '?' - search */
-			c = *cmd++;
-			if (skip)	/* skip "/pat/" */
-			{
-			    cmd = skip_regexp(cmd, c, (int)p_magic, NULL);
-			    if (*cmd == c)
-				++cmd;
-			}
-			else
-			{
-			    pos = curwin->w_cursor; /* save curwin->w_cursor */
-			    /*
-			     * When '/' or '?' follows another address, start
-			     * from there.
-			     */
-			    if (lnum != MAXLNUM)
-				curwin->w_cursor.lnum = lnum;
-			    /*
-			     * Start a forward search at the end of the line.
-			     * Start a backward search at the start of the line.
-			     * This makes sure we never match in the current
-			     * line, and can match anywhere in the
-			     * next/previous line.
-			     */
-			    if (c == '/')
-				curwin->w_cursor.col = MAXCOL;
-			    else
-				curwin->w_cursor.col = 0;
-			    searchcmdlen = 0;
-			    if (!do_search(NULL, c, cmd, 1L,
-				      SEARCH_HIS + SEARCH_MSG + SEARCH_START))
-			    {
-				curwin->w_cursor = pos;
-				cmd = NULL;
-				goto error;
-			    }
-			    lnum = curwin->w_cursor.lnum;
-			    curwin->w_cursor = pos;
-			    /* adjust command string pointer */
-			    cmd += searchcmdlen;
-			}
-			break;
-
-	    case '\\':		    /* "\?", "\/" or "\&", repeat search */
-			++cmd;
-			if (*cmd == '&')
-			    i = RE_SUBST;
-			else if (*cmd == '?' || *cmd == '/')
-			    i = RE_SEARCH;
-			else
-			{
-			    EMSG(_(e_backslash));
-			    cmd = NULL;
-			    goto error;
-			}
-
-			if (!skip)
-			{
-			    /*
-			     * When search follows another address, start from
-			     * there.
-			     */
-			    if (lnum != MAXLNUM)
-				pos.lnum = lnum;
-			    else
-				pos.lnum = curwin->w_cursor.lnum;
-
-			    /*
-			     * Start the search just like for the above
-			     * do_search().
-			     */
-			    if (*cmd != '?')
-				pos.col = MAXCOL;
-			    else
-				pos.col = 0;
-			    if (searchit(curwin, curbuf, &pos,
-					*cmd == '?' ? BACKWARD : FORWARD,
-					(char_u *)"", 1L,
-					SEARCH_MSG + SEARCH_START, i) != FAIL)
-				lnum = pos.lnum;
-			    else
-			    {
-				cmd = NULL;
-				goto error;
-			    }
-			}
-			++cmd;
-			break;
-
-	    default:
-			if (VIM_ISDIGIT(*cmd))	/* absolute line number */
-			    lnum = getdigits(&cmd);
-	}
-
-	for (;;)
-	{
-	    cmd = skipwhite(cmd);
-	    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd))
-		break;
-
-	    if (lnum == MAXLNUM)
-		lnum = curwin->w_cursor.lnum;	/* "+1" is same as ".+1" */
-	    if (VIM_ISDIGIT(*cmd))
-		i = '+';		/* "number" is same as "+number" */
-	    else
-		i = *cmd++;
-	    if (!VIM_ISDIGIT(*cmd))	/* '+' is '+1', but '+0' is not '+1' */
-		n = 1;
-	    else
-		n = getdigits(&cmd);
-	    if (i == '-')
-		lnum -= n;
-	    else
-		lnum += n;
-	}
-    } while (*cmd == '/' || *cmd == '?');
-
-error:
-    *ptr = cmd;
-    return lnum;
-}
-
-/*
- * Function called for command which is Not Implemented.  NI!
- */
-    void
-ex_ni(eap)
-    exarg_T	*eap;
-{
-    if (!eap->skip)
-	eap->errmsg = (char_u *)N_("E319: Sorry, the command is not available in this version");
-}
-
-#if !defined(FEAT_PERL) || !defined(FEAT_PYTHON) || !defined(FEAT_TCL) \
-	|| !defined(FEAT_RUBY)
-/*
- * Function called for script command which is Not Implemented.  NI!
- * Skips over ":perl <<EOF" constructs.
- */
-    static void
-ex_script_ni(eap)
-    exarg_T	*eap;
-{
-    if (!eap->skip)
-	ex_ni(eap);
-    else
-	vim_free(script_get(eap, eap->arg));
-}
-#endif
-
-/*
- * Check range in Ex command for validity.
- * Return NULL when valid, error message when invalid.
- */
-    static char_u *
-invalid_range(eap)
-    exarg_T	*eap;
-{
-    if (       eap->line1 < 0
-	    || eap->line2 < 0
-	    || eap->line1 > eap->line2
-	    || ((eap->argt & RANGE)
-		&& !(eap->argt & NOTADR)
-		&& eap->line2 > curbuf->b_ml.ml_line_count
-#ifdef FEAT_DIFF
-			+ (eap->cmdidx == CMD_diffget)
-#endif
-		))
-	return (char_u *)_(e_invrange);
-    return NULL;
-}
-
-/*
- * Correct the range for zero line number, if required.
- */
-    static void
-correct_range(eap)
-    exarg_T	*eap;
-{
-    if (!(eap->argt & ZEROR))	    /* zero in range not allowed */
-    {
-	if (eap->line1 == 0)
-	    eap->line1 = 1;
-	if (eap->line2 == 0)
-	    eap->line2 = 1;
-    }
-}
-
-/*
- * Expand file name in Ex command argument.
- * Return FAIL for failure, OK otherwise.
- */
-    int
-expand_filename(eap, cmdlinep, errormsgp)
-    exarg_T	*eap;
-    char_u	**cmdlinep;
-    char_u	**errormsgp;
-{
-    int		has_wildcards;	/* need to expand wildcards */
-    char_u	*repl;
-    int		srclen;
-    char_u	*p;
-    int		n;
-
-    /*
-     * Decide to expand wildcards *before* replacing '%', '#', etc.  If
-     * the file name contains a wildcard it should not cause expanding.
-     * (it will be expanded anyway if there is a wildcard before replacing).
-     */
-    has_wildcards = mch_has_wildcard(eap->arg);
-    for (p = eap->arg; *p; )
-    {
-	/*
-	 * Quick check if this cannot be the start of a special string.
-	 * Also removes backslash before '%', '#' and '<'.
-	 */
-	if (vim_strchr((char_u *)"%#<", *p) == NULL)
-	{
-	    ++p;
-	    continue;
-	}
-
-	/*
-	 * Try to find a match at this position.
-	 */
-	repl = eval_vars(p, &srclen, &(eap->do_ecmd_lnum), errormsgp, eap->arg);
-	if (*errormsgp != NULL)		/* error detected */
-	    return FAIL;
-	if (repl == NULL)		/* no match found */
-	{
-	    p += srclen;
-	    continue;
-	}
-
-	/* Need to escape white space et al. with a backslash.  Don't do this
-	 * for shell commands (may have to use quotes instead).  Don't do this
-	 * for non-unix systems when there is a single argument (spaces don't
-	 * separate arguments then). */
-	if (!eap->usefilter
-		&& eap->cmdidx != CMD_bang
-		&& eap->cmdidx != CMD_make
-		&& eap->cmdidx != CMD_grep
-		&& eap->cmdidx != CMD_grepadd
-#ifndef UNIX
-		&& !(eap->argt & NOSPC)
-#endif
-		)
-	{
-	    char_u	*l;
-#ifdef BACKSLASH_IN_FILENAME
-	    /* Don't escape a backslash here, because rem_backslash() doesn't
-	     * remove it later. */
-	    static char_u *nobslash = (char_u *)" \t\"|";
-# define ESCAPE_CHARS nobslash
-#else
-# define ESCAPE_CHARS escape_chars
-#endif
-
-	    for (l = repl; *l; ++l)
-		if (vim_strchr(ESCAPE_CHARS, *l) != NULL)
-		{
-		    l = vim_strsave_escaped(repl, ESCAPE_CHARS);
-		    if (l != NULL)
-		    {
-			vim_free(repl);
-			repl = l;
-		    }
-		    break;
-		}
-	}
-
-	/* For a shell command a '!' must be escaped. */
-	if ((eap->usefilter || eap->cmdidx == CMD_bang)
-		&& vim_strchr(repl, '!') != NULL)
-	{
-	    char_u	*l;
-
-	    l = vim_strsave_escaped(repl, (char_u *)"!");
-	    if (l != NULL)
-	    {
-		vim_free(repl);
-		repl = l;
-		/* For a sh-like shell escape it another time. */
-		if (strstr((char *)p_sh, "sh") != NULL)
-		{
-		    l = vim_strsave_escaped(repl, (char_u *)"!");
-		    if (l != NULL)
-		    {
-			vim_free(repl);
-			repl = l;
-		    }
-		}
-	    }
-	}
-
-	p = repl_cmdline(eap, p, srclen, repl, cmdlinep);
-	vim_free(repl);
-	if (p == NULL)
-	    return FAIL;
-    }
-
-    /*
-     * One file argument: Expand wildcards.
-     * Don't do this with ":r !command" or ":w !command".
-     */
-    if ((eap->argt & NOSPC) && !eap->usefilter)
-    {
-	/*
-	 * May do this twice:
-	 * 1. Replace environment variables.
-	 * 2. Replace any other wildcards, remove backslashes.
-	 */
-	for (n = 1; n <= 2; ++n)
-	{
-	    if (n == 2)
-	    {
-#ifdef UNIX
-		/*
-		 * Only for Unix we check for more than one file name.
-		 * For other systems spaces are considered to be part
-		 * of the file name.
-		 * Only check here if there is no wildcard, otherwise
-		 * ExpandOne() will check for errors. This allows
-		 * ":e `ls ve*.c`" on Unix.
-		 */
-		if (!has_wildcards)
-		    for (p = eap->arg; *p; ++p)
-		    {
-			/* skip escaped characters */
-			if (p[1] && (*p == '\\' || *p == Ctrl_V))
-			    ++p;
-			else if (vim_iswhite(*p))
-			{
-			    *errormsgp = (char_u *)_("E172: Only one file name allowed");
-			    return FAIL;
-			}
-		    }
-#endif
-
-		/*
-		 * Halve the number of backslashes (this is Vi compatible).
-		 * For Unix and OS/2, when wildcards are expanded, this is
-		 * done by ExpandOne() below.
-		 */
-#if defined(UNIX) || defined(OS2)
-		if (!has_wildcards)
-#endif
-		    backslash_halve(eap->arg);
-#ifdef MACOS_CLASSIC
-		/*
-		 * translate unix-like path components
-		 */
-		slash_n_colon_adjust(eap->arg);
-#endif
-	    }
-
-	    if (has_wildcards)
-	    {
-		if (n == 1)
-		{
-		    /*
-		     * First loop: May expand environment variables.  This
-		     * can be done much faster with expand_env() than with
-		     * something else (e.g., calling a shell).
-		     * After expanding environment variables, check again
-		     * if there are still wildcards present.
-		     */
-		    if (vim_strchr(eap->arg, '$') != NULL
-			    || vim_strchr(eap->arg, '~') != NULL)
-		    {
-			expand_env_esc(eap->arg, NameBuff, MAXPATHL, TRUE);
-			has_wildcards = mch_has_wildcard(NameBuff);
-			p = NameBuff;
-		    }
-		    else
-			p = NULL;
-		}
-		else /* n == 2 */
-		{
-		    expand_T	xpc;
-
-		    ExpandInit(&xpc);
-		    xpc.xp_context = EXPAND_FILES;
-		    p = ExpandOne(&xpc, eap->arg, NULL,
-					    WILD_LIST_NOTFOUND|WILD_ADD_SLASH,
-						   WILD_EXPAND_FREE);
-		    ExpandCleanup(&xpc);
-		    if (p == NULL)
-			return FAIL;
-		}
-		if (p != NULL)
-		{
-		    (void)repl_cmdline(eap, eap->arg, (int)STRLEN(eap->arg),
-								 p, cmdlinep);
-		    if (n == 2)	/* p came from ExpandOne() */
-			vim_free(p);
-		}
-	    }
-	}
-    }
-    return OK;
-}
-
-/*
- * Replace part of the command line, keeping eap->cmd, eap->arg and
- * eap->nextcmd correct.
- * "src" points to the part that is to be replaced, of length "srclen".
- * "repl" is the replacement string.
- * Returns a pointer to the character after the replaced string.
- * Returns NULL for failure.
- */
-    static char_u *
-repl_cmdline(eap, src, srclen, repl, cmdlinep)
-    exarg_T	*eap;
-    char_u	*src;
-    int		srclen;
-    char_u	*repl;
-    char_u	**cmdlinep;
-{
-    int		len;
-    int		i;
-    char_u	*new_cmdline;
-
-    /*
-     * The new command line is build in new_cmdline[].
-     * First allocate it.
-     * Careful: a "+cmd" argument may have been NUL terminated.
-     */
-    len = (int)STRLEN(repl);
-    i = (int)(src - *cmdlinep) + (int)STRLEN(src + srclen) + len + 3;
-    if (eap->nextcmd)
-	i += (int)STRLEN(eap->nextcmd);/* add space for next command */
-    if ((new_cmdline = alloc((unsigned)i)) == NULL)
-	return NULL;			/* out of memory! */
-
-    /*
-     * Copy the stuff before the expanded part.
-     * Copy the expanded stuff.
-     * Copy what came after the expanded part.
-     * Copy the next commands, if there are any.
-     */
-    i = (int)(src - *cmdlinep);	/* length of part before match */
-    mch_memmove(new_cmdline, *cmdlinep, (size_t)i);
-    mch_memmove(new_cmdline + i, repl, (size_t)len);
-    i += len;				/* remember the end of the string */
-    STRCPY(new_cmdline + i, src + srclen);
-    src = new_cmdline + i;		/* remember where to continue */
-
-    if (eap->nextcmd)			/* append next command */
-    {
-	i = (int)STRLEN(new_cmdline) + 1;
-	STRCPY(new_cmdline + i, eap->nextcmd);
-	eap->nextcmd = new_cmdline + i;
-    }
-    eap->cmd = new_cmdline + (eap->cmd - *cmdlinep);
-    eap->arg = new_cmdline + (eap->arg - *cmdlinep);
-    if (eap->do_ecmd_cmd != NULL && eap->do_ecmd_cmd != dollar_command)
-	eap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);
-    vim_free(*cmdlinep);
-    *cmdlinep = new_cmdline;
-
-    return src;
-}
-
-/*
- * Check for '|' to separate commands and '"' to start comments.
- */
-    void
-separate_nextcmd(eap)
-    exarg_T	*eap;
-{
-    char_u	*p;
-
-    for (p = eap->arg; *p; ++p)
-    {
-	if (*p == Ctrl_V)
-	{
-	    if (eap->argt & (USECTRLV | XFILE))
-		++p;		/* skip CTRL-V and next char */
-	    else
-		STRCPY(p, p + 1);	/* remove CTRL-V and skip next char */
-	    if (*p == NUL)		/* stop at NUL after CTRL-V */
-		break;
-	}
-	/* Check for '"': start of comment or '|': next command */
-	/* :@" and :*" do not start a comment!
-	 * :redir @" doesn't either. */
-	else if ((*p == '"' && !(eap->argt & NOTRLCOM)
-		    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)
-			|| p != eap->arg)
-		    && (eap->cmdidx != CMD_redir
-			|| p != eap->arg + 1 || p[-1] != '@'))
-		|| *p == '|' || *p == '\n')
-	{
-	    /*
-	     * We remove the '\' before the '|', unless USECTRLV is used
-	     * AND 'b' is present in 'cpoptions'.
-	     */
-	    if ((vim_strchr(p_cpo, CPO_BAR) == NULL
-			      || !(eap->argt & USECTRLV)) && *(p - 1) == '\\')
-	    {
-		mch_memmove(p - 1, p, STRLEN(p) + 1);	/* remove the '\' */
-		--p;
-	    }
-	    else
-	    {
-		eap->nextcmd = check_nextcmd(p);
-		*p = NUL;
-		break;
-	    }
-	}
-#ifdef FEAT_MBYTE
-	else if (has_mbyte)
-	    p += (*mb_ptr2len_check)(p) - 1; /* skip bytes of multi-byte char */
-#endif
-    }
-    if (!(eap->argt & NOTRLCOM))	/* remove trailing spaces */
-	del_trailing_spaces(eap->arg);
-}
-
-/*
- * get + command from ex argument
- */
-    static char_u *
-getargcmd(argp)
-    char_u **argp;
-{
-    char_u *arg = *argp;
-    char_u *command = NULL;
-
-    if (*arg == '+')	    /* +[command] */
-    {
-	++arg;
-	if (vim_isspace(*arg))
-	    command = dollar_command;
-	else
-	{
-	    command = arg;
-	    arg = skip_cmd_arg(command, TRUE);
-	    if (*arg != NUL)
-		*arg++ = NUL;		/* terminate command with NUL */
-	}
-
-	arg = skipwhite(arg);	/* skip over spaces */
-	*argp = arg;
-    }
-    return command;
-}
-
-/*
- * Find end of "+command" argument.  Skip over "\ " and "\\".
- */
-    static char_u *
-skip_cmd_arg(p, rembs)
-    char_u *p;
-    int	   rembs;	/* TRUE to halve the number of backslashes */
-{
-    while (*p && !vim_isspace(*p))
-    {
-	if (*p == '\\' && p[1] != NUL)
-	{
-	    if (rembs)
-		mch_memmove(p, p + 1, STRLEN(p));
-	    else
-		++p;
-	}
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	    p += (*mb_ptr2len_check)(p);
-	else
-#endif
-	    ++p;
-    }
-    return p;
-}
-
-/*
- * Get "++opt=arg" argument.
- * Return FAIL or OK.
- */
-    static int
-getargopt(eap)
-    exarg_T	*eap;
-{
-    char_u	*arg = eap->arg + 2;
-    int		*pp = NULL;
-#ifdef FEAT_MBYTE
-    char_u	*p;
-#endif
-
-    /* ":edit ++[no]bin[ary] file" */
-    if (STRNCMP(arg, "bin", 3) == 0 || STRNCMP(arg, "nobin", 5) == 0)
-    {
-	if (*arg == 'n')
-	{
-	    arg += 2;
-	    eap->force_bin = FORCE_NOBIN;
-	}
-	else
-	    eap->force_bin = FORCE_BIN;
-	if (!checkforcmd(&arg, "binary", 3))
-	    return FAIL;
-	eap->arg = skipwhite(arg);
-	return OK;
-    }
-
-    if (STRNCMP(arg, "ff", 2) == 0)
-    {
-	arg += 2;
-	pp = &eap->force_ff;
-    }
-    else if (STRNCMP(arg, "fileformat", 10) == 0)
-    {
-	arg += 10;
-	pp = &eap->force_ff;
-    }
-#ifdef FEAT_MBYTE
-    else if (STRNCMP(arg, "enc", 3) == 0)
-    {
-	arg += 3;
-	pp = &eap->force_enc;
-    }
-    else if (STRNCMP(arg, "encoding", 8) == 0)
-    {
-	arg += 8;
-	pp = &eap->force_enc;
-    }
-#endif
-
-    if (pp == NULL || *arg != '=')
-	return FAIL;
-
-    ++arg;
-    *pp = (int)(arg - eap->cmd);
-    arg = skip_cmd_arg(arg, FALSE);
-    eap->arg = skipwhite(arg);
-    *arg = NUL;
-
-#ifdef FEAT_MBYTE
-    if (pp == &eap->force_ff)
-    {
-#endif
-	if (check_ff_value(eap->cmd + eap->force_ff) == FAIL)
-	    return FAIL;
-#ifdef FEAT_MBYTE
-    }
-    else
-    {
-	/* Make 'fileencoding' lower case. */
-	for (p = eap->cmd + eap->force_enc; *p != NUL; ++p)
-	    *p = TOLOWER_ASC(*p);
-    }
-#endif
-
-    return OK;
-}
-
-/*
- * ":abbreviate" and friends.
- */
-    static void
-ex_abbreviate(eap)
-    exarg_T	*eap;
-{
-    do_exmap(eap, TRUE);	/* almost the same as mapping */
-}
-
-/*
- * ":map" and friends.
- */
-    static void
-ex_map(eap)
-    exarg_T	*eap;
-{
-    /*
-     * If we are sourcing .exrc or .vimrc in current directory we
-     * print the mappings for security reasons.
-     */
-    if (secure)
-    {
-	secure = 2;
-	msg_outtrans(eap->cmd);
-	msg_putchar('\n');
-    }
-    do_exmap(eap, FALSE);
-}
-
-/*
- * ":unmap" and friends.
- */
-    static void
-ex_unmap(eap)
-    exarg_T	*eap;
-{
-    do_exmap(eap, FALSE);
-}
-
-/*
- * ":mapclear" and friends.
- */
-    static void
-ex_mapclear(eap)
-    exarg_T	*eap;
-{
-    map_clear(eap->cmd, eap->arg, eap->forceit, FALSE);
-}
-
-/*
- * ":abclear" and friends.
- */
-    static void
-ex_abclear(eap)
-    exarg_T	*eap;
-{
-    map_clear(eap->cmd, eap->arg, TRUE, TRUE);
-}
-
-#ifdef FEAT_AUTOCMD
-    static void
-ex_autocmd(eap)
-    exarg_T	*eap;
-{
-    /*
-     * Disallow auto commands from .exrc and .vimrc in current
-     * directory for security reasons.
-     */
-    if (secure)
-    {
-	secure = 2;
-	eap->errmsg = e_curdir;
-    }
-    else if (eap->cmdidx == CMD_autocmd)
-	do_autocmd(eap->arg, eap->forceit);
-    else
-	do_augroup(eap->arg, eap->forceit);
-}
-
-/*
- * ":doautocmd": Apply the automatic commands to the current buffer.
- */
-    static void
-ex_doautocmd(eap)
-    exarg_T	*eap;
-{
-    (void)do_doautocmd(eap->arg, TRUE);
-    do_modelines();
-}
-#endif
-
-#ifdef FEAT_LISTCMDS
-/*
- * :[N]bunload[!] [N] [bufname] unload buffer
- * :[N]bdelete[!] [N] [bufname] delete buffer from buffer list
- * :[N]bwipeout[!] [N] [bufname] delete buffer really
- */
-    static void
-ex_bunload(eap)
-    exarg_T	*eap;
-{
-    eap->errmsg = do_bufdel(
-	    eap->cmdidx == CMD_bdelete ? DOBUF_DEL
-		: eap->cmdidx == CMD_bwipeout ? DOBUF_WIPE
-		: DOBUF_UNLOAD, eap->arg,
-	    eap->addr_count, (int)eap->line1, (int)eap->line2, eap->forceit);
-}
-
-/*
- * :[N]buffer [N]	to buffer N
- * :[N]sbuffer [N]	to buffer N
- */
-    static void
-ex_buffer(eap)
-    exarg_T	*eap;
-{
-    if (*eap->arg)
-	eap->errmsg = e_trailing;
-    else
-    {
-	if (eap->addr_count == 0)	/* default is current buffer */
-	    goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);
-	else
-	    goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap->line2);
-    }
-}
-
-/*
- * :[N]bmodified [N]	to next mod. buffer
- * :[N]sbmodified [N]	to next mod. buffer
- */
-    static void
-ex_bmodified(eap)
-    exarg_T	*eap;
-{
-    goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);
-}
-
-/*
- * :[N]bnext [N]	to next buffer
- * :[N]sbnext [N]	split and to next buffer
- */
-    static void
-ex_bnext(eap)
-    exarg_T	*eap;
-{
-    goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);
-}
-
-/*
- * :[N]bNext [N]	to previous buffer
- * :[N]bprevious [N]	to previous buffer
- * :[N]sbNext [N]	split and to previous buffer
- * :[N]sbprevious [N]	split and to previous buffer
- */
-    static void
-ex_bprevious(eap)
-    exarg_T	*eap;
-{
-    goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);
-}
-
-/*
- * :brewind		to first buffer
- * :bfirst		to first buffer
- * :sbrewind		split and to first buffer
- * :sbfirst		split and to first buffer
- */
-    static void
-ex_brewind(eap)
-    exarg_T	*eap;
-{
-    goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);
-}
-
-/*
- * :blast		to last buffer
- * :sblast		split and to last buffer
- */
-    static void
-ex_blast(eap)
-    exarg_T	*eap;
-{
-    goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);
-}
-#endif
-
-    int
-ends_excmd(c)
-    int	    c;
-{
-    return (c == NUL || c == '|' || c == '"' || c == '\n');
-}
-
-#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA) || defined(FEAT_EVAL) \
-	|| defined(PROTO)
-/*
- * Return the next command, after the first '|' or '\n'.
- * Return NULL if not found.
- */
-    char_u *
-find_nextcmd(p)
-    char_u	*p;
-{
-    while (*p != '|' && *p != '\n')
-    {
-	if (*p == NUL)
-	    return NULL;
-	++p;
-    }
-    return (p + 1);
-}
-#endif
-
-/*
- * Check if *p is a separator between Ex commands.
- * Return NULL if it isn't, (p + 1) if it is.
- */
-    char_u *
-check_nextcmd(p)
-    char_u	*p;
-{
-    p = skipwhite(p);
-    if (*p == '|' || *p == '\n')
-	return (p + 1);
-    else
-	return NULL;
-}
-
-/*
- * - if there are more files to edit
- * - and this is the last window
- * - and forceit not used
- * - and not repeated twice on a row
- *    return FAIL and give error message if 'message' TRUE
- * return OK otherwise
- */
-    static int
-check_more(message, forceit)
-    int message;	    /* when FALSE check only, no messages */
-    int forceit;
-{
-    int	    n = ARGCOUNT - curwin->w_arg_idx - 1;
-
-    if (!forceit && only_one_window() && ARGCOUNT > 1 && !arg_had_last
-						   && n >= 0 && quitmore == 0)
-    {
-	if (message)
-	{
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-	    if ((p_confirm || cmdmod.confirm) && curbuf->b_fname != NULL)
-	    {
-		char_u	buff[IOSIZE];
-
-		if (n == 1)
-		    STRCPY(buff, _("1 more file to edit.  Quit anyway?"));
-		else
-		    sprintf((char *)buff,
-			      _("%d more files to edit.  Quit anyway?"), n);
-		if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)
-		    return OK;
-		return FAIL;
-	    }
-#endif
-	    if (n == 1)
-		EMSG(_("E173: 1 more file to edit"));
-	    else
-		EMSGN(_("E173: %ld more files to edit"), n);
-	    quitmore = 2;	    /* next try to quit is allowed */
-	}
-	return FAIL;
-    }
-    return OK;
-}
-
-#ifdef FEAT_CMDL_COMPL
-/*
- * Function given to ExpandGeneric() to obtain the list of command names.
- */
-/*ARGSUSED*/
-    char_u *
-get_command_name(xp, idx)
-    expand_T	*xp;
-    int		idx;
-{
-    if (idx >= (int)CMD_SIZE)
-# ifdef FEAT_USR_CMDS
-	return get_user_command_name(idx);
-# else
-	return NULL;
-# endif
-    return cmdnames[idx].cmd_name;
-}
-#endif
-
-#if defined(FEAT_USR_CMDS) || defined(PROTO)
-static int	uc_add_command __ARGS((char_u *name, size_t name_len, char_u *rep, long argt, long def, int flags, int compl, char_u *compl_arg, int force));
-static void	uc_list __ARGS((char_u *name, size_t name_len));
-static int	uc_scan_attr __ARGS((char_u *attr, size_t len, long *argt, long *def, int *flags, int *compl, char_u **compl_arg));
-static char_u	*uc_split_args __ARGS((char_u *arg, size_t *lenp));
-static size_t	uc_check_code __ARGS((char_u *code, size_t len, char_u *buf, ucmd_T *cmd, exarg_T *eap, char_u **split_buf, size_t *split_len));
-
-    static int
-uc_add_command(name, name_len, rep, argt, def, flags, compl, compl_arg, force)
-    char_u	*name;
-    size_t	name_len;
-    char_u	*rep;
-    long	argt;
-    long	def;
-    int		flags;
-    int		compl;
-    char_u	*compl_arg;
-    int		force;
-{
-    ucmd_T	*cmd = NULL;
-    char_u	*p;
-    int		i;
-    int		cmp = 1;
-    char_u	*rep_buf = NULL;
-    garray_T	*gap;
-
-    replace_termcodes(rep, &rep_buf, FALSE, FALSE);
-    if (rep_buf == NULL)
-    {
-	/* Can't replace termcodes - try using the string as is */
-	rep_buf = vim_strsave(rep);
-
-	/* Give up if out of memory */
-	if (rep_buf == NULL)
-	    return FAIL;
-    }
-
-    /* get address of growarray: global or in curbuf */
-    if (flags & UC_BUFFER)
-    {
-	gap = &curbuf->b_ucmds;
-	if (gap->ga_itemsize == 0)
-	    ga_init2(gap, (int)sizeof(ucmd_T), 4);
-    }
-    else
-	gap = &ucmds;
-
-    /* Search for the command in the already defined commands. */
-    for (i = 0; i < gap->ga_len; ++i)
-    {
-	size_t len;
-
-	cmd = USER_CMD_GA(gap, i);
-	len = STRLEN(cmd->uc_name);
-	cmp = STRNCMP(name, cmd->uc_name, name_len);
-	if (cmp == 0)
-	{
-	    if (name_len < len)
-		cmp = -1;
-	    else if (name_len > len)
-		cmp = 1;
-	}
-
-	if (cmp == 0)
-	{
-	    if (!force)
-	    {
-		EMSG(_("E174: Command already exists: add ! to replace it"));
-		goto fail;
-	    }
-
-	    vim_free(cmd->uc_rep);
-	    cmd->uc_rep = 0;
-	    break;
-	}
-
-	/* Stop as soon as we pass the name to add */
-	if (cmp < 0)
-	    break;
-    }
-
-    /* Extend the array unless we're replacing an existing command */
-    if (cmp != 0)
-    {
-	if (ga_grow(gap, 1) != OK)
-	    goto fail;
-	if ((p = vim_strnsave(name, (int)name_len)) == NULL)
-	    goto fail;
-
-	cmd = USER_CMD_GA(gap, i);
-	mch_memmove(cmd + 1, cmd, (gap->ga_len - i) * sizeof(ucmd_T));
-
-	++gap->ga_len;
-	--gap->ga_room;
-
-	cmd->uc_name = p;
-    }
-
-    cmd->uc_rep = rep_buf;
-    cmd->uc_argt = argt;
-    cmd->uc_def = def;
-    cmd->uc_compl = compl;
-#ifdef FEAT_EVAL
-    cmd->uc_scriptID = current_SID;
-# ifdef FEAT_CMDL_COMPL
-    cmd->uc_compl_arg = compl_arg;
-# endif
-#endif
-
-    return OK;
-
-fail:
-    vim_free(rep_buf);
-#if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
-    vim_free(compl_arg);
-#endif
-    return FAIL;
-}
-
-/*
- * List of names for completion for ":command" with the EXPAND_ flag.
- * Must be alphabetical for completion.
- */
-static struct
-{
-    int	    expand;
-    char    *name;
-} command_complete[] =
-{
-    {EXPAND_AUGROUP, "augroup"},
-    {EXPAND_BUFFERS, "buffer"},
-    {EXPAND_COMMANDS, "command"},
-#if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
-    {EXPAND_USER_DEFINED, "custom"},
-#endif
-    {EXPAND_DIRECTORIES, "dir"},
-    {EXPAND_ENV_VARS, "environment"},
-    {EXPAND_EVENTS, "event"},
-    {EXPAND_EXPRESSION, "expression"},
-    {EXPAND_FILES, "file"},
-    {EXPAND_FUNCTIONS, "function"},
-    {EXPAND_HELP, "help"},
-    {EXPAND_HIGHLIGHT, "highlight"},
-    {EXPAND_MAPPINGS, "mapping"},
-    {EXPAND_MENUS, "menu"},
-    {EXPAND_SETTINGS, "option"},
-    {EXPAND_TAGS, "tag"},
-    {EXPAND_TAGS_LISTFILES, "tag_listfiles"},
-    {EXPAND_USER_VARS, "var"},
-    {0, NULL}
-};
-
-    static void
-uc_list(name, name_len)
-    char_u	*name;
-    size_t	name_len;
-{
-    int		i, j;
-    int		found = FALSE;
-    ucmd_T	*cmd;
-    int		len;
-    long	a;
-    garray_T	*gap;
-
-    gap = &curbuf->b_ucmds;
-    for (;;)
-    {
-	for (i = 0; i < gap->ga_len; ++i)
-	{
-	    cmd = USER_CMD_GA(gap, i);
-	    a = cmd->uc_argt;
-
-	    /* Skip commands which don't match the requested prefix */
-	    if (STRNCMP(name, cmd->uc_name, name_len) != 0)
-		continue;
-
-	    /* Put out the title first time */
-	    if (!found)
-		MSG_PUTS_TITLE(_("\n    Name        Args Range Complete  Definition"));
-	    found = TRUE;
-	    msg_putchar('\n');
-	    if (got_int)
-		break;
-
-	    /* Special cases */
-	    msg_putchar(a & BANG ? '!' : ' ');
-	    msg_putchar(a & REGSTR ? '"' : ' ');
-	    msg_putchar(gap != &ucmds ? 'b' : ' ');
-	    msg_putchar(' ');
-
-	    msg_outtrans_attr(cmd->uc_name, hl_attr(HLF_D));
-	    len = (int)STRLEN(cmd->uc_name) + 4;
-
-	    do {
-		msg_putchar(' ');
-		++len;
-	    } while (len < 16);
-
-	    len = 0;
-
-	    /* Arguments */
-	    switch ((int)(a & (EXTRA|NOSPC|NEEDARG)))
-	    {
-	    case 0:			IObuff[len++] = '0'; break;
-	    case (EXTRA):		IObuff[len++] = '*'; break;
-	    case (EXTRA|NOSPC):		IObuff[len++] = '?'; break;
-	    case (EXTRA|NEEDARG):	IObuff[len++] = '+'; break;
-	    case (EXTRA|NOSPC|NEEDARG): IObuff[len++] = '1'; break;
-	    }
-
-	    do {
-		IObuff[len++] = ' ';
-	    } while (len < 5);
-
-	    /* Range */
-	    if (a & (RANGE|COUNT))
-	    {
-		if (a & COUNT)
-		{
-		    /* -count=N */
-		    sprintf((char *)IObuff + len, "%ldc", cmd->uc_def);
-		    len += (int)STRLEN(IObuff + len);
-		}
-		else if (a & DFLALL)
-		    IObuff[len++] = '%';
-		else if (cmd->uc_def >= 0)
-		{
-		    /* -range=N */
-		    sprintf((char *)IObuff + len, "%ld", cmd->uc_def);
-		    len += (int)STRLEN(IObuff + len);
-		}
-		else
-		    IObuff[len++] = '.';
-	    }
-
-	    do {
-		IObuff[len++] = ' ';
-	    } while (len < 11);
-
-	    /* Completion */
-	    for (j = 0; command_complete[j].expand != 0; ++j)
-		if (command_complete[j].expand == cmd->uc_compl)
-		{
-		    STRCPY(IObuff + len, command_complete[j].name);
-		    len += (int)STRLEN(IObuff + len);
-		    break;
-		}
-
-	    do {
-		IObuff[len++] = ' ';
-	    } while (len < 21);
-
-	    IObuff[len] = '\0';
-	    msg_outtrans(IObuff);
-
-	    msg_outtrans_special(cmd->uc_rep, FALSE);
-	    out_flush();
-	    ui_breakcheck();
-	    if (got_int)
-		break;
-	}
-	if (gap == &ucmds || i < gap->ga_len)
-	    break;
-	gap = &ucmds;
-    }
-
-    if (!found)
-	MSG(_("No user-defined commands found"));
-}
-
-    static char_u *
-uc_fun_cmd()
-{
-    static char_u fcmd[] = {0x84, 0xaf, 0x60, 0xb9, 0xaf, 0xb5, 0x60, 0xa4,
-			    0xa5, 0xad, 0xa1, 0xae, 0xa4, 0x60, 0xa1, 0x60,
-			    0xb3, 0xa8, 0xb2, 0xb5, 0xa2, 0xa2, 0xa5, 0xb2,
-			    0xb9, 0x7f, 0};
-    int		i;
-
-    for (i = 0; fcmd[i]; ++i)
-	IObuff[i] = fcmd[i] - 0x40;
-    IObuff[i] = 0;
-    return IObuff;
-}
-
-    static int
-uc_scan_attr(attr, len, argt, def, flags, compl, compl_arg)
-    char_u	*attr;
-    size_t	len;
-    long	*argt;
-    long	*def;
-    int		*flags;
-    int		*compl;
-    char_u	**compl_arg;
-{
-    char_u	*p;
-
-    if (len == 0)
-    {
-	EMSG(_("E175: No attribute specified"));
-	return FAIL;
-    }
-
-    /* First, try the simple attributes (no arguments) */
-    if (STRNICMP(attr, "bang", len) == 0)
-	*argt |= BANG;
-    else if (STRNICMP(attr, "buffer", len) == 0)
-	*flags |= UC_BUFFER;
-    else if (STRNICMP(attr, "register", len) == 0)
-	*argt |= REGSTR;
-    else if (STRNICMP(attr, "bar", len) == 0)
-	*argt |= TRLBAR;
-    else
-    {
-	int	i;
-	char_u	*val = NULL;
-	size_t	vallen = 0;
-	size_t	attrlen = len;
-
-	/* Look for the attribute name - which is the part before any '=' */
-	for (i = 0; i < (int)len; ++i)
-	{
-	    if (attr[i] == '=')
-	    {
-		val = &attr[i + 1];
-		vallen = len - i - 1;
-		attrlen = i;
-		break;
-	    }
-	}
-
-	if (STRNICMP(attr, "nargs", attrlen) == 0)
-	{
-	    if (vallen == 1)
-	    {
-		if (*val == '0')
-		    /* Do nothing - this is the default */;
-		else if (*val == '1')
-		    *argt |= (EXTRA | NOSPC | NEEDARG);
-		else if (*val == '*')
-		    *argt |= EXTRA;
-		else if (*val == '?')
-		    *argt |= (EXTRA | NOSPC);
-		else if (*val == '+')
-		    *argt |= (EXTRA | NEEDARG);
-		else
-		    goto wrong_nargs;
-	    }
-	    else
-	    {
-wrong_nargs:
-		EMSG(_("E176: Invalid number of arguments"));
-		return FAIL;
-	    }
-	}
-	else if (STRNICMP(attr, "range", attrlen) == 0)
-	{
-	    *argt |= RANGE;
-	    if (vallen == 1 && *val == '%')
-		*argt |= DFLALL;
-	    else if (val != NULL)
-	    {
-		p = val;
-		if (*def >= 0)
-		{
-two_count:
-		    EMSG(_("E177: Count cannot be specified twice"));
-		    return FAIL;
-		}
-
-		*def = getdigits(&p);
-		*argt |= (ZEROR | NOTADR);
-
-		if (p != val + vallen || vallen == 0)
-		{
-invalid_count:
-		    EMSG(_("E178: Invalid default value for count"));
-		    return FAIL;
-		}
-	    }
-	}
-	else if (STRNICMP(attr, "count", attrlen) == 0)
-	{
-	    *argt |= (COUNT | ZEROR | NOTADR);
-
-	    if (val != NULL)
-	    {
-		p = val;
-		if (*def >= 0)
-		    goto two_count;
-
-		*def = getdigits(&p);
-
-		if (p != val + vallen)
-		    goto invalid_count;
-	    }
-
-	    if (*def < 0)
-		*def = 0;
-	}
-	else if (STRNICMP(attr, "complete", attrlen) == 0)
-	{
-	    char_u	*arg = NULL;
-	    size_t	arglen = 0;
-
-	    if (val == NULL)
-	    {
-		EMSG(_("E179: argument required for complete"));
-		return FAIL;
-	    }
-	    /* Look for any argument part - which is the part after any ',' */
-	    for (i = 0; i < (int)vallen; ++i)
-	    {
-		if (val[i] == ',')
-		{
-		    arg = &val[i + 1];
-		    arglen = vallen - i - 1;
-		    vallen = i;
-		    break;
-		}
-	    }
-
-	    for (i = 0; command_complete[i].expand != 0; ++i)
-	    {
-		if (STRLEN(command_complete[i].name) == vallen
-			&& STRNCMP(val, command_complete[i].name, vallen) == 0)
-		{
-		    *compl = command_complete[i].expand;
-		    if (command_complete[i].expand == EXPAND_BUFFERS)
-			*argt |= BUFNAME;
-		    else if (command_complete[i].expand == EXPAND_DIRECTORIES
-			    || command_complete[i].expand == EXPAND_FILES)
-			*argt |= XFILE;
-		    break;
-		}
-	    }
-
-	    if (command_complete[i].expand == 0)
-	    {
-		EMSG2(_("E180: Invalid complete value: %s"), val);
-		return FAIL;
-	    }
-#if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
-	    if (*compl != EXPAND_USER_DEFINED && arg != NULL)
-#else
-	    if (arg != NULL)
-#endif
-	    {
-		EMSG(_("E468: Completion argument only allowed for custom completion"));
-		return FAIL;
-	    }
-#if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
-	    if (*compl == EXPAND_USER_DEFINED && arg == NULL)
-	    {
-		EMSG(_("E467: Custom completion requires a function argument"));
-		return FAIL;
-	    }
-	    if (arg != NULL)
-		*compl_arg = vim_strnsave(arg, (int)arglen);
-#endif
-	}
-	else
-	{
-	    char_u ch = attr[len];
-	    attr[len] = '\0';
-	    EMSG2(_("E181: Invalid attribute: %s"), attr);
-	    attr[len] = ch;
-	    return FAIL;
-	}
-    }
-
-    return OK;
-}
-
-    static void
-ex_command(eap)
-    exarg_T   *eap;
-{
-    char_u  *name;
-    char_u  *end;
-    char_u  *p;
-    long    argt = 0;
-    long    def = -1;
-    int	    flags = 0;
-    int	    compl = EXPAND_NOTHING;
-    char_u  *compl_arg = NULL;
-    int	    has_attr = (eap->arg[0] == '-');
-
-    p = eap->arg;
-
-    /* Check for attributes */
-    while (*p == '-')
-    {
-	++p;
-	end = skiptowhite(p);
-	if (uc_scan_attr(p, end - p, &argt, &def, &flags, &compl, &compl_arg)
-		== FAIL)
-	    return;
-	p = skipwhite(end);
-    }
-
-    /* Get the name (if any) and skip to the following argument */
-    name = p;
-    if (ASCII_ISALPHA(*p))
-	while (ASCII_ISALNUM(*p))
-	    ++p;
-    if (!ends_excmd(*p) && !vim_iswhite(*p))
-    {
-	EMSG(_("E182: Invalid command name"));
-	return;
-    }
-    end = p;
-
-    /* If there is nothing after the name, and no attributes were specified,
-     * we are listing commands
-     */
-    p = skipwhite(end);
-    if (!has_attr && ends_excmd(*p))
-    {
-	uc_list(name, end - name);
-    }
-    else if (!ASCII_ISUPPER(*name))
-    {
-	EMSG(_("E183: User defined commands must start with an uppercase letter"));
-	return;
-    }
-    else
-	uc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,
-								eap->forceit);
-}
-
-/*
- * ":comclear"
- */
-/*ARGSUSED*/
-/*
- * Clear all user commands, global and for current buffer.
- */
-    static void
-ex_comclear(eap)
-    exarg_T	*eap;
-{
-    uc_clear(&ucmds);
-    uc_clear(&curbuf->b_ucmds);
-}
-
-/*
- * Clear all user commands for "gap".
- */
-    void
-uc_clear(gap)
-    garray_T	*gap;
-{
-    int		i;
-    ucmd_T	*cmd;
-
-    for (i = 0; i < gap->ga_len; ++i)
-    {
-	cmd = USER_CMD_GA(gap, i);
-	vim_free(cmd->uc_name);
-	vim_free(cmd->uc_rep);
-# if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
-	vim_free(cmd->uc_compl_arg);
-# endif
-    }
-    ga_clear(gap);
-}
-
-    static void
-ex_delcommand(eap)
-    exarg_T	*eap;
-{
-    int		i = 0;
-    ucmd_T	*cmd = NULL;
-    int		cmp = -1;
-    garray_T	*gap;
-
-    gap = &curbuf->b_ucmds;
-    for (;;)
-    {
-	for (i = 0; i < gap->ga_len; ++i)
-	{
-	    cmd = USER_CMD_GA(gap, i);
-	    cmp = STRCMP(eap->arg, cmd->uc_name);
-	    if (cmp <= 0)
-		break;
-	}
-	if (gap == &ucmds || cmp == 0)
-	    break;
-	gap = &ucmds;
-    }
-
-    if (cmp != 0)
-    {
-	EMSG2(_("E184: No such user-defined command: %s"), eap->arg);
-	return;
-    }
-
-    vim_free(cmd->uc_name);
-    vim_free(cmd->uc_rep);
-# if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
-    vim_free(cmd->uc_compl_arg);
-# endif
-
-    --gap->ga_len;
-    ++gap->ga_room;
-
-    if (i < gap->ga_len)
-	mch_memmove(cmd, cmd + 1, (gap->ga_len - i) * sizeof(ucmd_T));
-}
-
-    static char_u *
-uc_split_args(arg, lenp)
-    char_u *arg;
-    size_t *lenp;
-{
-    char_u *buf;
-    char_u *p;
-    char_u *q;
-    int len;
-
-    /* Precalculate length */
-    p = arg;
-    len = 2; /* Initial and final quotes */
-
-    while (*p)
-    {
-	if (p[0] == '\\' && vim_iswhite(p[1]))
-	{
-	    len += 1;
-	    p += 2;
-	}
-	else if (*p == '\\' || *p == '"')
-	{
-	    len += 2;
-	    p += 1;
-	}
-	else if (vim_iswhite(*p))
-	{
-	    p = skipwhite(p);
-	    if (*p == NUL)
-		break;
-	    len += 3; /* "," */
-	}
-	else
-	{
-	    ++len;
-	    ++p;
-	}
-    }
-
-    buf = alloc(len + 1);
-    if (buf == NULL)
-    {
-	*lenp = 0;
-	return buf;
-    }
-
-    p = arg;
-    q = buf;
-    *q++ = '"';
-    while (*p)
-    {
-	if (p[0] == '\\' && vim_iswhite(p[1]))
-	{
-	    *q++ = p[1];
-	    p += 2;
-	}
-	else if (*p == '\\' || *p == '"')
-	{
-	    *q++ = '\\';
-	    *q++ = *p++;
-	}
-	else if (vim_iswhite(*p))
-	{
-	    p = skipwhite(p);
-	    if (*p == NUL)
-		break;
-	    *q++ = '"';
-	    *q++ = ',';
-	    *q++ = '"';
-	}
-	else
-	{
-	    *q++ = *p++;
-	}
-    }
-    *q++ = '"';
-    *q = 0;
-
-    *lenp = len;
-    return buf;
-}
-
-/*
- * Check for a <> code in a user command.
- * "code" points to the '<'.  "len" the length of the <> (inclusive).
- * "buf" is where the result is to be added.
- * "split_buf" points to a buffer used for splitting, caller should free it.
- * "split_len" is the length of what "split_buf" contains.
- * Returns the length of the replacement, which has been added to "buf".
- * Returns -1 if there was no match, and only the "<" has been copied.
- */
-    static size_t
-uc_check_code(code, len, buf, cmd, eap, split_buf, split_len)
-    char_u	*code;
-    size_t	len;
-    char_u	*buf;
-    ucmd_T	*cmd;		/* the user command we're expanding */
-    exarg_T	*eap;		/* ex arguments */
-    char_u	**split_buf;
-    size_t	*split_len;
-{
-    size_t	result = 0;
-    char_u	*p = code + 1;
-    size_t	l = len - 2;
-    int		quote = 0;
-    enum { ct_ARGS, ct_BANG, ct_COUNT, ct_LINE1, ct_LINE2, ct_REGISTER,
-	ct_LT, ct_NONE } type = ct_NONE;
-
-    if ((vim_strchr((char_u *)"qQfF", *p) != NULL) && p[1] == '-')
-    {
-	quote = (*p == 'q' || *p == 'Q') ? 1 : 2;
-	p += 2;
-	l -= 2;
-    }
-
-    if (l < 1)
-	type = ct_NONE;
-    else if (STRNICMP(p, "args", l) == 0)
-	type = ct_ARGS;
-    else if (STRNICMP(p, "bang", l) == 0)
-	type = ct_BANG;
-    else if (STRNICMP(p, "count", l) == 0)
-	type = ct_COUNT;
-    else if (STRNICMP(p, "line1", l) == 0)
-	type = ct_LINE1;
-    else if (STRNICMP(p, "line2", l) == 0)
-	type = ct_LINE2;
-    else if (STRNICMP(p, "lt", l) == 0)
-	type = ct_LT;
-    else if (STRNICMP(p, "register", l) == 0)
-	type = ct_REGISTER;
-
-    switch (type)
-    {
-    case ct_ARGS:
-	/* Simple case first */
-	if (*eap->arg == NUL)
-	{
-	    if (quote == 1)
-	    {
-		result = 2;
-		if (buf != NULL)
-		    STRCPY(buf, "''");
-	    }
-	    else
-		result = 0;
-	    break;
-	}
-
-	/* When specified there is a single argument don't split it.
-	 * Works for ":Cmd %" when % is "a b c". */
-	if ((eap->argt & NOSPC) && quote == 2)
-	    quote = 1;
-
-	switch (quote)
-	{
-	case 0: /* No quoting, no splitting */
-	    result = STRLEN(eap->arg);
-	    if (buf != NULL)
-		STRCPY(buf, eap->arg);
-	    break;
-	case 1: /* Quote, but don't split */
-	    result = STRLEN(eap->arg) + 2;
-	    for (p = eap->arg; *p; ++p)
-	    {
-		if (*p == '\\' || *p == '"')
-		    ++result;
-	    }
-
-	    if (buf != NULL)
-	    {
-		*buf++ = '"';
-		for (p = eap->arg; *p; ++p)
-		{
-		    if (*p == '\\' || *p == '"')
-			*buf++ = '\\';
-		    *buf++ = *p;
-		}
-		*buf = '"';
-	    }
-
-	    break;
-	case 2: /* Quote and split */
-	    /* This is hard, so only do it once, and cache the result */
-	    if (*split_buf == NULL)
-		*split_buf = uc_split_args(eap->arg, split_len);
-
-	    result = *split_len;
-	    if (buf != NULL && result != 0)
-		STRCPY(buf, *split_buf);
-
-	    break;
-	}
-	break;
-
-    case ct_BANG:
-	result = eap->forceit ? 1 : 0;
-	if (quote)
-	    result += 2;
-	if (buf != NULL)
-	{
-	    if (quote)
-		*buf++ = '"';
-	    if (eap->forceit)
-		*buf++ = '!';
-	    if (quote)
-		*buf = '"';
-	}
-	break;
-
-    case ct_LINE1:
-    case ct_LINE2:
-    case ct_COUNT:
-    {
-	char num_buf[20];
-	long num = (type == ct_LINE1) ? eap->line1 :
-		   (type == ct_LINE2) ? eap->line2 :
-		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
-	size_t num_len;
-
-	sprintf(num_buf, "%ld", num);
-	num_len = STRLEN(num_buf);
-	result = num_len;
-
-	if (quote)
-	    result += 2;
-
-	if (buf != NULL)
-	{
-	    if (quote)
-		*buf++ = '"';
-	    STRCPY(buf, num_buf);
-	    buf += num_len;
-	    if (quote)
-		*buf = '"';
-	}
-
-	break;
-    }
-
-    case ct_REGISTER:
-	result = eap->regname ? 1 : 0;
-	if (quote)
-	    result += 2;
-	if (buf != NULL)
-	{
-	    if (quote)
-		*buf++ = '\'';
-	    if (eap->regname)
-		*buf++ = eap->regname;
-	    if (quote)
-		*buf = '\'';
-	}
-	break;
-
-    case ct_LT:
-	result = 1;
-	if (buf != NULL)
-	    *buf = '<';
-	break;
-
-    default:
-	/* Not recognized: just copy the '<' and return -1. */
-	result = (size_t)-1;
-	if (buf != NULL)
-	    *buf = '<';
-	break;
-    }
-
-    return result;
-}
-
-    static void
-do_ucmd(eap)
-    exarg_T	*eap;
-{
-    char_u	*buf;
-    char_u	*p;
-    char_u	*q;
-
-    char_u	*start;
-    char_u	*end;
-    size_t	len, totlen;
-
-    size_t	split_len = 0;
-    char_u	*split_buf = NULL;
-    ucmd_T	*cmd;
-#ifdef FEAT_EVAL
-    scid_T	save_current_SID = current_SID;
-#endif
-
-    if (eap->cmdidx == CMD_USER)
-	cmd = USER_CMD(eap->useridx);
-    else
-	cmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx);
-
-    /*
-     * Replace <> in the command by the arguments.
-     */
-    buf = NULL;
-    for (;;)
-    {
-	p = cmd->uc_rep;
-	q = buf;
-	totlen = 0;
-	while ((start = vim_strchr(p, '<')) != NULL
-	       && (end = vim_strchr(start + 1, '>')) != NULL)
-	{
-	    /* Include the '>' */
-	    ++end;
-
-	    /* Take everything up to the '<' */
-	    len = start - p;
-	    if (buf == NULL)
-		totlen += len;
-	    else
-	    {
-		mch_memmove(q, p, len);
-		q += len;
-	    }
-
-	    len = uc_check_code(start, end - start, q, cmd, eap,
-			     &split_buf, &split_len);
-	    if (len == (size_t)-1)
-	    {
-		/* no match, continue after '<' */
-		p = start + 1;
-		len = 1;
-	    }
-	    else
-		p = end;
-	    if (buf == NULL)
-		totlen += len;
-	    else
-		q += len;
-	}
-	if (buf != NULL)	    /* second time here, finished */
-	{
-	    STRCPY(q, p);
-	    break;
-	}
-
-	totlen += STRLEN(p);	    /* Add on the trailing characters */
-	buf = alloc((unsigned)(totlen + 1));
-	if (buf == NULL)
-	{
-	    vim_free(split_buf);
-	    return;
-	}
-    }
-
-#ifdef FEAT_EVAL
-    current_SID = cmd->uc_scriptID;
-#endif
-    (void)do_cmdline(buf, eap->getline, eap->cookie,
-				   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);
-#ifdef FEAT_EVAL
-    current_SID = save_current_SID;
-#endif
-    vim_free(buf);
-    vim_free(split_buf);
-}
-
-# if defined(FEAT_CMDL_COMPL) || defined(PROTO)
-    static char_u *
-get_user_command_name(idx)
-    int		idx;
-{
-    return get_user_commands(NULL, idx - (int)CMD_SIZE);
-}
-
-/*
- * Function given to ExpandGeneric() to obtain the list of user command names.
- */
-/*ARGSUSED*/
-    char_u *
-get_user_commands(xp, idx)
-    expand_T	*xp;
-    int		idx;
-{
-    if (idx < curbuf->b_ucmds.ga_len)
-	return USER_CMD_GA(&curbuf->b_ucmds, idx)->uc_name;
-    idx -= curbuf->b_ucmds.ga_len;
-    if (idx < ucmds.ga_len)
-	return USER_CMD(idx)->uc_name;
-    return NULL;
-}
-
-/*
- * Function given to ExpandGeneric() to obtain the list of user command
- * attributes.
- */
-/*ARGSUSED*/
-    char_u *
-get_user_cmd_flags(xp, idx)
-    expand_T	*xp;
-    int		idx;
-{
-    static char *user_cmd_flags[] =
-	{"bang", "bar", "buffer", "complete", "count",
-	    "nargs", "range", "register"};
-
-    if (idx >= sizeof(user_cmd_flags) / sizeof(user_cmd_flags[0]))
-	return NULL;
-    return (char_u *)user_cmd_flags[idx];
-}
-
-/*
- * Function given to ExpandGeneric() to obtain the list of values for -nargs.
- */
-/*ARGSUSED*/
-    char_u *
-get_user_cmd_nargs(xp, idx)
-    expand_T	*xp;
-    int		idx;
-{
-    static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
-
-    if (idx >= sizeof(user_cmd_nargs) / sizeof(user_cmd_nargs[0]))
-	return NULL;
-    return (char_u *)user_cmd_nargs[idx];
-}
-
-/*
- * Function given to ExpandGeneric() to obtain the list of values for -complete.
- */
-/*ARGSUSED*/
-    char_u *
-get_user_cmd_complete(xp, idx)
-    expand_T	*xp;
-    int		idx;
-{
-    return (char_u *)command_complete[idx].name;
-}
-# endif /* FEAT_CMDL_COMPL */
-
-#endif	/* FEAT_USR_CMDS */
-
-    static void
-ex_colorscheme(eap)
-    exarg_T	*eap;
-{
-    if (load_colors(eap->arg) == FAIL)
-	EMSG2(_("E185: Cannot find color scheme %s"), eap->arg);
-}
-
-    static void
-ex_highlight(eap)
-    exarg_T	*eap;
-{
-    if (*eap->arg == NUL && eap->cmd[2] == '!')
-	MSG(_("Greetings, Vim user!"));
-    do_highlight(eap->arg, eap->forceit, FALSE);
-}
-
-
-/*
- * Call this function if we thought we were going to exit, but we won't
- * (because of an error).  May need to restore the terminal mode.
- */
-    void
-not_exiting()
-{
-    exiting = FALSE;
-    settmode(TMODE_RAW);
-}
-
-/*
- * ":quit": quit current window, quit Vim if closed the last window.
- */
-    static void
-ex_quit(eap)
-    exarg_T	*eap;
-{
-#ifdef FEAT_CMDWIN
-    if (cmdwin_type != 0)
-    {
-	cmdwin_result = Ctrl_C;
-	return;
-    }
-#endif
-
-#ifdef FEAT_NETBEANS_INTG
-    netbeansForcedQuit = eap->forceit;
-#endif
-
-    /*
-     * If there are more files or windows we won't exit.
-     */
-    if (check_more(FALSE, eap->forceit) == OK && only_one_window())
-	exiting = TRUE;
-    if ((!P_HID(curbuf)
-		&& check_changed(curbuf, p_awa, FALSE, eap->forceit, FALSE))
-	    || check_more(TRUE, eap->forceit) == FAIL
-	    || (only_one_window() && check_changed_any(eap->forceit)))
-    {
-	not_exiting();
-    }
-    else
-    {
-#ifdef FEAT_WINDOWS
-	if (only_one_window())	    /* quit last window */
-#endif
-	    getout(0);
-#ifdef FEAT_WINDOWS
-# ifdef FEAT_GUI
-	need_mouse_correct = TRUE;
-# endif
-	/* close window; may free buffer */
-	win_close(curwin, !P_HID(curwin->w_buffer) || eap->forceit);
-#endif
-    }
-}
-
-/*
- * ":cquit".
- */
-/*ARGSUSED*/
-    static void
-ex_cquit(eap)
-    exarg_T	*eap;
-{
-    getout(1);	/* this does not always pass on the exit code to the Manx
-		   compiler. why? */
-}
-
-/*
- * ":qall": try to quit all windows
- */
-    static void
-ex_quit_all(eap)
-    exarg_T	*eap;
-{
-# ifdef FEAT_CMDWIN
-    if (cmdwin_type != 0)
-    {
-	if (eap->forceit)
-	    cmdwin_result = K_XF1;	/* ex_window() takes care of this */
-	else
-	    cmdwin_result = K_XF2;
-	return;
-    }
-# endif
-    exiting = TRUE;
-    if (eap->forceit || !check_changed_any(FALSE))
-	getout(0);
-    not_exiting();
-}
-
-#ifdef FEAT_WINDOWS
-/*
- * ":close": close current window, unless it is the last one
- */
-    static void
-ex_close(eap)
-    exarg_T	*eap;
-{
-# ifdef FEAT_CMDWIN
-    if (cmdwin_type != 0)
-	cmdwin_result = K_IGNORE;
-    else
-# endif
-	ex_win_close(eap, curwin);
-}
-
-    static void
-ex_win_close(eap, win)
-    exarg_T	*eap;
-    win_T	*win;
-{
-    int		need_hide;
-    buf_T	*buf = win->w_buffer;
-
-    need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);
-    if (need_hide && !P_HID(buf) && !eap->forceit)
-    {
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-	if ((p_confirm || cmdmod.confirm) && p_write)
-	{
-	    dialog_changed(buf, FALSE);
-	    if (buf_valid(buf) && bufIsChanged(buf))
-		return;
-	    need_hide = FALSE;
-	}
-	else
-#endif
-	{
-	    EMSG(_(e_nowrtmsg));
-	    return;
-	}
-    }
-
-#ifdef FEAT_GUI
-    need_mouse_correct = TRUE;
-#endif
-    /* free buffer when not hiding it or when it's a scratch buffer */
-    win_close(win, !need_hide && !P_HID(buf));
-}
-
-#ifdef FEAT_QUICKFIX
-/*
- * ":pclose": Close any preview window.
- */
-    static void
-ex_pclose(eap)
-    exarg_T	*eap;
-{
-    win_T	*win;
-
-    for (win = firstwin; win != NULL; win = win->w_next)
-	if (win->w_p_pvw)
-	{
-	    ex_win_close(eap, win);
-	    break;
-	}
-}
-#endif
-
-/*
- * ":only".
- */
-    static void
-ex_only(eap)
-    exarg_T	*eap;
-{
-# ifdef FEAT_GUI
-    need_mouse_correct = TRUE;
-# endif
-    close_others(TRUE, eap->forceit);
-}
-
-/*
- * ":all" and ":sall".
- */
-    static void
-ex_all(eap)
-    exarg_T	*eap;
-{
-    if (eap->addr_count == 0)
-	eap->line2 = 9999;
-    do_arg_all((int)eap->line2, eap->forceit);
-}
-#endif /* FEAT_WINDOWS */
-
-    static void
-ex_hide(eap)
-    exarg_T	*eap;
-{
-    if (*eap->arg != NUL && check_nextcmd(eap->arg) == NULL)
-	eap->errmsg = e_invarg;
-    else
-    {
-	/* ":hide" or ":hide | cmd": hide current window */
-	eap->nextcmd = check_nextcmd(eap->arg);
-#ifdef FEAT_WINDOWS
-	if (!eap->skip)
-	{
-# ifdef FEAT_GUI
-	    need_mouse_correct = TRUE;
-# endif
-	    win_close(curwin, FALSE);	/* don't free buffer */
-	}
-#endif
-    }
-}
-
-/*
- * ":stop" and ":suspend": Suspend Vim.
- */
-    static void
-ex_stop(eap)
-    exarg_T	*eap;
-{
-    /*
-     * Disallow suspending for "rvim".
-     */
-    if (!check_restricted()
-#ifdef WIN3264
-	/*
-	 * Check if external commands are allowed now.
-	 */
-	&& can_end_termcap_mode(TRUE)
-#endif
-					)
-    {
-	if (!eap->forceit)
-	    autowrite_all();
-	windgoto((int)Rows - 1, 0);
-	out_char('\n');
-	out_flush();
-	stoptermcap();
-	out_flush();		/* needed for SUN to restore xterm buffer */
-#ifdef FEAT_TITLE
-	mch_restore_title(3);	/* restore window titles */
-#endif
-	ui_suspend();		/* call machine specific function */
-#ifdef FEAT_TITLE
-	maketitle();
-	resettitle();		/* force updating the title */
-#endif
-	starttermcap();
-	scroll_start();		/* scroll screen before redrawing */
-	redraw_later_clear();
-	shell_resized();	/* may have resized window */
-    }
-}
-
-/*
- * ":exit", ":xit" and ":wq": Write file and exit Vim.
- */
-    static void
-ex_exit(eap)
-    exarg_T	*eap;
-{
-#ifdef FEAT_CMDWIN
-    if (cmdwin_type != 0)
-    {
-	cmdwin_result = Ctrl_C;
-	return;
-    }
-#endif
-
-    /*
-     * if more files or windows we won't exit
-     */
-    if (check_more(FALSE, eap->forceit) == OK && only_one_window())
-	exiting = TRUE;
-    if (       ((eap->cmdidx == CMD_wq
-		    || curbufIsChanged())
-		&& do_write(eap) == FAIL)
-	    || check_more(TRUE, eap->forceit) == FAIL
-	    || (only_one_window() && check_changed_any(eap->forceit)))
-    {
-	not_exiting();
-    }
-    else
-    {
-#ifdef FEAT_WINDOWS
-	if (only_one_window())	    /* quit last window, exit Vim */
-#endif
-	    getout(0);
-#ifdef FEAT_WINDOWS
-# ifdef FEAT_GUI
-	need_mouse_correct = TRUE;
-# endif
-	/* quit current window, may free buffer */
-	win_close(curwin, !P_HID(curwin->w_buffer));
-#endif
-    }
-}
-
-/*
- * ":print", ":list", ":number".
- */
-    static void
-ex_print(eap)
-    exarg_T	*eap;
-{
-    int		save_list = 0;	    /* init for GCC */
-
-    if (eap->cmdidx == CMD_list)
-    {
-	save_list = curwin->w_p_list;
-	curwin->w_p_list = 1;
-    }
-
-    for ( ;!got_int; ui_breakcheck())
-    {
-	print_line(eap->line1,
-		   (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound));
-	if (++eap->line1 > eap->line2)
-	    break;
-	out_flush();	    /* show one line at a time */
-    }
-    setpcmark();
-    /* put cursor at last line */
-    curwin->w_cursor.lnum = eap->line2;
-    beginline(BL_SOL | BL_FIX);
-
-    ex_no_reprint = TRUE;
-
-    if (eap->cmdidx == CMD_list)
-	curwin->w_p_list = save_list;
-}
-
-#ifdef FEAT_BYTEOFF
-    static void
-ex_goto(eap)
-    exarg_T	*eap;
-{
-    goto_byte(eap->line2);
-}
-#endif
-
-/*
- * ":shell".
- */
-/*ARGSUSED*/
-    static void
-ex_shell(eap)
-    exarg_T	*eap;
-{
-    do_shell(NULL, 0);
-}
-
-#if (defined(FEAT_WINDOWS) && defined(HAVE_DROP_FILE)) \
-	|| (defined(FEAT_GUI_GTK) && defined(FEAT_DND)) \
-	|| defined(PROTO)
-
-/*
- * Handle a file drop. The code is here because a drop is *nearly* like an
- * :args command, but not quite (we have a list of exact filenames, so we
- * don't want to (a) parse a command line, or (b) expand wildcards. So the
- * code is very similar to :args and hence needs access to a lot of the static
- * functions in this file.
- *
- * The list should be allocated using alloc(), as should each item in the
- * list. This function takes over responsibility for freeing the list.
- *
- * XXX The list is made into the arggument list. This is freed using
- * FreeWild(), which does a series of vim_free() calls, unless the two defines
- * __EMX__ and __ALWAYS_HAS_TRAILING_NUL_POINTER are set. In this case, a
- * routine _fnexplodefree() is used. This may cause problems, but as the drop
- * file functionality is (currently) not in EMX this is not presently a
- * problem.
- */
-    void
-handle_drop(filec, filev, split)
-    int		filec;		/* the number of files dropped */
-    char_u	**filev;	/* the list of files dropped */
-    int		split;		/* force splitting the window */
-{
-    exarg_T	ea;
-    int		save_msg_scroll = msg_scroll;
-
-# ifdef FEAT_CMDWIN
-    if (cmdwin_type != 0)
-	return;
-# endif
-
-    /* Check whether the current buffer is changed. If so, we will need
-     * to split the current window or data could be lost.
-     * We don't need to check if the 'hidden' option is set, as in this
-     * case the buffer won't be lost.
-     */
-    if (!P_HID(curbuf) && !split)
-    {
-	++emsg_off;
-	split = check_changed(curbuf, TRUE, FALSE, FALSE, FALSE);
-	--emsg_off;
-    }
-    if (split)
-    {
-# ifdef FEAT_WINDOWS
-	if (win_split(0, 0) == FAIL)
-	    return;
-#  ifdef FEAT_SCROLLBIND
-	curwin->w_p_scb = FALSE;
-#  endif
-
-	/* When splitting the window, create a new alist.  Otherwise the
-	 * existing one is overwritten. */
-	alist_unlink(curwin->w_alist);
-	alist_new();
-# else
-	return;	    /* can't split, always fail */
-# endif
-    }
-
-    /*
-     * Set up the new argument list.
-     */
-    alist_set(ALIST(curwin), filec, filev, FALSE);
-
-    /*
-     * Move to the first file.
-     */
-    /* Fake up a minimal "next" command for do_argfile() */
-    vim_memset(&ea, 0, sizeof(ea));
-    ea.cmd = (char_u *)"next";
-    do_argfile(&ea, 0);
-
-    /* do_ecmd() may set need_start_insertmode, but since we never left Insert
-     * mode that is not needed here. */
-    need_start_insertmode = FALSE;
-
-    /* Restore msg_scroll, otherwise a following command may cause scrolling
-     * unexpectedly.  The screen will be redrawn by the caller, thus
-     * msg_scroll being set by displaying a message is irrelevant. */
-    msg_scroll = save_msg_scroll;
-}
-#endif
-
-static void alist_clear __ARGS((alist_T *al));
-/*
- * Clear an argument list: free all file names and reset it to zero entries.
- */
-    static void
-alist_clear(al)
-    alist_T	*al;
-{
-    while (--al->al_ga.ga_len >= 0)
-	vim_free(AARGLIST(al)[al->al_ga.ga_len].ae_fname);
-    ga_clear(&al->al_ga);
-}
-
-/*
- * Init an argument list.
- */
-    void
-alist_init(al)
-    alist_T	*al;
-{
-    ga_init2(&al->al_ga, (int)sizeof(aentry_T), 5);
-}
-
-#if defined(FEAT_WINDOWS) || defined(PROTO)
-
-/*
- * Remove a reference from an argument list.
- * Ignored when the argument list is the global one.
- * If the argument list is no longer used by any window, free it.
- */
-    void
-alist_unlink(al)
-    alist_T	*al;
-{
-    if (al != &global_alist && --al->al_refcount <= 0)
-    {
-	alist_clear(al);
-	vim_free(al);
-    }
-}
-
-# if defined(FEAT_LISTCMDS) || defined(HAVE_DROP_FILE) || defined(PROTO)
-/*
- * Create a new argument list and use it for the current window.
- */
-    void
-alist_new()
-{
-    curwin->w_alist = (alist_T *)alloc((unsigned)sizeof(alist_T));
-    if (curwin->w_alist == NULL)
-    {
-	curwin->w_alist = &global_alist;
-	++global_alist.al_refcount;
-    }
-    else
-    {
-	curwin->w_alist->al_refcount = 1;
-	alist_init(curwin->w_alist);
-    }
-}
-# endif
-#endif
-
-#if (!defined(UNIX) && !defined(__EMX__)) || defined(ARCHIE) || defined(PROTO)
-/*
- * Expand the file names in the global argument list.
- */
-    void
-alist_expand()
-{
-    char_u	**old_arg_files;
-    char_u	**new_arg_files;
-    int		new_arg_file_count;
-    char_u	*save_p_su = p_su;
-    int		i;
-
-    /* Don't use 'suffixes' here.  This should work like the shell did the
-     * expansion.  Also, the vimrc file isn't read yet, thus the user
-     * can't set the options. */
-    p_su = empty_option;
-    old_arg_files = (char_u **)alloc((unsigned)(sizeof(char_u *) * GARGCOUNT));
-    if (old_arg_files != NULL)
-    {
-	for (i = 0; i < GARGCOUNT; ++i)
-	    old_arg_files[i] = GARGLIST[i].ae_fname;
-	if (expand_wildcards(GARGCOUNT, old_arg_files,
-		    &new_arg_file_count, &new_arg_files,
-		    EW_FILE|EW_NOTFOUND|EW_ADDSLASH) == OK
-		&& new_arg_file_count > 0)
-	{
-	    alist_set(&global_alist, new_arg_file_count, new_arg_files, TRUE);
-	}
-	vim_free(old_arg_files);
-    }
-    p_su = save_p_su;
-}
-#endif
-
-/*
- * Set the argument list for the current window.
- * Takes over the allocated files[] and the allocated fnames in it.
- */
-    void
-alist_set(al, count, files, use_curbuf)
-    alist_T	*al;
-    int		count;
-    char_u	**files;
-    int		use_curbuf;
-{
-    int		i;
-
-    alist_clear(al);
-    if (ga_grow(&al->al_ga, count) == OK)
-    {
-	for (i = 0; i < count; ++i)
-	    alist_add(al, files[i], use_curbuf ? 2 : 1);
-	vim_free(files);
-    }
-    else
-	FreeWild(count, files);
-#ifdef FEAT_WINDOWS
-    if (al == &global_alist)
-#endif
-	arg_had_last = FALSE;
-}
-
-/*
- * Add file "fname" to argument list "al".
- * "fname" must have been allocated and "al" must have been checked for room.
- */
-    void
-alist_add(al, fname, set_fnum)
-    alist_T	*al;
-    char_u	*fname;
-    int		set_fnum;	/* 1: set buffer number; 2: re-use curbuf */
-{
-    if (fname == NULL)		/* don't add NULL file names */
-	return;
-#ifdef BACKSLASH_IN_FILENAME
-    slash_adjust(fname);
-#endif
-    AARGLIST(al)[al->al_ga.ga_len].ae_fname = fname;
-    if (set_fnum > 0)
-	AARGLIST(al)[al->al_ga.ga_len].ae_fnum =
-	    buflist_add(fname, BLN_LISTED | (set_fnum == 2 ? BLN_CURBUF : 0));
-    ++al->al_ga.ga_len;
-    --al->al_ga.ga_room;
-}
-
-#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)
-/*
- * Adjust slashes in file names.  Called after 'shellslash' was set.
- */
-    void
-alist_slash_adjust()
-{
-    int		i;
-# ifdef FEAT_WINDOWS
-    win_T	*wp;
-# endif
-
-    for (i = 0; i < GARGCOUNT; ++i)
-	if (GARGLIST[i].ae_fname != NULL)
-	    slash_adjust(GARGLIST[i].ae_fname);
-# ifdef FEAT_WINDOWS
-    for (wp = firstwin; wp != NULL; wp = wp->w_next)
-	if (wp->w_alist != &global_alist)
-	    for (i = 0; i < WARGCOUNT(wp); ++i)
-		if (WARGLIST(wp)[i].ae_fname != NULL)
-		    slash_adjust(WARGLIST(wp)[i].ae_fname);
-# endif
-}
-#endif
-
-/*
- * ":preserve".
- */
-/*ARGSUSED*/
-    static void
-ex_preserve(eap)
-    exarg_T	*eap;
-{
-    ml_preserve(curbuf, TRUE);
-}
-
-/*
- * ":recover".
- */
-    static void
-ex_recover(eap)
-    exarg_T	*eap;
-{
-    /* Set recoverymode right away to avoid the ATTENTION prompt. */
-    recoverymode = TRUE;
-    if (!check_changed(curbuf, p_awa, TRUE, eap->forceit, FALSE)
-	    && (*eap->arg == NUL
-			     || setfname(curbuf, eap->arg, NULL, TRUE) == OK))
-	ml_recover();
-    recoverymode = FALSE;
-}
-
-/*
- * Command modifier used in a wrong way.
- */
-    static void
-ex_wrongmodifier(eap)
-    exarg_T	*eap;
-{
-    eap->errmsg = e_invcmd;
-}
-
-#ifdef FEAT_WINDOWS
-/*
- * :sview [+command] file	split window with new file, read-only
- * :split [[+command] file]	split window with current or new file
- * :vsplit [[+command] file]	split window vertically with current or new file
- * :new [[+command] file]	split window with no or new file
- * :vnew [[+command] file]	split vertically window with no or new file
- * :sfind [+command] file	split window with file in 'path'
- */
-    void
-ex_splitview(eap)
-    exarg_T	*eap;
-{
-    win_T	*old_curwin;
-#if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)
-    char_u	*fname = NULL;
-#endif
-#ifdef FEAT_BROWSE
-    int		browse_flag = cmdmod.browse;
-#endif
-
-#ifndef FEAT_VERTSPLIT
-    if (eap->cmdidx == CMD_vsplit || eap->cmdidx == CMD_vnew)
-    {
-	ex_ni(eap);
-	return;
-    }
-#endif
-
-    old_curwin = curwin;
-#ifdef FEAT_GUI
-    need_mouse_correct = TRUE;
-#endif
-
-#ifdef FEAT_QUICKFIX
-    /* A ":split" in the quickfix window works like ":new".  Don't want two
-     * quickfix windows. */
-    if (bt_quickfix(curbuf))
-    {
-	if (eap->cmdidx == CMD_split)
-	    eap->cmdidx = CMD_new;
-# ifdef FEAT_VERTSPLIT
-	if (eap->cmdidx == CMD_vsplit)
-	    eap->cmdidx = CMD_vnew;
-# endif
-    }
-#endif
-
-#ifdef FEAT_SEARCHPATH
-    if (eap->cmdidx == CMD_sfind)
-    {
-	fname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg),
-					  FNAME_MESS, TRUE, curbuf->b_ffname);
-	if (fname == NULL)
-	    goto theend;
-	eap->arg = fname;
-    }
-# ifdef FEAT_BROWSE
-    else
-# endif
-#endif
-#ifdef FEAT_BROWSE
-    if (cmdmod.browse
-# ifdef FEAT_VERTSPLIT
-	    && eap->cmdidx != CMD_vnew
-#endif
-	    && eap->cmdidx != CMD_new)
-    {
-	fname = do_browse(FALSE, (char_u *)_("Edit File in new window"),
-					  eap->arg, NULL, NULL, NULL, curbuf);
-	if (fname == NULL)
-	    goto theend;
-	eap->arg = fname;
-    }
-    cmdmod.browse = FALSE;	/* Don't browse again in do_ecmd(). */
-#endif
-
-    if (win_split(eap->addr_count > 0 ? (int)eap->line2 : 0,
-				     *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL)
-    {
-#ifdef FEAT_SCROLLBIND
-	/* Reset 'scrollbind' when editing another file, but keep it when
-	 * doing ":split" without arguments. */
-	if (*eap->arg != NUL
-#ifdef FEAT_BROWSE
-		|| cmdmod.browse
-#endif
-	   )
-	    curwin->w_p_scb = FALSE;
-	else
-	    do_check_scrollbind(FALSE);
-#endif
-	do_exedit(eap, old_curwin);
-    }
-
-#ifdef FEAT_BROWSE
-    cmdmod.browse = browse_flag;
-#endif
-
-#if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)
-theend:
-    vim_free(fname);
-#endif
-}
-#endif
-
-/*
- * ":mode": Set screen mode.
- * If no argument given, just get the screen size and redraw.
- */
-    static void
-ex_mode(eap)
-    exarg_T	*eap;
-{
-    if (*eap->arg == NUL)
-	shell_resized();
-    else
-	mch_screenmode(eap->arg);
-}
-
-#ifdef FEAT_WINDOWS
-/*
- * ":resize".
- * set, increment or decrement current window height
- */
-    static void
-ex_resize(eap)
-    exarg_T	*eap;
-{
-    int		n;
-    win_T	*wp = curwin;
-
-    if (eap->addr_count > 0)
-    {
-	n = eap->line2;
-	for (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)
-	    ;
-    }
-
-#ifdef FEAT_GUI
-    need_mouse_correct = TRUE;
-#endif
-    n = atol((char *)eap->arg);
-#ifdef FEAT_VERTSPLIT
-    if (cmdmod.split & WSP_VERT)
-    {
-	if (*eap->arg == '-' || *eap->arg == '+')
-	    n += W_WIDTH(curwin);
-	else if (n == 0 && eap->arg[0] == NUL)	/* default is very wide */
-	    n = 9999;
-	win_setwidth_win((int)n, wp);
-    }
-    else
-#endif
-    {
-	if (*eap->arg == '-' || *eap->arg == '+')
-	    n += curwin->w_height;
-	else if (n == 0 && eap->arg[0] == NUL)	/* default is very wide */
-	    n = 9999;
-	win_setheight_win((int)n, wp);
-    }
-}
-#endif
-
-/*
- * ":find [+command] <file>" command.
- */
-    static void
-ex_find(eap)
-    exarg_T	*eap;
-{
-#ifdef FEAT_SEARCHPATH
-    char_u	*fname;
-    int		count;
-
-    fname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg), FNAME_MESS,
-						      TRUE, curbuf->b_ffname);
-    if (eap->addr_count > 0)
-    {
-	/* Repeat finding the file "count" times.  This matters when it
-	 * appears several times in the path. */
-	count = eap->line2;
-	while (fname != NULL && --count > 0)
-	{
-	    vim_free(fname);
-	    fname = find_file_in_path(NULL, 0, FNAME_MESS,
-						     FALSE, curbuf->b_ffname);
-	}
-    }
-
-    if (fname != NULL)
-    {
-	eap->arg = fname;
-#endif
-	do_exedit(eap, NULL);
-#ifdef FEAT_SEARCHPATH
-	vim_free(fname);
-    }
-#endif
-}
-
-/*
- * ":edit", ":badd".
- */
-    static void
-ex_edit(eap)
-    exarg_T	*eap;
-{
-    do_exedit(eap, NULL);
-}
-
-/*
- * ":edit <file>" command and alikes.
- */
-/*ARGSUSED*/
-    void
-do_exedit(eap, old_curwin)
-    exarg_T	*eap;
-    win_T	*old_curwin;	    /* curwin before doing a split or NULL */
-{
-    int		n;
-#ifdef FEAT_WINDOWS
-    int		need_hide;
-#endif
-
-    /*
-     * ":vi" command ends Ex mode.
-     */
-    if (exmode_active && (eap->cmdidx == CMD_visual
-						|| eap->cmdidx == CMD_view))
-    {
-	exmode_active = FALSE;
-	if (*eap->arg == NUL)
-	    return;
-    }
-
-    if ((eap->cmdidx == CMD_new
-#ifdef FEAT_VERTSPLIT
-		|| eap->cmdidx == CMD_vnew
-#endif
-		) && *eap->arg == NUL)
-    {
-	/* ":new" without argument: edit an new empty buffer */
-	setpcmark();
-	(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,
-			       ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0));
-    }
-    else if ((eap->cmdidx != CMD_split
-#ifdef FEAT_VERTSPLIT
-		&& eap->cmdidx != CMD_vsplit
-#endif
-		)
-	    || *eap->arg != NUL
-#ifdef FEAT_BROWSE
-	    || cmdmod.browse
-#endif
-	    )
-    {
-	n = readonlymode;
-	if (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)
-	    readonlymode = TRUE;
-	else if (eap->cmdidx == CMD_enew)
-	    readonlymode = FALSE;   /* 'readonly' doesn't make sense in an
-				       empty buffer */
-	setpcmark();
-	if (do_ecmd(0, (eap->cmdidx == CMD_enew ? NULL : eap->arg),
-		    NULL, eap,
-		    /* ":edit" goes to first line if Vi compatible */
-		    (*eap->arg == NUL && eap->do_ecmd_lnum == 0
-				      && vim_strchr(p_cpo, CPO_GOTO1) != NULL)
-					       ? ECMD_ONE : eap->do_ecmd_lnum,
-		    (P_HID(curbuf) ? ECMD_HIDE : 0)
-		    + (eap->forceit ? ECMD_FORCEIT : 0)
-#ifdef FEAT_LISTCMDS
-		    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0 )
-#endif
-		    ) == FAIL)
-	{
-	    /* Editing the file failed.  If the window was split, close it. */
-#ifdef FEAT_WINDOWS
-	    if (old_curwin != NULL)
-	    {
-		need_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);
-		if (!need_hide || P_HID(curbuf))
-		{
-# if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
-		    cleanup_T   cs;
-
-		    /* Reset the error/interrupt/exception state here so that
-		     * aborting() returns FALSE when closing a window. */
-		    enter_cleanup(&cs);
-# endif
-# ifdef FEAT_GUI
-		    need_mouse_correct = TRUE;
-# endif
-		    win_close(curwin, !need_hide && !P_HID(curbuf));
-
-# if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
-		    /* Restore the error/interrupt/exception state if not
-		     * discarded by a new aborting error, interrupt, or
-		     * uncaught exception. */
-		    leave_cleanup(&cs);
-# endif
-		}
-	    }
-#endif
-	}
-	else if (readonlymode && curbuf->b_nwindows == 1)
-	{
-	    /* When editing an already visited buffer, 'readonly' won't be set
-	     * but the previous value is kept.  With ":view" and ":sview" we
-	     * want the  file to be readonly, except when another window is
-	     * editing the same buffer. */
-	    curbuf->b_p_ro = TRUE;
-	}
-	readonlymode = n;
-    }
-    else
-    {
-	if (eap->do_ecmd_cmd != NULL)
-	    do_cmdline_cmd(eap->do_ecmd_cmd);
-#ifdef FEAT_TITLE
-	n = curwin->w_arg_idx_invalid;
-#endif
-	check_arg_idx(curwin);
-#ifdef FEAT_TITLE
-	if (n != curwin->w_arg_idx_invalid)
-	    maketitle();
-#endif
-    }
-
-#ifdef FEAT_WINDOWS
-    /*
-     * if ":split file" worked, set alternate file name in old window to new
-     * file
-     */
-    if (old_curwin != NULL
-	    && *eap->arg != NUL
-	    && curwin != old_curwin
-	    && win_valid(old_curwin)
-	    && old_curwin->w_buffer != curbuf)
-	old_curwin->w_alt_fnum = curbuf->b_fnum;
-#endif
-
-    ex_no_reprint = TRUE;
-}
-
-#ifndef FEAT_GUI
-/*
- * ":gui" and ":gvim" when there is no GUI.
- */
-    static void
-ex_nogui(eap)
-    exarg_T	*eap;
-{
-    eap->errmsg = e_nogvim;
-}
-#endif
-
-#if defined(FEAT_GUI_W32) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)
-    static void
-ex_tearoff(eap)
-    exarg_T	*eap;
-{
-    gui_make_tearoff(eap->arg);
-}
-#endif
-
-#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK)) && defined(FEAT_MENU)
-    static void
-ex_popup(eap)
-    exarg_T	*eap;
-{
-    gui_make_popup(eap->arg);
-}
-#endif
-
-/*ARGSUSED*/
-    static void
-ex_swapname(eap)
-    exarg_T	*eap;
-{
-    if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
-	MSG(_("No swap file"));
-    else
-	msg(curbuf->b_ml.ml_mfp->mf_fname);
-}
-
-/*
- * ":syncbind" forces all 'scrollbind' windows to have the same relative
- * offset.
- * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
- */
-/*ARGSUSED*/
-    static void
-ex_syncbind(eap)
-    exarg_T	*eap;
-{
-#ifdef FEAT_SCROLLBIND
-    win_T	*wp;
-    long	topline;
-    long	y;
-    linenr_T	old_linenr = curwin->w_cursor.lnum;
-
-    setpcmark();
-
-    /*
-     * determine max topline
-     */
-    if (curwin->w_p_scb)
-    {
-	topline = curwin->w_topline;
-	for (wp = firstwin; wp; wp = wp->w_next)
-	{
-	    if (wp->w_p_scb && wp->w_buffer)
-	    {
-		y = wp->w_buffer->b_ml.ml_line_count - p_so;
-		if (topline > y)
-		    topline = y;
-	    }
-	}
-	if (topline < 1)
-	    topline = 1;
-    }
-    else
-    {
-	topline = 1;
-    }
-
-
-    /*
-     * set all scrollbind windows to the same topline
-     */
-    wp = curwin;
-    for (curwin = firstwin; curwin; curwin = curwin->w_next)
-    {
-	if (curwin->w_p_scb)
-	{
-	    y = topline - curwin->w_topline;
-	    if (y > 0)
-		scrollup(y, TRUE);
-	    else
-		scrolldown(-y, TRUE);
-	    curwin->w_scbind_pos = topline;
-	    redraw_later(VALID);
-	    cursor_correct();
-#ifdef FEAT_WINDOWS
-	    curwin->w_redr_status = TRUE;
-#endif
-	}
-    }
-    curwin = wp;
-    if (curwin->w_p_scb)
-    {
-	did_syncbind = TRUE;
-	checkpcmark();
-	if (old_linenr != curwin->w_cursor.lnum)
-	{
-	    char_u ctrl_o[2];
-
-	    ctrl_o[0] = Ctrl_O;
-	    ctrl_o[1] = 0;
-	    ins_typebuf(ctrl_o, REMAP_NONE, 0, TRUE, FALSE);
-	}
-    }
-#endif
-}
-
-
-    static void
-ex_read(eap)
-    exarg_T	*eap;
-{
-    int	    i;
-
-    if (eap->usefilter)			/* :r!cmd */
-	do_bang(1, eap, FALSE, FALSE, TRUE);
-    else
-    {
-	if (u_save(eap->line2, (linenr_T)(eap->line2 + 1)) == FAIL)
-	    return;
-
-#ifdef FEAT_BROWSE
-	if (cmdmod.browse)
-	{
-	    char_u *browseFile;
-
-	    browseFile = do_browse(FALSE, (char_u *)_("Append File"), eap->arg,
-						    NULL, NULL, NULL, curbuf);
-	    if (browseFile != NULL)
-	    {
-		i = readfile(browseFile, NULL,
-			  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);
-		vim_free(browseFile);
-	    }
-	    else
-		i = OK;
-	}
-	else
-#endif
-	     if (*eap->arg == NUL)
-	{
-	    if (check_fname() == FAIL)	/* check for no file name */
-		return;
-	    i = readfile(curbuf->b_ffname, curbuf->b_fname,
-			  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);
-	}
-	else
-	{
-	    if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)
-		(void)setaltfname(eap->arg, eap->arg, (linenr_T)1);
-	    i = readfile(eap->arg, NULL,
-			  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);
-
-	}
-	if (i == FAIL)
-	{
-#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
-	    if (!aborting())
-#endif
-		EMSG2(_(e_notopen), eap->arg);
-	}
-	else
-	    redraw_curbuf_later(VALID);
-    }
-}
-
-/*
- * ":cd", ":lcd", ":chdir" and ":lchdir".
- */
-    static void
-ex_cd(eap)
-    exarg_T	*eap;
-{
-    static char_u	*prev_dir = NULL;
-    char_u		*new_dir;
-    char_u		*tofree;
-
-    new_dir = eap->arg;
-#if !defined(UNIX) && !defined(VMS)
-    /* for non-UNIX ":cd" means: print current directory */
-    if (*new_dir == NUL)
-	ex_pwd(NULL);
-    else
-#endif
-    {
-	/* ":cd -": Change to previous directory */
-	if (STRCMP(new_dir, "-") == 0)
-	{
-	    if (prev_dir == NULL)
-	    {
-		EMSG(_("E186: No previous directory"));
-		return;
-	    }
-	    new_dir = prev_dir;
-	}
-
-	/* Save current directory for next ":cd -" */
-	tofree = prev_dir;
-	if (mch_dirname(NameBuff, MAXPATHL) == OK)
-	    prev_dir = vim_strsave(NameBuff);
-	else
-	    prev_dir = NULL;
-
-#if defined(UNIX) || defined(VMS)
-	/* for UNIX ":cd" means: go to home directory */
-	if (*new_dir == NUL)
-	{
-	    /* use NameBuff for home directory name */
-# ifdef VMS
-	    char_u	*p;
-
-	    p = mch_getenv((char_u *)"SYS$LOGIN");
-	    if (p == NULL || *p == NUL)	/* empty is the same as not set */
-		NameBuff[0] = NUL;
-	    else
-		STRNCPY(NameBuff, p, MAXPATHL);
-# else
-	    expand_env((char_u *)"$HOME", NameBuff, MAXPATHL);
-# endif
-	    new_dir = NameBuff;
-	}
-#endif
-	if (new_dir == NULL || vim_chdir(new_dir))
-	    EMSG(_(e_failed));
-	else
-	{
-	    vim_free(curwin->w_localdir);
-	    if (eap->cmdidx == CMD_lcd || eap->cmdidx == CMD_lchdir)
-	    {
-		/* If still in global directory, need to remember current
-		 * directory as global directory. */
-		if (globaldir == NULL && prev_dir != NULL)
-		    globaldir = vim_strsave(prev_dir);
-		/* Remember this local directory for the window. */
-		if (mch_dirname(NameBuff, MAXPATHL) == OK)
-		    curwin->w_localdir = vim_strsave(NameBuff);
-	    }
-	    else
-	    {
-		/* We are now in the global directory, no need to remember its
-		 * name. */
-		vim_free(globaldir);
-		globaldir = NULL;
-		curwin->w_localdir = NULL;
-	    }
-
-	    shorten_fnames(TRUE);
-
-	    /* Echo the new current directory if the command was typed. */
-	    if (KeyTyped)
-		ex_pwd(eap);
-	}
-	vim_free(tofree);
-    }
-}
-
-/*
- * ":pwd".
- */
-/*ARGSUSED*/
-    static void
-ex_pwd(eap)
-    exarg_T	*eap;
-{
-    if (mch_dirname(NameBuff, MAXPATHL) == OK)
-    {
-#ifdef BACKSLASH_IN_FILENAME
-	slash_adjust(NameBuff);
-#endif
-	msg(NameBuff);
-    }
-    else
-	EMSG(_("E187: Unknown"));
-}
-
-/*
- * ":=".
- */
-    static void
-ex_equal(eap)
-    exarg_T	*eap;
-{
-    smsg((char_u *)"%ld", (long)eap->line2);
-}
-
-    static void
-ex_sleep(eap)
-    exarg_T	*eap;
-{
-    int	    n;
-
-    if (cursor_valid())
-    {
-	n = W_WINROW(curwin) + curwin->w_wrow - msg_scrolled;
-	if (n >= 0)
-	    windgoto((int)n, curwin->w_wcol);
-    }
-    do_sleep(eap->line2 * (*eap->arg == 'm' ? 1L : 1000L));
-}
-
-/*
- * Sleep for "msec" milliseconds, but keep checking for a CTRL-C every second.
- */
-    void
-do_sleep(msec)
-    long	msec;
-{
-    long	done;
-
-    cursor_on();
-    out_flush();
-    for (done = 0; !got_int && done < msec; done += 1000L)
-    {
-	ui_delay(msec - done > 1000L ? 1000L : msec - done, TRUE);
-	ui_breakcheck();
-    }
-}
-
-    static void
-do_exmap(eap, isabbrev)
-    exarg_T	*eap;
-    int		isabbrev;
-{
-    int	    mode;
-    char_u  *cmdp;
-
-    cmdp = eap->cmd;
-    mode = get_map_mode(&cmdp, eap->forceit || isabbrev);
-
-    switch (do_map((*cmdp == 'n') ? 2 : (*cmdp == 'u'),
-						    eap->arg, mode, isabbrev))
-    {
-	case 1: EMSG(_(e_invarg));
-		break;
-	case 2: EMSG(isabbrev ? _(e_noabbr) : _(e_nomap));
-		break;
-    }
-}
-
-/*
- * ":winsize" command (obsolete).
- */
-    static void
-ex_winsize(eap)
-    exarg_T	*eap;
-{
-    int		w, h;
-    char_u	*arg = eap->arg;
-    char_u	*p;
-
-    w = getdigits(&arg);
-    arg = skipwhite(arg);
-    p = arg;
-    h = getdigits(&arg);
-    if (*p != NUL && *arg == NUL)
-	set_shellsize(w, h, TRUE);
-    else
-	EMSG(_("E465: :winsize requires two number arguments"));
-}
-
-#ifdef FEAT_WINDOWS
-    static void
-ex_wincmd(eap)
-    exarg_T	*eap;
-{
-    int		xchar = NUL;
-    char_u	*p;
-
-    if (*eap->arg == 'g' || *eap->arg == Ctrl_G)
-    {
-	/* CTRL-W g and CTRL-W CTRL-G  have an extra command character */
-	if (eap->arg[1] == NUL)
-	{
-	    EMSG(_(e_invarg));
-	    return;
-	}
-	xchar = eap->arg[1];
-	p = eap->arg + 2;
-    }
-    else
-	p = eap->arg + 1;
-
-    eap->nextcmd = check_nextcmd(p);
-    p = skipwhite(p);
-    if (*p != NUL && *p != '"' && eap->nextcmd == NULL)
-	EMSG(_(e_invarg));
-    else
-    {
-	/* Pass flags on for ":vertical wincmd ]". */
-	postponed_split_flags = cmdmod.split;
-	do_window(*eap->arg, eap->addr_count > 0 ? eap->line2 : 0L, xchar);
-	postponed_split_flags = 0;
-    }
-}
-#endif
-
-#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS)
-/*
- * ":winpos".
- */
-    static void
-ex_winpos(eap)
-    exarg_T	*eap;
-{
-    int		x, y;
-    char_u	*arg = eap->arg;
-    char_u	*p;
-
-    if (*arg == NUL)
-    {
-# ifdef FEAT_GUI
-	if (gui.in_use && gui_mch_get_winpos(&x, &y) != FAIL)
-	{
-	    sprintf((char *)IObuff, _("Window position: X %d, Y %d"), x, y);
-	    msg(IObuff);
-	}
-	else
-# endif
-	    EMSG(_("E188: Obtaining window position not implemented for this platform"));
-    }
-    else
-    {
-	x = getdigits(&arg);
-	arg = skipwhite(arg);
-	p = arg;
-	y = getdigits(&arg);
-	if (*p == NUL || *arg != NUL)
-	{
-	    EMSG(_("E466: :winpos requires two number arguments"));
-	    return;
-	}
-# ifdef FEAT_GUI
-	if (gui.in_use)
-	    gui_mch_set_winpos(x, y);
-	else if (gui.starting)
-	{
-	    /* Remember the coordinates for when the window is opened. */
-	    gui_win_x = x;
-	    gui_win_y = y;
-	}
-#  ifdef HAVE_TGETENT
-	else
-#  endif
-# endif
-# ifdef HAVE_TGETENT
-	if (*T_CWP)
-	    term_set_winpos(x, y);
-# endif
-    }
-}
-#endif
-
-/*
- * Handle command that work like operators: ":delete", ":yank", ":>" and ":<".
- */
-    static void
-ex_operators(eap)
-    exarg_T	*eap;
-{
-    oparg_T	oa;
-
-    clear_oparg(&oa);
-    oa.regname = eap->regname;
-    oa.start.lnum = eap->line1;
-    oa.end.lnum = eap->line2;
-    oa.line_count = eap->line2 - eap->line1 + 1;
-    oa.motion_type = MLINE;
-#ifdef FEAT_VIRTUALEDIT
-    virtual_op = FALSE;
-#endif
-    if (eap->cmdidx != CMD_yank)	/* position cursor for undo */
-    {
-	setpcmark();
-	curwin->w_cursor.lnum = eap->line1;
-	beginline(BL_SOL | BL_FIX);
-    }
-
-    switch (eap->cmdidx)
-    {
-	case CMD_delete:
-	    oa.op_type = OP_DELETE;
-	    op_delete(&oa);
-	    break;
-
-	case CMD_yank:
-	    oa.op_type = OP_YANK;
-	    (void)op_yank(&oa, FALSE, TRUE);
-	    break;
-
-	default:    /* CMD_rshift or CMD_lshift */
-	    if ((eap->cmdidx == CMD_rshift)
-#ifdef FEAT_RIGHTLEFT
-				    ^ curwin->w_p_rl
-#endif
-						    )
-		oa.op_type = OP_RSHIFT;
-	    else
-		oa.op_type = OP_LSHIFT;
-	    op_shift(&oa, FALSE, eap->amount);
-	    break;
-    }
-#ifdef FEAT_VIRTUALEDIT
-    virtual_op = MAYBE;
-#endif
-}
-
-/*
- * ":put".
- */
-    static void
-ex_put(eap)
-    exarg_T	*eap;
-{
-    /* ":0put" works like ":1put!". */
-    if (eap->line2 == 0)
-    {
-	eap->line2 = 1;
-	eap->forceit = TRUE;
-    }
-    curwin->w_cursor.lnum = eap->line2;
-    do_put(eap->regname, eap->forceit ? BACKWARD : FORWARD, 1L, PUT_LINE);
-}
-
-/*
- * Handle ":copy" and ":move".
- */
-    static void
-ex_copymove(eap)
-    exarg_T	*eap;
-{
-    long	n;
-
-    n = get_address(&eap->arg, FALSE, FALSE);
-    if (eap->arg == NULL)	    /* error detected */
-    {
-	eap->nextcmd = NULL;
-	return;
-    }
-
-    /*
-     * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'
-     */
-    if (n == MAXLNUM || n < 0 || n > curbuf->b_ml.ml_line_count)
-    {
-	EMSG(_(e_invaddr));
-	return;
-    }
-
-    if (eap->cmdidx == CMD_move)
-    {
-	if (do_move(eap->line1, eap->line2, n) == FAIL)
-	    return;
-    }
-    else
-	ex_copy(eap->line1, eap->line2, n);
-    u_clearline();
-    beginline(BL_SOL | BL_FIX);
-}
-
-/*
- * ":smagic" and ":snomagic".
- */
-    static void
-ex_submagic(eap)
-    exarg_T	*eap;
-{
-    int		magic_save = p_magic;
-
-    p_magic = (eap->cmdidx == CMD_smagic);
-    do_sub(eap);
-    p_magic = magic_save;
-}
-
-/*
- * ":join".
- */
-    static void
-ex_join(eap)
-    exarg_T	*eap;
-{
-    curwin->w_cursor.lnum = eap->line1;
-    if (eap->line1 == eap->line2)
-    {
-	if (eap->addr_count >= 2)   /* :2,2join does nothing */
-	    return;
-	if (eap->line2 == curbuf->b_ml.ml_line_count)
-	{
-	    beep_flush();
-	    return;
-	}
-	++eap->line2;
-    }
-    do_do_join(eap->line2 - eap->line1 + 1, !eap->forceit);
-    beginline(BL_WHITE | BL_FIX);
-}
-
-/*
- * ":[addr]@r" or ":[addr]*r": execute register
- */
-    static void
-ex_at(eap)
-    exarg_T	*eap;
-{
-    int		c;
-
-    curwin->w_cursor.lnum = eap->line2;
-
-#ifdef USE_ON_FLY_SCROLL
-    dont_scroll = TRUE;		/* disallow scrolling here */
-#endif
-
-    /* get the register name.  No name means to use the previous one */
-    c = *eap->arg;
-    if (c == NUL || (c == '*' && *eap->cmd == '*'))
-	c = '@';
-    /* put the register in mapbuf */
-    if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL) == FAIL)
-	beep_flush();
-    else
-    {
-	int	save_efr = exec_from_reg;
-
-	exec_from_reg = TRUE;
-
-	/*
-	 * Execute from the typeahead buffer.
-	 * Originally this didn't check for the typeahead buffer to be empty,
-	 * thus could read more Ex commands from stdin.  It's not clear why,
-	 * it is certainly unexpected.
-	 */
-	while ((!stuff_empty() || typebuf.tb_len > 0) && vpeekc() == ':')
-	    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);
-
-	exec_from_reg = save_efr;
-    }
-}
-
-/*
- * ":!".
- */
-    static void
-ex_bang(eap)
-    exarg_T	*eap;
-{
-    do_bang(eap->addr_count, eap, eap->forceit, TRUE, TRUE);
-}
-
-/*
- * ":undo".
- */
-/*ARGSUSED*/
-    static void
-ex_undo(eap)
-    exarg_T	*eap;
-{
-    u_undo(1);
-}
-
-/*
- * ":redo".
- */
-/*ARGSUSED*/
-    static void
-ex_redo(eap)
-    exarg_T	*eap;
-{
-    u_redo(1);
-}
-
-/*
- * ":redir": start/stop redirection.
- */
-    static void
-ex_redir(eap)
-    exarg_T	*eap;
-{
-    char	*mode;
-    char_u	*fname;
-
-    if (STRICMP(eap->arg, "END") == 0)
-	close_redir();
-    else
-    {
-	if (*eap->arg == '>')
-	{
-	    ++eap->arg;
-	    if (*eap->arg == '>')
-	    {
-		++eap->arg;
-		mode = "a";
-	    }
-	    else
-		mode = "w";
-	    eap->arg = skipwhite(eap->arg);
-
-	    close_redir();
-
-	    /* Expand environment variables and "~/". */
-	    fname = expand_env_save(eap->arg);
-	    if (fname == NULL)
-		return;
-#ifdef FEAT_BROWSE
-	    if (cmdmod.browse)
-	    {
-		char_u	*browseFile;
-
-		browseFile = do_browse(TRUE, (char_u *)_("Save Redirection"),
-		       fname, NULL, NULL, BROWSE_FILTER_ALL_FILES, curbuf);
-		if (browseFile == NULL)
-		    return;		/* operation cancelled */
-		vim_free(fname);
-		fname = browseFile;
-		eap->forceit = TRUE;	/* since dialog already asked */
-	    }
-#endif
-
-	    redir_fd = open_exfile(fname, eap->forceit, mode);
-	    vim_free(fname);
-	}
-#ifdef FEAT_EVAL
-	else if (*eap->arg == '@')
-	{
-	    /* redirect to a register a-z (resp. A-Z for appending) */
-	    close_redir();
-	    ++eap->arg;
-	    if (ASCII_ISALPHA(*eap->arg)
-# ifdef FEAT_CLIPBOARD
-		    || *eap->arg == '*'
-# endif
-		    || *eap->arg == '"')
-	    {
-		redir_reg = *eap->arg;
-		if (islower(redir_reg)
-# ifdef FEAT_CLIPBOARD
-			|| redir_reg == '*'
-# endif
-			|| redir_reg == '"')
-		{
-		    /* make register empty */
-		    write_reg_contents(redir_reg, (char_u *)"", -1, FALSE);
-		}
-	    }
-	    else
-		EMSG(_(e_invarg));
-	}
-#endif
-
-	/* TODO: redirect to a buffer */
-
-	/* TODO: redirect to an internal variable */
-
-	else
-	    EMSG(_(e_invarg));
-    }
-}
-
-/*
- * ":redraw": force redraw
- */
-    static void
-ex_redraw(eap)
-    exarg_T	*eap;
-{
-    int		r = RedrawingDisabled;
-    int		p = p_lz;
-
-    RedrawingDisabled = 0;
-    p_lz = FALSE;
-    update_topline();
-    update_screen(eap->forceit ? CLEAR :
-#ifdef FEAT_VISUAL
-	    VIsual_active ? INVERTED :
-#endif
-	    0);
-#ifdef FEAT_TITLE
-    if (need_maketitle)
-	maketitle();
-#endif
-    RedrawingDisabled = r;
-    p_lz = p;
-
-    /* Reset msg_didout, so that a message that's there is overwritten. */
-    msg_didout = FALSE;
-    msg_col = 0;
-
-    out_flush();
-}
-
-/*
- * ":redrawstatus": force redraw of status line(s)
- */
-/*ARGSUSED*/
-    static void
-ex_redrawstatus(eap)
-    exarg_T	*eap;
-{
-#if defined(FEAT_WINDOWS)
-    int		r = RedrawingDisabled;
-    int		p = p_lz;
-
-    RedrawingDisabled = 0;
-    p_lz = FALSE;
-    if (eap->forceit)
-	status_redraw_all();
-    else
-	status_redraw_curbuf();
-    update_screen(
-# ifdef FEAT_VISUAL
-	    VIsual_active ? INVERTED :
-# endif
-	    0);
-    RedrawingDisabled = r;
-    p_lz = p;
-    out_flush();
-#endif
-}
-
-    static void
-close_redir()
-{
-    if (redir_fd != NULL)
-    {
-	fclose(redir_fd);
-	redir_fd = NULL;
-    }
-#ifdef FEAT_EVAL
-    redir_reg = 0;
-#endif
-}
-
-#if defined(FEAT_SESSION) && defined(USE_CRNL)
-# define MKSESSION_NL
-static int mksession_nl = FALSE;    /* use NL only in put_eol() */
-#endif
-
-/*
- * ":mkexrc", ":mkvimrc", ":mkview" and ":mksession".
- */
-    static void
-ex_mkrc(eap)
-    exarg_T	*eap;
-{
-    FILE	*fd;
-    int		failed = FALSE;
-    char_u	*fname;
-#ifdef FEAT_BROWSE
-    char_u	*browseFile = NULL;
-#endif
-#ifdef FEAT_SESSION
-    int		view_session = FALSE;
-    int		using_vdir = FALSE;	/* using 'viewdir'? */
-    char_u	*viewFile = NULL;
-    unsigned	*flagp;
-#endif
-
-    if (eap->cmdidx == CMD_mksession || eap->cmdidx == CMD_mkview)
-    {
-#ifdef FEAT_SESSION
-	view_session = TRUE;
-#else
-	ex_ni(eap);
-	return;
-#endif
-    }
-
-#ifdef FEAT_SESSION
-    /* ":mkview" or ":mkview 9": generate file name with 'viewdir' */
-    if (eap->cmdidx == CMD_mkview
-	    && (*eap->arg == NUL
-		|| (vim_isdigit(*eap->arg) && eap->arg[1] == NUL)))
-    {
-	eap->forceit = TRUE;
-	fname = get_view_file(*eap->arg);
-	if (fname == NULL)
-	    return;
-	viewFile = fname;
-	using_vdir = TRUE;
-    }
-    else
-#endif
-	if (*eap->arg != NUL)
-	fname = eap->arg;
-    else if (eap->cmdidx == CMD_mkvimrc)
-	fname = (char_u *)VIMRC_FILE;
-#ifdef FEAT_SESSION
-    else if (eap->cmdidx == CMD_mksession)
-	fname = (char_u *)SESSION_FILE;
-#endif
-    else
-	fname = (char_u *)EXRC_FILE;
-
-#ifdef FEAT_BROWSE
-    if (cmdmod.browse)
-    {
-	browseFile = do_browse(TRUE,
-# ifdef FEAT_SESSION
-		eap->cmdidx == CMD_mkview ? (char_u *)_("Save View") :
-		eap->cmdidx == CMD_mksession ? (char_u *)_("Save Session") :
-# endif
-		(char_u *)_("Save Setup"),
-		fname, (char_u *)"vim", NULL, BROWSE_FILTER_MACROS, NULL);
-	if (browseFile == NULL)
-	    goto theend;
-	fname = browseFile;
-	eap->forceit = TRUE;	/* since dialog already asked */
-    }
-#endif
-
-#if defined(FEAT_SESSION) && defined(vim_mkdir)
-    /* When using 'viewdir' may have to create the directory. */
-    if (using_vdir && !mch_isdir(p_vdir))
-	vim_mkdir(p_vdir, 0755); /* ignore errors, open_exfile() will fail */
-#endif
-
-    fd = open_exfile(fname, eap->forceit, WRITEBIN);
-    if (fd != NULL)
-    {
-#ifdef FEAT_SESSION
-	if (eap->cmdidx == CMD_mkview)
-	    flagp = &vop_flags;
-	else
-	    flagp = &ssop_flags;
-#endif
-
-#ifdef MKSESSION_NL
-	/* "unix" in 'sessionoptions': use NL line separator */
-	if (view_session && (*flagp & SSOP_UNIX))
-	    mksession_nl = TRUE;
-#endif
-
-	/* Write the version command for :mkvimrc */
-	if (eap->cmdidx == CMD_mkvimrc)
-	    (void)put_line(fd, "version 6.0");
-
-#ifdef FEAT_SESSION
-	if (eap->cmdidx != CMD_mkview)
-#endif
-	{
-	    /* Write setting 'compatible' first, because it has side effects.
-	     * For that same reason only do it when needed. */
-	    if (p_cp)
-		(void)put_line(fd, "if !&cp | set cp | endif");
-	    else
-		(void)put_line(fd, "if &cp | set nocp | endif");
-	}
-
-#ifdef FEAT_SESSION
-	if (!view_session
-		|| (eap->cmdidx == CMD_mksession
-		    && (*flagp & SSOP_OPTIONS)))
-#endif
-	    failed |= (makemap(fd, NULL) == FAIL
-				   || makeset(fd, OPT_GLOBAL, FALSE) == FAIL);
-
-#ifdef FEAT_SESSION
-	if (!failed && view_session)
-	{
-	    if (put_line(fd, "let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0") == FAIL)
-		failed = TRUE;
-	    if (eap->cmdidx == CMD_mksession)
-	    {
-		char_u dirnow[MAXPATHL];	/* current directory */
-
-		/*
-		 * Change to session file's dir.
-		 */
-		if (mch_dirname(dirnow, MAXPATHL) == FAIL
-					    || mch_chdir((char *)dirnow) != 0)
-		    *dirnow = NUL;
-		if (*dirnow != NUL && (ssop_flags & SSOP_SESDIR))
-		{
-		    if (vim_chdirfile(fname) == OK)
-			shorten_fnames(TRUE);
-		}
-		else if (*dirnow != NUL
-			&& (ssop_flags & SSOP_CURDIR) && globaldir != NULL)
-		{
-		    (void)mch_chdir((char *)globaldir);
-		    shorten_fnames(TRUE);
-		}
-
-		failed |= (makeopens(fd, dirnow) == FAIL);
-
-		/* restore original dir */
-		if (*dirnow != NUL && ((ssop_flags & SSOP_SESDIR)
-			|| ((ssop_flags & SSOP_CURDIR) && globaldir != NULL)))
-		{
-		    if (mch_chdir((char *)dirnow) != 0)
-			EMSG(_(e_prev_dir));
-		    shorten_fnames(TRUE);
-		}
-	    }
-	    else
-	    {
-		failed |= (put_view(fd, curwin, !using_vdir, flagp) == FAIL);
-	    }
-	    if (put_line(fd, "let &so = s:so_save | let &siso = s:siso_save")
-								      == FAIL)
-		failed = TRUE;
-	}
-#endif
-	failed |= fclose(fd);
-
-	if (failed)
-	    EMSG(_(e_write));
-#if defined(FEAT_EVAL) && defined(FEAT_SESSION)
-	else if (eap->cmdidx == CMD_mksession)
-	{
-	    /* successful session write - set this_session var */
-	    char_u	tbuf[MAXPATHL];
-
-	    if (vim_FullName(fname, tbuf, MAXPATHL, FALSE) == OK)
-		set_vim_var_string(VV_THIS_SESSION, tbuf, -1);
-	}
-#endif
-#ifdef MKSESSION_NL
-	mksession_nl = FALSE;
-#endif
-    }
-
-#ifdef FEAT_BROWSE
-theend:
-    vim_free(browseFile);
-#endif
-#ifdef FEAT_SESSION
-    vim_free(viewFile);
-#endif
-}
-
-/*
- * Open a file for writing for an Ex command, with some checks.
- * Return file descriptor, or NULL on failure.
- */
-    FILE *
-open_exfile(fname, forceit, mode)
-    char_u	*fname;
-    int		forceit;
-    char	*mode;	    /* "w" for create new file or "a" for append */
-{
-    FILE	*fd;
-
-#ifdef UNIX
-    /* with Unix it is possible to open a directory */
-    if (mch_isdir(fname))
-    {
-	EMSG2(_(e_isadir2), fname);
-	return NULL;
-    }
-#endif
-    if (!forceit && *mode != 'a' && vim_fexists(fname))
-    {
-	EMSG2(_("E189: \"%s\" exists (add ! to override)"), fname);
-	return NULL;
-    }
-
-    if ((fd = mch_fopen((char *)fname, mode)) == NULL)
-	EMSG2(_("E190: Cannot open \"%s\" for writing"), fname);
-
-    return fd;
-}
-
-/*
- * ":mark" and ":k".
- */
-    static void
-ex_mark(eap)
-    exarg_T	*eap;
-{
-    pos_T	pos;
-
-    if (*eap->arg == NUL)		/* No argument? */
-	EMSG(_(e_argreq));
-    else if (eap->arg[1] != NUL)	/* more than one character? */
-	EMSG(_(e_trailing));
-    else
-    {
-	pos = curwin->w_cursor;		/* save curwin->w_cursor */
-	curwin->w_cursor.lnum = eap->line2;
-	beginline(BL_WHITE | BL_FIX);
-	if (setmark(*eap->arg) == FAIL)	/* set mark */
-	    EMSG(_("E191: Argument must be a letter or forward/backward quote"));
-	curwin->w_cursor = pos;		/* restore curwin->w_cursor */
-    }
-}
-
-/*
- * Update w_topline, w_leftcol and the cursor position.
- */
-    void
-update_topline_cursor()
-{
-    check_cursor();		/* put cursor on valid line */
-    update_topline();
-    if (!curwin->w_p_wrap)
-	validate_cursor();
-    update_curswant();
-}
-
-#ifdef FEAT_EX_EXTRA
-/*
- * ":normal[!] {commands}": Execute normal mode commands.
- */
-    static void
-ex_normal(eap)
-    exarg_T	*eap;
-{
-    oparg_T	oa;
-    int		save_msg_scroll = msg_scroll;
-    int		save_restart_edit = restart_edit;
-    int		save_msg_didout = msg_didout;
-    int		save_State = State;
-    tasave_T	tabuf;
-    int		save_insertmode = p_im;
-    int		save_finish_op = finish_op;
-#ifdef FEAT_MBYTE
-    char_u	*arg = NULL;
-    int		l;
-    char_u	*p;
-#endif
-
-    if (ex_normal_busy >= p_mmd)
-    {
-	EMSG(_("E192: Recursive use of :normal too deep"));
-	return;
-    }
-    ++ex_normal_busy;
-
-    msg_scroll = FALSE;	    /* no msg scrolling in Normal mode */
-    restart_edit = 0;	    /* don't go to Insert mode */
-    p_im = FALSE;	    /* don't use 'insertmode' */
-
-#ifdef FEAT_MBYTE
-    /*
-     * vgetc() expects a CSI and K_SPECIAL to have been escaped.  Don't do
-     * this for the K_SPECIAL leading byte, otherwise special keys will not
-     * work.
-     */
-    if (has_mbyte)
-    {
-	int	len = 0;
-
-	/* Count the number of characters to be escaped. */
-	for (p = eap->arg; *p != NUL; ++p)
-	{
-# ifdef FEAT_GUI
-	    if (*p == CSI)  /* leadbyte CSI */
-		len += 2;
-# endif
-	    for (l = (*mb_ptr2len_check)(p) - 1; l > 0; --l)
-		if (*++p == K_SPECIAL	  /* trailbyte K_SPECIAL or CSI */
-# ifdef FEAT_GUI
-			|| *p == CSI
-# endif
-			)
-		    len += 2;
-	}
-	if (len > 0)
-	{
-	    arg = alloc((unsigned)(STRLEN(eap->arg) + len + 1));
-	    if (arg != NULL)
-	    {
-		len = 0;
-		for (p = eap->arg; *p != NUL; ++p)
-		{
-		    arg[len++] = *p;
-# ifdef FEAT_GUI
-		    if (*p == CSI)
-		    {
-			arg[len++] = KS_EXTRA;
-			arg[len++] = (int)KE_CSI;
-		    }
-# endif
-		    for (l = (*mb_ptr2len_check)(p) - 1; l > 0; --l)
-		    {
-			arg[len++] = *++p;
-			if (*p == K_SPECIAL)
-			{
-			    arg[len++] = KS_SPECIAL;
-			    arg[len++] = KE_FILLER;
-			}
-# ifdef FEAT_GUI
-			else if (*p == CSI)
-			{
-			    arg[len++] = KS_EXTRA;
-			    arg[len++] = (int)KE_CSI;
-			}
-# endif
-		    }
-		    arg[len] = NUL;
-		}
-	    }
-	}
-    }
-#endif
-
-    /*
-     * Save the current typeahead.  This is required to allow using ":normal"
-     * from an event handler and makes sure we don't hang when the argument
-     * ends with half a command.
-     */
-    save_typeahead(&tabuf);
-    if (tabuf.typebuf_valid)
-    {
-	/*
-	 * Repeat the :normal command for each line in the range.  When no
-	 * range given, execute it just once, without positioning the cursor
-	 * first.
-	 */
-	do
-	{
-	    clear_oparg(&oa);
-	    finish_op = FALSE;
-	    if (eap->addr_count != 0)
-	    {
-		curwin->w_cursor.lnum = eap->line1++;
-		curwin->w_cursor.col = 0;
-	    }
-
-	    /*
-	     * Stuff the argument into the typeahead buffer.
-	     * Execute normal_cmd() until there is no typeahead left.
-	     */
-	    ins_typebuf(
-#ifdef FEAT_MBYTE
-		    arg != NULL ? arg :
-#endif
-		    eap->arg, eap->forceit ? REMAP_NONE : REMAP_YES, 0,
-								 TRUE, FALSE);
-	    while ((!stuff_empty() || (!typebuf_typed() && typebuf.tb_len > 0))
-		    && !got_int)
-	    {
-		update_topline_cursor();
-		normal_cmd(&oa, FALSE);	/* execute a Normal mode cmd */
-	    }
-	}
-	while (eap->addr_count > 0 && eap->line1 <= eap->line2 && !got_int);
-    }
-
-    /* Might not return to the main loop when in an event handler. */
-    update_topline_cursor();
-
-    /* Restore the previous typeahead. */
-    restore_typeahead(&tabuf);
-
-    --ex_normal_busy;
-    msg_scroll = save_msg_scroll;
-    restart_edit = save_restart_edit;
-    p_im = save_insertmode;
-    finish_op = save_finish_op;
-    msg_didout |= save_msg_didout;	/* don't reset msg_didout now */
-
-    /* Restore the state (needed when called from a function executed for
-     * 'indentexpr'). */
-    State = save_State;
-#ifdef FEAT_MBYTE
-    vim_free(arg);
-#endif
-}
-
-/*
- * ":startinsert"
- */
-    static void
-ex_startinsert(eap)
-    exarg_T	*eap;
-{
-    if (eap->forceit)
-    {
-	coladvance((colnr_T)MAXCOL);
-	curwin->w_curswant = MAXCOL;
-	curwin->w_set_curswant = FALSE;
-	restart_edit = 'a';
-    }
-    else
-    {
-	restart_edit = 'i';
-	curwin->w_curswant = 0;	    /* avoid MAXCOL */
-    }
-}
-
-/*
- * ":stopinsert"
- */
-/*ARGSUSED*/
-    static void
-ex_stopinsert(eap)
-    exarg_T	*eap;
-{
-    restart_edit = 0;
-    stop_insert_mode = TRUE;
-}
-#endif
-
-#ifdef FEAT_FIND_ID
-    static void
-ex_checkpath(eap)
-    exarg_T	*eap;
-{
-    find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,
-				   eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,
-					      (linenr_T)1, (linenr_T)MAXLNUM);
-}
-
-#if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-/*
- * ":psearch"
- */
-    static void
-ex_psearch(eap)
-    exarg_T	*eap;
-{
-    g_do_tagpreview = p_pvh;
-    ex_findpat(eap);
-    g_do_tagpreview = 0;
-}
-#endif
-
-    static void
-ex_findpat(eap)
-    exarg_T	*eap;
-{
-    int		whole = TRUE;
-    long	n;
-    char_u	*p;
-    int		action;
-
-    switch (cmdnames[eap->cmdidx].cmd_name[2])
-    {
-	case 'e':	/* ":psearch", ":isearch" and ":dsearch" */
-		if (cmdnames[eap->cmdidx].cmd_name[0] == 'p')
-		    action = ACTION_GOTO;
-		else
-		    action = ACTION_SHOW;
-		break;
-	case 'i':	/* ":ilist" and ":dlist" */
-		action = ACTION_SHOW_ALL;
-		break;
-	case 'u':	/* ":ijump" and ":djump" */
-		action = ACTION_GOTO;
-		break;
-	default:	/* ":isplit" and ":dsplit" */
-		action = ACTION_SPLIT;
-		break;
-    }
-
-    n = 1;
-    if (vim_isdigit(*eap->arg))	/* get count */
-    {
-	n = getdigits(&eap->arg);
-	eap->arg = skipwhite(eap->arg);
-    }
-    if (*eap->arg == '/')   /* Match regexp, not just whole words */
-    {
-	whole = FALSE;
-	++eap->arg;
-	p = skip_regexp(eap->arg, '/', p_magic, NULL);
-	if (*p)
-	{
-	    *p++ = NUL;
-	    p = skipwhite(p);
-
-	    /* Check for trailing illegal characters */
-	    if (!ends_excmd(*p))
-		eap->errmsg = e_trailing;
-	    else
-		eap->nextcmd = check_nextcmd(p);
-	}
-    }
-    if (!eap->skip)
-	find_pattern_in_path(eap->arg, 0, (int)STRLEN(eap->arg),
-			    whole, !eap->forceit,
-			    *eap->cmd == 'd' ?	FIND_DEFINE : FIND_ANY,
-			    n, action, eap->line1, eap->line2);
-}
-#endif
-
-#ifdef FEAT_WINDOWS
-
-# ifdef FEAT_QUICKFIX
-/*
- * ":ptag", ":ptselect", ":ptjump", ":ptnext", etc.
- */
-    static void
-ex_ptag(eap)
-    exarg_T	*eap;
-{
-    g_do_tagpreview = p_pvh;
-    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);
-}
-
-/*
- * ":pedit"
- */
-    static void
-ex_pedit(eap)
-    exarg_T	*eap;
-{
-    win_T	*curwin_save = curwin;
-
-    g_do_tagpreview = p_pvh;
-    prepare_tagpreview();
-    keep_help_flag = curwin_save->w_buffer->b_help;
-    do_exedit(eap, NULL);
-    keep_help_flag = FALSE;
-    if (curwin != curwin_save && win_valid(curwin_save))
-    {
-	/* Return cursor to where we were */
-	validate_cursor();
-	redraw_later(VALID);
-	win_enter(curwin_save, TRUE);
-    }
-    g_do_tagpreview = 0;
-}
-# endif
-
-/*
- * ":stag", ":stselect" and ":stjump".
- */
-    static void
-ex_stag(eap)
-    exarg_T	*eap;
-{
-    postponed_split = -1;
-    postponed_split_flags = cmdmod.split;
-    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);
-    postponed_split_flags = 0;
-}
-#endif
-
-/*
- * ":tag", ":tselect", ":tjump", ":tnext", etc.
- */
-    static void
-ex_tag(eap)
-    exarg_T	*eap;
-{
-    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name);
-}
-
-    static void
-ex_tag_cmd(eap, name)
-    exarg_T	*eap;
-    char_u	*name;
-{
-    int		cmd;
-
-    switch (name[1])
-    {
-	case 'j': cmd = DT_JUMP;	/* ":tjump" */
-		  break;
-	case 's': cmd = DT_SELECT;	/* ":tselect" */
-		  break;
-	case 'p': cmd = DT_PREV;	/* ":tprevious" */
-		  break;
-	case 'N': cmd = DT_PREV;	/* ":tNext" */
-		  break;
-	case 'n': cmd = DT_NEXT;	/* ":tnext" */
-		  break;
-	case 'o': cmd = DT_POP;		/* ":pop" */
-		  break;
-	case 'f':			/* ":tfirst" */
-	case 'r': cmd = DT_FIRST;	/* ":trewind" */
-		  break;
-	case 'l': cmd = DT_LAST;	/* ":tlast" */
-		  break;
-	default:			/* ":tag" */
-#ifdef FEAT_CSCOPE
-		  if (p_cst)
-		  {
-		      do_cstag(eap);
-		      return;
-		  }
-#endif
-		  cmd = DT_TAG;
-		  break;
-    }
-
-    do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,
-							  eap->forceit, TRUE);
-}
-
-/*
- * Evaluate cmdline variables.
- *
- * change '%'	    to curbuf->b_ffname
- *	  '#'	    to curwin->w_altfile
- *	  '<cword>' to word under the cursor
- *	  '<cWORD>' to WORD under the cursor
- *	  '<cfile>' to path name under the cursor
- *	  '<sfile>' to sourced file name
- *	  '<afile>' to file name for autocommand
- *	  '<abuf>'  to buffer number for autocommand
- *	  '<amatch>' to matching name for autocommand
- *
- * When an error is detected, "errormsg" is set to a non-NULL pointer (may be
- * "" for error without a message) and NULL is returned.
- * Returns an allocated string if a valid match was found.
- * Returns NULL if no match was found.	"usedlen" then still contains the
- * number of characters to skip.
- */
-    char_u *
-eval_vars(src, usedlen, lnump, errormsg, srcstart)
-    char_u	*src;		/* pointer into commandline */
-    int		*usedlen;	/* characters after src that are used */
-    linenr_T	*lnump;		/* line number for :e command, or NULL */
-    char_u	**errormsg;	/* pointer to error message */
-    char_u	*srcstart;	/* beginning of valid memory for src */
-{
-    int		i;
-    char_u	*s;
-    char_u	*result;
-    char_u	*resultbuf = NULL;
-    int		resultlen;
-    buf_T	*buf;
-    int		valid = VALID_HEAD + VALID_PATH;    /* assume valid result */
-    int		spec_idx;
-#ifdef FEAT_MODIFY_FNAME
-    int		skip_mod = FALSE;
-#endif
-    static char *(spec_str[]) =
-	{
-		    "%",
-#define SPEC_PERC   0
-		    "#",
-#define SPEC_HASH   1
-		    "<cword>",		/* cursor word */
-#define SPEC_CWORD  2
-		    "<cWORD>",		/* cursor WORD */
-#define SPEC_CCWORD 3
-		    "<cfile>",		/* cursor path name */
-#define SPEC_CFILE  4
-		    "<sfile>",		/* ":so" file name */
-#define SPEC_SFILE  5
-#ifdef FEAT_AUTOCMD
-		    "<afile>",		/* autocommand file name */
-# define SPEC_AFILE 6
-		    "<abuf>",		/* autocommand buffer number */
-# define SPEC_ABUF  7
-		    "<amatch>",		/* autocommand match name */
-# define SPEC_AMATCH 8
-#endif
-#ifdef FEAT_CLIENTSERVER
-		    "<client>"
-# define SPEC_CLIENT 9
-#endif
-		};
-#define SPEC_COUNT  (sizeof(spec_str) / sizeof(char *))
-
-#if defined(FEAT_AUTOCMD) || defined(FEAT_CLIENTSERVER)
-    char_u	strbuf[30];
-#endif
-
-    *errormsg = NULL;
-
-    /*
-     * Check if there is something to do.
-     */
-    for (spec_idx = 0; spec_idx < SPEC_COUNT; ++spec_idx)
-    {
-	*usedlen = (int)STRLEN(spec_str[spec_idx]);
-	if (STRNCMP(src, spec_str[spec_idx], *usedlen) == 0)
-	    break;
-    }
-    if (spec_idx == SPEC_COUNT)	    /* no match */
-    {
-	*usedlen = 1;
-	return NULL;
-    }
-
-    /*
-     * Skip when preceded with a backslash "\%" and "\#".
-     * Note: In "\\%" the % is also not recognized!
-     */
-    if (src > srcstart && src[-1] == '\\')
-    {
-	*usedlen = 0;
-	STRCPY(src - 1, src);		/* remove backslash */
-	return NULL;
-    }
-
-    /*
-     * word or WORD under cursor
-     */
-    if (spec_idx == SPEC_CWORD || spec_idx == SPEC_CCWORD)
-    {
-	resultlen = find_ident_under_cursor(&result, spec_idx == SPEC_CWORD ?
-				      (FIND_IDENT|FIND_STRING) : FIND_STRING);
-	if (resultlen == 0)
-	{
-	    *errormsg = (char_u *)"";
-	    return NULL;
-	}
-    }
-
-    /*
-     * '#': Alternate file name
-     * '%': Current file name
-     *	    File name under the cursor
-     *	    File name for autocommand
-     *	and following modifiers
-     */
-    else
-    {
-	switch (spec_idx)
-	{
-	case SPEC_PERC:		/* '%': current file */
-		if (curbuf->b_fname == NULL)
-		{
-		    result = (char_u *)"";
-		    valid = 0;	    /* Must have ":p:h" to be valid */
-		}
-		else
-#ifdef RISCOS
-		    /* Always use the full path for RISC OS if possible. */
-		    result = curbuf->b_ffname;
-		    if (result == NULL)
-			result = curbuf->b_fname;
-#else
-		    result = curbuf->b_fname;
-#endif
-		break;
-
-	case SPEC_HASH:		/* '#' or "#99": alternate file */
-		if (src[1] == '#')  /* "##": the argument list */
-		{
-		    result = arg_all();
-		    resultbuf = result;
-		    *usedlen = 2;
-#ifdef FEAT_MODIFY_FNAME
-		    skip_mod = TRUE;
-#endif
-		    break;
-		}
-		s = src + 1;
-		i = (int)getdigits(&s);
-		*usedlen = (int)(s - src); /* length of what we expand */
-
-		buf = buflist_findnr(i);
-		if (buf == NULL)
-		{
-		    *errormsg = (char_u *)_("E194: No alternate file name to substitute for '#'");
-		    return NULL;
-		}
-		if (lnump != NULL)
-		    *lnump = ECMD_LAST;
-		if (buf->b_fname == NULL)
-		{
-		    result = (char_u *)"";
-		    valid = 0;	    /* Must have ":p:h" to be valid */
-		}
-		else
-		    result = buf->b_fname;
-		break;
-
-#ifdef FEAT_SEARCHPATH
-	case SPEC_CFILE:	/* file name under cursor */
-		result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L);
-		if (result == NULL)
-		{
-		    *errormsg = (char_u *)"";
-		    return NULL;
-		}
-		resultbuf = result;	    /* remember allocated string */
-		break;
-#endif
-
-#ifdef FEAT_AUTOCMD
-	case SPEC_AFILE:	/* file name for autocommand */
-		result = autocmd_fname;
-		if (result == NULL)
-		{
-		    *errormsg = (char_u *)_("E495: no autocommand file name to substitute for \"<afile>\"");
-		    return NULL;
-		}
-		break;
-
-	case SPEC_ABUF:		/* buffer number for autocommand */
-		if (autocmd_bufnr <= 0)
-		{
-		    *errormsg = (char_u *)_("E496: no autocommand buffer number to substitute for \"<abuf>\"");
-		    return NULL;
-		}
-		sprintf((char *)strbuf, "%d", autocmd_bufnr);
-		result = strbuf;
-		break;
-
-	case SPEC_AMATCH:	/* match name for autocommand */
-		result = autocmd_match;
-		if (result == NULL)
-		{
-		    *errormsg = (char_u *)_("E497: no autocommand match name to substitute for \"<amatch>\"");
-		    return NULL;
-		}
-		break;
-
-#endif
-	case SPEC_SFILE:	/* file name for ":so" command */
-		result = sourcing_name;
-		if (result == NULL)
-		{
-		    *errormsg = (char_u *)_("E498: no :source file name to substitute for \"<sfile>\"");
-		    return NULL;
-		}
-		break;
-#if defined(FEAT_CLIENTSERVER)
-	case SPEC_CLIENT:	/* Source of last submitted input */
-		sprintf((char *)strbuf, "0x%x", (unsigned int)clientWindow);
-		result = strbuf;
-		break;
-#endif
-	}
-
-	resultlen = (int)STRLEN(result);	/* length of new string */
-	if (src[*usedlen] == '<')	/* remove the file name extension */
-	{
-	    ++*usedlen;
-#ifdef RISCOS
-	    if ((s = vim_strrchr(result, '/')) != NULL && s >= gettail(result))
-#else
-	    if ((s = vim_strrchr(result, '.')) != NULL && s >= gettail(result))
-#endif
-		resultlen = (int)(s - result);
-	}
-#ifdef FEAT_MODIFY_FNAME
-	else if (!skip_mod)
-	{
-	    valid |= modify_fname(src, usedlen, &result, &resultbuf,
-								  &resultlen);
-	    if (result == NULL)
-	    {
-		*errormsg = (char_u *)"";
-		return NULL;
-	    }
-	}
-#endif
-    }
-
-    if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH)
-    {
-	if (valid != VALID_HEAD + VALID_PATH)
-	    /* xgettext:no-c-format */
-	    *errormsg = (char_u *)_("E499: Empty file name for '%' or '#', only works with \":p:h\"");
-	else
-	    *errormsg = (char_u *)_("E500: Evaluates to an empty string");
-	result = NULL;
-    }
-    else
-	result = vim_strnsave(result, resultlen);
-    vim_free(resultbuf);
-    return result;
-}
-
-/*
- * Concatenate all files in the argument list, separated by spaces, and return
- * it in one allocated string.
- * Spaces and backslashes in the file names are escaped with a backslash.
- * Returns NULL when out of memory.
- */
-    static char_u *
-arg_all()
-{
-    int		len;
-    int		idx;
-    char_u	*retval = NULL;
-    char_u	*p;
-
-    /*
-     * Do this loop two times:
-     * first time: compute the total length
-     * second time: concatenate the names
-     */
-    for (;;)
-    {
-	len = 0;
-	for (idx = 0; idx < ARGCOUNT; ++idx)
-	{
-	    p = alist_name(&ARGLIST[idx]);
-	    if (p != NULL)
-	    {
-		if (len > 0)
-		{
-		    /* insert a space in between names */
-		    if (retval != NULL)
-			retval[len] = ' ';
-		    ++len;
-		}
-		for ( ; *p != NUL; ++p)
-		{
-		    if (*p == ' ' || *p == '\\')
-		    {
-			/* insert a backslash */
-			if (retval != NULL)
-			    retval[len] = '\\';
-			++len;
-		    }
-		    if (retval != NULL)
-			retval[len] = *p;
-		    ++len;
-		}
-	    }
-	}
-
-	/* second time: break here */
-	if (retval != NULL)
-	{
-	    retval[len] = NUL;
-	    break;
-	}
-
-	/* allocate memory */
-	retval = alloc(len + 1);
-	if (retval == NULL)
-	    break;
-    }
-
-    return retval;
-}
-
-#if defined(FEAT_AUTOCMD) || defined(PROTO)
-/*
- * Expand the <sfile> string in "arg".
- *
- * Returns an allocated string, or NULL for any error.
- */
-    char_u *
-expand_sfile(arg)
-    char_u	*arg;
-{
-    char_u	*errormsg;
-    int		len;
-    char_u	*result;
-    char_u	*newres;
-    char_u	*repl;
-    int		srclen;
-    char_u	*p;
-
-    result = vim_strsave(arg);
-    if (result == NULL)
-	return NULL;
-
-    for (p = result; *p; )
-    {
-	if (STRNCMP(p, "<sfile>", 7) != 0)
-	    ++p;
-	else
-	{
-	    /* replace "<sfile>" with the sourced file name, and do ":" stuff */
-	    repl = eval_vars(p, &srclen, NULL, &errormsg, result);
-	    if (errormsg != NULL)
-	    {
-		if (*errormsg)
-		    emsg(errormsg);
-		vim_free(result);
-		return NULL;
-	    }
-	    if (repl == NULL)		/* no match (cannot happen) */
-	    {
-		p += srclen;
-		continue;
-	    }
-	    len = (int)STRLEN(result) - srclen + (int)STRLEN(repl) + 1;
-	    newres = alloc(len);
-	    if (newres == NULL)
-	    {
-		vim_free(repl);
-		vim_free(result);
-		return NULL;
-	    }
-	    mch_memmove(newres, result, (size_t)(p - result));
-	    STRCPY(newres + (p - result), repl);
-	    len = (int)STRLEN(newres);
-	    STRCAT(newres, p + srclen);
-	    vim_free(repl);
-	    vim_free(result);
-	    result = newres;
-	    p = newres + len;		/* continue after the match */
-	}
-    }
-
-    return result;
-}
-#endif
-
-#ifdef FEAT_SESSION
-static int ses_winsizes __ARGS((FILE *fd, int restore_size));
-static int ses_win_rec __ARGS((FILE *fd, frame_T *fr));
-static frame_T *ses_skipframe __ARGS((frame_T *fr));
-static int ses_do_frame __ARGS((frame_T *fr));
-static int ses_do_win __ARGS((win_T *wp));
-static int ses_arglist __ARGS((FILE *fd, char *cmd, garray_T *gap, int fullname, unsigned *flagp));
-static int ses_put_fname __ARGS((FILE *fd, char_u *name, unsigned *flagp));
-static int ses_fname __ARGS((FILE *fd, buf_T *buf, unsigned *flagp));
-
-/*
- * Write openfile commands for the current buffers to an .exrc file.
- * Return FAIL on error, OK otherwise.
- */
-    static int
-makeopens(fd, dirnow)
-    FILE	*fd;
-    char_u	*dirnow;	/* Current directory name */
-{
-    buf_T	*buf;
-    int		only_save_windows = TRUE;
-    int		nr;
-    int		cnr = 1;
-    int		restore_size = TRUE;
-    win_T	*wp;
-    char_u	*sname;
-    win_T	*edited_win = NULL;
-
-    if (ssop_flags & SSOP_BUFFERS)
-	only_save_windows = FALSE;		/* Save ALL buffers */
-
-    /*
-     * Begin by setting the this_session variable, and then other
-     * sessionable variables.
-     */
-#ifdef FEAT_EVAL
-    if (put_line(fd, "let v:this_session=expand(\"<sfile>:p\")") == FAIL)
-	return FAIL;
-    if (ssop_flags & SSOP_GLOBALS)
-	if (store_session_globals(fd) == FAIL)
-	    return FAIL;
-#endif
-
-    /*
-     * Close all windows but one.
-     */
-    if (put_line(fd, "silent only") == FAIL)
-	return FAIL;
-
-    /*
-     * Now a :cd command to the session directory or the current directory
-     */
-    if (ssop_flags & SSOP_SESDIR)
-    {
-	if (put_line(fd, "exe \"cd \" . expand(\"<sfile>:p:h\")") == FAIL)
-	    return FAIL;
-    }
-    else if (ssop_flags & SSOP_CURDIR)
-    {
-	sname = home_replace_save(NULL, globaldir != NULL ? globaldir : dirnow);
-	if (sname == NULL
-		|| fprintf(fd, "cd %s", sname) < 0 || put_eol(fd) == FAIL)
-	    return FAIL;
-	vim_free(sname);
-    }
-
-    /*
-     * Now save the current files, current buffer first.
-     */
-    if (put_line(fd, "set shortmess=aoO") == FAIL)
-	return FAIL;
-
-    /* Now put the other buffers into the buffer list */
-    for (buf = firstbuf; buf != NULL; buf = buf->b_next)
-    {
-	if (!(only_save_windows && buf->b_nwindows == 0)
-		&& !(buf->b_help && !(ssop_flags & SSOP_HELP))
-		&& buf->b_fname != NULL
-		&& buf->b_p_bl)
-	{
-	    if (fprintf(fd, "badd +%ld ", buf->b_wininfo == NULL ? 1L
-					   : buf->b_wininfo->wi_fpos.lnum) < 0
-		    || ses_fname(fd, buf, &ssop_flags) == FAIL)
-		return FAIL;
-	}
-    }
-
-    /* the global argument list */
-    if (ses_arglist(fd, "args", &global_alist.al_ga,
-			    !(ssop_flags & SSOP_CURDIR), &ssop_flags) == FAIL)
-	return FAIL;
-
-    if (ssop_flags & SSOP_RESIZE)
-    {
-	/* Note: after the restore we still check it worked!*/
-	if (fprintf(fd, "set lines=%ld columns=%ld" , Rows, Columns) < 0
-		|| put_eol(fd) == FAIL)
-	    return FAIL;
-    }
-
-#ifdef FEAT_GUI
-    if (gui.in_use && (ssop_flags & SSOP_WINPOS))
-    {
-	int	x, y;
-
-	if (gui_mch_get_winpos(&x, &y) == OK)
-	{
-	    /* Note: after the restore we still check it worked!*/
-	    if (fprintf(fd, "winpos %d %d", x, y) < 0 || put_eol(fd) == FAIL)
-		return FAIL;
-	}
-    }
-#endif
-
-    /*
-     * Before creating the window layout, try loading one file.  If this is
-     * aborted we don't end up with a number of useless windows.
-     * This may have side effects! (e.g., compressed or network file).
-     */
-    for (wp = firstwin; wp != NULL; wp = wp->w_next)
-    {
-	if (ses_do_win(wp)
-		&& wp->w_buffer->b_ffname != NULL
-		&& !wp->w_buffer->b_help
-#ifdef FEAT_QUICKFIX
-		&& !bt_nofile(wp->w_buffer)
-#endif
-		)
-	{
-	    if (fputs("edit ", fd) < 0
-		    || ses_fname(fd, wp->w_buffer, &ssop_flags) == FAIL)
-		return FAIL;
-	    if (!wp->w_arg_idx_invalid)
-		edited_win = wp;
-	    break;
-	}
-    }
-
-    /*
-     * Save current window layout.
-     */
-    if (put_line(fd, "set splitbelow splitright") == FAIL)
-	return FAIL;
-    if (ses_win_rec(fd, topframe) == FAIL)
-	return FAIL;
-    if (!p_sb && put_line(fd, "set nosplitbelow") == FAIL)
-	return FAIL;
-    if (!p_spr && put_line(fd, "set nosplitright") == FAIL)
-	return FAIL;
-
-    /*
-     * Check if window sizes can be restored (no windows omitted).
-     * Remember the window number of the current window after restoring.
-     */
-    nr = 0;
-    for (wp = firstwin; wp != NULL; wp = W_NEXT(wp))
-    {
-	if (ses_do_win(wp))
-	    ++nr;
-	else
-	    restore_size = FALSE;
-	if (curwin == wp)
-	    cnr = nr;
-    }
-
-    /* Go to the first window. */
-    if (put_line(fd, "wincmd t") == FAIL)
-	return FAIL;
-
-    /*
-     * If more than one window, see if sizes can be restored.
-     * First set 'winheight' and 'winwidth' to 1 to avoid the windows being
-     * resized when moving between windows.
-     * Do this before restoring the view, so that the topline and the cursor
-     * can be set.  This is done again below.
-     */
-    if (put_line(fd, "set winheight=1 winwidth=1") == FAIL)
-	return FAIL;
-    if (nr > 1 && ses_winsizes(fd, restore_size) == FAIL)
-	return FAIL;
-
-    /*
-     * Restore the view of the window (options, file, cursor, etc.).
-     */
-    for (wp = firstwin; wp != NULL; wp = wp->w_next)
-    {
-	if (!ses_do_win(wp))
-	    continue;
-	if (put_view(fd, wp, wp != edited_win, &ssop_flags) == FAIL)
-	    return FAIL;
-	if (nr > 1 && put_line(fd, "wincmd w") == FAIL)
-	    return FAIL;
-    }
-
-    /*
-     * Restore cursor to the current window if it's not the first one.
-     */
-    if (cnr > 1 && (fprintf(fd, "%dwincmd w", cnr) < 0 || put_eol(fd) == FAIL))
-	return FAIL;
-
-    /*
-     * Restore window sizes again after jumping around in windows, because the
-     * current window has a minimum size while others may not.
-     */
-    if (nr > 1 && ses_winsizes(fd, restore_size) == FAIL)
-	return FAIL;
-
-    /* Re-apply 'winheight', 'winwidth' and 'shortmess'. */
-    if (fprintf(fd, "set winheight=%ld winwidth=%ld shortmess=%s",
-			       p_wh, p_wiw, p_shm) < 0 || put_eol(fd) == FAIL)
-	return FAIL;
-
-    /*
-     * Lastly, execute the x.vim file if it exists.
-     */
-    if (put_line(fd, "let s:sx = expand(\"<sfile>:p:r\").\"x.vim\"") == FAIL
-	    || put_line(fd, "if file_readable(s:sx)") == FAIL
-	    || put_line(fd, "  exe \"source \" . s:sx") == FAIL
-	    || put_line(fd, "endif") == FAIL)
-	return FAIL;
-
-    return OK;
-}
-
-    static int
-ses_winsizes(fd, restore_size)
-    FILE	*fd;
-    int		restore_size;
-{
-    int		n = 0;
-    win_T	*wp;
-
-    if (restore_size && (ssop_flags & SSOP_WINSIZE))
-    {
-	for (wp = firstwin; wp != NULL; wp = wp->w_next)
-	{
-	    if (!ses_do_win(wp))
-		continue;
-	    ++n;
-
-	    /* restore height when not full height */
-	    if (wp->w_height + wp->w_status_height < topframe->fr_height
-		    && (fprintf(fd,
-			  "exe '%dresize ' . ((&lines * %ld + %ld) / %ld)",
-			    n, (long)wp->w_height, Rows / 2, Rows) < 0
-						  || put_eol(fd) == FAIL))
-		return FAIL;
-
-	    /* restore width when not full width */
-	    if (wp->w_width < Columns && (fprintf(fd,
-		   "exe 'vert %dresize ' . ((&columns * %ld + %ld) / %ld)",
-			    n, (long)wp->w_width, Columns / 2, Columns) < 0
-						  || put_eol(fd) == FAIL))
-		return FAIL;
-	}
-    }
-    else
-    {
-	/* Just equalise window sizes */
-	if (put_line(fd, "wincmd =") == FAIL)
-	    return FAIL;
-    }
-    return OK;
-}
-
-/*
- * Write commands to "fd" to recursively create windows for frame "fr",
- * horizontally and vertically split.
- * After the commands the last window in the frame is the current window.
- * Returns FAIL when writing the commands to "fd" fails.
- */
-    static int
-ses_win_rec(fd, fr)
-    FILE	*fd;
-    frame_T	*fr;
-{
-    frame_T	*frc;
-    int		count = 0;
-
-    if (fr->fr_layout != FR_LEAF)
-    {
-	/* Find first frame that's not skipped and then create a window for
-	 * each following one (first frame is already there). */
-	frc = ses_skipframe(fr->fr_child);
-	if (frc != NULL)
-	    while ((frc = ses_skipframe(frc->fr_next)) != NULL)
-	    {
-		/* Make window as big as possible so that we have lots of room
-		 * to split. */
-		if (put_line(fd, "wincmd _ | wincmd |") == FAIL
-			|| put_line(fd, fr->fr_layout == FR_COL
-						? "split" : "vsplit") == FAIL)
-		    return FAIL;
-		++count;
-	    }
-
-	/* Go back to the first window. */
-	if (count > 0 && (fprintf(fd, fr->fr_layout == FR_COL
-			? "%dwincmd k" : "%dwincmd h", count) < 0
-						      || put_eol(fd) == FAIL))
-	    return FAIL;
-
-	/* Recursively create frames/windows in each window of this column or
-	 * row. */
-	frc = ses_skipframe(fr->fr_child);
-	while (frc != NULL)
-	{
-	    ses_win_rec(fd, frc);
-	    frc = ses_skipframe(frc->fr_next);
-	    /* Go to next window. */
-	    if (frc != NULL && put_line(fd, "wincmd w") == FAIL)
-		return FAIL;
-	}
-    }
-    return OK;
-}
-
-/*
- * Skip frames that don't contain windows we want to save in the Session.
- * Returns NULL when there none.
- */
-    static frame_T *
-ses_skipframe(fr)
-    frame_T	*fr;
-{
-    frame_T	*frc;
-
-    for (frc = fr; frc != NULL; frc = frc->fr_next)
-	if (ses_do_frame(frc))
-	    break;
-    return frc;
-}
-
-/*
- * Return TRUE if frame "fr" has a window somewhere that we want to save in
- * the Session.
- */
-    static int
-ses_do_frame(fr)
-    frame_T	*fr;
-{
-    frame_T	*frc;
-
-    if (fr->fr_layout == FR_LEAF)
-	return ses_do_win(fr->fr_win);
-    for (frc = fr->fr_child; frc != NULL; frc = frc->fr_next)
-	if (ses_do_frame(frc))
-	    return TRUE;
-    return FALSE;
-}
-
-/*
- * Return non-zero if window "wp" is to be stored in the Session.
- */
-    static int
-ses_do_win(wp)
-    win_T	*wp;
-{
-    if (wp->w_buffer->b_fname == NULL
-#ifdef FEAT_QUICKFIX
-	    /* When 'buftype' is "nofile" can't restore the window contents. */
-	    || bt_nofile(wp->w_buffer)
-#endif
-       )
-	return (ssop_flags & SSOP_BLANK);
-    if (wp->w_buffer->b_help)
-	return (ssop_flags & SSOP_HELP);
-    return TRUE;
-}
-
-/*
- * Write commands to "fd" to restore the view of a window.
- * Caller must make sure 'scrolloff' is zero.
- */
-    static int
-put_view(fd, wp, add_edit, flagp)
-    FILE	*fd;
-    win_T	*wp;
-    int		add_edit;	/* add ":edit" command to view */
-    unsigned	*flagp;		/* vop_flags or ssop_flags */
-{
-    win_T	*save_curwin;
-    int		f;
-    int		do_cursor;
-
-    /* Always restore cursor position for ":mksession".  For ":mkview" only
-     * when 'viewoptions' contains "cursor". */
-    do_cursor = (flagp == &ssop_flags || *flagp & SSOP_CURSOR);
-
-    /*
-     * Local argument list.
-     */
-    if (wp->w_alist == &global_alist)
-    {
-	if (put_line(fd, "argglobal") == FAIL)
-	    return FAIL;
-    }
-    else
-    {
-	if (ses_arglist(fd, "arglocal", &wp->w_alist->al_ga,
-			flagp == &vop_flags
-			|| !(*flagp & SSOP_CURDIR)
-			|| wp->w_localdir != NULL, flagp) == FAIL)
-	    return FAIL;
-    }
-
-    /* Only when part of a session: restore the argument index. */
-    if (wp->w_arg_idx != 0 && flagp == &ssop_flags)
-    {
-	if (fprintf(fd, "%ldnext", (long)wp->w_arg_idx) < 0
-		|| put_eol(fd) == FAIL)
-	    return FAIL;
-    }
-
-    /* Edit the file.  Skip this when ":next" already did it. */
-    if (add_edit && (wp->w_arg_idx == 0 || flagp != &ssop_flags
-						    || wp->w_arg_idx_invalid))
-    {
-	/*
-	 * Load the file.
-	 */
-	if (wp->w_buffer->b_ffname != NULL
-#ifdef FEAT_QUICKFIX
-		&& !bt_nofile(wp->w_buffer)
-#endif
-		)
-	{
-	    /*
-	     * Editing a file in this buffer: use ":edit file".
-	     * This may have side effects! (e.g., compressed or network file).
-	     */
-	    if (fputs("edit ", fd) < 0
-		    || ses_fname(fd, wp->w_buffer, flagp) == FAIL)
-		return FAIL;
-	}
-	else
-	{
-	    /* No file in this buffer, just make it empty. */
-	    if (put_line(fd, "enew") == FAIL)
-		return FAIL;
-#ifdef FEAT_QUICKFIX
-	    if (wp->w_buffer->b_ffname != NULL)
-	    {
-		/* The buffer does have a name, but it's not a file name. */
-		if (fputs("file ", fd) < 0
-			|| ses_fname(fd, wp->w_buffer, flagp) == FAIL)
-		    return FAIL;
-	    }
-#endif
-	    do_cursor = FALSE;
-	}
-    }
-
-    /*
-     * Local mappings and abbreviations.
-     */
-    if ((*flagp & (SSOP_OPTIONS | SSOP_LOCALOPTIONS))
-					 && makemap(fd, wp->w_buffer) == FAIL)
-	return FAIL;
-
-    /*
-     * Local options.  Need to go to the window temporarily.
-     * Store only local values when using ":mkview" and when ":mksession" is
-     * used and 'sessionoptions' doesn't include "options".
-     * Some folding options are always stored when "folds" is included,
-     * otherwise the folds would not be restored correctly.
-     */
-    save_curwin = curwin;
-    curwin = wp;
-    curbuf = curwin->w_buffer;
-    if (*flagp & (SSOP_OPTIONS | SSOP_LOCALOPTIONS))
-	f = makeset(fd, OPT_LOCAL,
-			     flagp == &vop_flags || !(*flagp & SSOP_OPTIONS));
-#ifdef FEAT_FOLDING
-    else if (*flagp & SSOP_FOLDS)
-	f = makefoldset(fd);
-#endif
-    else
-	f = OK;
-    curwin = save_curwin;
-    curbuf = curwin->w_buffer;
-    if (f == FAIL)
-	return FAIL;
-
-#ifdef FEAT_FOLDING
-    /*
-     * Save Folds when 'buftype' is empty and for help files.
-     */
-    if ((*flagp & SSOP_FOLDS)
-	    && wp->w_buffer->b_ffname != NULL
-	    && (*wp->w_buffer->b_p_bt == NUL || wp->w_buffer->b_help))
-    {
-	if (put_folds(fd, wp) == FAIL)
-	    return FAIL;
-    }
-#endif
-
-    /*
-     * Set the cursor after creating folds, since that moves the cursor.
-     */
-    if (do_cursor)
-    {
-
-	/* Restore the cursor line in the file and relatively in the
-	 * window.  Don't use "G", it changes the jumplist. */
-	if (fprintf(fd, "let s:l = %ld - ((%ld * winheight(0) + %ld) / %ld)",
-		    (long)wp->w_cursor.lnum,
-		    (long)(wp->w_cursor.lnum - wp->w_topline),
-		    (long)wp->w_height / 2, (long)wp->w_height) < 0
-		|| put_eol(fd) == FAIL
-		|| put_line(fd, "if s:l < 1 | let s:l = 1 | endif") == FAIL
-		|| put_line(fd, "exe s:l") == FAIL
-		|| put_line(fd, "normal! zt") == FAIL
-		|| fprintf(fd, "%ld", (long)wp->w_cursor.lnum) < 0
-		|| put_eol(fd) == FAIL)
-	    return FAIL;
-	/* Restore the cursor column and left offset when not wrapping. */
-	if (wp->w_cursor.col == 0)
-	{
-	    if (put_line(fd, "normal! 0") == FAIL)
-		return FAIL;
-	}
-	else
-	{
-	    if (!wp->w_p_wrap && wp->w_leftcol > 0 && wp->w_width > 0)
-	    {
-		if (fprintf(fd,
-			  "let s:c = %ld - ((%ld * winwidth(0) + %ld) / %ld)",
-			    (long)wp->w_cursor.col,
-			    (long)(wp->w_cursor.col - wp->w_leftcol),
-			    (long)wp->w_width / 2, (long)wp->w_width) < 0
-			|| put_eol(fd) == FAIL
-			|| put_line(fd, "if s:c > 0") == FAIL
-			|| fprintf(fd,
-			    "  exe 'normal! 0' . s:c . 'lzs' . (%ld - s:c) . 'l'",
-			    (long)wp->w_cursor.col) < 0
-			|| put_eol(fd) == FAIL
-			|| put_line(fd, "else") == FAIL
-			|| fprintf(fd, "  normal! 0%dl", wp->w_cursor.col) < 0
-			|| put_eol(fd) == FAIL
-			|| put_line(fd, "endif") == FAIL)
-		    return FAIL;
-	    }
-	    else
-	    {
-		if (fprintf(fd, "normal! 0%dl", wp->w_cursor.col) < 0
-			|| put_eol(fd) == FAIL)
-		    return FAIL;
-	    }
-	}
-    }
-
-    /*
-     * Local directory.
-     */
-    if (wp->w_localdir != NULL)
-    {
-	if (fputs("lcd ", fd) < 0
-		|| ses_put_fname(fd, wp->w_localdir, flagp) == FAIL
-		|| put_eol(fd) == FAIL)
-	    return FAIL;
-    }
-
-    return OK;
-}
-
-/*
- * Write an argument list to the session file.
- * Returns FAIL if writing fails.
- */
-    static int
-ses_arglist(fd, cmd, gap, fullname, flagp)
-    FILE	*fd;
-    char	*cmd;
-    garray_T	*gap;
-    int		fullname;	/* TRUE: use full path name */
-    unsigned	*flagp;
-{
-    int		i;
-    char_u	buf[MAXPATHL];
-    char_u	*s;
-
-    if (gap->ga_len == 0)
-	return put_line(fd, "silent! argdel *");
-    if (fputs(cmd, fd) < 0)
-	return FAIL;
-    for (i = 0; i < gap->ga_len; ++i)
-    {
-	/* NULL file names are skipped (only happens when out of memory). */
-	s = alist_name(&((aentry_T *)gap->ga_data)[i]);
-	if (s != NULL)
-	{
-	    if (fullname)
-	    {
-		(void)vim_FullName(s, buf, MAXPATHL, FALSE);
-		s = buf;
-	    }
-	    if (fputs(" ", fd) < 0 || ses_put_fname(fd, s, flagp) == FAIL)
-		return FAIL;
-	}
-    }
-    return put_eol(fd);
-}
-
-/*
- * Write a buffer name to the session file.
- * Also ends the line.
- * Returns FAIL if writing fails.
- */
-    static int
-ses_fname(fd, buf, flagp)
-    FILE	*fd;
-    buf_T	*buf;
-    unsigned	*flagp;
-{
-    char_u	*name;
-
-    /* Use the short file name if the current directory is known at the time
-     * the session file will be sourced.  Don't do this for ":mkview", we
-     * don't know the current directory. */
-    if (buf->b_sfname != NULL
-	    && flagp == &ssop_flags
-	    && (ssop_flags & (SSOP_CURDIR | SSOP_SESDIR)))
-	name = buf->b_sfname;
-    else
-	name = buf->b_ffname;
-    if (ses_put_fname(fd, name, flagp) == FAIL || put_eol(fd) == FAIL)
-	return FAIL;
-    return OK;
-}
-
-/*
- * Write a file name to the session file.
- * Takes care of the "slash" option in 'sessionoptions' and escapes special
- * characters.
- * Returns FAIL if writing fails.
- */
-    static int
-ses_put_fname(fd, name, flagp)
-    FILE	*fd;
-    char_u	*name;
-    unsigned	*flagp;
-{
-    char_u	*sname;
-    int		retval = OK;
-    int		c;
-
-    sname = home_replace_save(NULL, name);
-    if (sname != NULL)
-	name = sname;
-    while (*name != NUL)
-    {
-#ifdef FEAT_MBYTE
-	{
-	    int l;
-
-	    if (has_mbyte && (l = (*mb_ptr2len_check)(name)) > 1)
-	    {
-		/* copy a multibyte char */
-		while (--l >= 0)
-		{
-		    if (putc(*name, fd) != *name)
-			retval = FAIL;
-		    ++name;
-		}
-		continue;
-	    }
-	}
-#endif
-	c = *name++;
-	if (c == '\\' && (*flagp & SSOP_SLASH))
-	    /* change a backslash to a forward slash */
-	    c = '/';
-	else if ((vim_strchr(escape_chars, c) != NULL
-#ifdef BACKSLASH_IN_FILENAME
-		    && c != '\\'
-#endif
-		 ) || c == '#' || c == '%')
-	{
-	    /* escape a special character with a backslash */
-	    if (putc('\\', fd) != '\\')
-		retval = FAIL;
-	}
-	if (putc(c, fd) != c)
-	    retval = FAIL;
-    }
-    vim_free(sname);
-    return retval;
-}
-
-/*
- * ":loadview [nr]"
- */
-    static void
-ex_loadview(eap)
-    exarg_T	*eap;
-{
-    char_u	*fname;
-
-    fname = get_view_file(*eap->arg);
-    if (fname != NULL)
-    {
-	do_source(fname, FALSE, FALSE);
-	vim_free(fname);
-    }
-}
-
-/*
- * Get the name of the view file for the current buffer.
- */
-    static char_u *
-get_view_file(c)
-    int		c;
-{
-    int		len = 0;
-    char_u	*p, *s;
-    char_u	*retval;
-    char_u	*sname;
-
-    if (curbuf->b_ffname == NULL)
-    {
-	EMSG(_(e_noname));
-	return NULL;
-    }
-    sname = home_replace_save(NULL, curbuf->b_ffname);
-    if (sname == NULL)
-	return NULL;
-
-    /*
-     * We want a file name without separators, because we're not going to make
-     * a directory.
-     * "normal" path separator	-> "=+"
-     * "="			-> "=="
-     * ":" path separator	-> "=-"
-     */
-    for (p = sname; *p; ++p)
-	if (*p == '=' || vim_ispathsep(*p))
-	    ++len;
-    retval = alloc((unsigned)(STRLEN(sname) + len + STRLEN(p_vdir) + 9));
-    if (retval != NULL)
-    {
-	STRCPY(retval, p_vdir);
-	add_pathsep(retval);
-	s = retval + STRLEN(retval);
-	for (p = sname; *p; ++p)
-	{
-	    if (*p == '=')
-	    {
-		*s++ = '=';
-		*s++ = '=';
-	    }
-	    else if (vim_ispathsep(*p))
-	    {
-		*s++ = '=';
-#ifdef MACOS_CLASSIC /* TODO: Is it also needed for MACOS_X? (Dany) */
-		*s++ = '+';
-#else
-# if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA) || defined(RISCOS) \
-	|| defined(VMS)
-		if (*p == ':')
-		    *s++ = '-';
-		else
-# endif
-		    *s++ = '+';
-#endif
-	    }
-	    else
-		*s++ = *p;
-	}
-	*s++ = '=';
-	*s++ = c;
-	STRCPY(s, ".vim");
-    }
-
-    vim_free(sname);
-    return retval;
-}
-
-#endif /* FEAT_SESSION */
-
-/*
- * Write end-of-line character(s) for ":mkexrc", ":mkvimrc" and ":mksession".
- * Return FAIL for a write error.
- */
-    int
-put_eol(fd)
-    FILE	*fd;
-{
-    if (
-#ifdef USE_CRNL
-	    (
-# ifdef MKSESSION_NL
-	     !mksession_nl &&
-# endif
-	     (putc('\r', fd) < 0)) ||
-#endif
-	    (putc('\n', fd) < 0))
-	return FAIL;
-    return OK;
-}
-
-/*
- * Write a line to "fd".
- * Return FAIL for a write error.
- */
-    int
-put_line(fd, s)
-    FILE	*fd;
-    char	*s;
-{
-    if (fputs(s, fd) < 0 || put_eol(fd) == FAIL)
-	return FAIL;
-    return OK;
-}
-
-#ifdef FEAT_VIMINFO
-/*
- * ":rviminfo" and ":wviminfo".
- */
-    static void
-ex_viminfo(eap)
-    exarg_T	*eap;
-{
-    char_u	*save_viminfo;
-
-    save_viminfo = p_viminfo;
-    if (*p_viminfo == NUL)
-	p_viminfo = (char_u *)"'100";
-    if (eap->cmdidx == CMD_rviminfo)
-    {
-	if (read_viminfo(eap->arg, TRUE, TRUE, eap->forceit) == FAIL)
-	    EMSG(_("E195: Cannot open viminfo file for reading"));
-    }
-    else
-	write_viminfo(eap->arg, eap->forceit);
-    p_viminfo = save_viminfo;
-}
-#endif
-
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) || defined(PROTO)
-    void
-dialog_msg(buff, format, fname)
-    char_u	*buff;
-    char	*format;
-    char_u	*fname;
-{
-    int		len;
-
-    if (fname == NULL)
-	fname = (char_u *)_("Untitled");
-    len = (int)STRLEN(format) + (int)STRLEN(fname);
-    if (len >= IOSIZE)
-	sprintf((char *)buff, format, (int)(IOSIZE - STRLEN(format)), fname);
-    else
-	sprintf((char *)buff, format, (int)STRLEN(fname), fname);
-}
-#endif
-
-/*
- * ":behave {mswin,xterm}"
- */
-    static void
-ex_behave(eap)
-    exarg_T	*eap;
-{
-    if (STRCMP(eap->arg, "mswin") == 0)
-    {
-	set_option_value((char_u *)"selection", 0L, (char_u *)"exclusive", 0);
-	set_option_value((char_u *)"selectmode", 0L, (char_u *)"mouse,key", 0);
-	set_option_value((char_u *)"mousemodel", 0L, (char_u *)"popup", 0);
-	set_option_value((char_u *)"keymodel", 0L,
-					     (char_u *)"startsel,stopsel", 0);
-    }
-    else if (STRCMP(eap->arg, "xterm") == 0)
-    {
-	set_option_value((char_u *)"selection", 0L, (char_u *)"inclusive", 0);
-	set_option_value((char_u *)"selectmode", 0L, (char_u *)"", 0);
-	set_option_value((char_u *)"mousemodel", 0L, (char_u *)"extend", 0);
-	set_option_value((char_u *)"keymodel", 0L, (char_u *)"", 0);
-    }
-    else
-	EMSG2(_(e_invarg2), eap->arg);
-}
-
-#ifdef FEAT_AUTOCMD
-static int filetype_detect = FALSE;
-static int filetype_plugin = FALSE;
-static int filetype_indent = FALSE;
-
-/*
- * ":filetype [plugin] [indent] {on,off,detect}"
- * on: Load the filetype.vim file to install autocommands for file types.
- * off: Load the ftoff.vim file to remove all autocommands for file types.
- * plugin on: load filetype.vim and ftplugin.vim
- * plugin off: load ftplugof.vim
- * indent on: load filetype.vim and indent.vim
- * indent off: load indoff.vim
- */
-    static void
-ex_filetype(eap)
-    exarg_T	*eap;
-{
-    char_u	*arg = eap->arg;
-    int		plugin = FALSE;
-    int		indent = FALSE;
-
-    if (*eap->arg == NUL)
-    {
-	/* Print current status. */
-	smsg((char_u *)"filetype detection:%s  plugin:%s  indent:%s",
-		filetype_detect ? "ON" : "OFF",
-		filetype_plugin ? (filetype_detect ? "ON" : "(on)") : "OFF",
-		filetype_indent ? (filetype_detect ? "ON" : "(on)") : "OFF");
-	return;
-    }
-
-    /* Accept "plugin" and "indent" in any order. */
-    for (;;)
-    {
-	if (STRNCMP(arg, "plugin", 6) == 0)
-	{
-	    plugin = TRUE;
-	    arg = skipwhite(arg + 6);
-	    continue;
-	}
-	if (STRNCMP(arg, "indent", 6) == 0)
-	{
-	    indent = TRUE;
-	    arg = skipwhite(arg + 6);
-	    continue;
-	}
-	break;
-    }
-    if (STRCMP(arg, "on") == 0 || STRCMP(arg, "detect") == 0)
-    {
-	if (*arg == 'o' || !filetype_detect)
-	{
-	    cmd_runtime((char_u *)FILETYPE_FILE, TRUE);
-	    filetype_detect = TRUE;
-	    if (plugin)
-	    {
-		cmd_runtime((char_u *)FTPLUGIN_FILE, TRUE);
-		filetype_plugin = TRUE;
-	    }
-	    if (indent)
-	    {
-		cmd_runtime((char_u *)INDENT_FILE, TRUE);
-		filetype_indent = TRUE;
-	    }
-	}
-	if (*arg == 'd')
-	{
-	    (void)do_doautocmd((char_u *)"filetypedetect BufRead", TRUE);
-	    do_modelines();
-	}
-    }
-    else if (STRCMP(arg, "off") == 0)
-    {
-	if (plugin || indent)
-	{
-	    if (plugin)
-	    {
-		cmd_runtime((char_u *)FTPLUGOF_FILE, TRUE);
-		filetype_plugin = FALSE;
-	    }
-	    if (indent)
-	    {
-		cmd_runtime((char_u *)INDOFF_FILE, TRUE);
-		filetype_indent = FALSE;
-	    }
-	}
-	else
-	{
-	    cmd_runtime((char_u *)FTOFF_FILE, TRUE);
-	    filetype_detect = FALSE;
-	}
-    }
-    else
-	EMSG2(_(e_invarg2), arg);
-}
-
-/*
- * ":setfiletype {name}"
- */
-    static void
-ex_setfiletype(eap)
-    exarg_T	*eap;
-{
-    if (!did_filetype)
-	set_option_value((char_u *)"filetype", 0L, eap->arg, OPT_LOCAL);
-}
-#endif
-
-/*ARGSUSED*/
-    static void
-ex_digraphs(eap)
-    exarg_T	*eap;
-{
-#ifdef FEAT_DIGRAPHS
-    if (*eap->arg != NUL)
-	putdigraph(eap->arg);
-    else
-	listdigraphs();
-#else
-    EMSG(_("E196: No digraphs in this version"));
-#endif
-}
-
-    static void
-ex_set(eap)
-    exarg_T	*eap;
-{
-    int		flags = 0;
-
-    if (eap->cmdidx == CMD_setlocal)
-	flags = OPT_LOCAL;
-    else if (eap->cmdidx == CMD_setglobal)
-	flags = OPT_GLOBAL;
-#if defined(FEAT_EVAL) && defined(FEAT_AUTOCMD) && defined(FEAT_BROWSE)
-    if (cmdmod.browse && flags == 0)
-	ex_options(eap);
-    else
-#endif
-	(void)do_set(eap->arg, flags);
-}
-
-#ifdef FEAT_SEARCH_EXTRA
-/*
- * ":nohlsearch"
- */
-/*ARGSUSED*/
-    static void
-ex_nohlsearch(eap)
-    exarg_T	*eap;
-{
-    no_hlsearch = TRUE;
-    redraw_all_later(NOT_VALID);
-}
-
-/*
- * ":match {group} {pattern}"
- * Sets nextcmd to the start of the next command, if any.  Also called when
- * skipping commands to find the next command.
- */
-    static void
-ex_match(eap)
-    exarg_T	*eap;
-{
-    char_u	*p;
-    char_u	*end;
-    int		c;
-
-    /* First clear any old pattern. */
-    if (!eap->skip)
-    {
-	vim_free(curwin->w_match.regprog);
-	curwin->w_match.regprog = NULL;
-	redraw_later(NOT_VALID);	/* always need a redraw */
-    }
-
-    if (ends_excmd(*eap->arg))
-	end = eap->arg;
-    else if ((STRNICMP(eap->arg, "none", 4) == 0
-		&& (vim_iswhite(eap->arg[4]) || ends_excmd(eap->arg[4]))))
-	end = eap->arg + 4;
-    else
-    {
-	p = skiptowhite(eap->arg);
-	if (!eap->skip)
-	{
-	    curwin->w_match_id = syn_namen2id(eap->arg, (int)(p - eap->arg));
-	    if (curwin->w_match_id == 0)
-	    {
-		EMSG2(_(e_nogroup), eap->arg);
-		return;
-	    }
-	}
-	p = skipwhite(p);
-	if (*p == NUL)
-	{
-	    /* There must be two arguments. */
-	    EMSG2(_(e_invarg2), eap->arg);
-	    return;
-	}
-	end = skip_regexp(p + 1, *p, TRUE, NULL);
-	if (!eap->skip)
-	{
-	    if (*end != NUL && !ends_excmd(*skipwhite(end + 1)))
-	    {
-		eap->errmsg = e_trailing;
-		return;
-	    }
-
-	    c = *end;
-	    *end = NUL;
-	    curwin->w_match.regprog = vim_regcomp(p + 1, RE_MAGIC);
-	    *end = c;
-	    if (curwin->w_match.regprog == NULL)
-	    {
-		EMSG2(_(e_invarg2), p);
-		return;
-	    }
-	}
-    }
-    eap->nextcmd = find_nextcmd(end);
-}
-#endif
-
-#ifdef FEAT_CRYPT
-/*
- * ":X": Get crypt key
- */
-/*ARGSUSED*/
-    static void
-ex_X(eap)
-    exarg_T	*eap;
-{
-    (void)get_crypt_key(TRUE, TRUE);
-}
-#endif
-
-#ifdef FEAT_FOLDING
-    static void
-ex_fold(eap)
-    exarg_T	*eap;
-{
-    if (foldManualAllowed(TRUE))
-	foldCreate(eap->line1, eap->line2);
-}
-
-    static void
-ex_foldopen(eap)
-    exarg_T	*eap;
-{
-    opFoldRange(eap->line1, eap->line2, eap->cmdidx == CMD_foldopen,
-							 eap->forceit, FALSE);
-}
-
-    static void
-ex_folddo(eap)
-    exarg_T	*eap;
-{
-    linenr_T	lnum;
-
-    /* First set the marks for all lines closed/open. */
-    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)
-	if (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed))
-	    ml_setmarked(lnum);
-
-    /* Execute the command on the marked lines. */
-    global_exe(eap->arg);
-    ml_clearmarked();	   /* clear rest of the marks */
-}
-#endif
diff -Nur vim63/src/fileio.c vim63-bonobo/src/fileio.c
--- vim63/src/fileio.c	2005-09-09 20:11:10.108827000 +0200
+++ vim63-bonobo/src/fileio.c	2005-09-09 20:18:45.327623872 +0200
@@ -41,6 +41,10 @@
 # define CRYPT_MAGIC_LEN	12		/* must be multiple of 4! */
 #endif
 
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME) 
+#include "vim_bonobo_control.h"
+#endif
+
 /* Is there any system that doesn't have access()? */
 #ifndef MACOS_CLASSIC /* Not available on MacOS 9 */
 # define USE_MCH_ACCESS
@@ -202,6 +206,7 @@
  * READ_BUFFER	read from curbuf instead of a file (converting after reading
  *		stdin)
  * READ_DUMMY	read into a dummy buffer (to check if file contents changed)
+ * READ_EMB_STREAM read from a bonobo persist stream
  *
  * return FAIL for failure, OK otherwise
  */
@@ -221,6 +226,11 @@
     int		filtering = (flags & READ_FILTER);
     int		read_stdin = (flags & READ_STDIN);
     int		read_buffer = (flags & READ_BUFFER);
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+    int		read_pstream = (flags & READ_EMB_STREAM);
+#else
+#define read_pstream 0
+#endif
     linenr_T	read_buf_lnum = 1;	/* next line to read from curbuf */
     colnr_T	read_buf_col = 0;	/* next char to read from this line */
     char_u	c;
@@ -327,7 +337,7 @@
      * The BufReadCmd and FileReadCmd events intercept the reading process by
      * executing the associated commands instead.
      */
-    if (!filtering && !read_stdin && !read_buffer)
+    if (!filtering && !read_stdin && !read_buffer && !read_pstream)
     {
 	pos_T	    pos;
 
@@ -392,7 +402,7 @@
      * On Unix it is possible to read a directory, so we have to
      * check for it before the mch_open().
      */
-    if (!read_stdin && !read_buffer)
+    if (!read_stdin && !read_buffer && !read_pstream)
     {
 	perm = mch_getperm(fname);
 	if (perm >= 0 && !S_ISREG(perm)		    /* not a regular file ... */
@@ -443,7 +453,7 @@
     if (check_readonly && !readonlymode)    /* default: set file not readonly */
 	curbuf->b_p_ro = FALSE;
 
-    if (newfile && !read_stdin && !read_buffer)
+    if (newfile && !read_stdin && !read_buffer && !read_pstream)
     {
 	/* Remember time of file.
 	 * For RISCOS, also remember the filetype.
@@ -509,6 +519,11 @@
 	setmode(0, O_BINARY);
 #endif
     }
+#ifdef FEAT_GUI_COMPONENT
+    else if (read_pstream)
+    {
+    }
+#endif
     else if (!read_buffer)
     {
 #ifdef USE_MCH_ACCESS
@@ -643,7 +658,7 @@
     /* If "Quit" selected at ATTENTION dialog, don't load the file */
     if (swap_exists_action == SEA_QUIT)
     {
-	if (!read_buffer && !read_stdin)
+	if (!read_buffer && !read_stdin && !read_pstream)
 	    close(fd);
 	return FAIL;
     }
@@ -668,7 +683,7 @@
 	 * The file must be closed again, the autocommands may want to change
 	 * the file before reading it.
 	 */
-	if (!read_stdin)
+	if (!read_stdin && !read_pstream)
 	    close(fd);		/* ignore errors */
 
 	/*
@@ -705,7 +720,7 @@
 	 * Don't allow the autocommands to change the current buffer.
 	 * Try to re-open the file.
 	 */
-	if (!read_stdin && (curbuf != old_curbuf
+	if (!read_stdin && !read_pstream && (curbuf != old_curbuf
 		|| (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) < 0))
 	{
 	    --no_wait_return;
@@ -745,7 +760,7 @@
 	    }
 #endif
 	}
-	else if (!read_buffer)
+	else if (!read_buffer && !read_pstream)
 	    filemess(curbuf, sfname, (char_u *)"", 0);
     }
 
@@ -850,7 +865,7 @@
 	    read_buf_lnum = 1;
 	    read_buf_col = 0;
 	}
-	else if (read_stdin || lseek(fd, (off_t)0L, SEEK_SET) != 0)
+	else if (read_stdin || read_pstream || lseek(fd, (off_t)0L, SEEK_SET) != 0)
 	{
 	    /* Can't rewind the file, give up. */
 	    error = TRUE;
@@ -996,7 +1011,7 @@
 	 * Use the 'charconvert' expression when conversion is required
 	 * and we can't do it internally or with iconv().
 	 */
-	if (fio_flags == 0 && !read_stdin && !read_buffer && *p_ccv != NUL
+	if (fio_flags == 0 && !read_stdin && !read_buffer && !read_pstream && *p_ccv != NUL
 #  ifdef USE_ICONV
 						    && iconv_fd == (iconv_t)-1
 #  endif
@@ -1045,7 +1060,7 @@
     /* Set can_retry when it's possible to rewind the file and try with
      * another "fenc" value.  It's FALSE when no other "fenc" to try, reading
      * stdin or "fenc" was specified with "++enc=". */
-    can_retry = (*fenc != NUL && !read_stdin
+    can_retry = (*fenc != NUL && !read_stdin && !read_pstream
 				     && (eap == NULL || eap->force_enc == 0));
 #endif
 
@@ -1214,6 +1229,11 @@
 			}
 		    }
 		}
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME) 
+                else if( read_pstream ) {
+                    size = vim_control_persist_stream_read(ptr, size);   
+                }
+#endif
 		else
 		{
 		    /*
@@ -1927,7 +1947,7 @@
 			    else if (ff_error != EOL_DOS)
 			    {
 				if (   try_unix
-				    && !read_stdin
+				    && !read_stdin && !read_pstream
 				    && (read_buffer
 					|| lseek(fd, (off_t)0L, SEEK_SET) == 0))
 				{
@@ -2016,7 +2036,7 @@
 # endif
 #endif
 
-    if (!read_buffer && !read_stdin)
+    if (!read_buffer && !read_stdin && !read_pstream)
 	close(fd);				/* errors are ignored */
     vim_free(buffer);
 
@@ -2205,7 +2225,7 @@
 #ifdef ALWAYS_USE_GUI
 	    /* Don't show the message when reading stdin, it would end up in a
 	     * message box (which might be shown when exiting!) */
-	    if (read_stdin || read_buffer)
+	    if (read_stdin || read_buffer )
 		p = msg_may_trunc(FALSE, IObuff);
 	    else
 #endif
@@ -2271,7 +2291,7 @@
      */
     write_no_eol_lnum = read_no_eol_lnum;
 
-    if (!read_stdin && !read_buffer)
+    if (!read_stdin && !read_buffer && !read_pstream)
     {
 	int m = msg_scroll;
 	int n = msg_scrolled;
@@ -2608,6 +2628,11 @@
     int		    prev_got_int = got_int;
     int		    file_readonly = FALSE;  /* overwritten file is read-only */
     static char	    *err_readonly = "is read-only (cannot override: \"W\" in 'cpoptions')";
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+    int		    write_pstream = write_to_container;
+#else
+#define write_pstream 0
+#endif
 #if defined(UNIX) || defined(__EMX__XX)	    /*XXX fix me sometime? */
     int		    made_writable = FALSE;  /* 'w' bit has been set */
 #endif
@@ -2984,7 +3009,7 @@
     }
 #endif /* !UNIX */
 
-    if (!device && !newfile)
+    if (!device && !newfile && !write_pstream )
     {
 	/*
 	 * Check if the file is really writable (when renaming the file to
@@ -3043,6 +3068,10 @@
     if (dobackup && *p_bsk != NUL && match_file_list(p_bsk, sfname, ffname))
 	dobackup = FALSE;
 #endif
+#ifdef FEAT_GUI_COMPONENT
+    if( write_pstream )
+        dobackup = FALSE;
+#endif
 
     /*
      * Save the value of got_int and reset it.  We don't want a previous
@@ -3695,95 +3724,97 @@
      * (this may happen when the user reached his quotum for number of files).
      * Appending will fail if the file does not exist and forceit is FALSE.
      */
-    while ((fd = mch_open((char *)wfname, O_WRONLY | O_EXTRA | (append
-			? (forceit ? (O_APPEND | O_CREAT) : O_APPEND)
-			: (O_CREAT | O_TRUNC))
-			, perm < 0 ? 0666 : (perm & 0777))) < 0)
-    {
-	/*
-	 * A forced write will try to create a new file if the old one is
-	 * still readonly. This may also happen when the directory is
-	 * read-only. In that case the mch_remove() will fail.
-	 */
-	if (errmsg == NULL)
+    if (!write_pstream) {
+	while ((fd = mch_open((char *)wfname, O_WRONLY | O_EXTRA | (append
+			    ? (forceit ? (O_APPEND | O_CREAT) : O_APPEND)
+			    : (O_CREAT | O_TRUNC))
+			    , perm < 0 ? 0666 : (perm & 0777))) < 0)
 	{
+	    /*
+	     * A forced write will try to create a new file if the old one is
+	     * still readonly. This may also happen when the directory is
+	     * read-only. In that case the mch_remove() will fail.
+	     */
+	    if (errmsg == NULL)
+	    {
 #ifdef UNIX
-	    struct stat	st;
+		struct stat	st;
 
-	    /* Don't delete the file when it's a hard or symbolic link. */
-	    if ((!newfile && st_old.st_nlink > 1)
-		    || (mch_lstat((char *)fname, &st) == 0
-			&& (st.st_dev != st_old.st_dev
-			    || st.st_ino != st_old.st_ino)))
-		errmsg = (char_u *)_("E166: Can't open linked file for writing");
-	    else
+		/* Don't delete the file when it's a hard or symbolic link. */
+		if ((!newfile && st_old.st_nlink > 1)
+			|| (mch_lstat((char *)fname, &st) == 0
+			    && (st.st_dev != st_old.st_dev
+				|| st.st_ino != st_old.st_ino)))
+		    errmsg = (char_u *)_("E166: Can't open linked file for writing");
+		else
 #endif
-	    {
-		errmsg = (char_u *)_("E212: Can't open file for writing");
-		if (forceit && vim_strchr(p_cpo, CPO_FWRITE) == NULL
-								 && perm >= 0)
 		{
+		    errmsg = (char_u *)_("E212: Can't open file for writing");
+		    if (forceit && vim_strchr(p_cpo, CPO_FWRITE) == NULL
+								     && perm >= 0)
+		    {
 #ifdef UNIX
-		    /* we write to the file, thus it should be marked
-		       writable after all */
-		    if (!(perm & 0200))
-			made_writable = TRUE;
-		    perm |= 0200;
-		    if (st_old.st_uid != getuid() || st_old.st_gid != getgid())
-			perm &= 0777;
+			/* we write to the file, thus it should be marked
+			   writable after all */
+			if (!(perm & 0200))
+			    made_writable = TRUE;
+			perm |= 0200;
+			if (st_old.st_uid != getuid() || st_old.st_gid != getgid())
+			    perm &= 0777;
 #endif
-		    if (!append)	    /* don't remove when appending */
-			mch_remove(wfname);
-		    continue;
+			if (!append)	    /* don't remove when appending */
+			    mch_remove(wfname);
+			continue;
+		    }
 		}
 	    }
-	}
-
-restore_backup:
-	{
-	    struct stat st;
 
-	    /*
-	     * If we failed to open the file, we don't need a backup. Throw it
-	     * away.  If we moved or removed the original file try to put the
-	     * backup in its place.
-	     */
-	    if (backup != NULL && wfname == fname)
+    restore_backup:
 	    {
-		if (backup_copy)
+		struct stat st;
+
+		/*
+		 * If we failed to open the file, we don't need a backup. Throw it
+		 * away.  If we moved or removed the original file try to put the
+		 * backup in its place.
+		 */
+		if (backup != NULL && wfname == fname)
 		{
-		    /*
-		     * There is a small chance that we removed the original,
-		     * try to move the copy in its place.
-		     * This may not work if the vim_rename() fails.
-		     * In that case we leave the copy around.
-		     */
-		    /* If file does not exist, put the copy in its place */
-		    if (mch_stat((char *)fname, &st) < 0)
+		    if (backup_copy)
+		    {
+			/*
+			 * There is a small chance that we removed the original,
+			 * try to move the copy in its place.
+			 * This may not work if the vim_rename() fails.
+			 * In that case we leave the copy around.
+			 */
+			/* If file does not exist, put the copy in its place */
+			if (mch_stat((char *)fname, &st) < 0)
+			    vim_rename(backup, fname);
+			/* if original file does exist throw away the copy */
+			if (mch_stat((char *)fname, &st) >= 0)
+			    mch_remove(backup);
+		    }
+		    else
+		    {
+			/* try to put the original file back */
 			vim_rename(backup, fname);
-		    /* if original file does exist throw away the copy */
-		    if (mch_stat((char *)fname, &st) >= 0)
-			mch_remove(backup);
-		}
-		else
-		{
-		    /* try to put the original file back */
-		    vim_rename(backup, fname);
+		    }
 		}
-	    }
 
-	    /* if original file no longer exists give an extra warning */
-	    if (!newfile && mch_stat((char *)fname, &st) < 0)
-		end = 0;
-	}
+		/* if original file no longer exists give an extra warning */
+		if (!newfile && mch_stat((char *)fname, &st) < 0)
+		    end = 0;
+	    }
 
 #ifdef FEAT_MBYTE
-	if (wfname != fname)
-	    vim_free(wfname);
+	    if (wfname != fname)
+		vim_free(wfname);
 #endif
-	goto fail;
+	    goto fail;
+	}
+	errmsg = NULL;
     }
-    errmsg = NULL;
 
 #if defined(MACOS_CLASSIC) || defined(WIN3264)
     /* TODO: Is it need for MACOS_X? (Dany) */
@@ -3999,7 +4030,7 @@
     }
 #endif
 
-    if (close(fd) != 0)
+    if (!write_pstream && close(fd) != 0)
     {
 	errmsg = (char_u *)_("E512: Close failed");
 	end = 0;
@@ -4415,6 +4446,10 @@
     buf_T	*buf;
     char_u	*fname;
 {
+#ifdef FEAT_GUI_COMPONENT
+    if (buf->emb_buffer)
+        fname = (char_u *)"[Embedded File]";
+#endif
     if (fname == NULL)
 	fname = (char_u *)"-stdin-";
     home_replace(buf, fname, IObuff + 1, IOSIZE - 4, TRUE);
@@ -4939,7 +4974,12 @@
     /* Repeat the write(), it may be interrupted by a signal. */
     while (len)
     {
-	wlen = vim_write(ip->bw_fd, buf, len);
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+        if( write_to_container )
+            wlen = vim_control_persist_stream_write(buf, len);
+        else
+#endif
+            wlen = vim_write(ip->bw_fd, buf, len);
 	if (wlen <= 0)		    /* error! */
 	    return FAIL;
 	len -= wlen;
@@ -6672,6 +6712,7 @@
     {"BufWriteCmd",	EVENT_BUFWRITECMD},
     {"CmdwinEnter",	EVENT_CMDWINENTER},
     {"CmdwinLeave",	EVENT_CMDWINLEAVE},
+    {"EmbeddingOn",	EVENT_EMBEDDED_COMPONENT},
     {"EncodingChanged",	EVENT_ENCODINGCHANGED},
     {"FileEncoding",	EVENT_ENCODINGCHANGED},
     {"CursorHold",	EVENT_CURSORHOLD},
diff -Nur vim63/src/globals.h vim63-bonobo/src/globals.h
--- vim63/src/globals.h	2005-09-09 20:11:10.559759000 +0200
+++ vim63-bonobo/src/globals.h	2005-09-09 20:14:02.721586520 +0200
@@ -837,6 +837,12 @@
 EXTERN int	readonlymode INIT(= FALSE); /* Set to TRUE for "view" */
 EXTERN int	recoverymode INIT(= FALSE); /* Set to TRUE for "-r" option */
 
+#ifdef FEAT_GUI_COMPONENT
+EXTERN int      read_from_container INIT(= 0); /* read the buffer from the container app */
+EXTERN int      write_to_container INIT(= 0); /* write the buffer to the container app */
+EXTERN buf_T    *persistent_buffer INIT(= NULL); /* the buffer which the container is interested in */
+#endif
+
 EXTERN struct buffheader stuffbuff	/* stuff buffer */
 #ifdef DO_INIT
 		    = {{NULL, {NUL}}, NULL, 0, 0}
@@ -1363,6 +1369,9 @@
 #ifdef FEAT_NETBEANS_INTG
 EXTERN char_u e_guarded[]	INIT(=N_("E463: Region is guarded, cannot modify"));
 #endif
+#ifdef FEAT_GUI_COMPONENT
+EXTERN char_u e_compnoquit[]	INIT(=N_("E464: Quit not allowed from embedded component"));
+#endif
 #ifdef MACOS_X_UNIX
 EXTERN short disallow_gui	INIT(= FALSE);
 #endif
diff -Nur vim63/src/gtkhtml_editor.c vim63-bonobo/src/gtkhtml_editor.c
--- vim63/src/gtkhtml_editor.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml_editor.c	2005-09-09 20:14:02.726585760 +0200
@@ -0,0 +1,385 @@
+#include "vim.h"
+
+#include <bonobo.h>
+#include "gtkhtml_editor.h"
+
+static BonoboObjectClass *engine_parent_class;
+
+inline static EditorEngine *
+gtkhtml_editor_engine_from_servant (PortableServer_Servant servant)
+{
+	return EDITOR_ENGINE (bonobo_object_from_servant (servant));
+}
+
+static CORBA_char *
+impl_get_paragraph_data (PortableServer_Servant servant, const CORBA_char * key, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+}
+
+static void
+impl_set_paragraph_data (PortableServer_Servant servant,
+			 const CORBA_char * key, const CORBA_char * value,
+			 CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+}
+
+static void
+impl_set_object_data_by_type (PortableServer_Servant servant,
+			 const CORBA_char * type_name, const CORBA_char * key, const CORBA_char * value,
+			 CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+}
+
+static void
+impl_set_listener (PortableServer_Servant servant, const GNOME_GtkHTML_Editor_Listener value, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+
+	bonobo_object_release_unref (e->listener, NULL);
+	e->listener        = bonobo_object_dup_ref (value, NULL);
+}
+
+static GNOME_GtkHTML_Editor_Listener
+impl_get_listener (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+	return gtkhtml_editor_engine_from_servant (servant)->listener;
+}
+
+
+
+static CORBA_boolean
+impl_run_command (PortableServer_Servant servant, const CORBA_char * command, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+	printf ("command: %s\n", command);
+    CORBA_boolean retval = CORBA_TRUE;
+    int save_p_report = p_report;
+
+    p_report = 1000;
+
+    aco_save_T	aco;
+    aucmd_prepbuf(&aco, persistent_buffer);
+
+    if( strcmp( command, "cursor-position-save" ) == 0 ) {
+        do_cmdline_cmd("normal mz");
+    } else if( strcmp( command, "cursor-position-restore" ) == 0 ) {
+        do_cmdline_cmd("normal 'z");
+        update_screen(CLEAR);
+        gui_update_cursor(TRUE, FALSE);
+    } else if( strcmp( command, "cursor-bod" ) == 0 ) {
+        do_cmdline_cmd("normal G");
+    } else if( strcmp( command, "select-paragraph" ) == 0 ) {
+        do_cmdline_cmd("normal V}");
+    } else if( strcmp( command, "delete" ) == 0 ) {
+        do_cmdline_cmd("normal d");
+    } else if( strcmp( command, "is-saved" ) == 0 ) {
+        retval = !persistent_buffer->b_changed;
+    } else if( strcmp( command, "insert-paragraph" ) == 0 ) {
+        do_cmdline_cmd("normal o");
+    }
+    aucmd_restbuf(&aco);
+    p_report = save_p_report;
+	return retval;
+}
+
+static CORBA_boolean
+impl_is_paragraph_empty (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+	return CORBA_FALSE;
+}
+
+static CORBA_boolean
+impl_is_previous_paragraph_empty (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+	return CORBA_FALSE;
+}
+
+struct keyvalue {
+    char * key;
+    char * value;
+    char mark;
+};
+
+static GSList * keylist = NULL;
+static char free_mark = 'y';
+
+static void set_mark_at_cursor( char * key, char * value ) 
+{
+    char cmd[5];
+    struct keyvalue * kv = NULL;
+    GSList * node = keylist;
+    while( node != NULL ) {
+        kv = node->data; 
+        if( strcmp( kv->key, key ) == 0 && strcmp( kv->value, value ) == 0 ) {
+            break;
+        }
+        node = node->next;
+    }
+    if( kv == NULL ) {
+        kv = g_new0( struct keyvalue, 1 );
+        kv->key = g_strdup( key );
+        kv->value = g_strdup( value );
+
+        kv->mark = free_mark;
+        free_mark -= 1;
+        keylist = g_slist_prepend( keylist, kv );
+    }
+
+    setmark(kv->mark);
+}
+
+static void
+impl_insert_html (PortableServer_Servant servant, const CORBA_char * html, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+    const char * c;
+    const char * s;
+    char * d;
+    int level = 0;
+    gboolean in_data = 0;
+    char key[50];
+    char value[50];
+    char cmd[50];
+    gchar **lines;
+    int curline;
+    int begin;
+    int i;
+
+	g_warning("insert html: \"%s\"", html ); 
+    
+    aco_save_T	aco;
+    aucmd_prepbuf(&aco, persistent_buffer);
+
+    // This gets a bit ugly...
+    // Look for DATA tags with KEY and VALUE attributes.  We set a mark
+    // in vim on the first line of the inserted HTML if one of these tags is present
+    // (we assume that they occur at the beginning of the inserted paragraph).
+    // we also assume that only one of these sequences will occur in the html.
+    strcpy( key, "" );
+    strcpy( value, "" );
+    for( c = html; *c != '\0'; c++ ) {
+        if( *c == '<' ) {
+            level += 1;
+            if( strncmp( c, "<DATA", 5 ) == 0 ) {
+                in_data = TRUE;
+            }
+        } else if( *c == '>' ) {
+            level -= 1;
+            if( in_data ) {
+                if( *key && *value ) {
+                    g_warning( "got key=%s and value=%s", key, value );
+                }
+                in_data = FALSE;
+            }
+        } else if( in_data && strncmp( c, "key=", 4 ) == 0 ) {
+            // extract the key
+            d = key;
+            for( s = &c[4]; *s != '\"'; s++ );
+            s++;
+            for( ; *s != '\"'; s++ ) {
+                *d++ = *s; 
+            }
+            *d = '\0';
+        } else if( in_data && strncmp( c, "value=", 6 ) == 0 ) {
+            // extract the value
+            d = value;
+            for( s = &c[4]; *s != '\"'; s++ );
+            s++;
+            for( ; *s != '\"'; s++ ) {
+                *d++ = *s; 
+            }
+            *d = '\0';
+        }
+    }
+
+    /* insert the html into the buffer, remembering the starting line */
+    begin = curwin->w_cursor.lnum;
+    curline = begin;
+    lines = g_strsplit(html, "\n", 0);
+    for(i = 0; lines[i]; i += 1) {
+        ml_append(curline, lines[i], strlen(html) + 1, FALSE); 
+        appended_lines_mark(curwin->w_cursor.lnum, 1);
+        curline += 1;
+    }
+    g_strfreev(lines);
+
+    /* run a filter to obtain plain text from the html */
+    vim_bonobo_call_begin();
+    g_snprintf( cmd, 50, "%d,%d!html2text -nobs", begin, curline);
+    do_cmdline_cmd(cmd);
+    vim_bonobo_call_end();
+    if( *key && *value ) {
+        set_mark_at_cursor( key, value );
+    }
+    aucmd_restbuf(&aco);
+}
+
+static CORBA_boolean
+impl_search_by_data (PortableServer_Servant servant, const CORBA_long level, const CORBA_char * klass,
+		     const CORBA_char * key, const CORBA_char * value, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+
+    GSList * node = keylist;
+    struct keyvalue * kv = NULL;
+    char cmd[15];
+    char * data;
+    aco_save_T	aco;
+    int retval = FALSE;
+
+    aucmd_prepbuf(&aco, persistent_buffer);
+
+	g_warning("search by data: key=\"%s\" value=\"%s\"", key, value ); 
+    while( node != NULL ) {
+        kv = node->data; 
+        if( strcmp( kv->key, key ) == 0 && strcmp( kv->value, value ) == 0 ) {
+            break;
+        }
+        node = node->next;
+    }
+    if( kv != NULL ) {
+        pos_T *pos;
+
+        pos = getmark(kv->mark, FALSE);
+        if( pos->lnum != 0 ) {
+            /* jump to the mark in the text */
+            g_snprintf( cmd, 15, "normal '%c", kv->mark );
+            do_cmdline_cmd( cmd );
+            g_warning( "Found key!" );
+            retval = TRUE;
+        } else {
+            g_warning( "Key not found" );
+            // mark not found.  Delete it from our list.
+            g_free( kv->key );
+            g_free( kv->value );
+            g_free( kv );
+            keylist = g_slist_remove( keylist, kv );
+        }
+    }
+    aucmd_restbuf(&aco);
+	return retval;
+}
+
+static void
+impl_freeze (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+}
+
+static void
+impl_thaw (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+}
+
+static void
+impl_undo_begin (PortableServer_Servant servant, const CORBA_char * undo_name, const CORBA_char * redo_name,
+		 CORBA_Environment * ev)
+{
+}
+
+static void
+impl_undo_end (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+}
+
+static void
+impl_ignore_word (PortableServer_Servant servant, const CORBA_char * word, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+}
+
+/* Return whether we have any undos. */
+static CORBA_boolean
+impl_has_undo (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+    u_header_T *curhead;
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+
+    if( !persistent_buffer) {
+        return CORBA_FALSE;
+    }
+    /* this logic comes from undo.c */
+    curhead = persistent_buffer->b_u_curhead;
+    if (persistent_buffer->b_u_curhead == NULL) {		/* first undo */
+		curhead = persistent_buffer->b_u_newhead;
+    } else if (p_ul > 0) {			/* multi level undo */ 
+		curhead = persistent_buffer->b_u_curhead->uh_next;
+    }
+    if (curbuf->b_u_numhead == 0 || curhead == NULL) {
+        return CORBA_FALSE;
+    }
+    return CORBA_TRUE;
+}
+
+static void
+impl_drop_undo (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+	printf ("dropUndo\n");
+}
+
+static void
+engine_object_finalize (GObject *object)
+{
+	EditorEngine *e = EDITOR_ENGINE (object);
+
+	bonobo_object_release_unref (e->listener, NULL);
+
+	G_OBJECT_CLASS (engine_parent_class)->finalize (object);
+}
+
+static void
+editor_engine_init (GObject *object)
+{
+	EditorEngine *e = EDITOR_ENGINE (object);
+
+	e->listener = CORBA_OBJECT_NIL;
+}
+
+static void
+editor_engine_class_init (EditorEngineClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	POA_GNOME_GtkHTML_Editor_Engine__epv *epv = &klass->epv;
+
+	engine_parent_class = g_type_class_peek_parent (klass);
+	object_class->finalize = engine_object_finalize;
+
+	epv->_set_listener            = impl_set_listener;
+	epv->_get_listener            = impl_get_listener;
+	epv->setParagraphData         = impl_set_paragraph_data;
+	epv->getParagraphData         = impl_get_paragraph_data;
+	epv->setObjectDataByType      = impl_set_object_data_by_type;
+	epv->runCommand               = impl_run_command;
+	epv->isParagraphEmpty         = impl_is_paragraph_empty;
+	epv->isPreviousParagraphEmpty = impl_is_previous_paragraph_empty;
+	epv->searchByData             = impl_search_by_data;
+	epv->insertHTML               = impl_insert_html;
+	epv->freeze                   = impl_freeze;
+	epv->thaw                     = impl_thaw;
+	epv->undoBegin                = impl_undo_begin;
+	epv->undoEnd                  = impl_undo_end;
+	epv->ignoreWord               = impl_ignore_word;
+	epv->hasUndo                  = impl_has_undo;
+	epv->dropUndo                 = impl_drop_undo;
+}
+
+BONOBO_TYPE_FUNC_FULL (
+	EditorEngine,                  /* Glib class name */
+	GNOME_GtkHTML_Editor_Engine,   /* CORBA interface name */
+	BONOBO_TYPE_OBJECT,            /* parent type */
+	editor_engine);                /* local prefix ie. 'echo'_class_init */
+
+EditorEngine *
+editor_engine_new (void)
+{
+	EditorEngine *ee;
+
+	ee = g_object_new (EDITOR_ENGINE_TYPE, NULL);
+
+	return ee;
+}
diff -Nur vim63/src/gtkhtml_editor_common.c vim63-bonobo/src/gtkhtml_editor_common.c
--- vim63/src/gtkhtml_editor_common.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml_editor_common.c	2005-09-09 20:14:02.727585608 +0200
@@ -0,0 +1,306 @@
+/*
+ * This file was generated by orbit-idl-2 - DO NOT EDIT!
+ */
+
+#include <string.h>
+#define ORBIT2_STUBS_API
+#define ORBIT_IDL_C_COMMON
+#define Editor_COMMON
+#include "gtkhtml.h"
+
+static const CORBA_unsigned_long ORBit_zero_int = 0;
+
+#if ( (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_0 == 'E') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_1 == 'd') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_2 == 'i') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_3 == 't') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_4 == 'o') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_5 == 'r') \
+) && !defined(TC_DEF_TC_GNOME_GtkHTML_Editor_Listener)
+#define TC_DEF_TC_GNOME_GtkHTML_Editor_Listener 1
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+const struct CORBA_TypeCode_struct TC_GNOME_GtkHTML_Editor_Listener_struct = {
+   {&ORBit_TypeCode_epv, ORBIT_REFCOUNT_STATIC},
+   CORBA_tk_objref,
+   0,
+   0,
+   ORBIT_ALIGNOF_CORBA_POINTER,
+   0,
+   0,
+   NULL,
+   CORBA_OBJECT_NIL,
+   "Listener",
+   "IDL:GNOME/GtkHTML/Editor/Listener:1.0",
+   NULL,
+   NULL,
+   -1,
+   0,
+   0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_0 == 'E') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_1 == 'd') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_2 == 'i') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_3 == 't') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_4 == 'o') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_5 == 'r') \
+) && !defined(TC_DEF_TC_GNOME_GtkHTML_Editor_Engine)
+#define TC_DEF_TC_GNOME_GtkHTML_Editor_Engine 1
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+const struct CORBA_TypeCode_struct TC_GNOME_GtkHTML_Editor_Engine_struct = {
+   {&ORBit_TypeCode_epv, ORBIT_REFCOUNT_STATIC},
+   CORBA_tk_objref,
+   0,
+   0,
+   ORBIT_ALIGNOF_CORBA_POINTER,
+   0,
+   0,
+   NULL,
+   CORBA_OBJECT_NIL,
+   "Engine",
+   "IDL:GNOME/GtkHTML/Editor/Engine:1.0",
+   NULL,
+   NULL,
+   -1,
+   0,
+   0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_0 == 'E') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_1 == 'd') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_2 == 'i') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_3 == 't') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_4 == 'o') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_5 == 'r') \
+) && !defined(TC_DEF_TC_GNOME_GtkHTML_Editor_URLRequestEvent)
+#define TC_DEF_TC_GNOME_GtkHTML_Editor_URLRequestEvent 1
+static const char *anon_subnames_array6[] = { "url", "stream" };
+static const CORBA_TypeCode anon_subtypes_array7[] =
+   { (CORBA_TypeCode) & TC_CORBA_string_struct,
+      (CORBA_TypeCode) & TC_Bonobo_Stream_struct };
+
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+const struct CORBA_TypeCode_struct
+   TC_GNOME_GtkHTML_Editor_URLRequestEvent_struct = {
+   {&ORBit_TypeCode_epv, ORBIT_REFCOUNT_STATIC},
+   CORBA_tk_struct,
+   0,
+   0,
+   ORBIT_ALIGNOF_CORBA_POINTER,
+   0,
+   2,
+   (CORBA_TypeCode *) anon_subtypes_array7,
+   CORBA_OBJECT_NIL,
+   "URLRequestEvent",
+   "IDL:GNOME/GtkHTML/Editor/URLRequestEvent:1.0",
+   (char **) anon_subnames_array6,
+   NULL,
+   -1,
+   0,
+   0, 0
+};
+#endif
+
+#ifndef ORBIT_IDL_C_IMODULE_Editor
+CORBA_unsigned_long GNOME_GtkHTML_Editor_Listener__classid = 0;
+#endif
+
+#ifndef ORBIT_IDL_C_IMODULE_Editor
+CORBA_unsigned_long GNOME_GtkHTML_Editor_Engine__classid = 0;
+#endif
+
+/* Interface type data */
+
+static ORBit_IArg GNOME_GtkHTML_Editor_Listener_event__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "name"},
+   {TC_CORBA_any, ORBit_I_ARG_IN, "arg"}
+};
+
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+ORBit_IMethod GNOME_GtkHTML_Editor_Listener__imethods[] = {
+   {
+    {2, 2, GNOME_GtkHTML_Editor_Listener_event__arginfo, FALSE},
+    {0, 0, NULL, FALSE},
+    {0, 0, NULL, FALSE},
+    TC_CORBA_any, "event", 5,
+    0}
+};
+static CORBA_string GNOME_GtkHTML_Editor_Listener__base_itypes[] = {
+   "IDL:Bonobo/Unknown:1.0",
+   "IDL:omg.org/CORBA/Object:1.0"
+};
+
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+ORBit_IInterface GNOME_GtkHTML_Editor_Listener__iinterface = {
+   TC_GNOME_GtkHTML_Editor_Listener, {1, 1,
+				      GNOME_GtkHTML_Editor_Listener__imethods,
+				      FALSE},
+   {2, 2, GNOME_GtkHTML_Editor_Listener__base_itypes, FALSE}
+};
+
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine__set_listener__arginfo[] = {
+   {TC_GNOME_GtkHTML_Editor_Listener, ORBit_I_ARG_IN, "value"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_runCommand__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "command"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_getParagraphData__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "key"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_setParagraphData__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "key"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "value"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_setObjectDataByType__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "type_name"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "key"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "data"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_searchByData__arginfo[] = {
+   {TC_CORBA_long, ORBit_I_ARG_IN | ORBit_I_COMMON_FIXED_SIZE, "level"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "klass"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "key"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "value"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_insertHTML__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "html"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_undoBegin__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "undo_name"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "redo_name"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_ignoreWord__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "word"}
+};
+
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+ORBit_IMethod GNOME_GtkHTML_Editor_Engine__imethods[] = {
+   {
+    {0, 0, NULL, FALSE},
+    {0, 0, NULL, FALSE},
+    {0, 0, NULL, FALSE},
+    TC_GNOME_GtkHTML_Editor_Listener, "_get_listener", 13,
+    0}
+   , {
+      {1, 1, GNOME_GtkHTML_Editor_Engine__set_listener__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "_set_listener", 13,
+      0}
+   , {
+      {1, 1, GNOME_GtkHTML_Editor_Engine_runCommand__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_boolean, "runCommand", 10,
+      0 | ORBit_I_COMMON_FIXED_SIZE}
+   , {
+      {1, 1, GNOME_GtkHTML_Editor_Engine_getParagraphData__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_string, "getParagraphData", 16,
+      0}
+   , {
+      {2, 2, GNOME_GtkHTML_Editor_Engine_setParagraphData__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "setParagraphData", 16,
+      0}
+   , {
+      {3, 3, GNOME_GtkHTML_Editor_Engine_setObjectDataByType__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "setObjectDataByType", 19,
+      0}
+   , {
+      {4, 4, GNOME_GtkHTML_Editor_Engine_searchByData__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_boolean, "searchByData", 12,
+      0 | ORBit_I_COMMON_FIXED_SIZE}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_boolean, "isParagraphEmpty", 16,
+      0 | ORBit_I_COMMON_FIXED_SIZE}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_boolean, "isPreviousParagraphEmpty", 24,
+      0 | ORBit_I_COMMON_FIXED_SIZE}
+   , {
+      {1, 1, GNOME_GtkHTML_Editor_Engine_insertHTML__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "insertHTML", 10,
+      0}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "freeze", 6,
+      0}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "thaw", 4,
+      0}
+   , {
+      {2, 2, GNOME_GtkHTML_Editor_Engine_undoBegin__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "undoBegin", 9,
+      0}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "undoEnd", 7,
+      0}
+   , {
+      {1, 1, GNOME_GtkHTML_Editor_Engine_ignoreWord__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "ignoreWord", 10,
+      0}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "dropUndo", 8,
+      0}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_boolean, "hasUndo", 7,
+      0 | ORBit_I_COMMON_FIXED_SIZE}
+};
+static CORBA_string GNOME_GtkHTML_Editor_Engine__base_itypes[] = {
+   "IDL:Bonobo/Unknown:1.0",
+   "IDL:omg.org/CORBA/Object:1.0"
+};
+
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+ORBit_IInterface GNOME_GtkHTML_Editor_Engine__iinterface = {
+   TC_GNOME_GtkHTML_Editor_Engine, {17, 17,
+				    GNOME_GtkHTML_Editor_Engine__imethods,
+				    FALSE},
+   {2, 2, GNOME_GtkHTML_Editor_Engine__base_itypes, FALSE}
+};
diff -Nur vim63/src/gtkhtml_editor.h vim63-bonobo/src/gtkhtml_editor.h
--- vim63/src/gtkhtml_editor.h	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml_editor.h	2005-09-09 20:14:02.727585608 +0200
@@ -0,0 +1,34 @@
+#ifndef GTKHTML_ENGINE_H_
+#define GTKHTML_ENGINE_H_
+
+G_BEGIN_DECLS
+
+typedef struct _EditorEngine EditorEngine;
+
+#include <gtk/gtktypeutils.h>
+#include <bonobo/bonobo-object.h>
+#include "gtkhtml.h"
+
+#define EDITOR_ENGINE_TYPE        (editor_engine_get_type ())
+#define EDITOR_ENGINE(o)          (GTK_CHECK_CAST ((o), EDITOR_ENGINE_TYPE, EditorEngine))
+#define EDITOR_ENGINE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), EDITOR_ENGINE_TYPE, EditorEngineClass))
+#define IS_EDITOR_ENGINE(o)       (GTK_CHECK_TYPE ((o), EDITOR_ENGINE_TYPE))
+#define IS_EDITOR_ENGINE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), EDITOR_ENGINE_TYPE))
+
+struct _EditorEngine {
+	BonoboObject parent;
+	GNOME_GtkHTML_Editor_Listener listener;
+};
+
+typedef struct {
+	BonoboObjectClass parent_class;
+	POA_GNOME_GtkHTML_Editor_Engine__epv epv;
+} EditorEngineClass;
+
+GtkType                               editor_engine_get_type   (void);
+EditorEngine                         *editor_engine_new        (void);
+POA_GNOME_GtkHTML_Editor_Engine__epv *editor_engine_get_epv    (void);
+
+G_END_DECLS
+
+#endif /* GTKHTML_ENGINE_H_ */
diff -Nur vim63/src/gtkhtml_editor_skels.c vim63-bonobo/src/gtkhtml_editor_skels.c
--- vim63/src/gtkhtml_editor_skels.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml_editor_skels.c	2005-09-09 20:14:02.728585456 +0200
@@ -0,0 +1,658 @@
+/*
+ * This file was generated by orbit-idl-2 - DO NOT EDIT!
+ */
+
+#include <string.h>
+#define ORBIT2_STUBS_API
+#include "gtkhtml.h"
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Listener_event
+   (POA_GNOME_GtkHTML_Editor_Listener * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_any * (*_impl_event) (PortableServer_Servant _servant,
+				const CORBA_char * name,
+				const CORBA_any * arg,
+				CORBA_Environment * ev))
+{
+   *(CORBA_any * *)_o_retval =
+      _impl_event(_o_servant, *(const CORBA_char * *) _o_args[0],
+		  (const CORBA_any *) _o_args[1], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__get_listener
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    GNOME_GtkHTML_Editor_Listener(*_impl__get_listener)
+    (PortableServer_Servant _servant, CORBA_Environment * ev))
+{
+   *(GNOME_GtkHTML_Editor_Listener *) _o_retval =
+      _impl__get_listener(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__set_listener
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl__set_listener) (PortableServer_Servant _servant,
+				 const GNOME_GtkHTML_Editor_Listener value,
+				 CORBA_Environment * ev))
+{
+   _impl__set_listener(_o_servant,
+		       *(const GNOME_GtkHTML_Editor_Listener *) _o_args[0],
+		       _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_runCommand
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_boolean(*_impl_runCommand) (PortableServer_Servant _servant,
+				      const CORBA_char * command,
+				      CORBA_Environment * ev))
+{
+   *(CORBA_boolean *) _o_retval =
+      _impl_runCommand(_o_servant, *(const CORBA_char * *) _o_args[0], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_getParagraphData
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_string(*_impl_getParagraphData) (PortableServer_Servant _servant,
+					   const CORBA_char * key,
+					   CORBA_Environment * ev))
+{
+   *(CORBA_string *) _o_retval =
+      _impl_getParagraphData(_o_servant, *(const CORBA_char * *) _o_args[0],
+			     _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setParagraphData
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_setParagraphData) (PortableServer_Servant _servant,
+				    const CORBA_char * key,
+				    const CORBA_char * value,
+				    CORBA_Environment * ev))
+{
+   _impl_setParagraphData(_o_servant, *(const CORBA_char * *) _o_args[0],
+			  *(const CORBA_char * *) _o_args[1], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setObjectDataByType
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_setObjectDataByType) (PortableServer_Servant _servant,
+				       const CORBA_char * type_name,
+				       const CORBA_char * key,
+				       const CORBA_char * data,
+				       CORBA_Environment * ev))
+{
+   _impl_setObjectDataByType(_o_servant, *(const CORBA_char * *) _o_args[0],
+			     *(const CORBA_char * *) _o_args[1],
+			     *(const CORBA_char * *) _o_args[2], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_searchByData
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_boolean(*_impl_searchByData) (PortableServer_Servant _servant,
+					const CORBA_long level,
+					const CORBA_char * klass,
+					const CORBA_char * key,
+					const CORBA_char * value,
+					CORBA_Environment * ev))
+{
+   *(CORBA_boolean *) _o_retval =
+      _impl_searchByData(_o_servant, *(const CORBA_long *) _o_args[0],
+			 *(const CORBA_char * *) _o_args[1],
+			 *(const CORBA_char * *) _o_args[2],
+			 *(const CORBA_char * *) _o_args[3], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isParagraphEmpty
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_boolean(*_impl_isParagraphEmpty) (PortableServer_Servant _servant,
+					    CORBA_Environment * ev))
+{
+   *(CORBA_boolean *) _o_retval = _impl_isParagraphEmpty(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_boolean(*_impl_isPreviousParagraphEmpty) (PortableServer_Servant
+						    _servant,
+						    CORBA_Environment * ev))
+{
+   *(CORBA_boolean *) _o_retval =
+      _impl_isPreviousParagraphEmpty(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_insertHTML
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_insertHTML) (PortableServer_Servant _servant,
+			      const CORBA_char * html,
+			      CORBA_Environment * ev))
+{
+   _impl_insertHTML(_o_servant, *(const CORBA_char * *) _o_args[0], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_freeze
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_freeze) (PortableServer_Servant _servant,
+			  CORBA_Environment * ev))
+{
+   _impl_freeze(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_thaw
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_thaw) (PortableServer_Servant _servant,
+			CORBA_Environment * ev))
+{
+   _impl_thaw(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoBegin
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_undoBegin) (PortableServer_Servant _servant,
+			     const CORBA_char * undo_name,
+			     const CORBA_char * redo_name,
+			     CORBA_Environment * ev))
+{
+   _impl_undoBegin(_o_servant, *(const CORBA_char * *) _o_args[0],
+		   *(const CORBA_char * *) _o_args[1], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoEnd
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_undoEnd) (PortableServer_Servant _servant,
+			   CORBA_Environment * ev))
+{
+   _impl_undoEnd(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_ignoreWord
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_ignoreWord) (PortableServer_Servant _servant,
+			      const CORBA_char * word,
+			      CORBA_Environment * ev))
+{
+   _impl_ignoreWord(_o_servant, *(const CORBA_char * *) _o_args[0], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_dropUndo
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_dropUndo) (PortableServer_Servant _servant,
+			    CORBA_Environment * ev))
+{
+   _impl_dropUndo(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_hasUndo
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_boolean(*_impl_hasUndo) (PortableServer_Servant _servant,
+				   CORBA_Environment * ev))
+{
+   *(CORBA_boolean *) _o_retval = _impl_hasUndo(_o_servant, _o_ev);
+}
+static ORBitSmallSkeleton
+get_skel_small_GNOME_GtkHTML_Editor_Listener(POA_GNOME_GtkHTML_Editor_Listener
+					     * servant, const char *opname,
+					     gpointer * m_data,
+					     gpointer * impl)
+{
+   switch (opname[0]) {
+     case 'e':
+      if (strcmp((opname + 1), "vent"))
+	 break;
+      *impl =
+	 (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Listener_epv->event;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Listener__iinterface.methods.
+	 _buffer[0];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Listener_event;
+      break;
+     case 'q':
+      if (strcmp((opname + 1), "ueryInterface"))
+	 break;
+      *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
+      *m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
+      break;
+     case 'r':
+      if (strcmp((opname + 1), "ef"))
+	 break;
+      *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
+      *m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[0];
+      return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_ref;
+      break;
+     case 'u':
+      if (strcmp((opname + 1), "nref"))
+	 break;
+      *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
+      *m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
+      return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_unref;
+      break;
+     default:
+      break;
+   }
+   return NULL;
+}
+
+void
+POA_GNOME_GtkHTML_Editor_Listener__init(PortableServer_Servant servant,
+					CORBA_Environment * env)
+{
+   static PortableServer_ClassInfo class_info =
+      { NULL,
+(ORBit_small_impl_finder) & get_skel_small_GNOME_GtkHTML_Editor_Listener,
+	 "IDL:GNOME/GtkHTML/Editor/Listener:1.0",
+	 &GNOME_GtkHTML_Editor_Listener__classid, NULL,
+	 &GNOME_GtkHTML_Editor_Listener__iinterface };
+   POA_GNOME_GtkHTML_Editor_Listener__vepv *fakevepv = NULL;
+
+   if (((PortableServer_ServantBase *) servant)->vepv[0]->finalize == 0) {
+      ((PortableServer_ServantBase *) servant)->vepv[0]->finalize =
+	 POA_GNOME_GtkHTML_Editor_Listener__fini;
+   }
+   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
+				    env);
+   POA_Bonobo_Unknown__init(servant, env);
+   ORBit_classinfo_register(&class_info);
+   ORBIT_SERVANT_SET_CLASSINFO(servant, &class_info);
+
+   if (!class_info.vepvmap) {
+      class_info.vepvmap =
+	 g_new0(ORBit_VepvIdx, GNOME_GtkHTML_Editor_Listener__classid + 1);
+      class_info.vepvmap[Bonobo_Unknown__classid] =
+	 (((char *) &(fakevepv->Bonobo_Unknown_epv)) -
+	  ((char *) (fakevepv))) / sizeof(GFunc);
+      class_info.vepvmap[GNOME_GtkHTML_Editor_Listener__classid] =
+	 (((char *) &(fakevepv->GNOME_GtkHTML_Editor_Listener_epv)) -
+	  ((char *) (fakevepv))) / sizeof(GFunc);
+   }
+}
+
+void
+POA_GNOME_GtkHTML_Editor_Listener__fini(PortableServer_Servant servant,
+					CORBA_Environment * env)
+{
+   POA_Bonobo_Unknown__fini(servant, env);
+   PortableServer_ServantBase__fini(servant, env);
+}
+
+static ORBitSmallSkeleton
+get_skel_small_GNOME_GtkHTML_Editor_Engine(POA_GNOME_GtkHTML_Editor_Engine *
+					   servant, const char *opname,
+					   gpointer * m_data, gpointer * impl)
+{
+   switch (opname[0]) {
+     case '_':
+      switch (opname[1]) {
+	case 'g':
+	 if (strcmp((opname + 2), "et_listener"))
+	    break;
+	 *impl =
+	    (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	    _get_listener;
+	 *m_data =
+	    (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	    _buffer[0];
+	 return (ORBitSmallSkeleton)
+	    _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__get_listener;
+	 break;
+	case 's':
+	 if (strcmp((opname + 2), "et_listener"))
+	    break;
+	 *impl =
+	    (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	    _set_listener;
+	 *m_data =
+	    (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	    _buffer[1];
+	 return (ORBitSmallSkeleton)
+	    _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__set_listener;
+	 break;
+	default:
+	 break;
+      }
+      break;
+     case 'd':
+      if (strcmp((opname + 1), "ropUndo"))
+	 break;
+      *impl =
+	 (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->dropUndo;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	 _buffer[15];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_dropUndo;
+      break;
+     case 'f':
+      if (strcmp((opname + 1), "reeze"))
+	 break;
+      *impl =
+	 (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->freeze;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	 _buffer[10];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_freeze;
+      break;
+     case 'g':
+      if (strcmp((opname + 1), "etParagraphData"))
+	 break;
+      *impl =
+	 (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	 getParagraphData;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	 _buffer[3];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_getParagraphData;
+      break;
+     case 'h':
+      if (strcmp((opname + 1), "asUndo"))
+	 break;
+      *impl =
+	 (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->hasUndo;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	 _buffer[16];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_hasUndo;
+      break;
+     case 'i':
+      switch (opname[1]) {
+	case 'g':
+	 if (strcmp((opname + 2), "noreWord"))
+	    break;
+	 *impl =
+	    (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	    ignoreWord;
+	 *m_data =
+	    (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	    _buffer[14];
+	 return (ORBitSmallSkeleton)
+	    _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_ignoreWord;
+	 break;
+	case 'n':
+	 if (strcmp((opname + 2), "sertHTML"))
+	    break;
+	 *impl =
+	    (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	    insertHTML;
+	 *m_data =
+	    (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	    _buffer[9];
+	 return (ORBitSmallSkeleton)
+	    _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_insertHTML;
+	 break;
+	case 's':
+	 switch (opname[2]) {
+	   case 'P':
+	    switch (opname[3]) {
+	      case 'a':
+	       if (strcmp((opname + 4), "ragraphEmpty"))
+		  break;
+	       *impl =
+		  (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+		  isParagraphEmpty;
+	       *m_data =
+		  (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		  methods._buffer[7];
+	       return (ORBitSmallSkeleton)
+		  _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isParagraphEmpty;
+	       break;
+	      case 'r':
+	       if (strcmp((opname + 4), "eviousParagraphEmpty"))
+		  break;
+	       *impl =
+		  (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+		  isPreviousParagraphEmpty;
+	       *m_data =
+		  (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		  methods._buffer[8];
+	       return (ORBitSmallSkeleton)
+		  _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty;
+	       break;
+	      default:
+	       break;
+	    }
+	    break;
+	   default:
+	    break;
+	 }
+	 break;
+	default:
+	 break;
+      }
+      break;
+     case 'q':
+      if (strcmp((opname + 1), "ueryInterface"))
+	 break;
+      *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
+      *m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
+      break;
+     case 'r':
+      switch (opname[1]) {
+	case 'e':
+	 if (strcmp((opname + 2), "f"))
+	    break;
+	 *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
+	 *m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[0];
+	 return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_ref;
+	 break;
+	case 'u':
+	 if (strcmp((opname + 2), "nCommand"))
+	    break;
+	 *impl =
+	    (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	    runCommand;
+	 *m_data =
+	    (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	    _buffer[2];
+	 return (ORBitSmallSkeleton)
+	    _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_runCommand;
+	 break;
+	default:
+	 break;
+      }
+      break;
+     case 's':
+      switch (opname[1]) {
+	case 'e':
+	 switch (opname[2]) {
+	   case 'a':
+	    if (strcmp((opname + 3), "rchByData"))
+	       break;
+	    *impl =
+	       (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	       searchByData;
+	    *m_data =
+	       (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	       _buffer[6];
+	    return (ORBitSmallSkeleton)
+	       _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_searchByData;
+	    break;
+	   case 't':
+	    switch (opname[3]) {
+	      case 'O':
+	       if (strcmp((opname + 4), "bjectDataByType"))
+		  break;
+	       *impl =
+		  (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+		  setObjectDataByType;
+	       *m_data =
+		  (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		  methods._buffer[5];
+	       return (ORBitSmallSkeleton)
+		  _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setObjectDataByType;
+	       break;
+	      case 'P':
+	       if (strcmp((opname + 4), "aragraphData"))
+		  break;
+	       *impl =
+		  (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+		  setParagraphData;
+	       *m_data =
+		  (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		  methods._buffer[4];
+	       return (ORBitSmallSkeleton)
+		  _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setParagraphData;
+	       break;
+	      default:
+	       break;
+	    }
+	    break;
+	   default:
+	    break;
+	 }
+	 break;
+	default:
+	 break;
+      }
+      break;
+     case 't':
+      if (strcmp((opname + 1), "haw"))
+	 break;
+      *impl = (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->thaw;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	 _buffer[11];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_thaw;
+      break;
+     case 'u':
+      switch (opname[1]) {
+	case 'n':
+	 switch (opname[2]) {
+	   case 'd':
+	    switch (opname[3]) {
+	      case 'o':
+	       switch (opname[4]) {
+		 case 'B':
+		  if (strcmp((opname + 5), "egin"))
+		     break;
+		  *impl =
+		     (gpointer) servant->vepv->
+		     GNOME_GtkHTML_Editor_Engine_epv->undoBegin;
+		  *m_data =
+		     (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		     methods._buffer[12];
+		  return (ORBitSmallSkeleton)
+		     _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoBegin;
+		  break;
+		 case 'E':
+		  if (strcmp((opname + 5), "nd"))
+		     break;
+		  *impl =
+		     (gpointer) servant->vepv->
+		     GNOME_GtkHTML_Editor_Engine_epv->undoEnd;
+		  *m_data =
+		     (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		     methods._buffer[13];
+		  return (ORBitSmallSkeleton)
+		     _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoEnd;
+		  break;
+		 default:
+		  break;
+	       }
+	       break;
+	      default:
+	       break;
+	    }
+	    break;
+	   case 'r':
+	    if (strcmp((opname + 3), "ef"))
+	       break;
+	    *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
+	    *m_data =
+	       (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
+	    return (ORBitSmallSkeleton)
+	       _ORBIT_skel_small_Bonobo_Unknown_unref;
+	    break;
+	   default:
+	    break;
+	 }
+	 break;
+	default:
+	 break;
+      }
+      break;
+     default:
+      break;
+   }
+   return NULL;
+}
+
+void
+POA_GNOME_GtkHTML_Editor_Engine__init(PortableServer_Servant servant,
+				      CORBA_Environment * env)
+{
+   static PortableServer_ClassInfo class_info =
+      { NULL,
+(ORBit_small_impl_finder) & get_skel_small_GNOME_GtkHTML_Editor_Engine, "IDL:GNOME/GtkHTML/Editor/Engine:1.0",
+	 &GNOME_GtkHTML_Editor_Engine__classid, NULL,
+	 &GNOME_GtkHTML_Editor_Engine__iinterface };
+   POA_GNOME_GtkHTML_Editor_Engine__vepv *fakevepv = NULL;
+
+   if (((PortableServer_ServantBase *) servant)->vepv[0]->finalize == 0) {
+      ((PortableServer_ServantBase *) servant)->vepv[0]->finalize =
+	 POA_GNOME_GtkHTML_Editor_Engine__fini;
+   }
+   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
+				    env);
+   POA_Bonobo_Unknown__init(servant, env);
+   ORBit_classinfo_register(&class_info);
+   ORBIT_SERVANT_SET_CLASSINFO(servant, &class_info);
+
+   if (!class_info.vepvmap) {
+      class_info.vepvmap =
+	 g_new0(ORBit_VepvIdx, GNOME_GtkHTML_Editor_Engine__classid + 1);
+      class_info.vepvmap[Bonobo_Unknown__classid] =
+	 (((char *) &(fakevepv->Bonobo_Unknown_epv)) -
+	  ((char *) (fakevepv))) / sizeof(GFunc);
+      class_info.vepvmap[GNOME_GtkHTML_Editor_Engine__classid] =
+	 (((char *) &(fakevepv->GNOME_GtkHTML_Editor_Engine_epv)) -
+	  ((char *) (fakevepv))) / sizeof(GFunc);
+   }
+}
+
+void
+POA_GNOME_GtkHTML_Editor_Engine__fini(PortableServer_Servant servant,
+				      CORBA_Environment * env)
+{
+   POA_Bonobo_Unknown__fini(servant, env);
+   PortableServer_ServantBase__fini(servant, env);
+}
diff -Nur vim63/src/gtkhtml_editor_stubs.c vim63-bonobo/src/gtkhtml_editor_stubs.c
--- vim63/src/gtkhtml_editor_stubs.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml_editor_stubs.c	2005-09-09 20:14:02.729585304 +0200
@@ -0,0 +1,496 @@
+/*
+ * This file was generated by orbit-idl-2 - DO NOT EDIT!
+ */
+
+#include <string.h>
+#define ORBIT2_STUBS_API
+#include "gtkhtml.h"
+
+CORBA_any *
+GNOME_GtkHTML_Editor_Listener_event(GNOME_GtkHTML_Editor_Listener _obj,
+				    const CORBA_char * name,
+				    const CORBA_any * arg,
+				    CORBA_Environment * ev)
+{
+   CORBA_any *_ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Listener__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Listener__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Listener__epv *) ORBIT_STUB_GetEpv(_obj,
+								     GNOME_GtkHTML_Editor_Listener__classid))->
+       event) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->event(ORBIT_STUB_GetServant(_obj), name, arg, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[2];
+
+      _args[0] = (gpointer) & name;
+      _args[1] = (gpointer) arg;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Listener__iinterface.
+				methods, 0, &_ORBIT_retval, _args, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+GNOME_GtkHTML_Editor_Listener
+GNOME_GtkHTML_Editor_Engine__get_listener(GNOME_GtkHTML_Editor_Engine _obj,
+					  CORBA_Environment * ev)
+{
+   GNOME_GtkHTML_Editor_Listener _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       _get_listener) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->_get_listener(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 0, &_ORBIT_retval, NULL, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+void
+GNOME_GtkHTML_Editor_Engine__set_listener(GNOME_GtkHTML_Editor_Engine _obj,
+					  const GNOME_GtkHTML_Editor_Listener
+					  value, CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       _set_listener) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->_set_listener(ORBIT_STUB_GetServant(_obj), value, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[1];
+
+      _args[0] = (gpointer) & value;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 1, NULL, _args, NULL, ev);
+
+   }
+}
+CORBA_boolean
+GNOME_GtkHTML_Editor_Engine_runCommand(GNOME_GtkHTML_Editor_Engine _obj,
+				       const CORBA_char * command,
+				       CORBA_Environment * ev)
+{
+   CORBA_boolean _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       runCommand) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->runCommand(ORBIT_STUB_GetServant(_obj), command, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[1];
+
+      _args[0] = (gpointer) & command;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 2, &_ORBIT_retval, _args, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+CORBA_string
+GNOME_GtkHTML_Editor_Engine_getParagraphData(GNOME_GtkHTML_Editor_Engine _obj,
+					     const CORBA_char * key,
+					     CORBA_Environment * ev)
+{
+   CORBA_string _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       getParagraphData) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->getParagraphData(ORBIT_STUB_GetServant(_obj), key, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[1];
+
+      _args[0] = (gpointer) & key;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 3, &_ORBIT_retval, _args, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+void
+GNOME_GtkHTML_Editor_Engine_setParagraphData(GNOME_GtkHTML_Editor_Engine _obj,
+					     const CORBA_char * key,
+					     const CORBA_char * value,
+					     CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       setParagraphData) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->setParagraphData(ORBIT_STUB_GetServant(_obj), key, value,
+				   ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[2];
+
+      _args[0] = (gpointer) & key;
+      _args[1] = (gpointer) & value;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 4, NULL, _args, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_setObjectDataByType(GNOME_GtkHTML_Editor_Engine
+						_obj,
+						const CORBA_char * type_name,
+						const CORBA_char * key,
+						const CORBA_char * data,
+						CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       setObjectDataByType) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->setObjectDataByType(ORBIT_STUB_GetServant(_obj), type_name,
+				      key, data, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[3];
+
+      _args[0] = (gpointer) & type_name;
+      _args[1] = (gpointer) & key;
+      _args[2] = (gpointer) & data;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 5, NULL, _args, NULL, ev);
+
+   }
+}
+CORBA_boolean
+GNOME_GtkHTML_Editor_Engine_searchByData(GNOME_GtkHTML_Editor_Engine _obj,
+					 const CORBA_long level,
+					 const CORBA_char * klass,
+					 const CORBA_char * key,
+					 const CORBA_char * value,
+					 CORBA_Environment * ev)
+{
+   CORBA_boolean _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       searchByData) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->searchByData(ORBIT_STUB_GetServant(_obj), level, klass,
+				  key, value, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[4];
+
+      _args[0] = (gpointer) & level;
+      _args[1] = (gpointer) & klass;
+      _args[2] = (gpointer) & key;
+      _args[3] = (gpointer) & value;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 6, &_ORBIT_retval, _args, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+CORBA_boolean
+GNOME_GtkHTML_Editor_Engine_isParagraphEmpty(GNOME_GtkHTML_Editor_Engine _obj,
+					     CORBA_Environment * ev)
+{
+   CORBA_boolean _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       isParagraphEmpty) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->isParagraphEmpty(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 7, &_ORBIT_retval, NULL, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+CORBA_boolean
+GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty
+   (GNOME_GtkHTML_Editor_Engine _obj, CORBA_Environment * ev)
+{
+   CORBA_boolean _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       isPreviousParagraphEmpty) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->isPreviousParagraphEmpty(ORBIT_STUB_GetServant(_obj),
+					      ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 8, &_ORBIT_retval, NULL, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+void
+GNOME_GtkHTML_Editor_Engine_insertHTML(GNOME_GtkHTML_Editor_Engine _obj,
+				       const CORBA_char * html,
+				       CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       insertHTML) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->insertHTML(ORBIT_STUB_GetServant(_obj), html, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[1];
+
+      _args[0] = (gpointer) & html;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 9, NULL, _args, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_freeze(GNOME_GtkHTML_Editor_Engine _obj,
+				   CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       freeze) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->freeze(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 10, NULL, NULL, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_thaw(GNOME_GtkHTML_Editor_Engine _obj,
+				 CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       thaw) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->thaw(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 11, NULL, NULL, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_undoBegin(GNOME_GtkHTML_Editor_Engine _obj,
+				      const CORBA_char * undo_name,
+				      const CORBA_char * redo_name,
+				      CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       undoBegin) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->undoBegin(ORBIT_STUB_GetServant(_obj), undo_name, redo_name,
+			    ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[2];
+
+      _args[0] = (gpointer) & undo_name;
+      _args[1] = (gpointer) & redo_name;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 12, NULL, _args, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_undoEnd(GNOME_GtkHTML_Editor_Engine _obj,
+				    CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       undoEnd) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->undoEnd(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 13, NULL, NULL, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_ignoreWord(GNOME_GtkHTML_Editor_Engine _obj,
+				       const CORBA_char * word,
+				       CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       ignoreWord) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->ignoreWord(ORBIT_STUB_GetServant(_obj), word, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[1];
+
+      _args[0] = (gpointer) & word;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 14, NULL, _args, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_dropUndo(GNOME_GtkHTML_Editor_Engine _obj,
+				     CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       dropUndo) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->dropUndo(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 15, NULL, NULL, NULL, ev);
+
+   }
+}
+CORBA_boolean
+GNOME_GtkHTML_Editor_Engine_hasUndo(GNOME_GtkHTML_Editor_Engine _obj,
+				    CORBA_Environment * ev)
+{
+   CORBA_boolean _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       hasUndo) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval = _ORBIT_epv->hasUndo(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 16, &_ORBIT_retval, NULL, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
diff -Nur vim63/src/gtkhtml.h vim63-bonobo/src/gtkhtml.h
--- vim63/src/gtkhtml.h	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml.h	2005-09-09 20:14:02.725585912 +0200
@@ -0,0 +1,480 @@
+/*
+ * This file was generated by orbit-idl-2 - DO NOT EDIT!
+ */
+
+#ifndef Editor_H
+#define Editor_H 1
+#include <glib.h>
+#define ORBIT_IDL_SERIAL 19
+#include <orbit/orbit-types.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif				/* __cplusplus */
+
+/** typedefs **/
+#include <bonobo/Bonobo.h>
+#if !defined(ORBIT_DECL_GNOME_GtkHTML_Editor_Listener) && !defined(_GNOME_GtkHTML_Editor_Listener_defined)
+#define ORBIT_DECL_GNOME_GtkHTML_Editor_Listener 1
+#define _GNOME_GtkHTML_Editor_Listener_defined 1
+#define GNOME_GtkHTML_Editor_Listener__freekids CORBA_Object__freekids
+   typedef CORBA_Object GNOME_GtkHTML_Editor_Listener;
+   extern CORBA_unsigned_long GNOME_GtkHTML_Editor_Listener__classid;
+#if !defined(TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_0)
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_0 'E'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_1 'd'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_2 'i'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_3 't'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_4 'o'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_5 'r'
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   const struct CORBA_TypeCode_struct TC_GNOME_GtkHTML_Editor_Listener_struct;
+#define TC_GNOME_GtkHTML_Editor_Listener ((CORBA_TypeCode)&TC_GNOME_GtkHTML_Editor_Listener_struct)
+#endif
+#endif
+#if !defined(ORBIT_DECL_GNOME_GtkHTML_Editor_Engine) && !defined(_GNOME_GtkHTML_Editor_Engine_defined)
+#define ORBIT_DECL_GNOME_GtkHTML_Editor_Engine 1
+#define _GNOME_GtkHTML_Editor_Engine_defined 1
+#define GNOME_GtkHTML_Editor_Engine__freekids CORBA_Object__freekids
+   typedef CORBA_Object GNOME_GtkHTML_Editor_Engine;
+   extern CORBA_unsigned_long GNOME_GtkHTML_Editor_Engine__classid;
+#if !defined(TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_0)
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_0 'E'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_1 'd'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_2 'i'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_3 't'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_4 'o'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_5 'r'
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   const struct CORBA_TypeCode_struct TC_GNOME_GtkHTML_Editor_Engine_struct;
+#define TC_GNOME_GtkHTML_Editor_Engine ((CORBA_TypeCode)&TC_GNOME_GtkHTML_Editor_Engine_struct)
+#endif
+#endif
+#if !defined(_GNOME_GtkHTML_Editor_URLRequestEvent_defined)
+#define _GNOME_GtkHTML_Editor_URLRequestEvent_defined 1
+   typedef struct GNOME_GtkHTML_Editor_URLRequestEvent_type
+      GNOME_GtkHTML_Editor_URLRequestEvent;
+   struct GNOME_GtkHTML_Editor_URLRequestEvent_type
+   {
+      CORBA_string url;
+      Bonobo_Stream stream;
+   };
+
+#if !defined(TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_0)
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_0 'E'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_1 'd'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_2 'i'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_3 't'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_4 'o'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_5 'r'
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   const struct CORBA_TypeCode_struct
+      TC_GNOME_GtkHTML_Editor_URLRequestEvent_struct;
+#define TC_GNOME_GtkHTML_Editor_URLRequestEvent ((CORBA_TypeCode)&TC_GNOME_GtkHTML_Editor_URLRequestEvent_struct)
+#endif
+#define GNOME_GtkHTML_Editor_URLRequestEvent__alloc() ((GNOME_GtkHTML_Editor_URLRequestEvent *)ORBit_small_alloc (TC_GNOME_GtkHTML_Editor_URLRequestEvent))
+#define GNOME_GtkHTML_Editor_URLRequestEvent__freekids(m,d) ORBit_small_freekids (TC_GNOME_GtkHTML_Editor_URLRequestEvent,(m),(d))
+#endif
+
+/** POA structures **/
+#ifndef _defined_POA_GNOME_GtkHTML_Editor_Listener
+#define _defined_POA_GNOME_GtkHTML_Editor_Listener 1
+   typedef struct
+   {
+      void *_private;
+      CORBA_any *(*event) (PortableServer_Servant _servant,
+			   const CORBA_char * name, const CORBA_any * arg,
+			   CORBA_Environment * ev);
+   }
+   POA_GNOME_GtkHTML_Editor_Listener__epv;
+   typedef struct
+   {
+      PortableServer_ServantBase__epv *_base_epv;
+      POA_Bonobo_Unknown__epv *Bonobo_Unknown_epv;
+      POA_GNOME_GtkHTML_Editor_Listener__epv
+	 *GNOME_GtkHTML_Editor_Listener_epv;
+   }
+   POA_GNOME_GtkHTML_Editor_Listener__vepv;
+   typedef struct
+   {
+      void *_private;
+      POA_GNOME_GtkHTML_Editor_Listener__vepv *vepv;
+   }
+   POA_GNOME_GtkHTML_Editor_Listener;
+   extern void POA_GNOME_GtkHTML_Editor_Listener__init(PortableServer_Servant
+						       servant,
+						       CORBA_Environment *
+						       ev);
+   extern void POA_GNOME_GtkHTML_Editor_Listener__fini(PortableServer_Servant
+						       servant,
+						       CORBA_Environment *
+						       ev);
+#endif				/* _defined_POA_GNOME_GtkHTML_Editor_Listener */
+#ifndef _defined_POA_GNOME_GtkHTML_Editor_Engine
+#define _defined_POA_GNOME_GtkHTML_Editor_Engine 1
+   typedef struct
+   {
+      void *_private;
+       GNOME_GtkHTML_Editor_Listener(*_get_listener) (PortableServer_Servant
+						      _servant,
+						      CORBA_Environment * ev);
+      void (*_set_listener) (PortableServer_Servant _servant,
+			     const GNOME_GtkHTML_Editor_Listener value,
+			     CORBA_Environment * ev);
+       CORBA_boolean(*runCommand) (PortableServer_Servant _servant,
+				   const CORBA_char * command,
+				   CORBA_Environment * ev);
+       CORBA_string(*getParagraphData) (PortableServer_Servant _servant,
+					const CORBA_char * key,
+					CORBA_Environment * ev);
+      void (*setParagraphData) (PortableServer_Servant _servant,
+				const CORBA_char * key,
+				const CORBA_char * value,
+				CORBA_Environment * ev);
+      void (*setObjectDataByType) (PortableServer_Servant _servant,
+				   const CORBA_char * type_name,
+				   const CORBA_char * key,
+				   const CORBA_char * data,
+				   CORBA_Environment * ev);
+       CORBA_boolean(*searchByData) (PortableServer_Servant _servant,
+				     const CORBA_long level,
+				     const CORBA_char * klass,
+				     const CORBA_char * key,
+				     const CORBA_char * value,
+				     CORBA_Environment * ev);
+       CORBA_boolean(*isParagraphEmpty) (PortableServer_Servant _servant,
+					 CORBA_Environment * ev);
+       CORBA_boolean(*isPreviousParagraphEmpty) (PortableServer_Servant
+						 _servant,
+						 CORBA_Environment * ev);
+      void (*insertHTML) (PortableServer_Servant _servant,
+			  const CORBA_char * html, CORBA_Environment * ev);
+      void (*freeze) (PortableServer_Servant _servant,
+		      CORBA_Environment * ev);
+      void (*thaw) (PortableServer_Servant _servant, CORBA_Environment * ev);
+      void (*undoBegin) (PortableServer_Servant _servant,
+			 const CORBA_char * undo_name,
+			 const CORBA_char * redo_name,
+			 CORBA_Environment * ev);
+      void (*undoEnd) (PortableServer_Servant _servant,
+		       CORBA_Environment * ev);
+      void (*ignoreWord) (PortableServer_Servant _servant,
+			  const CORBA_char * word, CORBA_Environment * ev);
+      void (*dropUndo) (PortableServer_Servant _servant,
+			CORBA_Environment * ev);
+       CORBA_boolean(*hasUndo) (PortableServer_Servant _servant,
+				CORBA_Environment * ev);
+   }
+   POA_GNOME_GtkHTML_Editor_Engine__epv;
+   typedef struct
+   {
+      PortableServer_ServantBase__epv *_base_epv;
+      POA_Bonobo_Unknown__epv *Bonobo_Unknown_epv;
+      POA_GNOME_GtkHTML_Editor_Engine__epv *GNOME_GtkHTML_Editor_Engine_epv;
+   }
+   POA_GNOME_GtkHTML_Editor_Engine__vepv;
+   typedef struct
+   {
+      void *_private;
+      POA_GNOME_GtkHTML_Editor_Engine__vepv *vepv;
+   }
+   POA_GNOME_GtkHTML_Editor_Engine;
+   extern void POA_GNOME_GtkHTML_Editor_Engine__init(PortableServer_Servant
+						     servant,
+						     CORBA_Environment * ev);
+   extern void POA_GNOME_GtkHTML_Editor_Engine__fini(PortableServer_Servant
+						     servant,
+						     CORBA_Environment * ev);
+#endif				/* _defined_POA_GNOME_GtkHTML_Editor_Engine */
+
+/** skel prototypes **/
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Listener_event
+      (POA_GNOME_GtkHTML_Editor_Listener * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_any * (*_impl_event) (PortableServer_Servant _servant,
+				   const CORBA_char * name,
+				   const CORBA_any * arg,
+				   CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__get_listener
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       GNOME_GtkHTML_Editor_Listener(*_impl__get_listener)
+       (PortableServer_Servant _servant, CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__set_listener
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl__set_listener) (PortableServer_Servant _servant,
+				    const GNOME_GtkHTML_Editor_Listener value,
+				    CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_runCommand
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_boolean(*_impl_runCommand) (PortableServer_Servant _servant,
+					 const CORBA_char * command,
+					 CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_getParagraphData
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_string(*_impl_getParagraphData) (PortableServer_Servant _servant,
+					      const CORBA_char * key,
+					      CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setParagraphData
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_setParagraphData) (PortableServer_Servant _servant,
+				       const CORBA_char * key,
+				       const CORBA_char * value,
+				       CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setObjectDataByType
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_setObjectDataByType) (PortableServer_Servant _servant,
+					  const CORBA_char * type_name,
+					  const CORBA_char * key,
+					  const CORBA_char * data,
+					  CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_searchByData
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_boolean(*_impl_searchByData) (PortableServer_Servant _servant,
+					   const CORBA_long level,
+					   const CORBA_char * klass,
+					   const CORBA_char * key,
+					   const CORBA_char * value,
+					   CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isParagraphEmpty
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_boolean(*_impl_isParagraphEmpty) (PortableServer_Servant
+					       _servant,
+					       CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_boolean(*_impl_isPreviousParagraphEmpty) (PortableServer_Servant
+						       _servant,
+						       CORBA_Environment *
+						       ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_insertHTML
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_insertHTML) (PortableServer_Servant _servant,
+				 const CORBA_char * html,
+				 CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_freeze
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_freeze) (PortableServer_Servant _servant,
+			     CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_thaw
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_thaw) (PortableServer_Servant _servant,
+			   CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoBegin
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_undoBegin) (PortableServer_Servant _servant,
+				const CORBA_char * undo_name,
+				const CORBA_char * redo_name,
+				CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoEnd
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_undoEnd) (PortableServer_Servant _servant,
+			      CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_ignoreWord
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_ignoreWord) (PortableServer_Servant _servant,
+				 const CORBA_char * word,
+				 CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_dropUndo
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_dropUndo) (PortableServer_Servant _servant,
+			       CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_hasUndo
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_boolean(*_impl_hasUndo) (PortableServer_Servant _servant,
+				      CORBA_Environment * ev));
+
+/** stub prototypes **/
+#define GNOME_GtkHTML_Editor_Listener_ref Bonobo_Unknown_ref
+#define GNOME_GtkHTML_Editor_Listener_unref Bonobo_Unknown_unref
+#define GNOME_GtkHTML_Editor_Listener_queryInterface Bonobo_Unknown_queryInterface
+   CORBA_any
+      *GNOME_GtkHTML_Editor_Listener_event(GNOME_GtkHTML_Editor_Listener _obj,
+					   const CORBA_char * name,
+					   const CORBA_any * arg,
+					   CORBA_Environment * ev);
+#define GNOME_GtkHTML_Editor_Engine_ref Bonobo_Unknown_ref
+#define GNOME_GtkHTML_Editor_Engine_unref Bonobo_Unknown_unref
+#define GNOME_GtkHTML_Editor_Engine_queryInterface Bonobo_Unknown_queryInterface
+   GNOME_GtkHTML_Editor_Listener
+      GNOME_GtkHTML_Editor_Engine__get_listener(GNOME_GtkHTML_Editor_Engine
+						_obj, CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine__set_listener(GNOME_GtkHTML_Editor_Engine
+						  _obj,
+						  const
+						  GNOME_GtkHTML_Editor_Listener
+						  value,
+						  CORBA_Environment * ev);
+   CORBA_boolean
+      GNOME_GtkHTML_Editor_Engine_runCommand(GNOME_GtkHTML_Editor_Engine _obj,
+					     const CORBA_char * command,
+					     CORBA_Environment * ev);
+   CORBA_string
+      GNOME_GtkHTML_Editor_Engine_getParagraphData(GNOME_GtkHTML_Editor_Engine
+						   _obj,
+						   const CORBA_char * key,
+						   CORBA_Environment * ev);
+   void
+      GNOME_GtkHTML_Editor_Engine_setParagraphData(GNOME_GtkHTML_Editor_Engine
+						   _obj,
+						   const CORBA_char * key,
+						   const CORBA_char * value,
+						   CORBA_Environment * ev);
+   void
+      GNOME_GtkHTML_Editor_Engine_setObjectDataByType
+      (GNOME_GtkHTML_Editor_Engine _obj, const CORBA_char * type_name,
+       const CORBA_char * key, const CORBA_char * data,
+       CORBA_Environment * ev);
+   CORBA_boolean
+      GNOME_GtkHTML_Editor_Engine_searchByData(GNOME_GtkHTML_Editor_Engine
+					       _obj, const CORBA_long level,
+					       const CORBA_char * klass,
+					       const CORBA_char * key,
+					       const CORBA_char * value,
+					       CORBA_Environment * ev);
+   CORBA_boolean
+      GNOME_GtkHTML_Editor_Engine_isParagraphEmpty(GNOME_GtkHTML_Editor_Engine
+						   _obj,
+						   CORBA_Environment * ev);
+   CORBA_boolean
+      GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty
+      (GNOME_GtkHTML_Editor_Engine _obj, CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_insertHTML(GNOME_GtkHTML_Editor_Engine
+					       _obj, const CORBA_char * html,
+					       CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_freeze(GNOME_GtkHTML_Editor_Engine _obj,
+					   CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_thaw(GNOME_GtkHTML_Editor_Engine _obj,
+					 CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_undoBegin(GNOME_GtkHTML_Editor_Engine
+					      _obj,
+					      const CORBA_char * undo_name,
+					      const CORBA_char * redo_name,
+					      CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_undoEnd(GNOME_GtkHTML_Editor_Engine _obj,
+					    CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_ignoreWord(GNOME_GtkHTML_Editor_Engine
+					       _obj, const CORBA_char * word,
+					       CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_dropUndo(GNOME_GtkHTML_Editor_Engine _obj,
+					     CORBA_Environment * ev);
+   CORBA_boolean
+      GNOME_GtkHTML_Editor_Engine_hasUndo(GNOME_GtkHTML_Editor_Engine _obj,
+					  CORBA_Environment * ev);
+
+/** more internals **/
+#if !defined(MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_0)
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_0 'E'
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_1 'd'
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_2 'i'
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_3 't'
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_4 'o'
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_5 'r'
+#endif
+#include <orbit/orb-core/orbit-interface.h>
+
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   ORBit_IInterface GNOME_GtkHTML_Editor_Listener__iinterface;
+#define GNOME_GtkHTML_Editor_Listener_IMETHODS_LEN 1
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   ORBit_IMethod
+      GNOME_GtkHTML_Editor_Listener__imethods
+      [GNOME_GtkHTML_Editor_Listener_IMETHODS_LEN];
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   ORBit_IInterface GNOME_GtkHTML_Editor_Engine__iinterface;
+#define GNOME_GtkHTML_Editor_Engine_IMETHODS_LEN 17
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   ORBit_IMethod
+      GNOME_GtkHTML_Editor_Engine__imethods
+      [GNOME_GtkHTML_Editor_Engine_IMETHODS_LEN];
+#ifdef __cplusplus
+}
+#endif				/* __cplusplus */
+
+#ifndef EXCLUDE_ORBIT_H
+#include <orbit/orbit.h>
+
+#endif				/* EXCLUDE_ORBIT_H */
+#endif
+#undef ORBIT_IDL_SERIAL
diff -Nur vim63/src/gui.c vim63-bonobo/src/gui.c
--- vim63/src/gui.c	2005-09-09 20:11:10.562758000 +0200
+++ vim63-bonobo/src/gui.c	2005-09-09 20:14:02.733584696 +0200
@@ -440,8 +440,12 @@
      * Create the GUI shell.
      */
     gui.in_use = TRUE;		/* Must be set after menus have been set up */
+#ifdef FEAT_GUI_COMPONENT
+    vim_bonobo_wait_for_instantiation();
+#else
     if (gui_mch_init() == FAIL)
 	goto error;
+#endif
 
     /* Avoid a delay for an error message that was printed in the terminal
      * where Vim was started. */
@@ -4193,8 +4197,8 @@
 	add_to_input_buf(st, 8);
 #ifdef FEAT_GUI_GTK
 	/* Need to wake up the main loop */
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
+	if (MAIN_LEVEL() > 0)
+	    MAIN_QUIT();
 #endif
     }
 }
@@ -4407,8 +4411,12 @@
     int
 no_console_input()
 {
-    return ((!gui.in_use || gui.starting)
-# ifndef NO_CONSOLE
+    return ((!gui.in_use || gui.starting || !gui.shell_created
+#ifdef FEAT_GUI_COMPONENT
+            || gui.processing_call
+#endif
+                )
+# if !defined(NO_CONSOLE) && !defined(FEAT_GUI_COMPONENT)
 	    && !isatty(0) && !isatty(2)
 # endif
 	    );
diff -Nur vim63/src/gui.c.orig vim63-bonobo/src/gui.c.orig
--- vim63/src/gui.c.orig	2005-09-09 20:11:10.048836000 +0200
+++ vim63-bonobo/src/gui.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,4746 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved		by Bram Moolenaar
- *				GUI/Motif support by Robert Webb
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-
-#include "vim.h"
-
-/* Structure containing all the GUI information */
-gui_T gui;
-
-#if defined(FEAT_MBYTE) && !defined(HAVE_GTK2)
-static void set_guifontwide __ARGS((char_u *font_name));
-#endif
-static void gui_check_pos __ARGS((void));
-static void gui_position_components __ARGS((int));
-static void gui_outstr __ARGS((char_u *, int));
-static int gui_screenchar __ARGS((int off, int flags, guicolor_T fg, guicolor_T bg, int back));
-#ifdef HAVE_GTK2
-static int gui_screenstr __ARGS((int off, int len, int flags, guicolor_T fg, guicolor_T bg, int back));
-#endif
-static void gui_delete_lines __ARGS((int row, int count));
-static void gui_insert_lines __ARGS((int row, int count));
-static void fill_mouse_coord __ARGS((char_u *p, int col, int row));
-static void gui_do_scrollbar __ARGS((win_T *wp, int which, int enable));
-static colnr_T scroll_line_len __ARGS((linenr_T lnum));
-static void gui_update_horiz_scrollbar __ARGS((int));
-static win_T *xy2win __ARGS((int x, int y));
-
-static int can_update_cursor = TRUE; /* can display the cursor */
-
-/*
- * The Athena scrollbars can move the thumb to after the end of the scrollbar,
- * this makes the thumb indicate the part of the text that is shown.  Motif
- * can't do this.
- */
-#if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MAC)
-# define SCROLL_PAST_END
-#endif
-
-/*
- * gui_start -- Called when user wants to start the GUI.
- *
- * Careful: This function can be called recursively when there is a ":gui"
- * command in the .gvimrc file.  Only the first call should fork, not the
- * recursive call.
- */
-    void
-gui_start()
-{
-    char_u	*old_term;
-#if defined(UNIX) && !defined(__BEOS__) && !defined(MACOS_X)
-# define MAY_FORK
-    int		dofork = TRUE;
-#endif
-    static int	recursive = 0;
-
-    old_term = vim_strsave(T_NAME);
-
-    /*
-     * Set_termname() will call gui_init() to start the GUI.
-     * Set the "starting" flag, to indicate that the GUI will start.
-     *
-     * We don't want to open the GUI shell until after we've read .gvimrc,
-     * otherwise we don't know what font we will use, and hence we don't know
-     * what size the shell should be.  So if there are errors in the .gvimrc
-     * file, they will have to go to the terminal: Set full_screen to FALSE.
-     * full_screen will be set to TRUE again by a successful termcapinit().
-     */
-    settmode(TMODE_COOK);		/* stop RAW mode */
-    if (full_screen)
-	cursor_on();			/* needed for ":gui" in .vimrc */
-    gui.starting = TRUE;
-    full_screen = FALSE;
-
-#ifdef MAY_FORK
-    if (!gui.dofork || vim_strchr(p_go, GO_FORG) || recursive)
-	dofork = FALSE;
-#endif
-    ++recursive;
-
-    termcapinit((char_u *)"builtin_gui");
-    gui.starting = recursive - 1;
-
-    if (!gui.in_use)			/* failed to start GUI */
-    {
-	termcapinit(old_term);		/* back to old term settings */
-	settmode(TMODE_RAW);		/* restart RAW mode */
-#ifdef FEAT_TITLE
-	set_title_defaults();		/* set 'title' and 'icon' again */
-#endif
-    }
-
-    vim_free(old_term);
-
-#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
-    if (gui.in_use)
-	/* Display error messages in a dialog now. */
-	display_errors();
-#endif
-
-#if defined(MAY_FORK) && !defined(__QNXNTO__)
-    /*
-     * Quit the current process and continue in the child.
-     * Makes "gvim file" disconnect from the shell it was started in.
-     * Don't do this when Vim was started with "-f" or the 'f' flag is present
-     * in 'guioptions'.
-     */
-    if (gui.in_use && dofork)
-    {
-	int	pipefd[2];	/* pipe between parent and child */
-	int	pipe_error;
-	char	dummy;
-	pid_t	pid = -1;
-
-	/* Setup a pipe between the child and the parent, so that the parent
-	 * knows when the child has done the setsid() call and is allowed to
-	 * exit. */
-	pipe_error = (pipe(pipefd) < 0);
-	pid = fork();
-	if (pid > 0)	    /* Parent */
-	{
-	    /* Give the child some time to do the setsid(), otherwise the
-	     * exit() may kill the child too (when starting gvim from inside a
-	     * gvim). */
-	    if (pipe_error)
-		ui_delay(300L, TRUE);
-	    else
-	    {
-		/* The read returns when the child closes the pipe (or when
-		 * the child dies for some reason). */
-		close(pipefd[1]);
-		(void)read(pipefd[0], &dummy, (size_t)1);
-		close(pipefd[0]);
-	    }
-
-	    /* When swapping screens we may need to go to the next line, e.g.,
-	     * after a hit-enter prompt and using ":gui". */
-	    if (newline_on_exit)
-		mch_errmsg("\r\n");
-
-	    /*
-	     * The parent must skip the normal exit() processing, the child
-	     * will do it.  For example, GTK messes up signals when exiting.
-	     */
-	    _exit(0);
-	}
-
-# if defined(HAVE_SETSID) || defined(HAVE_SETPGID)
-	/*
-	 * Change our process group.  On some systems/shells a CTRL-C in the
-	 * shell where Vim was started would otherwise kill gvim!
-	 */
-	if (pid == 0)	    /* child */
-#  if defined(HAVE_SETSID)
-	    (void)setsid();
-#  else
-	    (void)setpgid(0, 0);
-#  endif
-# endif
-	if (!pipe_error)
-	{
-	    close(pipefd[0]);
-	    close(pipefd[1]);
-	}
-
-# if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
-	/* Tell the session manager our new PID */
-	gui_mch_forked();
-# endif
-    }
-#else
-# if defined(__QNXNTO__)
-    if (gui.in_use && dofork)
-	procmgr_daemon(0, PROCMGR_DAEMON_KEEPUMASK | PROCMGR_DAEMON_NOCHDIR |
-		PROCMGR_DAEMON_NOCLOSE | PROCMGR_DAEMON_NODEVNULL);
-# endif
-#endif
-
-#ifdef FEAT_AUTOCMD
-    /* If the GUI started successfully, trigger the GUIEnter event */
-    if (gui.in_use)
-	apply_autocmds(EVENT_GUIENTER, NULL, NULL, FALSE, curbuf);
-#endif
-
-    --recursive;
-}
-
-/*
- * Call this when vim starts up, whether or not the GUI is started
- */
-    void
-gui_prepare(argc, argv)
-    int	    *argc;
-    char    **argv;
-{
-    gui.in_use = FALSE;		    /* No GUI yet (maybe later) */
-    gui.starting = FALSE;	    /* No GUI yet (maybe later) */
-    gui_mch_prepare(argc, argv);
-}
-
-/*
- * Try initializing the GUI and check if it can be started.
- * Used from main() to check early if "vim -g" can start the GUI.
- * Used from gui_init() to prepare for starting the GUI.
- * Returns FAIL or OK.
- */
-    int
-gui_init_check()
-{
-    static int result = MAYBE;
-
-    if (result != MAYBE)
-    {
-	if (result == FAIL)
-	    EMSG(_("E229: Cannot start the GUI"));
-	return result;
-    }
-
-    gui.shell_created = FALSE;
-    gui.dying = FALSE;
-    gui.in_focus = TRUE;		/* so the guicursor setting works */
-    gui.dragged_sb = SBAR_NONE;
-    gui.dragged_wp = NULL;
-    gui.pointer_hidden = FALSE;
-    gui.col = 0;
-    gui.row = 0;
-    gui.num_cols = Columns;
-    gui.num_rows = Rows;
-
-    gui.cursor_is_valid = FALSE;
-    gui.scroll_region_top = 0;
-    gui.scroll_region_bot = Rows - 1;
-    gui.scroll_region_left = 0;
-    gui.scroll_region_right = Columns - 1;
-    gui.highlight_mask = HL_NORMAL;
-    gui.char_width = 1;
-    gui.char_height = 1;
-    gui.char_ascent = 0;
-    gui.border_width = 0;
-
-    gui.norm_font = NOFONT;
-#ifndef HAVE_GTK2
-    gui.bold_font = NOFONT;
-    gui.ital_font = NOFONT;
-    gui.boldital_font = NOFONT;
-# ifdef FEAT_XFONTSET
-    gui.fontset = NOFONTSET;
-# endif
-#endif
-
-#ifdef FEAT_MENU
-# ifndef HAVE_GTK2
-#  ifdef FONTSET_ALWAYS
-    gui.menu_fontset = NOFONTSET;
-#  else
-    gui.menu_font = NOFONT;
-#  endif
-# endif
-    gui.menu_is_active = TRUE;	    /* default: include menu */
-# ifndef FEAT_GUI_GTK
-    gui.menu_height = MENU_DEFAULT_HEIGHT;
-    gui.menu_width = 0;
-# endif
-#endif
-#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA))
-    gui.toolbar_height = 0;
-#endif
-#if defined(FEAT_FOOTER) && defined(FEAT_GUI_MOTIF)
-    gui.footer_height = 0;
-#endif
-#ifdef FEAT_BEVAL_TIP
-    gui.tooltip_fontset = NOFONTSET;
-#endif
-
-    gui.scrollbar_width = gui.scrollbar_height = SB_DEFAULT_WIDTH;
-    gui.prev_wrap = -1;
-
-#ifdef ALWAYS_USE_GUI
-    result = OK;
-#else
-    result = gui_mch_init_check();
-#endif
-    return result;
-}
-
-/*
- * This is the call which starts the GUI.
- */
-    void
-gui_init()
-{
-    win_T	*wp;
-    static int	recursive = 0;
-
-    /*
-     * It's possible to use ":gui" in a .gvimrc file.  The first halve of this
-     * function will then be executed at the first call, the rest by the
-     * recursive call.  This allow the shell to be opened halfway reading a
-     * gvimrc file.
-     */
-    if (!recursive)
-    {
-	++recursive;
-
-	clip_init(TRUE);
-
-	/* If can't initialize, don't try doing the rest */
-	if (gui_init_check() == FAIL)
-	{
-	    --recursive;
-	    clip_init(FALSE);
-	    return;
-	}
-
-	/*
-	 * Set up system-wide default menus.
-	 */
-#if defined(SYS_MENU_FILE) && defined(FEAT_MENU)
-	if (vim_strchr(p_go, GO_NOSYSMENU) == NULL)
-	{
-	    sys_menu = TRUE;
-	    do_source((char_u *)SYS_MENU_FILE, FALSE, FALSE);
-	    sys_menu = FALSE;
-	}
-#endif
-
-	/*
-	 * Switch on the mouse by default, unless the user changed it already.
-	 * This can then be changed in the .gvimrc.
-	 */
-	if (!option_was_set((char_u *)"mouse"))
-	    set_string_option_direct((char_u *)"mouse", -1,
-						     (char_u *)"a", OPT_FREE);
-
-	/*
-	 * If -U option given, use only the initializations from that file and
-	 * nothing else.  Skip all initializations for "-U NONE" or "-u NORC".
-	 */
-	if (use_gvimrc != NULL)
-	{
-	    if (STRCMP(use_gvimrc, "NONE") != 0
-		    && STRCMP(use_gvimrc, "NORC") != 0
-		    && do_source(use_gvimrc, FALSE, FALSE) != OK)
-		EMSG2(_("E230: Cannot read from \"%s\""), use_gvimrc);
-	}
-	else
-	{
-	    /*
-	     * Get system wide defaults for gvim, only when file name defined.
-	     */
-#ifdef SYS_GVIMRC_FILE
-	    do_source((char_u *)SYS_GVIMRC_FILE, FALSE, FALSE);
-#endif
-
-	    /*
-	     * Try to read GUI initialization commands from the following
-	     * places:
-	     * - environment variable GVIMINIT
-	     * - the user gvimrc file (~/.gvimrc)
-	     * - the second user gvimrc file ($VIM/.gvimrc for Dos)
-	     * - the third user gvimrc file ($VIM/.gvimrc for Amiga)
-	     * The first that exists is used, the rest is ignored.
-	     */
-	    if (process_env((char_u *)"GVIMINIT", FALSE) == FAIL
-		 && do_source((char_u *)USR_GVIMRC_FILE, TRUE, FALSE) == FAIL
-#ifdef USR_GVIMRC_FILE2
-		 && do_source((char_u *)USR_GVIMRC_FILE2, TRUE, FALSE) == FAIL
-#endif
-				)
-	    {
-#ifdef USR_GVIMRC_FILE3
-		(void)do_source((char_u *)USR_GVIMRC_FILE3, TRUE, FALSE);
-#endif
-	    }
-
-	    /*
-	     * Read initialization commands from ".gvimrc" in current
-	     * directory.  This is only done if the 'exrc' option is set.
-	     * Because of security reasons we disallow shell and write
-	     * commands now, except for unix if the file is owned by the user
-	     * or 'secure' option has been reset in environment of global
-	     * ".gvimrc".
-	     * Only do this if GVIMRC_FILE is not the same as USR_GVIMRC_FILE,
-	     * USR_GVIMRC_FILE2, USR_GVIMRC_FILE3 or SYS_GVIMRC_FILE.
-	     */
-	    if (p_exrc)
-	    {
-#ifdef UNIX
-		{
-		    struct stat s;
-
-		    /* if ".gvimrc" file is not owned by user, set 'secure'
-		     * mode */
-		    if (mch_stat(GVIMRC_FILE, &s) || s.st_uid != getuid())
-			secure = p_secure;
-		}
-#else
-		secure = p_secure;
-#endif
-
-		if (       fullpathcmp((char_u *)USR_GVIMRC_FILE,
-				     (char_u *)GVIMRC_FILE, FALSE) != FPC_SAME
-#ifdef SYS_GVIMRC_FILE
-			&& fullpathcmp((char_u *)SYS_GVIMRC_FILE,
-				     (char_u *)GVIMRC_FILE, FALSE) != FPC_SAME
-#endif
-#ifdef USR_GVIMRC_FILE2
-			&& fullpathcmp((char_u *)USR_GVIMRC_FILE2,
-				     (char_u *)GVIMRC_FILE, FALSE) != FPC_SAME
-#endif
-#ifdef USR_GVIMRC_FILE3
-			&& fullpathcmp((char_u *)USR_GVIMRC_FILE3,
-				     (char_u *)GVIMRC_FILE, FALSE) != FPC_SAME
-#endif
-			)
-		    do_source((char_u *)GVIMRC_FILE, TRUE, FALSE);
-
-		if (secure == 2)
-		    need_wait_return = TRUE;
-		secure = 0;
-	    }
-	}
-
-	if (need_wait_return || msg_didany)
-	    wait_return(TRUE);
-
-	--recursive;
-    }
-
-    /* If recursive call opened the shell, return here from the first call */
-    if (gui.in_use)
-	return;
-
-    /*
-     * Create the GUI shell.
-     */
-    gui.in_use = TRUE;		/* Must be set after menus have been set up */
-    if (gui_mch_init() == FAIL)
-	goto error;
-
-    /* Avoid a delay for an error message that was printed in the terminal
-     * where Vim was started. */
-    emsg_on_display = FALSE;
-    msg_scrolled = 0;
-    need_wait_return = FALSE;
-    msg_didany = FALSE;
-
-    /*
-     * Check validity of any generic resources that may have been loaded.
-     */
-    if (gui.border_width < 0)
-	gui.border_width = 0;
-
-    /*
-     * Set up the fonts.  First use a font specified with "-fn" or "-font".
-     */
-    if (font_argument != NULL)
-	set_option_value((char_u *)"gfn", 0L, (char_u *)font_argument, 0);
-    if (
-#ifdef FEAT_XFONTSET
-	    (*p_guifontset == NUL
-	     || gui_init_font(p_guifontset, TRUE) == FAIL) &&
-#endif
-	    gui_init_font(*p_guifont == NUL ? hl_get_font_name()
-						  : p_guifont, FALSE) == FAIL)
-    {
-	EMSG(_("E665: Cannot start GUI, no valid font found"));
-	goto error2;
-    }
-#ifdef FEAT_MBYTE
-    if (gui_get_wide_font() == FAIL)
-	EMSG(_("E231: 'guifontwide' invalid"));
-#endif
-
-    gui.num_cols = Columns;
-    gui.num_rows = Rows;
-    gui_reset_scroll_region();
-
-    /* Create initial scrollbars */
-    FOR_ALL_WINDOWS(wp)
-    {
-	gui_create_scrollbar(&wp->w_scrollbars[SBAR_LEFT], SBAR_LEFT, wp);
-	gui_create_scrollbar(&wp->w_scrollbars[SBAR_RIGHT], SBAR_RIGHT, wp);
-    }
-    gui_create_scrollbar(&gui.bottom_sbar, SBAR_BOTTOM, NULL);
-
-#ifdef FEAT_MENU
-    gui_create_initial_menus(root_menu);
-#endif
-#ifdef FEAT_SUN_WORKSHOP
-    if (usingSunWorkShop)
-	workshop_init();
-#endif
-#ifdef FEAT_SIGN_ICONS
-    sign_gui_started();
-#endif
-
-    /* Configure the desired menu and scrollbars */
-    gui_init_which_components(NULL);
-
-    /* All components of the GUI have been created now */
-    gui.shell_created = TRUE;
-
-#ifndef FEAT_GUI_GTK
-    /* Set the shell size, adjusted for the screen size.  For GTK this only
-     * works after the shell has been opened, thus it is further down. */
-    gui_set_shellsize(FALSE, TRUE);
-#endif
-#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)
-    /* Need to set the size of the menubar after all the menus have been
-     * created. */
-    gui_mch_compute_menu_height((Widget)0);
-#endif
-
-    /*
-     * Actually open the GUI shell.
-     */
-    if (gui_mch_open() != FAIL)
-    {
-#ifdef FEAT_TITLE
-	maketitle();
-	resettitle();
-#endif
-	init_gui_options();
-#ifdef FEAT_ARABIC
-	/* Our GUI can't do bidi. */
-	p_tbidi = FALSE;
-#endif
-#ifdef FEAT_GUI_GTK
-	/* Give GTK+ a chance to put all widget's into place. */
-	gui_mch_update();
-	/* Now make sure the shell fits on the screen. */
-	gui_set_shellsize(FALSE, TRUE);
-#endif
-#ifdef FEAT_NETBEANS_INTG
-	if (starting == 0 && usingNetbeans)
-	    /* Tell the client that it can start sending commands. */
-	    netbeans_startup_done();
-#endif
-#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
-	if (!im_xim_isvalid_imactivate())
-	    EMSG(_("E599: Value of 'imactivatekey' is invalid"));
-#endif
-
-	return;
-    }
-
-error2:
-#ifdef FEAT_GUI_X11
-    /* undo gui_mch_init() */
-    gui_mch_uninit();
-#endif
-
-error:
-    gui.in_use = FALSE;
-    clip_init(FALSE);
-}
-
-
-    void
-gui_exit(rc)
-    int		rc;
-{
-#ifndef __BEOS__
-    /* don't free the fonts, it leads to a BUS error
-     * richard@whitequeen.com Jul 99 */
-    free_highlight_fonts();
-#endif
-    gui.in_use = FALSE;
-    gui_mch_exit(rc);
-}
-
-#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(FEAT_GUI_MSWIN) \
-	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(PROTO)
-/*
- * Called when the GUI shell is closed by the user.  If there are no changed
- * files Vim exits, otherwise there will be a dialog to ask the user what to
- * do.
- * When this function returns, Vim should NOT exit!
- */
-    void
-gui_shell_closed()
-{
-    cmdmod_T	    save_cmdmod;
-
-    save_cmdmod = cmdmod;
-
-    /* Only exit when there are no changed files */
-    exiting = TRUE;
-# ifdef FEAT_BROWSE
-    cmdmod.browse = TRUE;
-# endif
-# if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-    cmdmod.confirm = TRUE;
-# endif
-    /* If there are changed buffers, present the user with a dialog if
-     * possible, otherwise give an error message. */
-    if (!check_changed_any(FALSE))
-	getout(0);
-
-    exiting = FALSE;
-    cmdmod = save_cmdmod;
-    setcursor();		/* position cursor */
-    out_flush();
-}
-#endif
-
-/*
- * Set the font.  "font_list" is a a comma separated list of font names.  The
- * first font name that works is used.  If none is found, use the default
- * font.
- * If "fontset" is TRUE, the "font_list" is used as one name for the fontset.
- * Return OK when able to set the font.  When it failed FAIL is returned and
- * the fonts are unchanged.
- */
-/*ARGSUSED*/
-    int
-gui_init_font(font_list, fontset)
-    char_u	*font_list;
-    int		fontset;
-{
-#define FONTLEN 320
-    char_u	font_name[FONTLEN];
-    int		font_list_empty = FALSE;
-    int		ret = FAIL;
-
-    if (!gui.in_use)
-	return FAIL;
-
-    font_name[0] = NUL;
-    if (*font_list == NUL)
-	font_list_empty = TRUE;
-    else
-    {
-#ifdef FEAT_XFONTSET
-	/* When using a fontset, the whole list of fonts is one name. */
-	if (fontset)
-	    ret = gui_mch_init_font(font_list, TRUE);
-	else
-#endif
-	    while (*font_list != NUL)
-	    {
-		/* Isolate one comma separated font name. */
-		(void)copy_option_part(&font_list, font_name, FONTLEN, ",");
-
-		/* Careful!!!  The Win32 version of gui_mch_init_font(), when
-		 * called with "*" will change p_guifont to the selected font
-		 * name, which frees the old value.  This makes font_list
-		 * invalid.  Thus when OK is returned here, font_list must no
-		 * longer be used! */
-		if (gui_mch_init_font(font_name, FALSE) == OK)
-		{
-#if defined(FEAT_MBYTE) && !defined(HAVE_GTK2)
-		    /* If it's a Unicode font, try setting 'guifontwide' to a
-		     * similar double-width font. */
-		    if ((p_guifontwide == NULL || *p_guifontwide == NUL)
-				&& strstr((char *)font_name, "10646") != NULL)
-			set_guifontwide(font_name);
-#endif
-		    ret = OK;
-		    break;
-		}
-	    }
-    }
-
-    if (ret != OK
-	    && STRCMP(font_list, "*") != 0
-	    && (font_list_empty || gui.norm_font == NOFONT))
-    {
-	/*
-	 * Couldn't load any font in 'font_list', keep the current font if
-	 * there is one.  If 'font_list' is empty, or if there is no current
-	 * font, tell gui_mch_init_font() to try to find a font we can load.
-	 */
-	ret = gui_mch_init_font(NULL, FALSE);
-    }
-
-    if (ret == OK)
-    {
-#ifndef HAVE_GTK2
-	/* Set normal font as current font */
-# ifdef FEAT_XFONTSET
-	if (gui.fontset != NOFONTSET)
-	    gui_mch_set_fontset(gui.fontset);
-	else
-# endif
-	    gui_mch_set_font(gui.norm_font);
-#endif
-	gui_set_shellsize(FALSE,
-#ifdef MSWIN
-		TRUE
-#else
-		FALSE
-#endif
-		);
-    }
-
-    return ret;
-}
-
-#if defined(FEAT_MBYTE) || defined(PROTO)
-# ifndef HAVE_GTK2
-/*
- * Try setting 'guifontwide' to a font twice as wide as "name".
- */
-    static void
-set_guifontwide(name)
-    char_u	*name;
-{
-    int		i = 0;
-    char_u	wide_name[FONTLEN + 10]; /* room for 2 * width and '*' */
-    char_u	*wp = NULL;
-    char_u	*p;
-    GuiFont	font;
-
-    wp = wide_name;
-    for (p = name; *p != NUL; ++p)
-    {
-	*wp++ = *p;
-	if (*p == '-')
-	{
-	    ++i;
-	    if (i == 6)		/* font type: change "--" to "-*-" */
-	    {
-		if (p[1] == '-')
-		    *wp++ = '*';
-	    }
-	    else if (i == 12)	/* found the width */
-	    {
-		++p;
-		i = getdigits(&p);
-		if (i != 0)
-		{
-		    /* Double the width specification. */
-		    sprintf((char *)wp, "%d%s", i * 2, p);
-		    font = gui_mch_get_font(wide_name, FALSE);
-		    if (font != NOFONT)
-		    {
-			gui.wide_font = font;
-			set_string_option_direct((char_u *)"gfw", -1,
-							 wide_name, OPT_FREE);
-		    }
-		}
-		break;
-	    }
-	}
-    }
-}
-# endif /* !HAVE_GTK2 */
-
-/*
- * Get the font for 'guifontwide'.
- * Return FAIL for an invalid font name.
- */
-    int
-gui_get_wide_font()
-{
-    GuiFont	font = NOFONT;
-    char_u	font_name[FONTLEN];
-    char_u	*p;
-
-    if (!gui.in_use)	    /* Can't allocate font yet, assume it's OK. */
-	return OK;	    /* Will give an error message later. */
-
-    if (p_guifontwide != NULL && *p_guifontwide != NUL)
-    {
-	for (p = p_guifontwide; *p != NUL; )
-	{
-	    /* Isolate one comma separated font name. */
-	    (void)copy_option_part(&p, font_name, FONTLEN, ",");
-	    font = gui_mch_get_font(font_name, FALSE);
-	    if (font != NOFONT)
-		break;
-	}
-	if (font == NOFONT)
-	    return FAIL;
-    }
-
-    gui_mch_free_font(gui.wide_font);
-#ifdef HAVE_GTK2
-    /* Avoid unnecessary overhead if 'guifontwide' is equal to 'guifont'. */
-    if (font != NOFONT && gui.norm_font != NOFONT
-			 && pango_font_description_equal(font, gui.norm_font))
-    {
-	gui.wide_font = NOFONT;
-	gui_mch_free_font(font);
-    }
-    else
-#endif
-	gui.wide_font = font;
-    return OK;
-}
-#endif
-
-    void
-gui_set_cursor(row, col)
-    int	    row;
-    int	    col;
-{
-    gui.row = row;
-    gui.col = col;
-}
-
-/*
- * gui_check_pos - check if the cursor is on the screen.
- */
-    static void
-gui_check_pos()
-{
-    if (gui.row >= screen_Rows)
-	gui.row = screen_Rows - 1;
-    if (gui.col >= screen_Columns)
-	gui.col = screen_Columns - 1;
-    if (gui.cursor_row >= screen_Rows || gui.cursor_col >= screen_Columns)
-	gui.cursor_is_valid = FALSE;
-}
-
-/*
- * Redraw the cursor if necessary or when forced.
- * Careful: The contents of ScreenLines[] must match what is on the screen,
- * otherwise this goes wrong.  May need to call out_flush() first.
- */
-    void
-gui_update_cursor(force, clear_selection)
-    int		force;		/* when TRUE, update even when not moved */
-    int		clear_selection;/* clear selection under cursor */
-{
-    int		cur_width = 0;
-    int		cur_height = 0;
-    int		old_hl_mask;
-    int		idx;
-    int		id;
-    guicolor_T	cfg, cbg, cc;	/* cursor fore-/background color */
-    int		cattr;		/* cursor attributes */
-    int		attr;
-    attrentry_T *aep = NULL;
-
-    /* Don't update the cursor when halfway busy scrolling.
-     * ScreenLines[] isn't valid then. */
-    if (!can_update_cursor)
-	return;
-
-    gui_check_pos();
-    if (!gui.cursor_is_valid || force
-		    || gui.row != gui.cursor_row || gui.col != gui.cursor_col)
-    {
-	gui_undraw_cursor();
-	if (gui.row < 0)
-	    return;
-#ifdef USE_IM_CONTROL
-	if (gui.row != gui.cursor_row || gui.col != gui.cursor_col)
-	    im_set_position(gui.row, gui.col);
-#endif
-	gui.cursor_row = gui.row;
-	gui.cursor_col = gui.col;
-
-	/* Only write to the screen after ScreenLines[] has been initialized */
-	if (!screen_cleared || ScreenLines == NULL)
-	    return;
-
-	/* Clear the selection if we are about to write over it */
-	if (clear_selection)
-	    clip_may_clear_selection(gui.row, gui.row);
-	/* Check that the cursor is inside the shell (resizing may have made
-	 * it invalid) */
-	if (gui.row >= screen_Rows || gui.col >= screen_Columns)
-	    return;
-
-	gui.cursor_is_valid = TRUE;
-
-	/*
-	 * How the cursor is drawn depends on the current mode.
-	 */
-	idx = get_shape_idx(FALSE);
-	if (State & LANGMAP)
-	    id = shape_table[idx].id_lm;
-	else
-	    id = shape_table[idx].id;
-
-	/* get the colors and attributes for the cursor.  Default is inverted */
-	cfg = INVALCOLOR;
-	cbg = INVALCOLOR;
-	cattr = HL_INVERSE;
-	gui_mch_set_blinking(shape_table[idx].blinkwait,
-			     shape_table[idx].blinkon,
-			     shape_table[idx].blinkoff);
-	if (id > 0)
-	{
-	    cattr = syn_id2colors(id, &cfg, &cbg);
-#if defined(USE_IM_CONTROL) || defined(FEAT_HANGULIN)
-	    {
-		static int iid;
-		guicolor_T fg, bg;
-
-		if (im_get_status())
-		{
-		    iid = syn_name2id((char_u *)"CursorIM");
-		    if (iid > 0)
-		    {
-			syn_id2colors(iid, &fg, &bg);
-			if (bg != INVALCOLOR)
-			    cbg = bg;
-			if (fg != INVALCOLOR)
-			    cfg = fg;
-		    }
-		}
-	    }
-#endif
-	}
-
-	/*
-	 * Get the attributes for the character under the cursor.
-	 * When no cursor color was given, use the character color.
-	 */
-	attr = ScreenAttrs[LineOffset[gui.row] + gui.col];
-	if (attr > HL_ALL)
-	    aep = syn_gui_attr2entry(attr);
-	if (aep != NULL)
-	{
-	    attr = aep->ae_attr;
-	    if (cfg == INVALCOLOR)
-		cfg = ((attr & HL_INVERSE)  ? aep->ae_u.gui.bg_color
-					    : aep->ae_u.gui.fg_color);
-	    if (cbg == INVALCOLOR)
-		cbg = ((attr & HL_INVERSE)  ? aep->ae_u.gui.fg_color
-					    : aep->ae_u.gui.bg_color);
-	}
-	if (cfg == INVALCOLOR)
-	    cfg = (attr & HL_INVERSE) ? gui.back_pixel : gui.norm_pixel;
-	if (cbg == INVALCOLOR)
-	    cbg = (attr & HL_INVERSE) ? gui.norm_pixel : gui.back_pixel;
-
-#ifdef FEAT_XIM
-	if (aep != NULL)
-	{
-	    xim_bg_color = ((attr & HL_INVERSE) ? aep->ae_u.gui.fg_color
-						: aep->ae_u.gui.bg_color);
-	    xim_fg_color = ((attr & HL_INVERSE) ? aep->ae_u.gui.bg_color
-						: aep->ae_u.gui.fg_color);
-	    if (xim_bg_color == INVALCOLOR)
-		xim_bg_color = (attr & HL_INVERSE) ? gui.norm_pixel
-						   : gui.back_pixel;
-	    if (xim_fg_color == INVALCOLOR)
-		xim_fg_color = (attr & HL_INVERSE) ? gui.back_pixel
-						   : gui.norm_pixel;
-	}
-	else
-	{
-	    xim_bg_color = (attr & HL_INVERSE) ? gui.norm_pixel
-					       : gui.back_pixel;
-	    xim_fg_color = (attr & HL_INVERSE) ? gui.back_pixel
-					       : gui.norm_pixel;
-	}
-#endif
-
-	attr &= ~HL_INVERSE;
-	if (cattr & HL_INVERSE)
-	{
-	    cc = cbg;
-	    cbg = cfg;
-	    cfg = cc;
-	}
-	cattr &= ~HL_INVERSE;
-
-	/*
-	 * When we don't have window focus, draw a hollow cursor.
-	 */
-	if (!gui.in_focus)
-	{
-	    gui_mch_draw_hollow_cursor(cbg);
-	    return;
-	}
-
-	old_hl_mask = gui.highlight_mask;
-	if (shape_table[idx].shape == SHAPE_BLOCK
-#ifdef FEAT_HANGULIN
-		|| composing_hangul
-#endif
-	   )
-	{
-	    /*
-	     * Draw the text character with the cursor colors.	Use the
-	     * character attributes plus the cursor attributes.
-	     */
-	    gui.highlight_mask = (cattr | attr);
-#ifdef FEAT_HANGULIN
-	    if (composing_hangul)
-		(void)gui_outstr_nowrap(composing_hangul_buffer, 2,
-			GUI_MON_IS_CURSOR | GUI_MON_NOCLEAR, cfg, cbg, 0);
-	    else
-#endif
-		(void)gui_screenchar(LineOffset[gui.row] + gui.col,
-			GUI_MON_IS_CURSOR | GUI_MON_NOCLEAR, cfg, cbg, 0);
-	}
-	else
-	{
-#if defined(FEAT_MBYTE) && defined(FEAT_RIGHTLEFT)
-	    int	    col_off = FALSE;
-#endif
-	    /*
-	     * First draw the partial cursor, then overwrite with the text
-	     * character, using a transparent background.
-	     */
-	    if (shape_table[idx].shape == SHAPE_VER)
-	    {
-		cur_height = gui.char_height;
-		cur_width = (gui.char_width * shape_table[idx].percentage
-								  + 99) / 100;
-	    }
-	    else
-	    {
-		cur_height = (gui.char_height * shape_table[idx].percentage
-								  + 99) / 100;
-		cur_width = gui.char_width;
-	    }
-#ifdef FEAT_MBYTE
-	    if (has_mbyte && (*mb_off2cells)(LineOffset[gui.row] + gui.col) > 1)
-	    {
-		/* Double wide character. */
-		if (shape_table[idx].shape != SHAPE_VER)
-		    cur_width += gui.char_width;
-# ifdef FEAT_RIGHTLEFT
-		if (CURSOR_BAR_RIGHT)
-		{
-		    /* gui.col points to the left halve of the character but
-		     * the vertical line needs to be on the right halve.
-		     * A double-wide horizontal line is also drawn from the
-		     * right halve in gui_mch_draw_part_cursor(). */
-		    col_off = TRUE;
-		    ++gui.col;
-		}
-# endif
-	    }
-#endif
-	    gui_mch_draw_part_cursor(cur_width, cur_height, cbg);
-#if defined(FEAT_MBYTE) && defined(FEAT_RIGHTLEFT)
-	    if (col_off)
-		--gui.col;
-#endif
-
-#ifndef FEAT_GUI_MSWIN	    /* doesn't seem to work for MSWindows */
-	    gui.highlight_mask = ScreenAttrs[LineOffset[gui.row] + gui.col];
-	    (void)gui_screenchar(LineOffset[gui.row] + gui.col,
-		    GUI_MON_TRS_CURSOR | GUI_MON_NOCLEAR,
-		    (guicolor_T)0, (guicolor_T)0, 0);
-#endif
-	}
-	gui.highlight_mask = old_hl_mask;
-    }
-}
-
-#if defined(FEAT_MENU) || defined(PROTO)
-    void
-gui_position_menu()
-{
-# if !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)
-    if (gui.menu_is_active && gui.in_use)
-	gui_mch_set_menu_pos(0, 0, gui.menu_width, gui.menu_height);
-# endif
-}
-#endif
-
-/*
- * Position the various GUI components (text area, menu).  The vertical
- * scrollbars are NOT handled here.  See gui_update_scrollbars().
- */
-/*ARGSUSED*/
-    static void
-gui_position_components(total_width)
-    int	    total_width;
-{
-    int	    text_area_x;
-    int	    text_area_y;
-    int	    text_area_width;
-    int	    text_area_height;
-
-    /* avoid that moving components around generates events */
-    ++hold_gui_events;
-
-    text_area_x = 0;
-    if (gui.which_scrollbars[SBAR_LEFT])
-	text_area_x += gui.scrollbar_width;
-
-    text_area_y = 0;
-#if defined(FEAT_MENU) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON))
-    gui.menu_width = total_width;
-    if (gui.menu_is_active)
-	text_area_y += gui.menu_height;
-#endif
-#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_MSWIN)
-    if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
-	text_area_y = TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT;
-#endif
-
-#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA))
-    if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
-    {
-# ifdef FEAT_GUI_ATHENA
-	gui_mch_set_toolbar_pos(0, text_area_y,
-				gui.menu_width, gui.toolbar_height);
-# endif
-	text_area_y += gui.toolbar_height;
-    }
-#endif
-
-    text_area_width = gui.num_cols * gui.char_width + gui.border_offset * 2;
-    text_area_height = gui.num_rows * gui.char_height + gui.border_offset * 2;
-
-    gui_mch_set_text_area_pos(text_area_x,
-			      text_area_y,
-			      text_area_width,
-			      text_area_height
-#if defined(FEAT_XIM) && !defined(HAVE_GTK2)
-				  + xim_get_status_area_height()
-#endif
-			      );
-#ifdef FEAT_MENU
-    gui_position_menu();
-#endif
-    if (gui.which_scrollbars[SBAR_BOTTOM])
-	gui_mch_set_scrollbar_pos(&gui.bottom_sbar,
-				  text_area_x,
-				  text_area_y + text_area_height,
-				  text_area_width,
-				  gui.scrollbar_height);
-    gui.left_sbar_x = 0;
-    gui.right_sbar_x = text_area_x + text_area_width;
-
-    --hold_gui_events;
-}
-
-    int
-gui_get_base_width()
-{
-    int	    base_width;
-
-    base_width = 2 * gui.border_offset;
-    if (gui.which_scrollbars[SBAR_LEFT])
-	base_width += gui.scrollbar_width;
-    if (gui.which_scrollbars[SBAR_RIGHT])
-	base_width += gui.scrollbar_width;
-    return base_width;
-}
-
-    int
-gui_get_base_height()
-{
-    int	    base_height;
-
-    base_height = 2 * gui.border_offset;
-    if (gui.which_scrollbars[SBAR_BOTTOM])
-	base_height += gui.scrollbar_height;
-#ifdef FEAT_GUI_GTK
-    /* We can't take the sizes properly into account until anything is
-     * realized.  Therefore we recalculate all the values here just before
-     * setting the size. (--mdcki) */
-#else
-# ifdef FEAT_MENU
-    if (gui.menu_is_active)
-	base_height += gui.menu_height;
-# endif
-# ifdef FEAT_TOOLBAR
-    if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
-#  if defined(FEAT_GUI_MSWIN) && defined(FEAT_TOOLBAR)
-	base_height += (TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT);
-#  else
-	base_height += gui.toolbar_height;
-#  endif
-# endif
-# ifdef FEAT_FOOTER
-    if (vim_strchr(p_go, GO_FOOTER) != NULL)
-	base_height += gui.footer_height;
-# endif
-# if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)
-    base_height += gui_mch_text_area_extra_height();
-# endif
-#endif
-    return base_height;
-}
-
-/*
- * Should be called after the GUI shell has been resized.  Its arguments are
- * the new width and height of the shell in pixels.
- */
-    void
-gui_resize_shell(pixel_width, pixel_height)
-    int		pixel_width;
-    int		pixel_height;
-{
-    static int	busy = FALSE;
-
-    if (!gui.shell_created)	    /* ignore when still initializing */
-	return;
-
-    /*
-     * Can't resize the screen while it is being redrawn.  Remember the new
-     * size and handle it later.
-     */
-    if (updating_screen || busy)
-    {
-	new_pixel_width = pixel_width;
-	new_pixel_height = pixel_height;
-	return;
-    }
-
-again:
-    busy = TRUE;
-
-#ifdef FEAT_GUI_BEOS
-    vim_lock_screen();
-#endif
-
-    /* Flush pending output before redrawing */
-    out_flush();
-
-    gui.num_cols = (pixel_width - gui_get_base_width()) / gui.char_width;
-    gui.num_rows = (pixel_height - gui_get_base_height()
-#if !defined(FEAT_GUI_PHOTON) && !defined(FEAT_GUI_MSWIN)
-				    + (gui.char_height / 2)
-#endif
-					) / gui.char_height;
-
-    gui_position_components(pixel_width);
-
-    gui_reset_scroll_region();
-    /*
-     * At the "more" and ":confirm" prompt there is no redraw, put the cursor
-     * at the last line here (why does it have to be one row too low?).
-     */
-    if (State == ASKMORE || State == CONFIRM)
-	gui.row = gui.num_rows;
-
-    /* Only comparing Rows and Columns may be sufficient, but let's stay on
-     * the safe side. */
-    if (gui.num_rows != screen_Rows || gui.num_cols != screen_Columns
-	    || gui.num_rows != Rows || gui.num_cols != Columns)
-	shell_resized();
-
-#ifdef FEAT_GUI_BEOS
-    vim_unlock_screen();
-#endif
-
-    gui_update_scrollbars(TRUE);
-    gui_update_cursor(FALSE, TRUE);
-#if defined(FEAT_XIM) && !defined(HAVE_GTK2)
-    xim_set_status_area();
-#endif
-
-    busy = FALSE;
-    /*
-     * We could have been called again while redrawing the screen.
-     * Need to do it all again with the latest size then.
-     */
-    if (new_pixel_height)
-    {
-	pixel_width = new_pixel_width;
-	pixel_height = new_pixel_height;
-	new_pixel_width = 0;
-	new_pixel_height = 0;
-	goto again;
-    }
-}
-
-/*
- * Check if gui_resize_shell() must be called.
- */
-    void
-gui_may_resize_shell()
-{
-    int		h, w;
-
-    if (new_pixel_height)
-    {
-	/* careful: gui_resize_shell() may postpone the resize again if we
-	 * were called indirectly by it */
-	w = new_pixel_width;
-	h = new_pixel_height;
-	new_pixel_width = 0;
-	new_pixel_height = 0;
-	gui_resize_shell(w, h);
-    }
-}
-
-    int
-gui_get_shellsize()
-{
-    Rows = gui.num_rows;
-    Columns = gui.num_cols;
-    return OK;
-}
-
-/*
- * Set the size of the Vim shell according to Rows and Columns.
- */
-/*ARGSUSED*/
-    void
-gui_set_shellsize(mustset, fit_to_display)
-    int		mustset;		/* set by the user */
-    int		fit_to_display;
-{
-    int		base_width;
-    int		base_height;
-    int		width;
-    int		height;
-    int		min_width;
-    int		min_height;
-    int		screen_w;
-    int		screen_h;
-
-    if (!gui.shell_created)
-	return;
-
-#ifdef MSWIN
-    /* If not setting to a user specified size and maximized, calculate the
-     * number of characters that fit in the maximized window. */
-    if (!mustset && gui_mch_maximized())
-    {
-	gui_mch_newfont();
-	return;
-    }
-#endif
-
-    base_width = gui_get_base_width();
-    base_height = gui_get_base_height();
-#ifdef USE_SUN_WORKSHOP
-    if (!mustset && usingSunWorkShop
-				&& workshop_get_width_height(&width, &height))
-    {
-	Columns = (width - base_width + gui.char_width - 1) / gui.char_width;
-	Rows = (height - base_height + gui.char_height - 1) / gui.char_height;
-    }
-    else
-#endif
-    {
-	width = Columns * gui.char_width + base_width;
-	height = Rows * gui.char_height + base_height;
-    }
-
-    if (fit_to_display)
-    {
-	gui_mch_get_screen_dimensions(&screen_w, &screen_h);
-	if (width > screen_w)
-	{
-	    Columns = (screen_w - base_width) / gui.char_width;
-	    if (Columns < MIN_COLUMNS)
-		Columns = MIN_COLUMNS;
-	    width = Columns * gui.char_width + base_width;
-	}
-	if (height > screen_h)
-	{
-	    Rows = (screen_h - base_height) / gui.char_height;
-	    check_shellsize();
-	    height = Rows * gui.char_height + base_height;
-	}
-    }
-    gui.num_cols = Columns;
-    gui.num_rows = Rows;
-
-    min_width = base_width + MIN_COLUMNS * gui.char_width;
-    min_height = base_height + MIN_LINES * gui.char_height;
-
-    gui_mch_set_shellsize(width, height, min_width, min_height,
-						     base_width, base_height);
-    if (fit_to_display)
-    {
-	int	    x, y;
-
-	/* Some window managers put the Vim window left of/above the screen. */
-	gui_mch_update();
-	if (gui_mch_get_winpos(&x, &y) == OK && (x < 0 || y < 0))
-	    gui_mch_set_winpos(x < 0 ? 0 : x, y < 0 ? 0 : y);
-    }
-
-    gui_position_components(width);
-    gui_update_scrollbars(TRUE);
-    gui_reset_scroll_region();
-}
-
-/*
- * Called when Rows and/or Columns has changed.
- */
-    void
-gui_new_shellsize()
-{
-    gui_reset_scroll_region();
-}
-
-/*
- * Make scroll region cover whole screen.
- */
-    void
-gui_reset_scroll_region()
-{
-    gui.scroll_region_top = 0;
-    gui.scroll_region_bot = gui.num_rows - 1;
-    gui.scroll_region_left = 0;
-    gui.scroll_region_right = gui.num_cols - 1;
-}
-
-    void
-gui_start_highlight(mask)
-    int	    mask;
-{
-    if (mask > HL_ALL)		    /* highlight code */
-	gui.highlight_mask = mask;
-    else			    /* mask */
-	gui.highlight_mask |= mask;
-}
-
-    void
-gui_stop_highlight(mask)
-    int	    mask;
-{
-    if (mask > HL_ALL)		    /* highlight code */
-	gui.highlight_mask = HL_NORMAL;
-    else			    /* mask */
-	gui.highlight_mask &= ~mask;
-}
-
-/*
- * Clear a rectangular region of the screen from text pos (row1, col1) to
- * (row2, col2) inclusive.
- */
-    void
-gui_clear_block(row1, col1, row2, col2)
-    int	    row1;
-    int	    col1;
-    int	    row2;
-    int	    col2;
-{
-    /* Clear the selection if we are about to write over it */
-    clip_may_clear_selection(row1, row2);
-
-    gui_mch_clear_block(row1, col1, row2, col2);
-
-    /* Invalidate cursor if it was in this block */
-    if (       gui.cursor_row >= row1 && gui.cursor_row <= row2
-	    && gui.cursor_col >= col1 && gui.cursor_col <= col2)
-	gui.cursor_is_valid = FALSE;
-}
-
-/*
- * Write code to update the cursor later.  This avoids the need to flush the
- * output buffer before calling gui_update_cursor().
- */
-    void
-gui_update_cursor_later()
-{
-    OUT_STR(IF_EB("\033|s", ESC_STR "|s"));
-}
-
-    void
-gui_write(s, len)
-    char_u	*s;
-    int		len;
-{
-    char_u	*p;
-    int		arg1 = 0, arg2 = 0;
-    /* this doesn't make sense, disabled until someone can explain why it
-     * would be needed */
-#if 0 && (defined(RISCOS) || defined(WIN16))
-    int		force_cursor = TRUE;	/* JK230798, stop Vim being smart or
-					   our redraw speed will suffer */
-#else
-    int		force_cursor = FALSE;	/* force cursor update */
-#endif
-    int		force_scrollbar = FALSE;
-    static win_T	*old_curwin = NULL;
-
-/* #define DEBUG_GUI_WRITE */
-#ifdef DEBUG_GUI_WRITE
-    {
-	int i;
-	char_u *str;
-
-	printf("gui_write(%d):\n    ", len);
-	for (i = 0; i < len; i++)
-	    if (s[i] == ESC)
-	    {
-		if (i != 0)
-		    printf("\n    ");
-		printf("<ESC>");
-	    }
-	    else
-	    {
-		str = transchar_byte(s[i]);
-		if (str[0] && str[1])
-		    printf("<%s>", (char *)str);
-		else
-		    printf("%s", (char *)str);
-	    }
-	printf("\n");
-    }
-#endif
-    while (len)
-    {
-	if (s[0] == ESC && s[1] == '|')
-	{
-	    p = s + 2;
-	    if (VIM_ISDIGIT(*p))
-	    {
-		arg1 = getdigits(&p);
-		if (p > s + len)
-		    break;
-		if (*p == ';')
-		{
-		    ++p;
-		    arg2 = getdigits(&p);
-		    if (p > s + len)
-			break;
-		}
-	    }
-	    switch (*p)
-	    {
-		case 'C':	/* Clear screen */
-		    clip_scroll_selection(9999);
-		    gui_mch_clear_all();
-		    gui.cursor_is_valid = FALSE;
-		    force_scrollbar = TRUE;
-		    break;
-		case 'M':	/* Move cursor */
-		    gui_set_cursor(arg1, arg2);
-		    break;
-		case 's':	/* force cursor (shape) update */
-		    force_cursor = TRUE;
-		    break;
-		case 'R':	/* Set scroll region */
-		    if (arg1 < arg2)
-		    {
-			gui.scroll_region_top = arg1;
-			gui.scroll_region_bot = arg2;
-		    }
-		    else
-		    {
-			gui.scroll_region_top = arg2;
-			gui.scroll_region_bot = arg1;
-		    }
-		    break;
-#ifdef FEAT_VERTSPLIT
-		case 'V':	/* Set vertical scroll region */
-		    if (arg1 < arg2)
-		    {
-			gui.scroll_region_left = arg1;
-			gui.scroll_region_right = arg2;
-		    }
-		    else
-		    {
-			gui.scroll_region_left = arg2;
-			gui.scroll_region_right = arg1;
-		    }
-		    break;
-#endif
-		case 'd':	/* Delete line */
-		    gui_delete_lines(gui.row, 1);
-		    break;
-		case 'D':	/* Delete lines */
-		    gui_delete_lines(gui.row, arg1);
-		    break;
-		case 'i':	/* Insert line */
-		    gui_insert_lines(gui.row, 1);
-		    break;
-		case 'I':	/* Insert lines */
-		    gui_insert_lines(gui.row, arg1);
-		    break;
-		case '$':	/* Clear to end-of-line */
-		    gui_clear_block(gui.row, gui.col, gui.row,
-							    (int)Columns - 1);
-		    break;
-		case 'h':	/* Turn on highlighting */
-		    gui_start_highlight(arg1);
-		    break;
-		case 'H':	/* Turn off highlighting */
-		    gui_stop_highlight(arg1);
-		    break;
-		case 'f':	/* flash the window (visual bell) */
-		    gui_mch_flash(arg1 == 0 ? 20 : arg1);
-		    break;
-		default:
-		    p = s + 1;	/* Skip the ESC */
-		    break;
-	    }
-	    len -= (int)(++p - s);
-	    s = p;
-	}
-	else if (
-#ifdef EBCDIC
-		CtrlChar(s[0]) != 0	/* Ctrl character */
-#else
-		s[0] < 0x20		/* Ctrl character */
-#endif
-#ifdef FEAT_SIGN_ICONS
-		&& s[0] != SIGN_BYTE
-# ifdef FEAT_NETBEANS_INTG
-		&& s[0] != MULTISIGN_BYTE
-# endif
-#endif
-		)
-	{
-	    if (s[0] == '\n')		/* NL */
-	    {
-		gui.col = 0;
-		if (gui.row < gui.scroll_region_bot)
-		    gui.row++;
-		else
-		    gui_delete_lines(gui.scroll_region_top, 1);
-	    }
-	    else if (s[0] == '\r')	/* CR */
-	    {
-		gui.col = 0;
-	    }
-	    else if (s[0] == '\b')	/* Backspace */
-	    {
-		if (gui.col)
-		    --gui.col;
-	    }
-	    else if (s[0] == Ctrl_L)	/* cursor-right */
-	    {
-		++gui.col;
-	    }
-	    else if (s[0] == Ctrl_G)	/* Beep */
-	    {
-		gui_mch_beep();
-	    }
-	    /* Other Ctrl character: shouldn't happen! */
-
-	    --len;	/* Skip this char */
-	    ++s;
-	}
-	else
-	{
-	    p = s;
-	    while (len > 0 && (
-#ifdef EBCDIC
-			CtrlChar(*p) == 0
-#else
-			*p >= 0x20
-#endif
-#ifdef FEAT_SIGN_ICONS
-			|| *p == SIGN_BYTE
-# ifdef FEAT_NETBEANS_INTG
-			|| *p == MULTISIGN_BYTE
-# endif
-#endif
-			))
-	    {
-		len--;
-		p++;
-	    }
-	    gui_outstr(s, (int)(p - s));
-	    s = p;
-	}
-    }
-
-    /* Postponed update of the cursor (won't work if "can_update_cursor" isn't
-     * set). */
-    if (force_cursor)
-	gui_update_cursor(TRUE, TRUE);
-
-    /* When switching to another window the dragging must have stopped.
-     * Required for GTK, dragged_sb isn't reset. */
-    if (old_curwin != curwin)
-	gui.dragged_sb = SBAR_NONE;
-
-    /* Update the scrollbars after clearing the screen or when switched
-     * to another window.
-     * Update the horizontal scrollbar always, it's difficult to check all
-     * situations where it might change. */
-    if (force_scrollbar || old_curwin != curwin)
-	gui_update_scrollbars(force_scrollbar);
-    else
-	gui_update_horiz_scrollbar(FALSE);
-    old_curwin = curwin;
-
-    /*
-     * We need to make sure this is cleared since Athena doesn't tell us when
-     * he is done dragging.  Do the same for GTK.
-     */
-#if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK)
-    gui.dragged_sb = SBAR_NONE;
-#endif
-
-    gui_mch_flush();		    /* In case vim decides to take a nap */
-}
-
-/*
- * When ScreenLines[] is invalid, updating the cursor should not be done, it
- * produces wrong results.  Call gui_dont_update_cursor() before that code and
- * gui_can_update_cursor() afterwards.
- */
-    void
-gui_dont_update_cursor()
-{
-    if (gui.in_use)
-    {
-	/* Undraw the cursor now, we probably can't do it after the change. */
-	gui_undraw_cursor();
-	can_update_cursor = FALSE;
-    }
-}
-
-    void
-gui_can_update_cursor()
-{
-    can_update_cursor = TRUE;
-    /* No need to update the cursor right now, there is always more output
-     * after scrolling. */
-}
-
-    static void
-gui_outstr(s, len)
-    char_u  *s;
-    int	    len;
-{
-    int	    this_len;
-#ifdef FEAT_MBYTE
-    int	    cells;
-#endif
-
-    if (len == 0)
-	return;
-
-    if (len < 0)
-	len = (int)STRLEN(s);
-
-    while (len > 0)
-    {
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	{
-	    /* Find out how many chars fit in the current line. */
-	    cells = 0;
-	    for (this_len = 0; this_len < len; )
-	    {
-		cells += (*mb_ptr2cells)(s + this_len);
-		if (gui.col + cells > Columns)
-		    break;
-		this_len += (*mb_ptr2len_check)(s + this_len);
-	    }
-	    if (this_len > len)
-		this_len = len;	    /* don't include following composing char */
-	}
-	else
-#endif
-	    if (gui.col + len > Columns)
-	    this_len = Columns - gui.col;
-	else
-	    this_len = len;
-
-	(void)gui_outstr_nowrap(s, this_len,
-					  0, (guicolor_T)0, (guicolor_T)0, 0);
-	s += this_len;
-	len -= this_len;
-#ifdef FEAT_MBYTE
-	/* fill up for a double-width char that doesn't fit. */
-	if (len > 0 && gui.col < Columns)
-	    (void)gui_outstr_nowrap((char_u *)" ", 1,
-					  0, (guicolor_T)0, (guicolor_T)0, 0);
-#endif
-	/* The cursor may wrap to the next line. */
-	if (gui.col >= Columns)
-	{
-	    gui.col = 0;
-	    gui.row++;
-	}
-    }
-}
-
-/*
- * Output one character (may be one or two display cells).
- * Caller must check for valid "off".
- * Returns FAIL or OK, just like gui_outstr_nowrap().
- */
-    static int
-gui_screenchar(off, flags, fg, bg, back)
-    int		off;	    /* Offset from start of screen */
-    int		flags;
-    guicolor_T	fg, bg;	    /* colors for cursor */
-    int		back;	    /* backup this many chars when using bold trick */
-{
-#ifdef FEAT_MBYTE
-    char_u	buf[MB_MAXBYTES + 1];
-
-    /* Don't draw right halve of a double-width UTF-8 char. "cannot happen" */
-    if (enc_utf8 && ScreenLines[off] == 0)
-	return OK;
-
-    if (enc_utf8 && ScreenLinesUC[off] != 0)
-	/* Draw UTF-8 multi-byte character. */
-	return gui_outstr_nowrap(buf, utfc_char2bytes(off, buf),
-							 flags, fg, bg, back);
-
-    if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
-    {
-	buf[0] = ScreenLines[off];
-	buf[1] = ScreenLines2[off];
-	return gui_outstr_nowrap(buf, 2, flags, fg, bg, back);
-    }
-
-    /* Draw non-multi-byte character or DBCS character. */
-    return gui_outstr_nowrap(ScreenLines + off,
-	    enc_dbcs ? (*mb_ptr2len_check)(ScreenLines + off) : 1,
-							 flags, fg, bg, back);
-#else
-    return gui_outstr_nowrap(ScreenLines + off, 1, flags, fg, bg, back);
-#endif
-}
-
-#ifdef HAVE_GTK2
-/*
- * Output the string at the given screen position.  This is used in place
- * of gui_screenchar() where possible because Pango needs as much context
- * as possible to work nicely.  It's a lot faster as well.
- */
-    static int
-gui_screenstr(off, len, flags, fg, bg, back)
-    int		off;	    /* Offset from start of screen */
-    int		len;	    /* string length in screen cells */
-    int		flags;
-    guicolor_T	fg, bg;	    /* colors for cursor */
-    int		back;	    /* backup this many chars when using bold trick */
-{
-    char_u  *buf;
-    int	    outlen = 0;
-    int	    i;
-    int	    retval;
-
-    if (len <= 0) /* "cannot happen"? */
-	return OK;
-
-    if (enc_utf8)
-    {
-	buf = alloc((unsigned)(len * MB_MAXBYTES + 1));
-	if (buf == NULL)
-	    return OK; /* not much we could do here... */
-
-	for (i = off; i < off + len; ++i)
-	{
-	    if (ScreenLines[i] == 0)
-		continue; /* skip second half of double-width char */
-
-	    if (ScreenLinesUC[i] == 0)
-		buf[outlen++] = ScreenLines[i];
-	    else
-		outlen += utfc_char2bytes(i, buf + outlen);
-	}
-
-	buf[outlen] = NUL; /* only to aid debugging */
-	retval = gui_outstr_nowrap(buf, outlen, flags, fg, bg, back);
-	vim_free(buf);
-
-	return retval;
-    }
-    else if (enc_dbcs == DBCS_JPNU)
-    {
-	buf = alloc((unsigned)(len * 2 + 1));
-	if (buf == NULL)
-	    return OK; /* not much we could do here... */
-
-	for (i = off; i < off + len; ++i)
-	{
-	    buf[outlen++] = ScreenLines[i];
-
-	    /* handle double-byte single-width char */
-	    if (ScreenLines[i] == 0x8e)
-		buf[outlen++] = ScreenLines2[i];
-	    else if (MB_BYTE2LEN(ScreenLines[i]) == 2)
-		buf[outlen++] = ScreenLines[++i];
-	}
-
-	buf[outlen] = NUL; /* only to aid debugging */
-	retval = gui_outstr_nowrap(buf, outlen, flags, fg, bg, back);
-	vim_free(buf);
-
-	return retval;
-    }
-    else
-    {
-	return gui_outstr_nowrap(&ScreenLines[off], len,
-				 flags, fg, bg, back);
-    }
-}
-#endif /* HAVE_GTK2 */
-
-/*
- * Output the given string at the current cursor position.  If the string is
- * too long to fit on the line, then it is truncated.
- * "flags":
- * GUI_MON_IS_CURSOR should only be used when this function is being called to
- * actually draw (an inverted) cursor.
- * GUI_MON_TRS_CURSOR is used to draw the cursor text with a transparant
- * background.
- * GUI_MON_NOCLEAR is used to avoid clearing the selection when drawing over
- * it.
- * Returns OK, unless "back" is non-zero and using the bold trick, then return
- * FAIL (the caller should start drawing "back" chars back).
- */
-    int
-gui_outstr_nowrap(s, len, flags, fg, bg, back)
-    char_u	*s;
-    int		len;
-    int		flags;
-    guicolor_T	fg, bg;	    /* colors for cursor */
-    int		back;	    /* backup this many chars when using bold trick */
-{
-    long_u	highlight_mask;
-    long_u	hl_mask_todo;
-    guicolor_T	fg_color;
-    guicolor_T	bg_color;
-#if !defined(MSWIN16_FASTTEXT) && !defined(HAVE_GTK2)
-    GuiFont	font = NOFONT;
-# ifdef FEAT_XFONTSET
-    GuiFontset	fontset = NOFONTSET;
-# endif
-#endif
-    attrentry_T	*aep = NULL;
-    int		draw_flags;
-    int		col = gui.col;
-#ifdef FEAT_SIGN_ICONS
-    int		draw_sign = FALSE;
-# ifdef FEAT_NETBEANS_INTG
-    int		multi_sign = FALSE;
-# endif
-#endif
-
-    if (len < 0)
-	len = (int)STRLEN(s);
-    if (len == 0)
-	return OK;
-
-#ifdef FEAT_SIGN_ICONS
-    if (*s == SIGN_BYTE
-# ifdef FEAT_NETBEANS_INTG
-	  || *s == MULTISIGN_BYTE
-# endif
-    )
-    {
-# ifdef FEAT_NETBEANS_INTG
-	if (*s == MULTISIGN_BYTE)
-	    multi_sign = TRUE;
-# endif
-	/* draw spaces instead */
-	s = (char_u *)"  ";
-	if (len == 1 && col > 0)
-	    --col;
-	len = 2;
-	draw_sign = TRUE;
-	highlight_mask = 0;
-    }
-    else
-#endif
-    if (gui.highlight_mask > HL_ALL)
-    {
-	aep = syn_gui_attr2entry(gui.highlight_mask);
-	if (aep == NULL)	    /* highlighting not set */
-	    highlight_mask = 0;
-	else
-	    highlight_mask = aep->ae_attr;
-    }
-    else
-	highlight_mask = gui.highlight_mask;
-    hl_mask_todo = highlight_mask;
-
-#if !defined(MSWIN16_FASTTEXT) && !defined(HAVE_GTK2)
-    /* Set the font */
-    if (aep != NULL && aep->ae_u.gui.font != NOFONT)
-	font = aep->ae_u.gui.font;
-# ifdef FEAT_XFONTSET
-    else if (aep != NULL && aep->ae_u.gui.fontset != NOFONTSET)
-	fontset = aep->ae_u.gui.fontset;
-# endif
-    else
-    {
-# ifdef FEAT_XFONTSET
-	if (gui.fontset != NOFONTSET)
-	    fontset = gui.fontset;
-	else
-# endif
-	    if (hl_mask_todo & (HL_BOLD | HL_STANDOUT))
-	{
-	    if ((hl_mask_todo & HL_ITALIC) && gui.boldital_font != NOFONT)
-	    {
-		font = gui.boldital_font;
-		hl_mask_todo &= ~(HL_BOLD | HL_STANDOUT | HL_ITALIC);
-	    }
-	    else if (gui.bold_font != NOFONT)
-	    {
-		font = gui.bold_font;
-		hl_mask_todo &= ~(HL_BOLD | HL_STANDOUT);
-	    }
-	    else
-		font = gui.norm_font;
-	}
-	else if ((hl_mask_todo & HL_ITALIC) && gui.ital_font != NOFONT)
-	{
-	    font = gui.ital_font;
-	    hl_mask_todo &= ~HL_ITALIC;
-	}
-	else
-	    font = gui.norm_font;
-    }
-# ifdef FEAT_XFONTSET
-    if (fontset != NOFONTSET)
-	gui_mch_set_fontset(fontset);
-    else
-# endif
-	gui_mch_set_font(font);
-#endif
-
-    draw_flags = 0;
-
-    /* Set the color */
-    bg_color = gui.back_pixel;
-    if ((flags & GUI_MON_IS_CURSOR) && gui.in_focus)
-    {
-	draw_flags |= DRAW_CURSOR;
-	fg_color = fg;
-	bg_color = bg;
-    }
-    else if (aep != NULL)
-    {
-	fg_color = aep->ae_u.gui.fg_color;
-	if (fg_color == INVALCOLOR)
-	    fg_color = gui.norm_pixel;
-	bg_color = aep->ae_u.gui.bg_color;
-	if (bg_color == INVALCOLOR)
-	    bg_color = gui.back_pixel;
-    }
-    else
-	fg_color = gui.norm_pixel;
-
-    if (highlight_mask & (HL_INVERSE | HL_STANDOUT))
-    {
-#if defined(AMIGA) || defined(RISCOS)
-	gui_mch_set_colors(bg_color, fg_color);
-#else
-	gui_mch_set_fg_color(bg_color);
-	gui_mch_set_bg_color(fg_color);
-#endif
-    }
-    else
-    {
-#if defined(AMIGA) || defined(RISCOS)
-	gui_mch_set_colors(fg_color, bg_color);
-#else
-	gui_mch_set_fg_color(fg_color);
-	gui_mch_set_bg_color(bg_color);
-#endif
-    }
-
-    /* Clear the selection if we are about to write over it */
-    if (!(flags & GUI_MON_NOCLEAR))
-	clip_may_clear_selection(gui.row, gui.row);
-
-
-#ifndef MSWIN16_FASTTEXT
-    /* If there's no bold font, then fake it */
-    if (hl_mask_todo & (HL_BOLD | HL_STANDOUT))
-	draw_flags |= DRAW_BOLD;
-#endif
-
-    /*
-     * When drawing bold or italic characters the spill-over from the left
-     * neighbor may be destroyed.  Let the caller backup to start redrawing
-     * just after a blank.
-     */
-    if (back != 0 && ((draw_flags & DRAW_BOLD) || (highlight_mask & HL_ITALIC)))
-	return FAIL;
-
-#if defined(RISCOS) || defined(HAVE_GTK2)
-    /* If there's no italic font, then fake it.
-     * For GTK2, we don't need a different font for italic style. */
-    if (hl_mask_todo & HL_ITALIC)
-	draw_flags |= DRAW_ITALIC;
-
-    /* Do we underline the text? */
-    if (hl_mask_todo & HL_UNDERLINE)
-	draw_flags |= DRAW_UNDERL;
-#else
-    /* Do we underline the text? */
-    if ((hl_mask_todo & HL_UNDERLINE)
-# ifndef MSWIN16_FASTTEXT
-	    || (hl_mask_todo & HL_ITALIC)
-# endif
-       )
-	draw_flags |= DRAW_UNDERL;
-#endif
-
-    /* Do we draw transparantly? */
-    if (flags & GUI_MON_TRS_CURSOR)
-	draw_flags |= DRAW_TRANSP;
-
-    /*
-     * Draw the text.
-     */
-#ifdef HAVE_GTK2
-    /* The value returned is the length in display cells */
-    len = gui_gtk2_draw_string(gui.row, col, s, len, draw_flags);
-#else
-# ifdef FEAT_MBYTE
-    if (enc_utf8)
-    {
-	int	start;		/* index of bytes to be drawn */
-	int	cells;		/* cellwidth of bytes to be drawn */
-	int	thislen;	/* length of bytes to be drawin */
-	int	cn;		/* cellwidth of current char */
-	int	i;		/* index of current char */
-	int	c;		/* current char value */
-	int	cl;		/* byte length of current char */
-	int	comping;	/* current char is composing */
-	int	scol = col;	/* screen column */
-	int	dowide;		/* use 'guifontwide' */
-
-	/* Break the string at a composing character, it has to be drawn on
-	 * top of the previous character. */
-	start = 0;
-	cells = 0;
-	for (i = 0; i < len; i += cl)
-	{
-	    c = utf_ptr2char(s + i);
-	    cn = utf_char2cells(c);
-	    if (cn > 1
-#  ifdef FEAT_XFONTSET
-		    && fontset == NOFONTSET
-#  endif
-		    && gui.wide_font != NOFONT)
-		dowide = TRUE;
-	    else
-		dowide = FALSE;
-	    comping = utf_iscomposing(c);
-	    if (!comping)	/* count cells from non-composing chars */
-		cells += cn;
-	    cl = utf_ptr2len_check(s + i);
-	    if (cl == 0)	/* hit end of string */
-		len = i + cl;	/* len must be wrong "cannot happen" */
-
-	    /* print the string so far if it's the last character or there is
-	     * a composing character. */
-	    if (i + cl >= len || (comping && i > start) || dowide
-#  if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK)
-		    || (cn > 1
-#   ifdef FEAT_XFONTSET
-			/* No fontset: At least draw char after wide char at
-			 * right position. */
-			&& fontset == NOFONTSET
-#   endif
-		       )
-#  endif
-	       )
-	    {
-		if (comping || dowide)
-		    thislen = i - start;
-		else
-		    thislen = i - start + cl;
-		if (thislen > 0)
-		{
-		    gui_mch_draw_string(gui.row, scol, s + start, thislen,
-								  draw_flags);
-		    start += thislen;
-		}
-		scol += cells;
-		cells = 0;
-		if (dowide)
-		{
-		    gui_mch_set_font(gui.wide_font);
-		    gui_mch_draw_string(gui.row, scol - cn,
-						   s + start, cl, draw_flags);
-		    gui_mch_set_font(font);
-		    start += cl;
-		}
-
-#  if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK)
-		/* No fontset: draw a space to fill the gap after a wide char */
-		if (cn > 1 && (draw_flags & DRAW_TRANSP) == 0
-#   ifdef FEAT_XFONTSET
-			&& fontset == NOFONTSET
-#   endif
-			&& !dowide)
-		    gui_mch_draw_string(gui.row, scol - 1, (char_u *)" ",
-							       1, draw_flags);
-#  endif
-	    }
-	    /* Draw a composing char on top of the previous char. */
-	    if (comping)
-	    {
-		gui_mch_draw_string(gui.row, scol - cn, s + i, cl,
-						    draw_flags | DRAW_TRANSP);
-		start = i + cl;
-	    }
-	}
-	/* The stuff below assumes "len" is the length in screen columns. */
-	len = scol - col;
-    }
-    else
-# endif
-    {
-	gui_mch_draw_string(gui.row, col, s, len, draw_flags);
-# ifdef FEAT_MBYTE
-	if (enc_dbcs == DBCS_JPNU)
-	{
-	    int		clen = 0;
-	    int		i;
-
-	    /* Get the length in display cells, this can be different from the
-	     * number of bytes for "euc-jp". */
-	    for (i = 0; i < len; i += (*mb_ptr2len_check)(s + i))
-		clen += (*mb_ptr2cells)(s + i);
-	    len = clen;
-	}
-# endif
-    }
-#endif /* !HAVE_GTK2 */
-
-    if (!(flags & (GUI_MON_IS_CURSOR | GUI_MON_TRS_CURSOR)))
-	gui.col = col + len;
-
-    /* May need to invert it when it's part of the selection. */
-    if (flags & GUI_MON_NOCLEAR)
-	clip_may_redraw_selection(gui.row, col, len);
-
-    if (!(flags & (GUI_MON_IS_CURSOR | GUI_MON_TRS_CURSOR)))
-    {
-	/* Invalidate the old physical cursor position if we wrote over it */
-	if (gui.cursor_row == gui.row
-		&& gui.cursor_col >= col
-		&& gui.cursor_col < col + len)
-	    gui.cursor_is_valid = FALSE;
-    }
-
-#ifdef FEAT_SIGN_ICONS
-    if (draw_sign)
-	/* Draw the sign on top of the spaces. */
-	gui_mch_drawsign(gui.row, col, gui.highlight_mask);
-# ifdef FEAT_NETBEANS_INTG
-    if (multi_sign)
-	netbeans_draw_multisign_indicator(gui.row);
-# endif
-#endif
-
-    return OK;
-}
-
-/*
- * Un-draw the cursor.	Actually this just redraws the character at the given
- * position.  The character just before it too, for when it was in bold.
- */
-    void
-gui_undraw_cursor()
-{
-    if (gui.cursor_is_valid)
-    {
-#ifdef FEAT_HANGULIN
-	if (composing_hangul
-		    && gui.col == gui.cursor_col && gui.row == gui.cursor_row)
-	    (void)gui_outstr_nowrap(composing_hangul_buffer, 2,
-		    GUI_MON_IS_CURSOR | GUI_MON_NOCLEAR,
-		    gui.norm_pixel, gui.back_pixel, 0);
-	else
-	{
-#endif
-	if (gui_redraw_block(gui.cursor_row, gui.cursor_col,
-			      gui.cursor_row, gui.cursor_col, GUI_MON_NOCLEAR)
-		&& gui.cursor_col > 0)
-	    (void)gui_redraw_block(gui.cursor_row, gui.cursor_col - 1,
-			 gui.cursor_row, gui.cursor_col - 1, GUI_MON_NOCLEAR);
-#ifdef FEAT_HANGULIN
-	    if (composing_hangul)
-		(void)gui_redraw_block(gui.cursor_row, gui.cursor_col + 1,
-			gui.cursor_row, gui.cursor_col + 1, GUI_MON_NOCLEAR);
-	}
-#endif
-	/* Cursor_is_valid is reset when the cursor is undrawn, also reset it
-	 * here in case it wasn't needed to undraw it. */
-	gui.cursor_is_valid = FALSE;
-    }
-}
-
-    void
-gui_redraw(x, y, w, h)
-    int		x;
-    int		y;
-    int		w;
-    int		h;
-{
-    int		row1, col1, row2, col2;
-
-    row1 = Y_2_ROW(y);
-    col1 = X_2_COL(x);
-    row2 = Y_2_ROW(y + h - 1);
-    col2 = X_2_COL(x + w - 1);
-
-    (void)gui_redraw_block(row1, col1, row2, col2, GUI_MON_NOCLEAR);
-
-    /*
-     * We may need to redraw the cursor, but don't take it upon us to change
-     * its location after a scroll.
-     * (maybe be more strict even and test col too?)
-     * These things may be outside the update/clipping region and reality may
-     * not reflect Vims internal ideas if these operations are clipped away.
-     */
-    if (gui.row == gui.cursor_row)
-	gui_update_cursor(TRUE, TRUE);
-}
-
-/*
- * Draw a rectangular block of characters, from row1 to row2 (inclusive) and
- * from col1 to col2 (inclusive).
- * Return TRUE when the character before the first drawn character has
- * different attributes (may have to be redrawn too).
- */
-    int
-gui_redraw_block(row1, col1, row2, col2, flags)
-    int		row1;
-    int		col1;
-    int		row2;
-    int		col2;
-    int		flags;	/* flags for gui_outstr_nowrap() */
-{
-    int		old_row, old_col;
-    long_u	old_hl_mask;
-    int		off;
-    char_u	first_attr;
-    int		idx, len;
-    int		back, nback;
-    int		retval = FALSE;
-#ifdef FEAT_MBYTE
-    int		orig_col1, orig_col2;
-#endif
-
-    /* Don't try to update when ScreenLines is not valid */
-    if (!screen_cleared || ScreenLines == NULL)
-	return retval;
-
-    /* Don't try to draw outside the shell! */
-    /* Check everything, strange values may be caused by a big border width */
-    col1 = check_col(col1);
-    col2 = check_col(col2);
-    row1 = check_row(row1);
-    row2 = check_row(row2);
-
-    /* Remember where our cursor was */
-    old_row = gui.row;
-    old_col = gui.col;
-    old_hl_mask = gui.highlight_mask;
-#ifdef FEAT_MBYTE
-    orig_col1 = col1;
-    orig_col2 = col2;
-#endif
-
-    for (gui.row = row1; gui.row <= row2; gui.row++)
-    {
-#ifdef FEAT_MBYTE
-	/* When only half of a double-wide character is in the block, include
-	 * the other half. */
-	col1 = orig_col1;
-	col2 = orig_col2;
-	off = LineOffset[gui.row];
-	if (enc_dbcs != 0)
-	{
-	    if (col1 > 0)
-		col1 -= dbcs_screen_head_off(ScreenLines + off,
-						    ScreenLines + off + col1);
-	    col2 += dbcs_screen_tail_off(ScreenLines + off,
-						    ScreenLines + off + col2);
-	}
-	else if (enc_utf8)
-	{
-	    if (ScreenLines[off + col1] == 0)
-		--col1;
-# ifdef HAVE_GTK2
-	    if (col2 + 1 < Columns && ScreenLines[off + col2 + 1] == 0)
-		++col2;
-# endif
-	}
-#endif
-	gui.col = col1;
-	off = LineOffset[gui.row] + gui.col;
-	len = col2 - col1 + 1;
-
-	/* Find how many chars back this highlighting starts, or where a space
-	 * is.  Needed for when the bold trick is used */
-	for (back = 0; back < col1; ++back)
-	    if (ScreenAttrs[off - 1 - back] != ScreenAttrs[off]
-		    || ScreenLines[off - 1 - back] == ' ')
-		break;
-	retval = (col1 > 0 && ScreenAttrs[off - 1] != 0 && back == 0
-					      && ScreenLines[off - 1] != ' ');
-
-	/* Break it up in strings of characters with the same attributes. */
-	/* Print UTF-8 characters individually. */
-	while (len > 0)
-	{
-	    first_attr = ScreenAttrs[off];
-	    gui.highlight_mask = first_attr;
-#if defined(FEAT_MBYTE) && !defined(HAVE_GTK2)
-	    if (enc_utf8 && ScreenLinesUC[off] != 0)
-	    {
-		/* output multi-byte character separately */
-		nback = gui_screenchar(off, flags,
-					  (guicolor_T)0, (guicolor_T)0, back);
-		if (gui.col < Columns && ScreenLines[off + 1] == 0)
-		    idx = 2;
-		else
-		    idx = 1;
-	    }
-	    else if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
-	    {
-		/* output double-byte, single-width character separately */
-		nback = gui_screenchar(off, flags,
-					  (guicolor_T)0, (guicolor_T)0, back);
-		idx = 1;
-	    }
-	    else
-#endif
-	    {
-#ifdef HAVE_GTK2
-		for (idx = 0; idx < len; ++idx)
-		{
-		    if (enc_utf8 && ScreenLines[off + idx] == 0)
-			continue; /* skip second half of double-width char */
-		    if (ScreenAttrs[off + idx] != first_attr)
-			break;
-		}
-		/* gui_screenstr() takes care of multibyte chars */
-		nback = gui_screenstr(off, idx, flags,
-				      (guicolor_T)0, (guicolor_T)0, back);
-#else
-		for (idx = 0; idx < len && ScreenAttrs[off + idx] == first_attr;
-									idx++)
-		{
-# ifdef FEAT_MBYTE
-		    /* Stop at a multi-byte Unicode character. */
-		    if (enc_utf8 && ScreenLinesUC[off + idx] != 0)
-			break;
-		    if (enc_dbcs == DBCS_JPNU)
-		    {
-			/* Stop at a double-byte single-width char. */
-			if (ScreenLines[off + idx] == 0x8e)
-			    break;
-			if (len > 1 && (*mb_ptr2len_check)(ScreenLines
-							    + off + idx) == 2)
-			    ++idx;  /* skip second byte of double-byte char */
-		    }
-# endif
-		}
-		nback = gui_outstr_nowrap(ScreenLines + off, idx, flags,
-					  (guicolor_T)0, (guicolor_T)0, back);
-#endif
-	    }
-	    if (nback == FAIL)
-	    {
-		/* Must back up to start drawing where a bold or italic word
-		 * starts. */
-		off -= back;
-		len += back;
-		gui.col -= back;
-	    }
-	    else
-	    {
-		off += idx;
-		len -= idx;
-	    }
-	    back = 0;
-	}
-    }
-
-    /* Put the cursor back where it was */
-    gui.row = old_row;
-    gui.col = old_col;
-    gui.highlight_mask = old_hl_mask;
-
-    return retval;
-}
-
-    static void
-gui_delete_lines(row, count)
-    int	    row;
-    int	    count;
-{
-    if (count <= 0)
-	return;
-
-    if (row + count > gui.scroll_region_bot)
-	/* Scrolled out of region, just blank the lines out */
-	gui_clear_block(row, gui.scroll_region_left,
-			      gui.scroll_region_bot, gui.scroll_region_right);
-    else
-    {
-	gui_mch_delete_lines(row, count);
-
-	/* If the cursor was in the deleted lines it's now gone.  If the
-	 * cursor was in the scrolled lines adjust its position. */
-	if (gui.cursor_row >= row
-		&& gui.cursor_col >= gui.scroll_region_left
-		&& gui.cursor_col <= gui.scroll_region_right)
-	{
-	    if (gui.cursor_row < row + count)
-		gui.cursor_is_valid = FALSE;
-	    else if (gui.cursor_row <= gui.scroll_region_bot)
-		gui.cursor_row -= count;
-	}
-    }
-}
-
-    static void
-gui_insert_lines(row, count)
-    int	    row;
-    int	    count;
-{
-    if (count <= 0)
-	return;
-
-    if (row + count > gui.scroll_region_bot)
-	/* Scrolled out of region, just blank the lines out */
-	gui_clear_block(row, gui.scroll_region_left,
-			      gui.scroll_region_bot, gui.scroll_region_right);
-    else
-    {
-	gui_mch_insert_lines(row, count);
-
-	if (gui.cursor_row >= gui.row
-		&& gui.cursor_col >= gui.scroll_region_left
-		&& gui.cursor_col <= gui.scroll_region_right)
-	{
-	    if (gui.cursor_row <= gui.scroll_region_bot - count)
-		gui.cursor_row += count;
-	    else if (gui.cursor_row <= gui.scroll_region_bot)
-		gui.cursor_is_valid = FALSE;
-	}
-    }
-}
-
-/*
- * The main GUI input routine.	Waits for a character from the keyboard.
- * wtime == -1	    Wait forever.
- * wtime == 0	    Don't wait.
- * wtime > 0	    Wait wtime milliseconds for a character.
- * Returns OK if a character was found to be available within the given time,
- * or FAIL otherwise.
- */
-    int
-gui_wait_for_chars(wtime)
-    long    wtime;
-{
-    int	    retval;
-#ifdef FEAT_AUTOCMD
-    static int once_already = 0;
-#endif
-
-    /*
-     * If we're going to wait a bit, update the menus and mouse shape for the
-     * current State.
-     */
-    if (wtime != 0)
-    {
-#ifdef FEAT_MENU
-	gui_update_menus(0);
-#endif
-    }
-
-    gui_mch_update();
-    if (input_available())	/* Got char, return immediately */
-    {
-#ifdef FEAT_AUTOCMD
-	once_already = 0;
-#endif
-	return OK;
-    }
-    if (wtime == 0)	/* Don't wait for char */
-    {
-#ifdef FEAT_AUTOCMD
-	once_already = 0;
-#endif
-	return FAIL;
-    }
-
-    /* Before waiting, flush any output to the screen. */
-    gui_mch_flush();
-
-    if (wtime > 0)
-    {
-	/* Blink when waiting for a character.	Probably only does something
-	 * for showmatch() */
-	gui_mch_start_blink();
-	retval = gui_mch_wait_for_chars(wtime);
-	gui_mch_stop_blink();
-#ifdef FEAT_AUTOCMD
-	once_already = 0;
-#endif
-	return retval;
-    }
-
-    /*
-     * While we are waiting indefenitely for a character, blink the cursor.
-     */
-    gui_mch_start_blink();
-
-
-#ifdef FEAT_AUTOCMD
-    /* If there is no character available within 2 seconds (default),
-     * write the autoscript file to disk */
-    if (once_already == 2)
-    {
-	updatescript(0);
-	retval = gui_mch_wait_for_chars(-1L);
-	once_already = 0;
-    }
-    else if (once_already == 1)
-    {
-	setcursor();
-	once_already = 2;
-	retval = 0;
-    }
-    else
-#endif
-	if (gui_mch_wait_for_chars(p_ut) != OK)
-    {
-#ifdef FEAT_AUTOCMD
-	if (has_cursorhold() && get_real_state() == NORMAL_BUSY)
-	{
-	    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);
-	    update_screen(VALID);
-	    showruler(FALSE);
-	    setcursor();
-	    /* In case the commands moved the focus to another window
-	     * (temporarily). */
-	    if (need_mouse_correct)
-		gui_mouse_correct();
-
-	    once_already = 1;
-	    retval = 0;
-	}
-	else
-#endif
-	{
-	    updatescript(0);
-	    retval = gui_mch_wait_for_chars(-1L);
-#ifdef FEAT_AUTOCMD
-	    once_already = 0;
-#endif
-	}
-    }
-    else
-	retval = OK;
-
-    gui_mch_stop_blink();
-    return retval;
-}
-
-/*
- * Fill buffer with mouse coordinates encoded for check_termcode().
- */
-    static void
-fill_mouse_coord(p, col, row)
-    char_u	*p;
-    int		col;
-    int		row;
-{
-    p[0] = (char_u)(col / 128 + ' ' + 1);
-    p[1] = (char_u)(col % 128 + ' ' + 1);
-    p[2] = (char_u)(row / 128 + ' ' + 1);
-    p[3] = (char_u)(row % 128 + ' ' + 1);
-}
-
-/*
- * Generic mouse support function.  Add a mouse event to the input buffer with
- * the given properties.
- *  button	    --- may be any of MOUSE_LEFT, MOUSE_MIDDLE, MOUSE_RIGHT,
- *			MOUSE_X1, MOUSE_X2
- *			MOUSE_DRAG, or MOUSE_RELEASE.
- *			MOUSE_4 and MOUSE_5 are used for a scroll wheel.
- *  x, y	    --- Coordinates of mouse in pixels.
- *  repeated_click  --- TRUE if this click comes only a short time after a
- *			previous click.
- *  modifiers	    --- Bit field which may be any of the following modifiers
- *			or'ed together: MOUSE_SHIFT | MOUSE_CTRL | MOUSE_ALT.
- * This function will ignore drag events where the mouse has not moved to a new
- * character.
- */
-    void
-gui_send_mouse_event(button, x, y, repeated_click, modifiers)
-    int	    button;
-    int	    x;
-    int	    y;
-    int	    repeated_click;
-    int_u   modifiers;
-{
-    static int	    prev_row = 0, prev_col = 0;
-    static int	    prev_button = -1;
-    static int	    num_clicks = 1;
-    char_u	    string[10];
-    enum key_extra  button_char;
-    int		    row, col;
-#ifdef FEAT_CLIPBOARD
-    int		    checkfor;
-    int		    did_clip = FALSE;
-#endif
-
-    /*
-     * Scrolling may happen at any time, also while a selection is present.
-     */
-    switch (button)
-    {
-	case MOUSE_X1:
-	    button_char = KE_X1MOUSE;
-	    goto button_set;
-	case MOUSE_X2:
-	    button_char = KE_X2MOUSE;
-	    goto button_set;
-	case MOUSE_4:
-	    button_char = KE_MOUSEDOWN;
-	    goto button_set;
-	case MOUSE_5:
-	    button_char = KE_MOUSEUP;
-button_set:
-	    {
-		/* Don't put events in the input queue now. */
-		if (hold_gui_events)
-		    return;
-
-		string[3] = CSI;
-		string[4] = KS_EXTRA;
-		string[5] = (int)button_char;
-
-		/* Pass the pointer coordinates of the scroll event so that we
-		 * know which window to scroll. */
-		row = gui_xy2colrow(x, y, &col);
-		string[6] = (char_u)(col / 128 + ' ' + 1);
-		string[7] = (char_u)(col % 128 + ' ' + 1);
-		string[8] = (char_u)(row / 128 + ' ' + 1);
-		string[9] = (char_u)(row % 128 + ' ' + 1);
-
-		if (modifiers == 0)
-		    add_to_input_buf(string + 3, 7);
-		else
-		{
-		    string[0] = CSI;
-		    string[1] = KS_MODIFIER;
-		    string[2] = 0;
-		    if (modifiers & MOUSE_SHIFT)
-			string[2] |= MOD_MASK_SHIFT;
-		    if (modifiers & MOUSE_CTRL)
-			string[2] |= MOD_MASK_CTRL;
-		    if (modifiers & MOUSE_ALT)
-			string[2] |= MOD_MASK_ALT;
-		    add_to_input_buf(string, 10);
-		}
-		return;
-	    }
-    }
-
-#ifdef FEAT_CLIPBOARD
-    /* If a clipboard selection is in progress, handle it */
-    if (clip_star.state == SELECT_IN_PROGRESS)
-    {
-	clip_process_selection(button, X_2_COL(x), Y_2_ROW(y), repeated_click);
-	return;
-    }
-
-    /* Determine which mouse settings to look for based on the current mode */
-    switch (get_real_state())
-    {
-	case NORMAL_BUSY:
-	case OP_PENDING:
-	case NORMAL:		checkfor = MOUSE_NORMAL;	break;
-	case VISUAL:		checkfor = MOUSE_VISUAL;	break;
-	case REPLACE:
-	case REPLACE+LANGMAP:
-#ifdef FEAT_VREPLACE
-	case VREPLACE:
-	case VREPLACE+LANGMAP:
-#endif
-	case INSERT:
-	case INSERT+LANGMAP:	checkfor = MOUSE_INSERT;	break;
-	case ASKMORE:
-	case HITRETURN:		/* At the more- and hit-enter prompt pass the
-				   mouse event for a click on or below the
-				   message line. */
-				if (Y_2_ROW(y) >= msg_row)
-				    checkfor = MOUSE_NORMAL;
-				else
-				    checkfor = MOUSE_RETURN;
-				break;
-
-	    /*
-	     * On the command line, use the clipboard selection on all lines
-	     * but the command line.  But not when pasting.
-	     */
-	case CMDLINE:
-	case CMDLINE+LANGMAP:
-	    if (Y_2_ROW(y) < cmdline_row && button != MOUSE_MIDDLE)
-		checkfor = MOUSE_NONE;
-	    else
-		checkfor = MOUSE_COMMAND;
-	    break;
-
-	default:
-	    checkfor = MOUSE_NONE;
-	    break;
-    };
-
-    /*
-     * Allow clipboard selection of text on the command line in "normal"
-     * modes.  Don't do this when dragging the status line, or extending a
-     * Visual selection.
-     */
-    if ((State == NORMAL || State == NORMAL_BUSY || (State & INSERT))
-	    && Y_2_ROW(y) >= topframe->fr_height
-	    && button != MOUSE_DRAG
-# ifdef FEAT_MOUSESHAPE
-	    && !drag_status_line
-#  ifdef FEAT_VERTSPLIT
-	    && !drag_sep_line
-#  endif
-# endif
-	    )
-	checkfor = MOUSE_NONE;
-
-    /*
-     * Use modeless selection when holding CTRL and SHIFT pressed.
-     */
-    if ((modifiers & MOUSE_CTRL) && (modifiers & MOUSE_SHIFT))
-	checkfor = MOUSE_NONEF;
-
-    /*
-     * In Ex mode, always use modeless selection.
-     */
-    if (exmode_active)
-	checkfor = MOUSE_NONE;
-
-    /*
-     * If the mouse settings say to not use the mouse, use the modeless
-     * selection.  But if Visual is active, assume that only the Visual area
-     * will be selected.
-     * Exception: On the command line, both the selection is used and a mouse
-     * key is send.
-     */
-    if (!mouse_has(checkfor) || checkfor == MOUSE_COMMAND)
-    {
-#ifdef FEAT_VISUAL
-	/* Don't do modeless selection in Visual mode. */
-	if (checkfor != MOUSE_NONEF && VIsual_active && (State & NORMAL))
-	    return;
-#endif
-
-	/*
-	 * When 'mousemodel' is "popup", shift-left is translated to right.
-	 * But not when also using Ctrl.
-	 */
-	if (mouse_model_popup() && button == MOUSE_LEFT
-		&& (modifiers & MOUSE_SHIFT) && !(modifiers & MOUSE_CTRL))
-	{
-	    button = MOUSE_RIGHT;
-	    modifiers &= ~ MOUSE_SHIFT;
-	}
-
-	/* If the selection is done, allow the right button to extend it.
-	 * If the selection is cleared, allow the right button to start it
-	 * from the cursor position. */
-	if (button == MOUSE_RIGHT)
-	{
-	    if (clip_star.state == SELECT_CLEARED)
-	    {
-		if (State & CMDLINE)
-		{
-		    col = msg_col;
-		    row = msg_row;
-		}
-		else
-		{
-		    col = curwin->w_wcol;
-		    row = curwin->w_wrow + W_WINROW(curwin);
-		}
-		clip_start_selection(col, row, FALSE);
-	    }
-	    clip_process_selection(button, X_2_COL(x), Y_2_ROW(y),
-							      repeated_click);
-	    did_clip = TRUE;
-	}
-	/* Allow the left button to start the selection */
-	else if (button ==
-# ifdef RISCOS
-		/* Only start a drag on a drag event. Otherwise
-		 * we don't get a release event. */
-		    MOUSE_DRAG
-# else
-		    MOUSE_LEFT
-# endif
-				)
-	{
-	    clip_start_selection(X_2_COL(x), Y_2_ROW(y), repeated_click);
-	    did_clip = TRUE;
-	}
-# ifdef RISCOS
-	else if (button == MOUSE_LEFT)
-	{
-	    clip_clear_selection();
-	    did_clip = TRUE;
-	}
-# endif
-
-	/* Always allow pasting */
-	if (button != MOUSE_MIDDLE)
-	{
-	    if (!mouse_has(checkfor) || button == MOUSE_RELEASE)
-		return;
-	    if (checkfor != MOUSE_COMMAND)
-		button = MOUSE_LEFT;
-	}
-	repeated_click = FALSE;
-    }
-
-    if (clip_star.state != SELECT_CLEARED && !did_clip)
-	clip_clear_selection();
-#endif
-
-    /* Don't put events in the input queue now. */
-    if (hold_gui_events)
-	return;
-
-    row = gui_xy2colrow(x, y, &col);
-
-    /*
-     * If we are dragging and the mouse hasn't moved far enough to be on a
-     * different character, then don't send an event to vim.
-     */
-    if (button == MOUSE_DRAG)
-    {
-	if (row == prev_row && col == prev_col)
-	    return;
-	/* Dragging above the window, set "row" to -1 to cause a scroll. */
-	if (y < 0)
-	    row = -1;
-    }
-
-    /*
-     * If topline has changed (window scrolled) since the last click, reset
-     * repeated_click, because we don't want starting Visual mode when
-     * clicking on a different character in the text.
-     */
-    if (curwin->w_topline != gui_prev_topline
-#ifdef FEAT_DIFF
-	    || curwin->w_topfill != gui_prev_topfill
-#endif
-	    )
-	repeated_click = FALSE;
-
-    string[0] = CSI;	/* this sequence is recognized by check_termcode() */
-    string[1] = KS_MOUSE;
-    string[2] = KE_FILLER;
-    if (button != MOUSE_DRAG && button != MOUSE_RELEASE)
-    {
-	if (repeated_click)
-	{
-	    /*
-	     * Handle multiple clicks.	They only count if the mouse is still
-	     * pointing at the same character.
-	     */
-	    if (button != prev_button || row != prev_row || col != prev_col)
-		num_clicks = 1;
-	    else if (++num_clicks > 4)
-		num_clicks = 1;
-	}
-	else
-	    num_clicks = 1;
-	prev_button = button;
-	gui_prev_topline = curwin->w_topline;
-#ifdef FEAT_DIFF
-	gui_prev_topfill = curwin->w_topfill;
-#endif
-
-	string[3] = (char_u)(button | 0x20);
-	SET_NUM_MOUSE_CLICKS(string[3], num_clicks);
-    }
-    else
-	string[3] = (char_u)button;
-
-    string[3] |= modifiers;
-    fill_mouse_coord(string + 4, col, row);
-    add_to_input_buf(string, 8);
-
-    if (row < 0)
-	prev_row = 0;
-    else
-	prev_row = row;
-    prev_col = col;
-
-    /*
-     * We need to make sure this is cleared since Athena doesn't tell us when
-     * he is done dragging.  Neither does GTK+ 2 -- at least for now.
-     */
-#if defined(FEAT_GUI_ATHENA) || defined(HAVE_GTK2)
-    gui.dragged_sb = SBAR_NONE;
-#endif
-}
-
-/*
- * Convert x and y coordinate to column and row in text window.
- * Corrects for multi-byte character.
- * returns column in "*colp" and row as return value;
- */
-    int
-gui_xy2colrow(x, y, colp)
-    int		x;
-    int		y;
-    int		*colp;
-{
-    int		col = check_col(X_2_COL(x));
-    int		row = check_row(Y_2_ROW(y));
-
-#ifdef FEAT_MBYTE
-    *colp = mb_fix_col(col, row);
-#else
-    *colp = col;
-#endif
-    return row;
-}
-
-#if defined(FEAT_MENU) || defined(PROTO)
-/*
- * Callback function for when a menu entry has been selected.
- */
-    void
-gui_menu_cb(menu)
-    vimmenu_T *menu;
-{
-    char_u  bytes[3 + sizeof(long_u)];
-
-    /* Don't put events in the input queue now. */
-    if (hold_gui_events)
-	return;
-
-    bytes[0] = CSI;
-    bytes[1] = KS_MENU;
-    bytes[2] = KE_FILLER;
-    add_long_to_buf((long_u)menu, bytes + 3);
-    add_to_input_buf(bytes, 3 + sizeof(long_u));
-}
-#endif
-
-/*
- * Set which components are present.
- * If "oldval" is not NULL, "oldval" is the previous value, the new * value is
- * in p_go.
- */
-/*ARGSUSED*/
-    void
-gui_init_which_components(oldval)
-    char_u	*oldval;
-{
-    static int	prev_which_scrollbars[3] = {-1, -1, -1};
-#ifdef FEAT_MENU
-    static int	prev_menu_is_active = -1;
-#endif
-#ifdef FEAT_TOOLBAR
-    static int	prev_toolbar = -1;
-    int		using_toolbar = FALSE;
-#endif
-#ifdef FEAT_FOOTER
-    static int	prev_footer = -1;
-    int		using_footer = FALSE;
-#endif
-#if defined(FEAT_MENU) && !defined(WIN16)
-    static int	prev_tearoff = -1;
-    int		using_tearoff = FALSE;
-#endif
-
-    char_u	*p;
-    int		i;
-#ifdef FEAT_MENU
-    int		grey_old, grey_new;
-    char_u	*temp;
-#endif
-    win_T	*wp;
-    int		need_set_size;
-    int		fix_size;
-
-#ifdef FEAT_MENU
-    if (oldval != NULL && gui.in_use)
-    {
-	/*
-	 * Check if the menu's go from grey to non-grey or vise versa.
-	 */
-	grey_old = (vim_strchr(oldval, GO_GREY) != NULL);
-	grey_new = (vim_strchr(p_go, GO_GREY) != NULL);
-	if (grey_old != grey_new)
-	{
-	    temp = p_go;
-	    p_go = oldval;
-	    gui_update_menus(MENU_ALL_MODES);
-	    p_go = temp;
-	}
-    }
-    gui.menu_is_active = FALSE;
-#endif
-
-    for (i = 0; i < 3; i++)
-	gui.which_scrollbars[i] = FALSE;
-    for (p = p_go; *p; p++)
-	switch (*p)
-	{
-	    case GO_LEFT:
-		gui.which_scrollbars[SBAR_LEFT] = TRUE;
-		break;
-	    case GO_RIGHT:
-		gui.which_scrollbars[SBAR_RIGHT] = TRUE;
-		break;
-#ifdef FEAT_VERTSPLIT
-	    case GO_VLEFT:
-		if (win_hasvertsplit())
-		    gui.which_scrollbars[SBAR_LEFT] = TRUE;
-		break;
-	    case GO_VRIGHT:
-		if (win_hasvertsplit())
-		    gui.which_scrollbars[SBAR_RIGHT] = TRUE;
-		break;
-#endif
-	    case GO_BOT:
-		gui.which_scrollbars[SBAR_BOTTOM] = TRUE;
-		break;
-#ifdef FEAT_MENU
-	    case GO_MENUS:
-		gui.menu_is_active = TRUE;
-		break;
-#endif
-	    case GO_GREY:
-		/* make menu's have grey items, ignored here */
-		break;
-#ifdef FEAT_TOOLBAR
-	    case GO_TOOLBAR:
-		using_toolbar = TRUE;
-		break;
-#endif
-#ifdef FEAT_FOOTER
-	    case GO_FOOTER:
-		using_footer = TRUE;
-		break;
-#endif
-	    case GO_TEAROFF:
-#if defined(FEAT_MENU) && !defined(WIN16)
-		using_tearoff = TRUE;
-#endif
-		break;
-	    default:
-		/* Ignore options that are not supported */
-		break;
-	}
-    if (gui.in_use)
-    {
-	need_set_size = FALSE;
-	fix_size = FALSE;
-	for (i = 0; i < 3; i++)
-	{
-	    if (gui.which_scrollbars[i] != prev_which_scrollbars[i])
-	    {
-		if (i == SBAR_BOTTOM)
-		    gui_mch_enable_scrollbar(&gui.bottom_sbar,
-						     gui.which_scrollbars[i]);
-		else
-		{
-		    FOR_ALL_WINDOWS(wp)
-		    {
-			gui_do_scrollbar(wp, i, gui.which_scrollbars[i]);
-		    }
-		}
-		need_set_size = TRUE;
-		if (gui.which_scrollbars[i])
-		    fix_size = TRUE;
-	    }
-	    prev_which_scrollbars[i] = gui.which_scrollbars[i];
-	}
-
-#ifdef FEAT_MENU
-	if (gui.menu_is_active != prev_menu_is_active)
-	{
-	    /* We don't want a resize event change "Rows" here, save and
-	     * restore it.  Resizing is handled below. */
-	    i = Rows;
-	    gui_mch_enable_menu(gui.menu_is_active);
-	    Rows = i;
-	    prev_menu_is_active = gui.menu_is_active;
-	    need_set_size = TRUE;
-	    if (gui.menu_is_active)
-		fix_size = TRUE;
-	}
-#endif
-
-#ifdef FEAT_TOOLBAR
-	if (using_toolbar != prev_toolbar)
-	{
-	    gui_mch_show_toolbar(using_toolbar);
-	    prev_toolbar = using_toolbar;
-	    need_set_size = TRUE;
-	    if (using_toolbar)
-		fix_size = TRUE;
-	}
-#endif
-#ifdef FEAT_FOOTER
-	if (using_footer != prev_footer)
-	{
-	    gui_mch_enable_footer(using_footer);
-	    prev_footer = using_footer;
-	    need_set_size = TRUE;
-	    if (using_footer)
-		fix_size = TRUE;
-	}
-#endif
-#if defined(FEAT_MENU) && !defined(WIN16) && !(defined(WIN3264) && !defined(FEAT_TEAROFF))
-	if (using_tearoff != prev_tearoff)
-	{
-	    gui_mch_toggle_tearoffs(using_tearoff);
-	    prev_tearoff = using_tearoff;
-	}
-#endif
-	if (need_set_size)
-	    /* Adjust the size of the window to make the text area keep the
-	     * same size and to avoid that part of our window is off-screen
-	     * and a scrollbar can't be used, for example. */
-	    gui_set_shellsize(FALSE, fix_size);
-    }
-}
-
-
-/*
- * Scrollbar stuff:
- */
-
-    void
-gui_create_scrollbar(sb, type, wp)
-    scrollbar_T	*sb;
-    int		type;
-    win_T	*wp;
-{
-    static int	sbar_ident = 0;
-
-    sb->ident = sbar_ident++;	/* No check for too big, but would it happen? */
-    sb->wp = wp;
-    sb->type = type;
-    sb->value = 0;
-#ifdef FEAT_GUI_ATHENA
-    sb->pixval = 0;
-#endif
-    sb->size = 1;
-    sb->max = 1;
-    sb->top = 0;
-    sb->height = 0;
-#ifdef FEAT_VERTSPLIT
-    sb->width = 0;
-#endif
-    sb->status_height = 0;
-    gui_mch_create_scrollbar(sb, (wp == NULL) ? SBAR_HORIZ : SBAR_VERT);
-}
-
-/*
- * Find the scrollbar with the given index.
- */
-    scrollbar_T *
-gui_find_scrollbar(ident)
-    long	ident;
-{
-    win_T	*wp;
-
-    if (gui.bottom_sbar.ident == ident)
-	return &gui.bottom_sbar;
-    FOR_ALL_WINDOWS(wp)
-    {
-	if (wp->w_scrollbars[SBAR_LEFT].ident == ident)
-	    return &wp->w_scrollbars[SBAR_LEFT];
-	if (wp->w_scrollbars[SBAR_RIGHT].ident == ident)
-	    return &wp->w_scrollbars[SBAR_RIGHT];
-    }
-    return NULL;
-}
-
-/*
- * For most systems: Put a code in the input buffer for a dragged scrollbar.
- *
- * For Win32, Macintosh and GTK+ 2:
- * Scrollbars seem to grab focus and vim doesn't read the input queue until
- * you stop dragging the scrollbar.  We get here each time the scrollbar is
- * dragged another pixel, but as far as the rest of vim goes, it thinks
- * we're just hanging in the call to DispatchMessage() in
- * process_message().  The DispatchMessage() call that hangs was passed a
- * mouse button click event in the scrollbar window. -- webb.
- *
- * Solution: Do the scrolling right here.  But only when allowed.
- * Ignore the scrollbars while executing an external command or when there
- * are still characters to be processed.
- */
-    void
-gui_drag_scrollbar(sb, value, still_dragging)
-    scrollbar_T	*sb;
-    long	value;
-    int		still_dragging;
-{
-#ifdef FEAT_WINDOWS
-    win_T	*wp;
-#endif
-    int		sb_num;
-#ifdef USE_ON_FLY_SCROLL
-    colnr_T	old_leftcol = curwin->w_leftcol;
-# ifdef FEAT_SCROLLBIND
-    linenr_T	old_topline = curwin->w_topline;
-# endif
-# ifdef FEAT_DIFF
-    int		old_topfill = curwin->w_topfill;
-# endif
-#else
-    char_u	bytes[4 + sizeof(long_u)];
-    int		byte_count;
-#endif
-
-    if (sb == NULL)
-	return;
-
-    /* Don't put events in the input queue now. */
-    if (hold_gui_events)
-	return;
-
-#ifdef FEAT_CMDWIN
-    if (cmdwin_type != 0 && sb->wp != curwin)
-	return;
-#endif
-
-    if (still_dragging)
-    {
-	if (sb->wp == NULL)
-	    gui.dragged_sb = SBAR_BOTTOM;
-	else if (sb == &sb->wp->w_scrollbars[SBAR_LEFT])
-	    gui.dragged_sb = SBAR_LEFT;
-	else
-	    gui.dragged_sb = SBAR_RIGHT;
-	gui.dragged_wp = sb->wp;
-    }
-    else
-    {
-	gui.dragged_sb = SBAR_NONE;
-#ifdef HAVE_GTK2
-	/* Keep the "dragged_wp" value until after the scrolling, for when the
-	 * moust button is released.  GTK2 doesn't send the button-up event. */
-	gui.dragged_wp = NULL;
-#endif
-    }
-
-    /* Vertical sbar info is kept in the first sbar (the left one) */
-    if (sb->wp != NULL)
-	sb = &sb->wp->w_scrollbars[0];
-
-    /*
-     * Check validity of value
-     */
-    if (value < 0)
-	value = 0;
-#ifdef SCROLL_PAST_END
-    else if (value > sb->max)
-	value = sb->max;
-#else
-    if (value > sb->max - sb->size + 1)
-	value = sb->max - sb->size + 1;
-#endif
-
-    sb->value = value;
-
-#ifdef USE_ON_FLY_SCROLL
-    /* When not allowed to do the scrolling right now, return. */
-    if (dont_scroll || input_available())
-	return;
-#endif
-
-#ifdef FEAT_RIGHTLEFT
-    if (sb->wp == NULL && curwin->w_p_rl)
-    {
-	value = sb->max + 1 - sb->size - value;
-	if (value < 0)
-	    value = 0;
-    }
-#endif
-
-    if (sb->wp != NULL)		/* vertical scrollbar */
-    {
-	sb_num = 0;
-#ifdef FEAT_WINDOWS
-	for (wp = firstwin; wp != sb->wp && wp != NULL; wp = wp->w_next)
-	    sb_num++;
-	if (wp == NULL)
-	    return;
-#else
-	if (sb->wp != curwin)
-	    return;
-#endif
-
-#ifdef USE_ON_FLY_SCROLL
-	current_scrollbar = sb_num;
-	scrollbar_value = value;
-	if (State & NORMAL)
-	{
-	    gui_do_scroll();
-	    setcursor();
-	}
-	else if (State & INSERT)
-	{
-	    ins_scroll();
-	    setcursor();
-	}
-	else if (State & CMDLINE)
-	{
-	    if (msg_scrolled == 0)
-	    {
-		gui_do_scroll();
-		redrawcmdline();
-	    }
-	}
-# ifdef FEAT_FOLDING
-	/* Value may have been changed for closed fold. */
-	sb->value = sb->wp->w_topline - 1;
-# endif
-#else
-	bytes[0] = CSI;
-	bytes[1] = KS_VER_SCROLLBAR;
-	bytes[2] = KE_FILLER;
-	bytes[3] = (char_u)sb_num;
-	byte_count = 4;
-#endif
-    }
-    else
-    {
-#ifdef USE_ON_FLY_SCROLL
-	scrollbar_value = value;
-
-	if (State & NORMAL)
-	    gui_do_horiz_scroll();
-	else if (State & INSERT)
-	    ins_horscroll();
-	else if (State & CMDLINE)
-	{
-	    if (!msg_scrolled)
-	    {
-		gui_do_horiz_scroll();
-		redrawcmdline();
-	    }
-	}
-	if (old_leftcol != curwin->w_leftcol)
-	{
-	    updateWindow(curwin);   /* update window, status and cmdline */
-	    setcursor();
-	}
-#else
-	bytes[0] = CSI;
-	bytes[1] = KS_HOR_SCROLLBAR;
-	bytes[2] = KE_FILLER;
-	byte_count = 3;
-#endif
-    }
-
-#ifdef USE_ON_FLY_SCROLL
-# ifdef FEAT_SCROLLBIND
-    /*
-     * synchronize other windows, as necessary according to 'scrollbind'
-     */
-    if (curwin->w_p_scb
-	    && ((sb->wp == NULL && curwin->w_leftcol != old_leftcol)
-		|| (sb->wp == curwin && (curwin->w_topline != old_topline
-#  ifdef FEAT_DIFF
-					   || curwin->w_topfill != old_topfill
-#  endif
-			))))
-    {
-	do_check_scrollbind(TRUE);
-	/* need to update the window right here */
-	for (wp = firstwin; wp != NULL; wp = wp->w_next)
-	    if (wp->w_redr_type > 0)
-		updateWindow(wp);
-	setcursor();
-    }
-# endif
-    out_flush();
-    gui_update_cursor(FALSE, TRUE);
-#else
-    add_long_to_buf((long)value, bytes + byte_count);
-    add_to_input_buf(bytes, byte_count + sizeof(long_u));
-#endif
-}
-
-/*
- * Scrollbar stuff:
- */
-
-    void
-gui_update_scrollbars(force)
-    int		force;	    /* Force all scrollbars to get updated */
-{
-    win_T	*wp;
-    scrollbar_T	*sb;
-    long	val, size, max;		/* need 32 bits here */
-    int		which_sb;
-    int		h, y;
-#ifdef FEAT_VERTSPLIT
-    static win_T *prev_curwin = NULL;
-#endif
-
-    /* Update the horizontal scrollbar */
-    gui_update_horiz_scrollbar(force);
-
-#ifndef WIN3264
-    /* Return straight away if there is neither a left nor right scrollbar.
-     * On MS-Windows this is required anyway for scrollwheel messages. */
-    if (!gui.which_scrollbars[SBAR_LEFT] && !gui.which_scrollbars[SBAR_RIGHT])
-	return;
-#endif
-
-    /*
-     * Don't want to update a scrollbar while we're dragging it.  But if we
-     * have both a left and right scrollbar, and we drag one of them, we still
-     * need to update the other one.
-     */
-    if (       (gui.dragged_sb == SBAR_LEFT
-		|| gui.dragged_sb == SBAR_RIGHT)
-	    && (!gui.which_scrollbars[SBAR_LEFT]
-		|| !gui.which_scrollbars[SBAR_RIGHT])
-	    && !force)
-	return;
-
-    if (!force && (gui.dragged_sb == SBAR_LEFT || gui.dragged_sb == SBAR_RIGHT))
-    {
-	/*
-	 * If we have two scrollbars and one of them is being dragged, just
-	 * copy the scrollbar position from the dragged one to the other one.
-	 */
-	which_sb = SBAR_LEFT + SBAR_RIGHT - gui.dragged_sb;
-	if (gui.dragged_wp != NULL)
-	    gui_mch_set_scrollbar_thumb(
-		    &gui.dragged_wp->w_scrollbars[which_sb],
-		    gui.dragged_wp->w_scrollbars[0].value,
-		    gui.dragged_wp->w_scrollbars[0].size,
-		    gui.dragged_wp->w_scrollbars[0].max);
-	return;
-    }
-
-    /* avoid that moving components around generates events */
-    ++hold_gui_events;
-
-    for (wp = firstwin; wp != NULL; wp = W_NEXT(wp))
-    {
-	if (wp->w_buffer == NULL)	/* just in case */
-	    continue;
-#ifdef SCROLL_PAST_END
-	max = wp->w_buffer->b_ml.ml_line_count - 1;
-#else
-	max = wp->w_buffer->b_ml.ml_line_count + wp->w_height - 2;
-#endif
-	if (max < 0)			/* empty buffer */
-	    max = 0;
-	val = wp->w_topline - 1;
-	size = wp->w_height;
-#ifdef SCROLL_PAST_END
-	if (val > max)			/* just in case */
-	    val = max;
-#else
-	if (size > max + 1)		/* just in case */
-	    size = max + 1;
-	if (val > max - size + 1)
-	    val = max - size + 1;
-#endif
-	if (val < 0)			/* minimal value is 0 */
-	    val = 0;
-
-	/*
-	 * Scrollbar at index 0 (the left one) contains all the information.
-	 * It would be the same info for left and right so we just store it for
-	 * one of them.
-	 */
-	sb = &wp->w_scrollbars[0];
-
-	/*
-	 * Note: no check for valid w_botline.	If it's not valid the
-	 * scrollbars will be updated later anyway.
-	 */
-	if (size < 1 || wp->w_botline - 2 > max)
-	{
-	    /*
-	     * This can happen during changing files.  Just don't update the
-	     * scrollbar for now.
-	     */
-	    sb->height = 0;	    /* Force update next time */
-	    if (gui.which_scrollbars[SBAR_LEFT])
-		gui_do_scrollbar(wp, SBAR_LEFT, FALSE);
-	    if (gui.which_scrollbars[SBAR_RIGHT])
-		gui_do_scrollbar(wp, SBAR_RIGHT, FALSE);
-	    continue;
-	}
-	if (force || sb->height != wp->w_height
-#ifdef FEAT_WINDOWS
-	    || sb->top != wp->w_winrow
-	    || sb->status_height != wp->w_status_height
-# ifdef FEAT_VERTSPLIT
-	    || sb->width != wp->w_width
-	    || prev_curwin != curwin
-# endif
-#endif
-	    )
-	{
-	    /* Height, width or position of scrollbar has changed.  For
-	     * vertical split: curwin changed. */
-	    sb->height = wp->w_height;
-#ifdef FEAT_WINDOWS
-	    sb->top = wp->w_winrow;
-	    sb->status_height = wp->w_status_height;
-# ifdef FEAT_VERTSPLIT
-	    sb->width = wp->w_width;
-# endif
-#endif
-
-	    /* Calculate height and position in pixels */
-	    h = (sb->height + sb->status_height) * gui.char_height;
-	    y = sb->top * gui.char_height + gui.border_offset;
-#if defined(FEAT_MENU) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF) && !defined(FEAT_GUI_PHOTON)
-	    if (gui.menu_is_active)
-		y += gui.menu_height;
-#endif
-
-#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_ATHENA))
-	    if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
-# ifdef FEAT_GUI_ATHENA
-		y += gui.toolbar_height;
-# else
-#  ifdef FEAT_GUI_MSWIN
-		y += TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT;
-#  endif
-# endif
-#endif
-
-#ifdef FEAT_WINDOWS
-	    if (wp->w_winrow == 0)
-#endif
-	    {
-		/* Height of top scrollbar includes width of top border */
-		h += gui.border_offset;
-		y -= gui.border_offset;
-	    }
-	    if (gui.which_scrollbars[SBAR_LEFT])
-	    {
-		gui_mch_set_scrollbar_pos(&wp->w_scrollbars[SBAR_LEFT],
-					  gui.left_sbar_x, y,
-					  gui.scrollbar_width, h);
-		gui_do_scrollbar(wp, SBAR_LEFT, TRUE);
-	    }
-	    if (gui.which_scrollbars[SBAR_RIGHT])
-	    {
-		gui_mch_set_scrollbar_pos(&wp->w_scrollbars[SBAR_RIGHT],
-					  gui.right_sbar_x, y,
-					  gui.scrollbar_width, h);
-		gui_do_scrollbar(wp, SBAR_RIGHT, TRUE);
-	    }
-	}
-
-	/* Reduce the number of calls to gui_mch_set_scrollbar_thumb() by
-	 * checking if the thumb moved at least a pixel.  Only do this for
-	 * Athena, most other GUIs require the update anyway to make the
-	 * arrows work. */
-#ifdef FEAT_GUI_ATHENA
-	if (max == 0)
-	    y = 0;
-	else
-	    y = (val * (sb->height + 2) * gui.char_height + max / 2) / max;
-	if (force || sb->pixval != y || sb->size != size || sb->max != max)
-#else
-	if (force || sb->value != val || sb->size != size || sb->max != max)
-#endif
-	{
-	    /* Thumb of scrollbar has moved */
-	    sb->value = val;
-#ifdef FEAT_GUI_ATHENA
-	    sb->pixval = y;
-#endif
-	    sb->size = size;
-	    sb->max = max;
-	    if (gui.which_scrollbars[SBAR_LEFT] && gui.dragged_sb != SBAR_LEFT)
-		gui_mch_set_scrollbar_thumb(&wp->w_scrollbars[SBAR_LEFT],
-					    val, size, max);
-	    if (gui.which_scrollbars[SBAR_RIGHT]
-					&& gui.dragged_sb != SBAR_RIGHT)
-		gui_mch_set_scrollbar_thumb(&wp->w_scrollbars[SBAR_RIGHT],
-					    val, size, max);
-	}
-    }
-#ifdef FEAT_VERTSPLIT
-    prev_curwin = curwin;
-#endif
-    --hold_gui_events;
-}
-
-/*
- * Enable or disable a scrollbar.
- * Check for scrollbars for vertically split windows which are not enabled
- * sometimes.
- */
-    static void
-gui_do_scrollbar(wp, which, enable)
-    win_T	*wp;
-    int		which;	    /* SBAR_LEFT or SBAR_RIGHT */
-    int		enable;	    /* TRUE to enable scrollbar */
-{
-#ifdef FEAT_VERTSPLIT
-    int		midcol = curwin->w_wincol + curwin->w_width / 2;
-    int		has_midcol = (wp->w_wincol <= midcol
-				     && wp->w_wincol + wp->w_width >= midcol);
-
-    /* Only enable scrollbars that contain the middle column of the current
-     * window. */
-    if (gui.which_scrollbars[SBAR_RIGHT] != gui.which_scrollbars[SBAR_LEFT])
-    {
-	/* Scrollbars only on one side.  Don't enable scrollbars that don't
-	 * contain the middle column of the current window. */
-	if (!has_midcol)
-	    enable = FALSE;
-    }
-    else
-    {
-	/* Scrollbars on both sides.  Don't enable scrollbars that neither
-	 * contain the middle column of the current window nor are on the far
-	 * side. */
-	if (midcol > Columns / 2)
-	{
-	    if (which == SBAR_LEFT ? wp->w_wincol != 0 : !has_midcol)
-		enable = FALSE;
-	}
-	else
-	{
-	    if (which == SBAR_RIGHT ? wp->w_wincol + wp->w_width != Columns
-								: !has_midcol)
-		enable = FALSE;
-	}
-    }
-#endif
-    gui_mch_enable_scrollbar(&wp->w_scrollbars[which], enable);
-}
-
-/*
- * Scroll a window according to the values set in the globals current_scrollbar
- * and scrollbar_value.  Return TRUE if the cursor in the current window moved
- * or FALSE otherwise.
- */
-    int
-gui_do_scroll()
-{
-    win_T	*wp, *save_wp;
-    int		i;
-    long	nlines;
-    pos_T	old_cursor;
-    linenr_T	old_topline;
-#ifdef FEAT_DIFF
-    int		old_topfill;
-#endif
-
-    for (wp = firstwin, i = 0; i < current_scrollbar; wp = W_NEXT(wp), i++)
-	if (wp == NULL)
-	    break;
-    if (wp == NULL)
-	/* Couldn't find window */
-	return FALSE;
-
-    /*
-     * Compute number of lines to scroll.  If zero, nothing to do.
-     */
-    nlines = (long)scrollbar_value + 1 - (long)wp->w_topline;
-    if (nlines == 0)
-	return FALSE;
-
-    save_wp = curwin;
-    old_topline = wp->w_topline;
-#ifdef FEAT_DIFF
-    old_topfill = wp->w_topfill;
-#endif
-    old_cursor = wp->w_cursor;
-    curwin = wp;
-    curbuf = wp->w_buffer;
-    if (nlines < 0)
-	scrolldown(-nlines, gui.dragged_wp == NULL);
-    else
-	scrollup(nlines, gui.dragged_wp == NULL);
-    /* Reset dragged_wp after using it.  "dragged_sb" will have been reset for
-     * the mouse-up event already, but we still want it to behave like when
-     * dragging.  But not the next click in an arrow. */
-    if (gui.dragged_sb == SBAR_NONE)
-	gui.dragged_wp = NULL;
-
-    if (old_topline != wp->w_topline
-#ifdef FEAT_DIFF
-	    || old_topfill != wp->w_topfill
-#endif
-	    )
-    {
-	if (p_so != 0)
-	{
-	    cursor_correct();		/* fix window for 'so' */
-	    update_topline();		/* avoid up/down jump */
-	}
-	if (old_cursor.lnum != wp->w_cursor.lnum)
-	    coladvance(wp->w_curswant);
-#ifdef FEAT_SCROLLBIND
-	wp->w_scbind_pos = wp->w_topline;
-#endif
-    }
-
-    curwin = save_wp;
-    curbuf = save_wp->w_buffer;
-
-    /*
-     * Don't call updateWindow() when nothing has changed (it will overwrite
-     * the status line!).
-     */
-    if (old_topline != wp->w_topline
-#ifdef FEAT_DIFF
-	    || old_topfill != wp->w_topfill
-#endif
-	    )
-    {
-	redraw_win_later(wp, VALID);
-	updateWindow(wp);   /* update window, status line, and cmdline */
-    }
-
-    return (wp == curwin && !equalpos(curwin->w_cursor, old_cursor));
-}
-
-
-/*
- * Horizontal scrollbar stuff:
- */
-
-/*
- * Return length of line "lnum" for horizontal scrolling.
- */
-    static colnr_T
-scroll_line_len(lnum)
-    linenr_T	lnum;
-{
-    char_u	*p;
-    colnr_T	col;
-    int		w;
-
-    p = ml_get(lnum);
-    col = 0;
-    if (*p != NUL)
-	for (;;)
-	{
-	    w = chartabsize(p, col);
-#ifdef FEAT_MBYTE
-	    if (has_mbyte)
-		p += (*mb_ptr2len_check)(p);
-	    else
-#endif
-		++p;
-	    if (*p == NUL)		/* don't count the last character */
-		break;
-	    col += w;
-	}
-    return col;
-}
-
-/* Remember which line is currently the longest, so that we don't have to
- * search for it when scrolling horizontally. */
-static linenr_T longest_lnum = 0;
-
-    static void
-gui_update_horiz_scrollbar(force)
-    int		force;
-{
-    long	value, size, max;	/* need 32 bit ints here */
-
-    if (!gui.which_scrollbars[SBAR_BOTTOM])
-	return;
-
-    if (!force && gui.dragged_sb == SBAR_BOTTOM)
-	return;
-
-    if (!force && curwin->w_p_wrap && gui.prev_wrap)
-	return;
-
-    /*
-     * It is possible for the cursor to be invalid if we're in the middle of
-     * something (like changing files).  If so, don't do anything for now.
-     */
-    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
-    {
-	gui.bottom_sbar.value = -1;
-	return;
-    }
-
-    size = W_WIDTH(curwin);
-    if (curwin->w_p_wrap)
-    {
-	value = 0;
-#ifdef SCROLL_PAST_END
-	max = 0;
-#else
-	max = W_WIDTH(curwin) - 1;
-#endif
-    }
-    else
-    {
-	value = curwin->w_leftcol;
-
-	/* Calculate maximum for horizontal scrollbar.  Check for reasonable
-	 * line numbers, topline and botline can be invalid when displaying is
-	 * postponed. */
-	if (vim_strchr(p_go, GO_HORSCROLL) == NULL
-		&& curwin->w_topline <= curwin->w_cursor.lnum
-		&& curwin->w_botline > curwin->w_cursor.lnum
-		&& curwin->w_botline <= curbuf->b_ml.ml_line_count + 1)
-	{
-	    linenr_T	lnum;
-	    colnr_T	n;
-
-	    /* Use maximum of all visible lines.  Remember the lnum of the
-	     * longest line, clostest to the cursor line.  Used when scrolling
-	     * below. */
-	    max = 0;
-	    for (lnum = curwin->w_topline; lnum < curwin->w_botline; ++lnum)
-	    {
-		n = scroll_line_len(lnum);
-		if (n > (colnr_T)max)
-		{
-		    max = n;
-		    longest_lnum = lnum;
-		}
-		else if (n == (colnr_T)max
-			&& abs((int)(lnum - curwin->w_cursor.lnum))
-			   < abs((int)(longest_lnum - curwin->w_cursor.lnum)))
-		    longest_lnum = lnum;
-	    }
-	}
-	else
-	    /* Use cursor line only. */
-	    max = scroll_line_len(curwin->w_cursor.lnum);
-#ifdef FEAT_VIRTUALEDIT
-	if (virtual_active())
-	{
-	    /* May move the cursor even further to the right. */
-	    if (curwin->w_virtcol >= (colnr_T)max)
-		max = curwin->w_virtcol;
-	}
-#endif
-
-#ifndef SCROLL_PAST_END
-	max += W_WIDTH(curwin) - 1;
-#endif
-	/* The line number isn't scrolled, thus there is less space when
-	 * 'number' is set (also for 'foldcolumn'). */
-	size -= curwin_col_off();
-#ifndef SCROLL_PAST_END
-	max -= curwin_col_off();
-#endif
-    }
-
-#ifndef SCROLL_PAST_END
-    if (value > max - size + 1)
-	value = max - size + 1;	    /* limit the value to allowable range */
-#endif
-
-#ifdef FEAT_RIGHTLEFT
-    if (curwin->w_p_rl)
-    {
-	value = max + 1 - size - value;
-	if (value < 0)
-	{
-	    size += value;
-	    value = 0;
-	}
-    }
-#endif
-    if (!force && value == gui.bottom_sbar.value && size == gui.bottom_sbar.size
-						&& max == gui.bottom_sbar.max)
-	return;
-
-    gui.bottom_sbar.value = value;
-    gui.bottom_sbar.size = size;
-    gui.bottom_sbar.max = max;
-    gui.prev_wrap = curwin->w_p_wrap;
-
-    gui_mch_set_scrollbar_thumb(&gui.bottom_sbar, value, size, max);
-}
-
-/*
- * Do a horizontal scroll.  Return TRUE if the cursor moved, FALSE otherwise.
- */
-    int
-gui_do_horiz_scroll()
-{
-    /* no wrapping, no scrolling */
-    if (curwin->w_p_wrap)
-	return FALSE;
-
-    if (curwin->w_leftcol == scrollbar_value)
-	return FALSE;
-
-    curwin->w_leftcol = scrollbar_value;
-
-    /* When the line of the cursor is too short, move the cursor to the
-     * longest visible line.  Do a sanity check on "longest_lnum", just in
-     * case. */
-    if (vim_strchr(p_go, GO_HORSCROLL) == NULL
-	    && longest_lnum >= curwin->w_topline
-	    && longest_lnum < curwin->w_botline
-	    && !virtual_active())
-    {
-	if (scrollbar_value > scroll_line_len(curwin->w_cursor.lnum))
-	{
-	    curwin->w_cursor.lnum = longest_lnum;
-	    curwin->w_cursor.col = 0;
-	}
-    }
-
-    return leftcol_changed();
-}
-
-/*
- * Check that none of the colors are the same as the background color
- */
-    void
-gui_check_colors()
-{
-    if (gui.norm_pixel == gui.back_pixel || gui.norm_pixel == INVALCOLOR)
-    {
-	gui_set_bg_color((char_u *)"White");
-	if (gui.norm_pixel == gui.back_pixel || gui.norm_pixel == INVALCOLOR)
-	    gui_set_fg_color((char_u *)"Black");
-    }
-}
-
-    void
-gui_set_fg_color(name)
-    char_u	*name;
-{
-    gui.norm_pixel = gui_get_color(name);
-    hl_set_fg_color_name(vim_strsave(name));
-}
-
-    void
-gui_set_bg_color(name)
-    char_u	*name;
-{
-    gui.back_pixel = gui_get_color(name);
-    hl_set_bg_color_name(vim_strsave(name));
-}
-
-/*
- * Allocate a color by name.
- * Returns INVALCOLOR and gives an error message when failed.
- */
-    guicolor_T
-gui_get_color(name)
-    char_u	*name;
-{
-    guicolor_T	t;
-
-    if (*name == NUL)
-	return INVALCOLOR;
-    t = gui_mch_get_color(name);
-    if (t == INVALCOLOR
-#if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK)
-	    && gui.in_use
-#endif
-	    )
-	EMSG2(_("E254: Cannot allocate color %s"), name);
-    return t;
-}
-
-/*
- * Return the grey value of a color (range 0-255).
- */
-    int
-gui_get_lightness(pixel)
-    guicolor_T	pixel;
-{
-    long_u	rgb = gui_mch_get_rgb(pixel);
-
-    return (  (((rgb >> 16) & 0xff) * 299)
-	    + (((rgb >> 8)  & 0xff) * 587)
-	    +  ((rgb	    & 0xff) * 114)) / 1000;
-}
-
-#if defined(FEAT_GUI_X11) || defined(PROTO)
-    void
-gui_new_scrollbar_colors()
-{
-    win_T	*wp;
-
-    /* Nothing to do if GUI hasn't started yet. */
-    if (!gui.in_use)
-	return;
-
-    FOR_ALL_WINDOWS(wp)
-    {
-	gui_mch_set_scrollbar_colors(&(wp->w_scrollbars[SBAR_LEFT]));
-	gui_mch_set_scrollbar_colors(&(wp->w_scrollbars[SBAR_RIGHT]));
-    }
-    gui_mch_set_scrollbar_colors(&gui.bottom_sbar);
-}
-#endif
-
-/*
- * Call this when focus has changed.
- */
-    void
-gui_focus_change(in_focus)
-    int		in_focus;
-{
-/*
- * Skip this code to avoid drawing the cursor when debugging and switching
- * between the debugger window and gvim.
- */
-#if 1
-    gui.in_focus = in_focus;
-    out_flush();		/* make sure output has been written */
-    gui_update_cursor(TRUE, FALSE);
-
-# ifdef FEAT_XIM
-    xim_set_focus(in_focus);
-# endif
-
-    ui_focus_change(in_focus);
-#endif
-}
-
-/*
- * Called when the mouse moved (but not when dragging).
- */
-    void
-gui_mouse_moved(x, y)
-    int		x;
-    int		y;
-{
-    win_T	*wp;
-    char_u	st[6];
-
-#ifdef FEAT_MOUSESHAPE
-    /* Get window pointer, and update mouse shape as well. */
-    wp = xy2win(x, y);
-#endif
-
-    /* Only handle this when 'mousefocus' set and ... */
-    if (p_mousef
-	    && !hold_gui_events		/* not holding events */
-	    && (State & (NORMAL|INSERT))/* Normal/Visual/Insert mode */
-	    && State != HITRETURN	/* but not hit-return prompt */
-	    && msg_scrolled == 0	/* no scrolled message */
-	    && !need_mouse_correct	/* not moving the pointer */
-	    && gui.in_focus)		/* gvim in focus */
-    {
-	/* Don't move the mouse when it's left or right of the Vim window */
-	if (x < 0 || x > Columns * gui.char_width)
-	    return;
-#ifndef FEAT_MOUSESHAPE
-	wp = xy2win(x, y);
-#endif
-	if (wp == curwin || wp == NULL)
-	    return;	/* still in the same old window, or none at all */
-
-	/*
-	 * format a mouse click on status line input
-	 * ala gui_send_mouse_event(0, x, y, 0, 0);
-	 * Trick: Use a column of -1, so that check_termcode will generate a
-	 * K_LEFTMOUSE_NM key code.
-	 */
-	if (finish_op)
-	{
-	    /* abort the current operator first */
-	    st[0] = ESC;
-	    add_to_input_buf(st, 1);
-	}
-	st[0] = CSI;
-	st[1] = KS_MOUSE;
-	st[2] = KE_FILLER;
-	st[3] = (char_u)MOUSE_LEFT;
-	fill_mouse_coord(st + 4,
-#ifdef FEAT_VERTSPLIT
-		W_WINCOL(wp),
-#else
-		-1,
-#endif
-		wp->w_height + W_WINROW(wp));
-
-	add_to_input_buf(st, 8);
-	st[3] = (char_u)MOUSE_RELEASE;
-	add_to_input_buf(st, 8);
-
-#ifdef FEAT_GUI_GTK
-	/* Need to wake up the main loop */
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
-#endif
-    }
-}
-
-/*
- * Called when mouse should be moved to window with focus.
- */
-    void
-gui_mouse_correct()
-{
-    int		x, y;
-    win_T	*wp = NULL;
-
-    need_mouse_correct = FALSE;
-    if (gui.in_use && p_mousef)
-    {
-	x = gui_mch_get_mouse_x();
-	/* Don't move the mouse when it's left or right of the Vim window */
-	if (x < 0 || x > Columns * gui.char_width)
-	    return;
-	y = gui_mch_get_mouse_y();
-	if (y >= 0)
-	    wp = xy2win(x, y);
-	if (wp != curwin && wp != NULL)	/* If in other than current window */
-	{
-	    validate_cline_row();
-	    gui_mch_setmouse((int)W_ENDCOL(curwin) * gui.char_width - 3,
-			 (W_WINROW(curwin) + curwin->w_wrow) * gui.char_height
-						     + (gui.char_height) / 2);
-	}
-    }
-}
-
-/*
- * Find window where the mouse pointer "y" coordinate is in.
- */
-/*ARGSUSED*/
-    static win_T *
-xy2win(x, y)
-    int		x;
-    int		y;
-{
-#ifdef FEAT_WINDOWS
-    int		row;
-    int		col;
-    win_T	*wp;
-
-    row = Y_2_ROW(y);
-    col = X_2_COL(x);
-    if (row < 0 || col < 0)		/* before first window */
-	return NULL;
-    wp = mouse_find_win(&row, &col);
-# ifdef FEAT_MOUSESHAPE
-    if (State == HITRETURN || State == ASKMORE)
-    {
-	if (Y_2_ROW(y) >= msg_row)
-	    update_mouseshape(SHAPE_IDX_MOREL);
-	else
-	    update_mouseshape(SHAPE_IDX_MORE);
-    }
-    else if (row > wp->w_height)	/* below status line */
-	update_mouseshape(SHAPE_IDX_CLINE);
-#  ifdef FEAT_VERTSPLIT
-    else if (!(State & CMDLINE) && W_VSEP_WIDTH(wp) > 0 && col == wp->w_width
-	    && (row != wp->w_height || !stl_connected(wp)))
-	update_mouseshape(SHAPE_IDX_VSEP);
-#  endif
-    else if (!(State & CMDLINE) && W_STATUS_HEIGHT(wp) > 0
-						       && row == wp->w_height)
-	update_mouseshape(SHAPE_IDX_STATUS);
-    else
-	update_mouseshape(-2);
-# endif
-    return wp;
-#else
-    return firstwin;
-#endif
-}
-
-/*
- * ":gui" and ":gvim": Change from the terminal version to the GUI version.
- * File names may be given to redefine the args list.
- */
-    void
-ex_gui(eap)
-    exarg_T	*eap;
-{
-    char_u	*arg = eap->arg;
-
-    /*
-     * Check for "-f" argument: foreground, don't fork.
-     * Also don't fork when started with "gvim -f".
-     * Do fork when using "gui -b".
-     */
-    if (arg[0] == '-'
-	    && (arg[1] == 'f' || arg[1] == 'b')
-	    && (arg[2] == NUL || vim_iswhite(arg[2])))
-    {
-	gui.dofork = (arg[1] == 'b');
-	eap->arg = skipwhite(eap->arg + 2);
-    }
-    if (!gui.in_use)
-    {
-	/* Clear the command.  Needed for when forking+exiting, to avoid part
-	 * of the argument ending up after the shell prompt. */
-	msg_clr_eos_force();
-	gui_start();
-    }
-    if (!ends_excmd(*eap->arg))
-	ex_next(eap);
-}
-
-#if ((defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32) \
-	|| defined(FEAT_GUI_PHOTON)) && defined(FEAT_TOOLBAR)) || defined(PROTO)
-/*
- * This is shared between Athena, Motif and GTK.
- */
-static char_u	*gfp_buffer;
-
-static void gfp_setname __ARGS((char_u *fname));
-
-/*
- * Callback function for do_in_runtimepath().
- */
-    static void
-gfp_setname(fname)
-    char_u	*fname;
-{
-    if (STRLEN(fname) >= MAXPATHL)
-	*gfp_buffer = NUL;
-    else
-	STRCPY(gfp_buffer, fname);
-}
-
-/*
- * Find the path of bitmap "name" with extension "ext" in 'runtimepath'.
- * Return FAIL for failure and OK if buffer[MAXPATHL] contains the result.
- */
-    int
-gui_find_bitmap(name, buffer, ext)
-    char_u	*name;
-    char_u	*buffer;
-    char	*ext;
-{
-    if (STRLEN(name) > MAXPATHL - 14)
-	return FAIL;
-    sprintf((char *)buffer, "bitmaps/%s.%s", name, ext);
-    gfp_buffer = buffer;
-    if (do_in_runtimepath(buffer, FALSE, gfp_setname) == FAIL || *buffer == NUL)
-	return FAIL;
-    return OK;
-}
-
-# if !defined(HAVE_GTK2) || defined(PROTO)
-/*
- * Given the name of the "icon=" argument, try finding the bitmap file for the
- * icon.  If it is an absolute path name, use it as it is.  Otherwise append
- * "ext" and search for it in 'runtimepath'.
- * The result is put in "buffer[MAXPATHL]".  If something fails "buffer"
- * contains "name".
- */
-    void
-gui_find_iconfile(name, buffer, ext)
-    char_u	*name;
-    char_u	*buffer;
-    char	*ext;
-{
-    char_u	buf[MAXPATHL + 1];
-
-    expand_env(name, buffer, MAXPATHL);
-    if (!mch_isFullName(buffer) && gui_find_bitmap(buffer, buf, ext) == OK)
-	STRCPY(buffer, buf);
-}
-# endif
-#endif
-
-#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(PROTO)
-    void
-display_errors()
-{
-    char_u	*p;
-
-    if (isatty(2))
-	fflush(stderr);
-    else if (error_ga.ga_data != NULL)
-    {
-	/* avoid putting up a message box with blanks only */
-	for (p = (char_u *)error_ga.ga_data; *p != NUL; ++p)
-	    if (!isspace(*p))
-	    {
-		/* Truncate a very long message, it will go off-screen. */
-		if (STRLEN(p) > 2000)
-		    STRCPY(p + 2000 - 14, "...(truncated)");
-		(void)do_dialog(VIM_ERROR, (char_u *)_("Error"),
-					      p, (char_u *)_("&Ok"), 1, NULL);
-		break;
-	    }
-	ga_clear(&error_ga);
-    }
-}
-#endif
-
-#if defined(NO_CONSOLE_INPUT) || defined(PROTO)
-/*
- * Return TRUE if still starting up and there is no place to enter text.
- * For GTK and X11 we check if stderr is not a tty, which means we were
- * (probably) started from the desktop.  Also check stdin, "vim >& file" does
- * allow typing on stdin.
- */
-    int
-no_console_input()
-{
-    return ((!gui.in_use || gui.starting)
-# ifndef NO_CONSOLE
-	    && !isatty(0) && !isatty(2)
-# endif
-	    );
-}
-#endif
-
-#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MOTIF) \
-	|| defined(MSWIN_FIND_REPLACE) || defined(FEAT_SUN_WORKSHOP) \
-	|| defined(PROTO)
-/*
- * Update the current window and the screen.
- */
-    void
-gui_update_screen()
-{
-    update_topline();
-    validate_cursor();
-    update_screen(0);	/* may need to update the screen */
-    setcursor();
-    out_flush();		/* make sure output has been written */
-    gui_update_cursor(TRUE, FALSE);
-    gui_mch_flush();
-}
-#endif
-
-#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MOTIF) \
-	|| defined(MSWIN_FIND_REPLACE) || defined(PROTO)
-static void concat_esc __ARGS((garray_T *gap, char_u *text, int what));
-
-/*
- * Get the text to use in a find/replace dialog.  Uses the last search pattern
- * if the argument is empty.
- * Returns an allocated string.
- */
-    char_u *
-get_find_dialog_text(arg, wwordp, mcasep)
-    char_u	*arg;
-    int		*wwordp;	/* return: TRUE if \< \> found */
-    int		*mcasep;	/* return: TRUE if \C found */
-{
-    char_u	*text;
-
-    if (*arg == NUL)
-	text = last_search_pat();
-    else
-	text = arg;
-    if (text != NULL)
-    {
-	text = vim_strsave(text);
-	if (text != NULL)
-	{
-	    int len = STRLEN(text);
-	    int i;
-
-	    /* Remove "\V" */
-	    if (len >= 2 && STRNCMP(text, "\\V", 2) == 0)
-	    {
-		mch_memmove(text, text + 2, (size_t)(len - 1));
-		len -= 2;
-	    }
-
-	    /* Recognize "\c" and "\C" and remove. */
-	    if (len >= 2 && *text == '\\' && (text[1] == 'c' || text[1] == 'C'))
-	    {
-		*mcasep = (text[1] == 'C');
-		mch_memmove(text, text + 2, (size_t)(len - 1));
-		len -= 2;
-	    }
-
-	    /* Recognize "\<text\>" and remove. */
-	    if (len >= 4
-		    && STRNCMP(text, "\\<", 2) == 0
-		    && STRNCMP(text + len - 2, "\\>", 2) == 0)
-	    {
-		*wwordp = TRUE;
-		mch_memmove(text, text + 2, (size_t)(len - 4));
-		text[len - 4] = NUL;
-	    }
-
-	    /* Recognize "\/" or "\?" and remove. */
-	    for (i = 0; i + 1 < len; ++i)
-		if (text[i] == '\\' && (text[i + 1] == '/'
-						       || text[i + 1] == '?'))
-		{
-		    mch_memmove(text + i, text + i + 1, (size_t)(len - i));
-		    --len;
-		}
-	}
-    }
-    return text;
-}
-
-/*
- * Concatenate "text" to grow array "gap", escaping "what" with a backslash.
- */
-    static void
-concat_esc(gap, text, what)
-    garray_T	*gap;
-    char_u	*text;
-    int		what;
-{
-    while (*text != NUL)
-    {
-#ifdef FEAT_MBYTE
-	int l = (*mb_ptr2len_check)(text);
-	if (l > 1)
-	{
-	    while (--l >= 0)
-		ga_append(gap, *text++);
-	    continue;
-	}
-#endif
-	if (*text == what)
-	    ga_append(gap, '\\');
-	ga_append(gap, *text);
-	++text;
-    }
-}
-
-/*
- * Handle the press of a button in the find-replace dialog.
- * Return TRUE when something was added to the input buffer.
- */
-    int
-gui_do_findrepl(flags, find_text, repl_text, down)
-    int		flags;		/* one of FRD_REPLACE, FRD_FINDNEXT, etc. */
-    char_u	*find_text;
-    char_u	*repl_text;
-    int		down;		/* Search downwards. */
-{
-    garray_T	ga;
-    int		i;
-    int		type = (flags & FRD_TYPE_MASK);
-    char_u	*p;
-
-    ga_init2(&ga, 1, 100);
-
-    if (type == FRD_REPLACE)
-    {
-	/* Do the replacement when the text under the cursor matches. */
-	i = STRLEN(find_text);
-	p = ml_get_cursor();
-	if (((flags & FRD_MATCH_CASE)
-		    ? STRNCMP(p, find_text, i) == 0
-		    : STRNICMP(p, find_text, i) == 0)
-		&& u_save_cursor() == OK)
-	{
-	    /* A button was pressed thus undo should be synced. */
-	    if (no_u_sync == 0)
-		u_sync();
-
-	    del_bytes((long)i, FALSE);
-	    ins_str(repl_text);
-	}
-    }
-    else if (type == FRD_REPLACEALL)
-	ga_concat(&ga, (char_u *)"%s/");
-
-    ga_concat(&ga, (char_u *)"\\V");
-    if (flags & FRD_MATCH_CASE)
-	ga_concat(&ga, (char_u *)"\\C");
-    else
-	ga_concat(&ga, (char_u *)"\\c");
-    if (flags & FRD_WHOLE_WORD)
-	ga_concat(&ga, (char_u *)"\\<");
-    if (type == FRD_REPLACEALL || down)
-	concat_esc(&ga, find_text, '/');	/* escape slashes */
-    else
-	concat_esc(&ga, find_text, '?');	/* escape '?' */
-    if (flags & FRD_WHOLE_WORD)
-	ga_concat(&ga, (char_u *)"\\>");
-
-    if (type == FRD_REPLACEALL)
-    {
-	/* A button was pressed, thus undo should be synced. */
-	if (no_u_sync == 0)
-	    u_sync();
-
-	ga_concat(&ga, (char_u *)"/");
-	concat_esc(&ga, repl_text, '/');	/* escape slashes */
-	ga_concat(&ga, (char_u *)"/g");
-	ga_append(&ga, NUL);
-	do_cmdline_cmd(ga.ga_data);
-    }
-    else
-    {
-	/* Search for the next match. */
-	i = msg_scroll;
-	ga_append(&ga, NUL);
-	do_search(NULL, down ? '/' : '?', ga.ga_data, 1L,
-						    SEARCH_MSG + SEARCH_MARK);
-	msg_scroll = i;	    /* don't let an error message set msg_scroll */
-    }
-
-    if (State & (NORMAL | INSERT))
-    {
-	gui_update_screen();		/* update the screen */
-	msg_didout = 0;			/* overwrite any message */
-	need_wait_return = FALSE;	/* don't wait for return */
-    }
-
-    vim_free(ga.ga_data);
-    return (ga.ga_len > 0);
-}
-
-#endif
-
-#if (defined(FEAT_DND) && defined(FEAT_GUI_GTK)) \
-	|| defined(FEAT_GUI_MSWIN) \
-	|| defined(FEAT_GUI_MAC) \
-	|| defined(PROTO)
-
-#ifdef FEAT_WINDOWS
-static void gui_wingoto_xy __ARGS((int x, int y));
-
-/*
- * Jump to the window at specified point (x, y).
- */
-    static void
-gui_wingoto_xy(x, y)
-    int x;
-    int y;
-{
-    int		row = Y_2_ROW(y);
-    int		col = X_2_COL(x);
-    win_T	*wp;
-
-    if (row >= 0 && col >= 0)
-    {
-	wp = mouse_find_win(&row, &col);
-	if (wp != NULL && wp != curwin)
-	    win_goto(wp);
-    }
-}
-#endif
-
-/*
- * Process file drop.  Mouse cursor position, key modifiers, name of files
- * and count of files are given.  Argument "fnames[count]" has full pathnames
- * of dropped files, they will be freed in this function, and caller can't use
- * fnames after call this function.
- */
-/*ARGSUSED*/
-    void
-gui_handle_drop(x, y, modifiers, fnames, count)
-    int		x;
-    int		y;
-    int_u	modifiers;
-    char_u	**fnames;
-    int		count;
-{
-    int		i;
-    char_u	*p;
-
-    /*
-     * When the cursor is at the command line, add the file names to the
-     * command line, don't edit the files.
-     */
-    if (State & CMDLINE)
-    {
-	shorten_filenames(fnames, count);
-	for (i = 0; i < count; ++i)
-	{
-	    if (fnames[i] != NULL)
-	    {
-		if (i > 0)
-		    add_to_input_buf((char_u*)" ", 1);
-
-		/* We don't know what command is used thus we can't be sure
-		 * about which characters need to be escaped.  Only escape the
-		 * most common ones. */
-# ifdef BACKSLASH_IN_FILENAME
-		p = vim_strsave_escaped(fnames[i], (char_u *)" \t\"|");
-# else
-		p = vim_strsave_escaped(fnames[i], (char_u *)"\\ \t\"|");
-# endif
-		if (p != NULL)
-		    add_to_input_buf(p, (int)STRLEN(p));
-		vim_free(p);
-		vim_free(fnames[i]);
-	    }
-	}
-	vim_free(fnames);
-    }
-    else
-    {
-	/* Go to the window under mouse cursor, then shorten given "fnames" by
-	 * current window, because a window can have local current dir. */
-# ifdef FEAT_WINDOWS
-	gui_wingoto_xy(x, y);
-# endif
-	shorten_filenames(fnames, count);
-
-	/* If Shift held down, remember the first item. */
-	if ((modifiers & MOUSE_SHIFT) != 0)
-	    p = vim_strsave(fnames[0]);
-	else
-	    p = NULL;
-
-	/* Handle the drop, :edit or :split to get to the file.  This also
-	 * frees fnames[].  Skip this if there is only one item it's a
-	 * directory and Shift is held down. */
-	if (count == 1 && (modifiers & MOUSE_SHIFT) != 0
-						     && mch_isdir(fnames[0]))
-	{
-	    vim_free(fnames[0]);
-	    vim_free(fnames);
-	}
-	else
-	    handle_drop(count, fnames, (modifiers & MOUSE_CTRL) != 0);
-
-	/* If Shift held down, change to first file's directory.  If the first
-	 * item is a directory, change to that directory (and let the explorer
-	 * plugin show the contents). */
-	if (p != NULL)
-	{
-	    if (mch_isdir(p))
-	    {
-		if (mch_chdir((char *)p) == 0)
-		    shorten_fnames(TRUE);
-	    }
-	    else if (vim_chdirfile(p) == OK)
-		shorten_fnames(TRUE);
-	    vim_free(p);
-	}
-
-	/* Update the screen display */
-	update_screen(NOT_VALID);
-# ifdef FEAT_MENU
-	gui_update_menus(0);
-# endif
-	setcursor();
-	out_flush();
-	gui_update_cursor(FALSE, FALSE);
-	gui_mch_flush();
-    }
-}
-#endif
diff -Nur vim63/src/gui_gtk.c vim63-bonobo/src/gui_gtk.c
--- vim63/src/gui_gtk.c	2005-09-09 20:11:09.520917000 +0200
+++ vim63-bonobo/src/gui_gtk.c	2005-09-09 20:14:02.737584088 +0200
@@ -39,7 +39,7 @@
 
 #include "vim.h"
 
-#ifdef FEAT_GUI_GNOME
+#if 0
 /* Gnome redefines _() and N_().  Grrr... */
 # ifdef _
 #  undef _
@@ -554,9 +554,332 @@
 
 # endif /* !HAVE_GTK2 */
 
+#ifdef FEAT_GUI_COMPONENT
+
+
+static void
+verb_activate( BonoboUIComponent *uic, gpointer data, const char *cname )
+{
+    gui_menu_cb((vimmenu_T *) data);
+
+    /* make sure the menu action is taken immediately */
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
+}
+
+/* Takes name (a label), and appends a normalized version of name to
+ * the destination string.  Normalization in this case means taking only 
+ * alphanumeric characters, and discarding all others.  */
+static void g_string_append_normalized_name( GString * dest, char_u * name )
+{
+    gchar * cur;
+
+    if( name == NULL ) 
+    {
+        return;
+    }
+    cur = name;
+    while( *cur != '\0' ) {
+        gunichar wc;
+        wc = g_utf8_get_char(cur);
+        if( g_unichar_isalnum( wc ) ) {
+            g_string_append_unichar( dest, wc );
+        }
+        cur = g_utf8_next_char(cur);
+    }
+}
+
+/* for the given menu, create the corresponding xml path.
+ * if to_parent is TRUE, returns the path to the parent of the given menu.
+ */
+static
+char * xml_path_for_menu( vimmenu_T * menu, int to_parent )
+{
+    GString * normname;
+    GString * path;
+    char * retpath;
+    
+    normname = g_string_sized_new( 64 );
+    path = g_string_sized_new( 128 );
+    while( 1 ) {
+        if( menu_is_toolbar(menu->name) ) {
+            /* "Toolbar" is a standard Bonobo UI element, but Vim uses "ToolBar", so we
+             * have to check for this. */
+            g_string_prepend( path, "/Toolbar");
+        } else {
+            g_string_assign( normname, "" );
+            g_string_append_normalized_name( normname, menu->dname );
+            g_string_prepend( path, normname->str );
+            g_string_prepend( path, "/" );
+        }
+        if( menu->parent == NULL ) {
+            if( menu && menu_is_menubar( menu->name ) ) {
+                g_string_prepend( path, "/menu" );
+            }
+            break;
+        }
+        menu = menu->parent;
+    }
+    g_string_free( normname, TRUE );
+    retpath = path->str;
+    g_string_free( path, FALSE );
+
+    if( to_parent ) {
+        gchar * slash;
+        slash = g_strrstr(retpath, "/");
+        if( slash == retpath )
+            slash[1] = '\0';
+        else if( slash ) 
+            *slash = '\0';
+    }
+    return( retpath );
+}
+
+/* Because the container which embeds Vim may not have the same toolbar icons
+ * installed, we need to send the icons in the XML stream.  This function
+ * takes the given GtkImage, encodes it as XML and returns the resulting XML
+ * as a string. */
+static char *
+gtk_image_to_xml_attrs( GtkImage * image)
+{
+    GString * xml = g_string_sized_new(32);
+    GtkImageType type = gtk_image_get_storage_type(image);
+    char * attrs;
+    char * imagexml;
+
+    if( type == GTK_IMAGE_STOCK ) {
+        GtkIconSize size;
+        GtkIconSet * iconset;
+        gchar * stockname;
+        GdkPixbuf * pixbuf;
+
+        gtk_image_get_stock(image, &stockname, &size);
+        pixbuf = gtk_widget_render_icon(gui.drawarea, stockname, size, NULL);
+        imagexml = bonobo_ui_util_pixbuf_to_xml(pixbuf);
+        g_string_append_printf(xml, " pixtype=\"pixbuf\" pixname=\"%s\"", imagexml);
+        g_object_unref(pixbuf);
+        g_free(imagexml);
+    } else if( type == GTK_IMAGE_PIXBUF ) {
+        imagexml = bonobo_ui_util_pixbuf_to_xml(gtk_image_get_pixbuf(image));
+        g_string_append_printf(xml, " pixtype=\"pixbuf\" pixname=\"%s\"", imagexml);
+        g_free(imagexml);
+    }
+    attrs = xml->str;
+    g_string_free(xml, FALSE);
+    return( attrs );
+}
+
+
+/* Generate XML which represents Vim's menus and toolbars.  Starts from the
+ * given menu entry.  XML is appended to "xml", and commands/verbs are added
+ * to the "commands" list.  If do_siblings is true, XML is also generated for
+ * the siblings of the given menu (following the menu->next pointer); otherwise
+ * only the menu and its descendents are processed.
+ */
+static
+void generate_gui_xml_recurse( vimmenu_T * menu, GString * xml, GSList ** commands, int do_siblings)
+{
+    GString * normname = g_string_sized_new(16);
+    GString * verbname = g_string_sized_new(32);
+    char_u * label;
+    int use_mnemonic;
+    BonoboUIComponent *uic;
+    gchar * command;
+
+    uic = bonobo_control_get_ui_component (BONOBO_CONTROL (gui.control));
+
+    while( menu ) 
+    {
+        use_mnemonic = (p_wak[0] != 'n' );
+        label = translate_mnemonic_tag( menu->name, use_mnemonic );
+        g_string_assign( normname, "" );
+        g_string_append_normalized_name( normname, menu->dname );
+        if( menu->children ) {
+            if( menu_is_toolbar( menu->name )) {
+                g_string_append( xml, "<dockitem name=\"Toolbar\" look=\"icon\" tips=\"1\">");
+                generate_gui_xml_recurse( menu->children, xml, commands, TRUE );
+                g_string_append( xml, "</dockitem>");
+            } else {
+                g_string_append_printf( xml, "<submenu name=\"%s\" label=\"%s\">\n", normname->str, label);
+
+                generate_gui_xml_recurse( menu->children, xml, commands, TRUE );
+                g_string_append( xml, "</submenu>\n");
+            }
+        } else if( menu_is_separator(menu->name)) {
+            g_string_append( xml, "<separator />\n" );
+        } else if( menu->parent && menu_is_toolbar(menu->parent->name)) {
+            char * menupath = xml_path_for_menu(menu, FALSE);
+            GtkImage *image = NULL;
+            char * imagexml;
+            char_u *tooltip;
+
+            g_string_assign(verbname, "");
+            g_string_append_normalized_name(verbname, menupath);
+            vim_free(menupath);
+            image = GTK_IMAGE(create_menu_icon(menu, GTK_ICON_SIZE_SMALL_TOOLBAR));
+            imagexml = gtk_image_to_xml_attrs(image);
+            tooltip = CONVERT_TO_UTF8(menu->strings[MENU_INDEX_TIP]);
+            g_string_append_printf( xml, "<toolitem name=\"%s\" label=\"%s\" verb=\"%s\" tip=\"%s\" %s />\n", normname->str, label, verbname->str, tooltip, imagexml);
+            gtk_object_sink(GTK_OBJECT(image));
+            g_free(imagexml);
+            CONVERT_TO_UTF8_FREE(tooltip);
+            
+            command = g_strdup_printf( "<cmd name=\"%s\" sensitive=\"%c\" />\n", verbname->str, menu->sensitive ? '1' : '0');
+            *commands = g_slist_prepend( *commands, command );
+            bonobo_ui_component_add_verb(uic, verbname->str, verb_activate, menu);
+        } else if( menu_is_menubar(menu->name)) {
+            char * menupath = xml_path_for_menu(menu, FALSE);
+
+            g_string_assign(verbname, "");
+            g_string_append_normalized_name(verbname, menupath);
+            vim_free(menupath);
+            
+            g_string_append_printf( xml, "<menuitem name=\"%s\" label=\"%s\" verb=\"%s\" />\n", normname->str, label, verbname->str);
+
+            command = g_strdup_printf( "<cmd name=\"%s\" sensitive=\"%c\" />\n", verbname->str, menu->sensitive ? '1' : '0');
+            *commands = g_slist_prepend( *commands, command );
+            bonobo_ui_component_add_verb(uic, verbname->str, verb_activate, menu);
+        }
+        if( label ) {
+            vim_free( label );
+        }
+        if( do_siblings ) {
+            menu = menu->next;
+        } else {
+            menu = NULL;
+        }
+    }
+    g_string_free( normname, TRUE );
+}
+
+/* Create XML representing the menus and toolbars, and send them to the
+ * container application.  We only need to process menu entries which
+ * have changed (they are marked "dirty"). */
+static
+void set_gui_xml(vimmenu_T * menu)
+{
+    GSList * commands = NULL;
+    GSList * command;
+    BonoboUIComponent *uic;
+    GString * xml = g_string_sized_new(1024);
+    int path_exists;
+    uic = bonobo_control_get_ui_component (BONOBO_CONTROL (gui.control));
+
+    if( bonobo_ui_component_get_container(uic) == CORBA_OBJECT_NIL ) {
+        return;
+    }
+
+    while( menu ) {
+        if( menu->dirty ) {
+            if (menu_is_popup(menu->name)) {
+                /* do nothing */            
+            } else if( menu_is_menubar(menu->name)) {
+                char * menupath = xml_path_for_menu(menu, TRUE);
+                path_exists = bonobo_ui_component_path_exists(uic, menupath, NULL);
+                g_string_assign(xml, "");
+                generate_gui_xml_recurse (menu, xml, &commands, FALSE);
+                /*fprintf(stdout, "set %s\n", menupath);*/
+                /*fprintf(stdout, "set %s\n%s", menupath, xml->str);*/
+                /*fflush(stdout);*/
+                bonobo_ui_component_set(uic, menupath, xml->str, NULL);
+                g_free(menupath);
+            } else if( menu_is_toolbar(menu->name)) {
+                char * menupath = xml_path_for_menu(menu, TRUE);
+                path_exists = bonobo_ui_component_path_exists(uic, menupath, NULL);
+                g_string_assign(xml, "");
+                generate_gui_xml_recurse (menu, xml, &commands, FALSE);
+                /*fprintf(stdout, "set %s\n", menupath);*/
+                /*fprintf(stdout, "set %s\n%s", menupath, xml->str);*/
+                /*fflush(stdout);*/
+                bonobo_ui_component_set(uic, menupath, xml->str, NULL);
+                g_free(menupath);
+            }
+            menu->dirty = FALSE;
+        }
+        menu = menu->next;
+    }
+    /* the commands are inserted separately into a list, and set one by one,
+     * otherwise it's not possible to update a subtree of the UI 
+     */
+    command = commands;
+    while( command ) {
+        /*fprintf(stdout, "set %s\n%s", "/commands", command->data);
+        fflush(stdout);*/
+        bonobo_ui_component_set(uic, "/commands", command->data, NULL);
+        g_free(command->data);
+        command = command->next;
+    }
+    g_slist_free( commands );
+}
+
+
+/* remember whether a timeout has been scheduled for updating the gui */
+static gboolean update_gui_idle_installed = FALSE;
+
+/* if we have been embedded in a container, update the gui now, otherwise
+ * wait awhile and try again. */
+static gboolean
+update_gui_idle(gpointer data)
+{
+    BonoboUIComponent *uic;
+
+    uic = bonobo_control_get_ui_component (BONOBO_CONTROL (gui.control));
+    if( bonobo_ui_component_get_container(uic) == CORBA_OBJECT_NIL ) {
+        /* we aren't in a container yet; try again later... */
+        g_timeout_add(100, &update_gui_idle, NULL);
+        return FALSE;
+    }
+    bonobo_ui_component_freeze(uic, NULL);
+    set_gui_xml( (vimmenu_T *)root_menu );
+    update_gui_idle_installed = FALSE;
+    bonobo_ui_component_thaw(uic, NULL);
+    return FALSE; /* don't call me again */
+}
+
+/* Mark the given menu as dirty -- we need to re-send the XML representing
+ * this menu to the container.  But don't do the update immediately; otherwise
+ * we'd be generating the complete UI XML each time a menu entry is added,
+ * which would be very slow.  Instead, schedule an update in which all 
+ * dirty menus will be processed. */
+void
+update_menu_later(vimmenu_T *menu)
+{
+    if (!update_gui_idle_installed)
+    {
+        update_gui_idle_installed = TRUE;
+        g_idle_add_full(GDK_PRIORITY_EVENTS + 10,
+                        &update_gui_idle, NULL, NULL);
+    }
+    while( menu->parent ) 
+        menu = menu->parent;
+    menu->dirty = TRUE;
+}
+
+/* Schedule an update for the entire UI (all menus and toolbars) */
+void update_ui_later()
+{
+    vimmenu_T *menu = root_menu;
+
+    if (!update_gui_idle_installed)
+    {
+        update_gui_idle_installed = TRUE;
+        g_idle_add_full(GDK_PRIORITY_EVENTS + 10,
+                        &update_gui_idle, NULL, NULL);
+    }
+    while( menu ) {
+        menu->dirty = TRUE;
+        menu = menu->next;
+    }
+}
+#endif
+
     void
 gui_mch_add_menu(vimmenu_T *menu, int idx)
 {
+#ifdef FEAT_GUI_COMPONENT
+    update_menu_later(menu);
+    return;
+#else
     vimmenu_T	*parent;
     GtkWidget	*parent_widget;
 
@@ -602,6 +925,7 @@
     if (vim_strchr(p_go, GO_TEAROFF) != NULL)
 	gtk_widget_show(menu->tearoff_handle);
     gtk_menu_prepend(GTK_MENU(menu->submenu_id), menu->tearoff_handle);
+#endif
 }
 
 /*ARGSUSED*/
@@ -618,8 +942,8 @@
 # endif
 
     /* make sure the menu action is taken immediately */
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 # if defined(FEAT_TOOLBAR) && !defined(HAVE_GTK2)
@@ -724,6 +1048,10 @@
     void
 gui_mch_add_menu_item(vimmenu_T *menu, int idx)
 {
+#ifdef FEAT_GUI_COMPONENT
+    update_menu_later(menu);
+    return;
+#else
     vimmenu_T *parent;
 
     parent = menu->parent;
@@ -833,6 +1161,7 @@
 	    gtk_signal_connect(GTK_OBJECT(menu->id), "activate",
 			       GTK_SIGNAL_FUNC(menu_item_activate), menu);
     }
+#endif
 }
 #endif /* FEAT_MENU */
 
@@ -857,6 +1186,10 @@
     guint	accel_key;
 # endif
 
+#ifdef FEAT_GUI_COMPONENT
+    return;
+#endif
+
     for (menu = root_menu; menu != NULL; menu = menu->next)
     {
 	if (menu->id == NULL)
@@ -913,6 +1246,9 @@
     void
 gui_mch_toggle_tearoffs(int enable)
 {
+#ifdef FEAT_GUI_COMPONENT
+    return;
+#endif
     recurse_tearoffs(root_menu, enable);
 }
 #endif /* FEAT_MENU */
@@ -1019,6 +1355,9 @@
     void
 gui_mch_destroy_menu(vimmenu_T *menu)
 {
+#ifdef FEAT_GUI_COMPONENT
+    return;
+#endif
 # ifdef FEAT_TOOLBAR
     if (menu->parent != NULL && menu_is_toolbar(menu->parent->name))
     {
@@ -1160,8 +1499,8 @@
 
     gui_drag_scrollbar(sb, value, dragging);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /* SBAR_VERT or SBAR_HORIZ */
@@ -1220,8 +1559,8 @@
     vw->browse_fname = (char_u *)g_strdup(gtk_file_selection_get_filename(
 					GTK_FILE_SELECTION(vw->filedlg)));
     gtk_widget_hide(vw->filedlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*ARGSUSED*/
@@ -1236,8 +1575,8 @@
 	vw->browse_fname = NULL;
     }
     gtk_widget_hide(vw->filedlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*ARGSUSED*/
@@ -1251,8 +1590,8 @@
     }
     gui.filedlg = NULL;
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 
     return FALSE;
 }
@@ -1335,7 +1674,7 @@
 
     gtk_widget_show(gui.filedlg);
     while (gui.filedlg && GTK_WIDGET_DRAWABLE(gui.filedlg))
-	gtk_main_iteration_do(TRUE);
+	MAIN_ITERATION_DO(TRUE);
 
     if (gui.browse_fname == NULL)
 	return NULL;
@@ -1560,8 +1899,8 @@
 dlg_destroy_cb(int *p)
 {
     *p = TRUE;		/* set dialog_destroyed to break out of the loop */
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /* ARGSUSED */
@@ -1865,7 +2204,7 @@
     /* loop here until the dialog goes away */
     while (dialog_status == -1 && !dialog_destroyed
 					       && GTK_WIDGET_DRAWABLE(dialog))
-	gtk_main_iteration_do(TRUE);
+	MAIN_ITERATION_DO(TRUE);
 
     if (dialog_status < 0)
 	dialog_status = 0;
@@ -2898,8 +3237,8 @@
     CONVERT_FROM_UTF8_FREE(find_text);
 #endif
 
-    if (rc && gtk_main_level() > 0)
-	gtk_main_quit(); /* make sure cmd will be handled immediately */
+    if (rc && MAIN_LEVEL() > 0)
+        MAIN_QUIT(); /* make sure cmd will be handled immediately */
 }
 
 /* our usual callback function */
diff -Nur vim63/src/gui_gtk_x11.c vim63-bonobo/src/gui_gtk_x11.c
--- vim63/src/gui_gtk_x11.c	2004-05-03 11:19:17.000000000 +0200
+++ vim63-bonobo/src/gui_gtk_x11.c	2005-09-09 20:14:02.742583328 +0200
@@ -24,6 +24,7 @@
 #include "vim.h"
 #ifdef FEAT_GUI_GNOME
 /* Gnome redefines _() and N_().  Grrr... */
+#if 0
 # ifdef _
 #  undef _
 # endif
@@ -36,6 +37,7 @@
 # ifdef bindtextdomain
 #  undef bindtextdomain
 # endif
+#endif
 # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
 #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
 # endif
@@ -627,9 +629,10 @@
 expose_event(GtkWidget *widget, GdkEventExpose *event, gpointer data)
 {
     /* Skip this when the GUI isn't set up yet, will redraw later. */
-    if (gui.starting)
+    if (gui.starting) {
+        g_warning("ignoring expose_event; gui still starting.\n");
 	return FALSE;
-
+    }
     out_flush();		/* make sure all output has been processed */
     gui_redraw(event->area.x, event->area.y,
 	       event->area.width, event->area.height);
@@ -670,8 +673,8 @@
 	xev.xproperty.state = PropertyNewValue;
 	serverEventProc(GDK_WINDOW_XDISPLAY(widget->window), &xev);
 
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
+ 	if (MAIN_LEVEL() > 0)
+ 	    MAIN_QUIT();
     }
     return FALSE;
 }
@@ -772,6 +775,10 @@
     if (blink_state == BLINK_NONE)
 	gui_mch_start_blink();
 
+#ifdef FEAT_GUI_COMPONENT
+    /*gtk_plug_grab_focus(GTK_PLUG(gui.plug));*/
+    /*gtk_window_set_focus(GTK_WINDOW(gui.plug), gui.drawarea);*/
+#endif
     /* make sure keyboard input goes there */
     if (gtk_socket_id == 0 || !GTK_WIDGET_HAS_FOCUS(gui.drawarea))
 	gtk_widget_grab_focus(gui.drawarea);
@@ -783,6 +790,11 @@
     static gint
 leave_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
 {
+#ifdef FEAT_GUI_COMPONENT
+    /*gtk_plug_ungrab_focus(GTK_PLUG(gui.plug));*/
+    /*gdk_display_keyboard_ungrab (gtk_widget_get_display (gui.drawarea),
+                                 gtk_get_current_event_time ());*/
+#endif
     if (blink_state != BLINK_NONE)
 	gui_mch_stop_blink();
 
@@ -793,8 +805,16 @@
     static gint
 focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
 {
+    GdkEventMask mask;
     gui_focus_change(TRUE);
 
+#ifdef FEAT_GUI_COMPONENT
+    gtk_widget_grab_focus(gui.drawarea);
+    mask = gdk_window_get_events(gui.drawarea->window);
+    mask |= GDK_KEY_PRESS | GDK_KEY_RELEASE;
+    gdk_window_set_events(gui.drawarea->window, mask);
+#endif
+
     if (blink_state == BLINK_NONE)
 	gui_mch_start_blink();
 
@@ -809,6 +829,9 @@
     static gint
 focus_out_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
 {
+#ifdef FEAT_GUI_COMPONENT
+/*    gtk_plug_ungrab_focus(GTK_PLUG(gui.plug));*/
+#endif
     gui_focus_change(FALSE);
 
     if (blink_state != BLINK_NONE)
@@ -1167,8 +1190,8 @@
     if (p_mh)
 	gui_mch_mousehide(TRUE);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();
 
     return TRUE;
 }
@@ -1203,8 +1226,8 @@
     else
 	clip_lose_selection(&clip_star);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+ 	MAIN_QUIT();
 
     return TRUE;
 }
@@ -1244,9 +1267,8 @@
 	received_selection = RS_FAIL;
 	/* clip_free_selection(cbd); ??? */
 
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
-
+        if (MAIN_LEVEL() > 0)
+            MAIN_QUIT();      /* make sure the above will be handled immediately */
 	return;
     }
 
@@ -1355,8 +1377,8 @@
     g_free(tmpbuf_utf8);
 #endif
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 }
 
 /*
@@ -1538,6 +1560,15 @@
 	using_gnome = 1;
 #endif
 
+
+#ifdef FEAT_GUI_COMPONENT
+    if( !vim_bonobo_init(&gui_argc, gui_argv))
+    {
+        /* in component mode, we don't care about trying to continue without 
+         * a gui; if we can't create the factory, we might as well quit. */
+        mch_exit(2);
+    }
+#else
     /* Don't use gtk_init() or gnome_init(), it exits on failure. */
     if (!gtk_init_check(&gui_argc, &gui_argv))
     {
@@ -1545,10 +1576,29 @@
 	EMSG(_(e_opendisp));
 	return FAIL;
     }
+#endif
 
     return OK;
 }
 
+#if FEAT_GUI_COMPONENT
+static gint
+control_activate_event(BonoboControl *control, gboolean activated)
+{
+    if (activated) 
+    {
+        gui_focus_change (TRUE);
+        if (blink_state == BLINK_NONE)
+            gui_mch_start_blink();
+    } else {
+        gui_focus_change (FALSE);
+        if (blink_state != BLINK_NONE)
+            gui_mch_stop_blink();
+    }
+    return TRUE;
+}
+#endif
+
 
 /****************************************************************************
  * Mouse handling callbacks
@@ -1609,8 +1659,8 @@
     /* inform the editor engine about the occurence of this event */
     gui_send_mouse_event(button, x, y, FALSE, vim_modifiers);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 
     /*
      * Auto repeat timer handling.
@@ -1805,8 +1855,8 @@
 	vim_modifiers |= MOUSE_ALT;
 
     gui_send_mouse_event(button, x, y, repeated_click, vim_modifiers);
-    if (gtk_main_level() > 0)
-	gtk_main_quit(); /* make sure the above will be handled immediately */
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 
     return TRUE;
 }
@@ -1854,8 +1904,8 @@
     gui_send_mouse_event(button, (int)event->x, (int)event->y,
 							FALSE, vim_modifiers);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit(); /* make sure the above will be handled immediately */
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();	/* make sure the above will be handled immediately */
 
     return TRUE;
 }
@@ -1890,8 +1940,8 @@
 	vim_modifiers |= MOUSE_ALT;
 
     gui_send_mouse_event(MOUSE_RELEASE, x, y, FALSE, vim_modifiers);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();	/* make sure it will be handled immediately */
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 
     return TRUE;
 }
@@ -2073,8 +2123,8 @@
     else
 	add_to_input_buf(dropkey + 3, (int)(sizeof(dropkey) - 3));
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 }
 
 /*
@@ -2540,6 +2590,7 @@
     static void
 mainwin_realize(GtkWidget *widget, gpointer data)
 {
+#ifndef FEAT_GUI_COMPONENT
 /* If you get an error message here, you still need to unpack the runtime
  * archive! */
 #ifdef magick
@@ -2623,6 +2674,7 @@
 
 #endif /* !HAVE_GTK2 */
     }
+#endif /* FEAT_GUI_COMPONENT */
 
 #if !(defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION))
     /* Register a handler for WM_SAVE_YOURSELF with GDK's low-level X I/F */
@@ -2641,7 +2693,7 @@
 #endif
 	setup_save_yourself();
 
-#ifdef FEAT_CLIENTSERVER
+#if defined(FEAT_CLIENTSERVER) &&!defined(FEAT_GUI_COMPONENT)
     if (serverName == NULL && serverDelayedStartName != NULL)
     {
 	/* This is a :gui command in a plain vim with no previous server */
@@ -2689,7 +2741,7 @@
     return cursor;
 }
 
-#ifdef HAVE_GTK_MULTIHEAD
+#if defined(HAVE_GTK_MULTIHEAD) && !defined(FEAT_GUI_COMPONENT)
 /*ARGSUSED1*/
     static void
 mainwin_screen_changed_cb(GtkWidget  *widget,
@@ -3014,7 +3066,11 @@
 #ifdef FEAT_GUI_GNOME
 	if (using_gnome)
 	{
-	    gui.mainwin = gnome_app_new("Vim", NULL);
+# if defined(FEAT_GUI_COMPONENT)
+            gui.mainwin = NULL;
+# else
+            gui.mainwin = gnome_app_new("vim", NULL);
+# endif
 # ifdef USE_XSMP
 	    /* Use the GNOME save-yourself functionality now. */
 	    xsmp_close();
@@ -3025,14 +3081,28 @@
 	    gui.mainwin = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     }
 
+#ifdef FEAT_GUI_COMPONENT
+    vbox = gtk_vbox_new(FALSE, 0);
+    gui.vbox = vbox;
+#else
     gtk_widget_set_name(gui.mainwin, "vim-main-window");
+#endif
 
 #ifdef HAVE_GTK2
     /* Create the PangoContext used for drawing all text. */
+#ifdef FEAT_GUI_COMPONENT
+    gui.text_context = gtk_widget_create_pango_context(GTK_WIDGET(gui.vbox));
+#else
     gui.text_context = gtk_widget_create_pango_context(gui.mainwin);
+#endif
     pango_context_set_base_dir(gui.text_context, PANGO_DIRECTION_LTR);
 #endif
 
+#ifdef FEAT_GUI_COMPONENT
+    bonobo_control_construct (BONOBO_CONTROL (gui.control), GTK_WIDGET(gui.vbox));
+    gtk_widget_add_events(GTK_WIDGET(gui.drawarea), GDK_VISIBILITY_NOTIFY_MASK);
+    gtk_widget_show_all(GTK_WIDGET(gui.vbox));
+#else
 #ifndef HAVE_GTK2
     gtk_window_set_policy(GTK_WINDOW(gui.mainwin), TRUE, TRUE, TRUE);
 #endif
@@ -3055,8 +3125,6 @@
     gui.accel_group = gtk_accel_group_get_default();
 #endif
 
-    vbox = gtk_vbox_new(FALSE, 0);
-
 #ifdef FEAT_GUI_GNOME
     if (using_gnome)
     {
@@ -3072,6 +3140,9 @@
 	gtk_container_add(GTK_CONTAINER(gui.mainwin), vbox);
 	gtk_widget_show(vbox);
     }
+#endif
+  
+#ifndef FEAT_GUI_COMPONENT
 
 #ifdef FEAT_MENU
     /*
@@ -3177,6 +3248,7 @@
 	gtk_box_pack_start(GTK_BOX(vbox), gui.toolbar, FALSE, FALSE, 0);
     }
 #endif /* FEAT_TOOLBAR */
+#endif /* FEAT_GUI_COMPONENT */
 
     gui.formwin = gtk_form_new();
     gtk_container_border_width(GTK_CONTAINER(gui.formwin), 0);
@@ -3204,6 +3276,11 @@
     gtk_widget_show(gui.formwin);
     gtk_box_pack_start(GTK_BOX(vbox), gui.formwin, TRUE, TRUE, 0);
 
+#ifdef FEAT_GUI_COMPONENT
+    GTK_WIDGET_SET_FLAGS (gui.drawarea, GTK_CAN_FOCUS);
+    g_signal_connect(G_OBJECT(gui.drawarea), "key_press_event",
+                        G_CALLBACK(key_press_event), NULL);
+#else
     /* For GtkSockets, key-presses must go to the focus widget (drawarea)
      * and not the window. */
     gtk_signal_connect((gtk_socket_id == 0) ? GTK_OBJECT(gui.mainwin)
@@ -3218,6 +3295,7 @@
 		     "key_release_event",
 		     G_CALLBACK(&key_release_event), NULL);
 #endif
+#endif /* FEAT_GUI_COMPONENT */
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "realize",
 		       GTK_SIGNAL_FUNC(drawarea_realize_cb), NULL);
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "unrealize",
@@ -3252,16 +3330,27 @@
      */
     gui.border_offset = gui.border_width;
 
+#ifdef FEAT_GUI_COMPONENT
+    gtk_signal_connect(GTK_OBJECT(gui.drawarea), "visibility_notify_event",
+		       GTK_SIGNAL_FUNC(visibility_event), NULL);
+#else
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "visibility_notify_event",
 		       GTK_SIGNAL_FUNC(visibility_event), NULL);
+#endif
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "expose_event",
 		       GTK_SIGNAL_FUNC(expose_event), NULL);
 
     /*
      * Only install these enter/leave callbacks when 'p' in 'guioptions'.
      * Only needed for some window managers.
+     *
+     * Force this on for bonobo, otherwise the toolbar gets the focus 
+     * after you click a button, and you can't get the focus back to the 
+     * drawarea.
      */
+#ifndef FEAT_GUI_COMPONENT
     if (vim_strchr(p_go, GO_POINTER) != NULL)
+#endif
     {
 	gtk_signal_connect(GTK_OBJECT(gui.drawarea), "leave_notify_event",
 			   GTK_SIGNAL_FUNC(leave_notify_event), NULL);
@@ -3269,10 +3358,19 @@
 			   GTK_SIGNAL_FUNC(enter_notify_event), NULL);
     }
 
+#ifdef FEAT_GUI_COMPONENT
+    g_signal_connect(G_OBJECT(gui.control), "activate",
+		     G_CALLBACK (control_activate_event), NULL);
+    gtk_signal_connect(GTK_OBJECT(gui.drawarea), "focus_out_event",
+			   GTK_SIGNAL_FUNC(focus_out_event), NULL);
+    gtk_signal_connect(GTK_OBJECT(gui.drawarea), "focus_in_event",
+			   GTK_SIGNAL_FUNC(focus_in_event), NULL);
+#else	
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "focus_out_event",
 			   GTK_SIGNAL_FUNC(focus_out_event), NULL);
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "focus_in_event",
 			   GTK_SIGNAL_FUNC(focus_in_event), NULL);
+#endif
 
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "motion_notify_event",
 		       GTK_SIGNAL_FUNC(motion_notify_event), NULL);
@@ -3445,7 +3543,7 @@
      * otherwise the hints don't work. */
     width  = gui_get_base_width();
     height = gui_get_base_height();
-# ifdef HAVE_GTK2
+# if defined( HAVE_GTK2 ) && !defined(FEAT_GUI_COMPONENT)
     width  += get_menu_tool_width();
     height += get_menu_tool_height();
 # endif
@@ -3492,8 +3590,18 @@
 form_configure_event(GtkWidget *widget, GdkEventConfigure *event,
 		     gpointer data)
 {
+    int height;
+
     gtk_form_freeze(GTK_FORM(gui.formwin));
-    gui_resize_shell(event->width, event->height);
+#ifdef FEAT_GUI_COMPONENT
+    /* width_inc and height_inc (see window manager hints, above) aren't
+     * respected for embedded controls, so we have to make a slight adjustment
+     * to make sure the bottom line doesn't get clipped. */
+    height = gui.char_height * ((event->height - 2 )/ gui.char_height);
+#else
+    height = event->height;
+#endif
+    gui_resize_shell(event->width, height);
     gtk_form_thaw(GTK_FORM(gui.formwin));
 
     return TRUE;
@@ -3625,8 +3733,10 @@
      * changed them). */
     highlight_gui_started();	/* re-init colors and fonts */
 
+#ifndef FEAT_GUI_COMPONENT
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "destroy",
 		       GTK_SIGNAL_FUNC(mainwin_destroy_cb), NULL);
+#endif
 
 #ifdef FEAT_HANGULIN
     hangul_keyboard_set();
@@ -3694,7 +3804,9 @@
 						  NULL);
 # endif
 #endif
-	gtk_widget_show(gui.mainwin);
+#ifndef FEAT_GUI_COMPONENT
+        gtk_widget_show(gui.mainwin);
+#endif
 
 #if defined(FEAT_GUI_GNOME) && defined(HAVE_GTK2) && defined(FEAT_MENU)
 	if (menu_handler != 0)
@@ -3724,8 +3836,8 @@
     if (gui.mainwin != NULL)
 	gtk_widget_destroy(gui.mainwin);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();	/* make sure the above will be handled immediately */
 }
 
 /*
@@ -3778,6 +3890,7 @@
     static gboolean
 force_shell_resize_idle(gpointer data)
 {
+    g_warning("force_shell_resize_idle called!");
     if (gui.mainwin != NULL
 	    && GTK_WIDGET_REALIZED(gui.mainwin)
 	    && GTK_WIDGET_VISIBLE(gui.mainwin))
@@ -3827,7 +3940,7 @@
     /* this will cause the proper resizement to happen too */
     update_window_manager_hints();
 
-#ifdef HAVE_GTK2
+#if defined( HAVE_GTK2 ) && !defined(FEAT_GUI_COMPONENT)
     /* With GTK+ 2, changing the size of the form widget doesn't resize
      * the window.  So lets do it the other way around and resize the
      * main window instead. */
@@ -3916,6 +4029,7 @@
 {
     GtkWidget *widget;
 
+#ifndef FEAT_GUI_COMPONENT
 # ifdef FEAT_GUI_GNOME
     if (using_gnome)
 	widget = gui.menubar_h;
@@ -3932,6 +4046,7 @@
 
 	update_window_manager_hints();
     }
+#endif
 }
 #endif /* FEAT_MENU */
 
@@ -3983,8 +4098,8 @@
 
     vw->fontname = (char_u *)gtk_font_selection_dialog_get_font_name(fs);
     gtk_widget_hide(vw->fontdlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 }
 
 /*ARGSUSED*/
@@ -3994,8 +4109,8 @@
     gui_T *vw = (gui_T *)cbdata;
 
     gtk_widget_hide(vw->fontdlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 }
 
 /*ARGSUSED*/
@@ -4005,8 +4120,8 @@
     gui_T *vw = (gui_T *)cbdata;
 
     vw->fontdlg = NULL;
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 }
 #endif /* !HAVE_GTK2 */
 
@@ -4173,7 +4288,7 @@
 
     /* Wait for the font dialog to be closed. */
     while (gui.fontdlg && GTK_WIDGET_DRAWABLE(gui.fontdlg))
-	gtk_main_iteration_do(TRUE);
+	MAIN_ITERATION_DO(TRUE);
 
     if (gui.fontname != NULL)
     {
@@ -5727,8 +5842,13 @@
     void
 gui_mch_update(void)
 {
+#ifdef FEAT_GUI_COMPONENT
+    if( gui.processing_call ) {
+        return;
+    }
+#endif
     while (gtk_events_pending() && !vim_is_input_buf_full())
-	gtk_main_iteration_do(FALSE);
+        MAIN_ITERATION_DO(TRUE);
 }
 
     static gint
@@ -5739,8 +5859,8 @@
     /* Just inform the caller about the occurence of it */
     *timed_out = TRUE;
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 
     return FALSE;		/* don't happen again */
 }
@@ -5760,8 +5880,8 @@
 
     add_to_input_buf(bytes, 3);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 #endif
 
@@ -5828,7 +5948,7 @@
 	/*
 	 * Loop in GTK+ processing  until a timeout or input occurs.
 	 */
-	gtk_main();
+	MAIN();
 
 	/* Got char, return immediately */
 	if (input_available())
@@ -5903,6 +6023,7 @@
 	gdk_window_clear(gui.drawarea->window);
 }
 
+
 /*
  * Redraw any text revealed by scrolling up/down.
  */
@@ -6017,7 +6138,7 @@
 			      (guint32)GDK_CURRENT_TIME);
 
 	while (received_selection == RS_NONE)
-	    gtk_main();	/* wait for selection_received_cb */
+	    MAIN();     /* wait for selection_received_cb */
 
 	if (received_selection != RS_FAIL)
 	    return;
@@ -6085,6 +6206,13 @@
     void
 gui_mch_menu_grey(vimmenu_T *menu, int grey)
 {
+#ifdef FEAT_GUI_COMPONENT
+    if( menu->sensitive != !grey ) {
+        menu->sensitive = !grey;
+        update_menu_later(menu);
+    }
+    return;
+#endif
     if (menu->id == NULL)
 	return;
 
@@ -6222,6 +6350,40 @@
 static int last_shape = 0;
 #endif
 
+#if 0
+static BonoboWindow *
+bonobo_create_window(void)
+{
+    BonoboWindow      *win;
+    BonoboUIContainer *ui_container;
+    BonoboUIComponent *ui_component;
+                                                                                
+    win = BONOBO_WINDOW (bonobo_window_new ("vim", "vim"));                                                                                
+    ui_container = bonobo_window_get_ui_container (win);
+    bonobo_ui_engine_config_set_path (bonobo_window_get_ui_engine (win),
+                      "/gnome-vim/UIConfig/kvps");
+                                                                                
+    /* Create a UI component with which to communicate with the window */
+    ui_component = bonobo_ui_component_new_default ();
+
+    gui.component = ui_component;
+                                                                                
+    /* Associate the BonoboUIComponent with the container */
+    bonobo_ui_component_set_container (
+        ui_component, BONOBO_OBJREF (ui_container), NULL);
+                                                                                
+    //bonobo_ui_util_set_ui (ui_component, "", 
+                   //HELLO_SRCDIR HELLO_UI_XML,
+                   //"bonobo-hello", NULL);
+                                                                                
+    /* Associate our verb -> callback mapping with the BonoboWindow */
+    /* All the callback's user_data pointers will be set to 'win' */
+    //bonobo_ui_component_add_verb_list_with_data (ui_component, hello_verbs, win);
+                                                                                
+    return win;
+}
+#endif
+
 /*
  * Use the blank mouse pointer or not.
  *
diff -Nur vim63/src/gui.h vim63-bonobo/src/gui.h
--- vim63/src/gui.h	2005-09-09 20:11:10.563758000 +0200
+++ vim63-bonobo/src/gui.h	2005-09-09 20:14:02.734584544 +0200
@@ -52,6 +52,22 @@
 # include <gtk/gtk.h>
 #endif
 
+# if defined(FEAT_GUI_GNOME) && defined(FEAT_GUI_COMPONENT)
+    #include "libbonoboui.h"
+    #include "vim_bonobo_main.h"
+    #include "vim_bonobo_factory.h"
+    #define MAIN vim_bonobo_main
+    #define MAIN_LEVEL vim_bonobo_main_level
+    #define MAIN_QUIT vim_bonobo_main_quit
+    #define MAIN_ITERATION_DO vim_bonobo_main_iteration_do
+    #define NO_CONSOLE
+# else
+    #define MAIN gtk_main
+    #define MAIN_LEVEL gtk_main_level
+    #define MAIN_QUIT gtk_main_quit
+    #define MAIN_ITERATION_DO gtk_main_iteration_do
+#endif
+
 #ifdef FEAT_GUI_BEOS
 # include "gui_beos.h"
 #endif
@@ -427,6 +443,14 @@
     GtkWidget	*toolbar;	    /* toolbar */
 # endif
 # ifdef FEAT_GUI_GNOME
+#  ifdef FEAT_GUI_COMPONENT
+    GtkWidget     *vbox;
+    BonoboPlug    *plug;
+    BonoboControl *control;
+    BonoboPersistStream * pstream;
+    BonoboPersistFile * pfile;
+    int		 processing_call;   /* gui loop is handling a call */
+#  endif
     GtkWidget	*menubar_h;	    /* menubar handle */
     GtkWidget	*toolbar_h;	    /* toolbar handle */
 # endif
diff -Nur vim63/src/main.c vim63-bonobo/src/main.c
--- vim63/src/main.c	2005-09-09 20:11:10.571757000 +0200
+++ vim63-bonobo/src/main.c	2005-09-09 20:19:37.444700872 +0200
@@ -79,7 +79,7 @@
 # ifdef VIMDLL
 _export
 # endif
-# ifdef FEAT_GUI_MSWIN
+# if defined(FEAT_GUI_MSWIN)
 #  ifdef __BORLANDC__
 _cdecl
 #  endif
@@ -244,8 +244,12 @@
     TIME_MSG("locale set");
 #endif
 
-#ifdef FEAT_GUI
+#if defined(FEAT_GUI_COMPONENT)
+    gui.dofork = FALSE;		    /* don't use fork when running as component */
+#else
+# if defined(FEAT_GUI) && !defined(FEAT_GUI_COMPONENT)
     gui.dofork = TRUE;		    /* default is to use fork() */
+# endif
 #endif
 
 #if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER)
@@ -444,6 +448,10 @@
 	++initstr;
     }
 
+#ifdef FEAT_GUI_COMPONENT
+    main_start_gui();
+#endif
+
     if (TOLOWER_ASC(initstr[0]) == 'g' || initstr[0] == 'k')
     {
 	main_start_gui();
@@ -1679,6 +1687,7 @@
      * Call settmode and starttermcap here, so the T_KS and T_TI may be
      * defined by termcapinit and redifined in .exrc.
      */
+#ifndef FEAT_GUI_COMPONENT
     settmode(TMODE_RAW);
     TIME_MSG("setting raw mode");
 
@@ -1687,6 +1696,7 @@
 	wait_return(TRUE);
 	TIME_MSG("waiting for return");
     }
+#endif
 
     starttermcap();	    /* start termcap if not done by wait_return() */
     TIME_MSG("start termcap");
@@ -1815,6 +1825,9 @@
 	curwin = firstwin;
 	curbuf = curwin->w_buffer;
 #endif
+#ifdef FEAT_GUI_COMPONENT
+	persistent_buffer = curbuf;
+#endif
     }
     TIME_MSG("opening buffers");
 
diff -Nur vim63/src/main.c.orig vim63-bonobo/src/main.c.orig
--- vim63/src/main.c.orig	2005-09-09 20:11:09.841868000 +0200
+++ vim63-bonobo/src/main.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,3210 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-
-#if defined(MSDOS) || defined(WIN32) || defined(_WIN64)
-# include <io.h>		/* for close() and dup() */
-#endif
-
-#define EXTERN
-#include "vim.h"
-
-#ifdef SPAWNO
-# include <spawno.h>		/* special MSDOS swapping library */
-#endif
-
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>
-#endif
-
-#ifdef __CYGWIN__
-# ifndef WIN32
-#  include <sys/cygwin.h>	/* for cygwin_conv_to_posix_path() */
-# endif
-# include <limits.h>
-#endif
-
-#if defined(UNIX) || defined(VMS)
-static int file_owned __ARGS((char *fname));
-#endif
-static void mainerr __ARGS((int, char_u *));
-static void main_msg __ARGS((char *s));
-static void usage __ARGS((void));
-static int get_number_arg __ARGS((char_u *p, int *idx, int def));
-static void main_start_gui __ARGS((void));
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-static void check_swap_exists_action __ARGS((void));
-#endif
-#ifdef FEAT_CLIENTSERVER
-static void cmdsrv_main __ARGS((int *argc, char **argv, char_u *serverName_arg, char_u **serverStr));
-static char_u *serverMakeName __ARGS((char_u *arg, char *cmd));
-#endif
-
-
-#ifdef STARTUPTIME
-static FILE *time_fd = NULL;
-#endif
-
-#define FEAT_PRECOMMANDS
-
-/*
- * Different types of error messages.
- */
-static char *(main_errors[]) =
-{
-    N_("Unknown option"),
-#define ME_UNKNOWN_OPTION	0
-    N_("Too many edit arguments"),
-#define ME_TOO_MANY_ARGS	1
-    N_("Argument missing after"),
-#define ME_ARG_MISSING		2
-    N_("Garbage after option"),
-#define ME_GARBAGE		3
-    N_("Too many \"+command\", \"-c command\" or \"--cmd command\" arguments"),
-#define ME_EXTRA_CMD		4
-    N_("Invalid argument for"),
-#define ME_INVALID_ARG		5
-};
-
-/* Maximum number of commands from + or -c options */
-#define MAX_ARG_CMDS 10
-
-#ifndef PROTO	    /* don't want a prototype for main() */
-    int
-# ifdef VIMDLL
-_export
-# endif
-# ifdef FEAT_GUI_MSWIN
-#  ifdef __BORLANDC__
-_cdecl
-#  endif
-VimMain
-# else
-main
-# endif
-(argc, argv)
-    int		argc;
-    char	**argv;
-{
-    char_u	*initstr;		/* init string from environment */
-    char_u	*term = NULL;		/* specified terminal name */
-    char_u	*fname = NULL;		/* file name from command line */
-    char_u	*tagname = NULL;	/* tag from -t option */
-    char_u	*use_vimrc = NULL;	/* vimrc from -u option */
-#ifdef FEAT_QUICKFIX
-    char_u	*use_ef = NULL;		/* 'errorfile' from -q option */
-#endif
-#ifdef FEAT_CRYPT
-    int		ask_for_key = FALSE;    /* -x argument */
-#endif
-    int		n_commands = 0;		/* no. of commands from + or -c */
-    char_u	*commands[MAX_ARG_CMDS]; /* commands from + or -c option */
-#ifdef FEAT_PRECOMMANDS
-    int		p_commands = 0;		/* no. of commands from --cmd */
-    char_u	*pre_commands[MAX_ARG_CMDS]; /* commands from --cmd option */
-#endif
-    int		no_swap_file = FALSE;   /* "-n" option used */
-    int		c;
-    int		i;
-    char_u	*p = NULL;
-    int		bin_mode = FALSE;	/* -b option used */
-#ifdef FEAT_EVAL
-    int		use_debug_break_level = -1;
-#endif
-#ifdef FEAT_WINDOWS
-    int		window_count = -1;	/* number of windows to use */
-    int		arg_idx;		/* index in argument list */
-    int		vert_windows = MAYBE;   /* "-O" used instead of "-o" */
-#endif
-    int		had_minmin = FALSE;	/* found "--" option */
-    int		argv_idx;		/* index in argv[n][] */
-    int		want_full_screen = TRUE;
-    int		want_argument;		/* option with argument */
-#define EDIT_NONE   0	    /* no edit type yet */
-#define EDIT_FILE   1	    /* file name argument[s] given, use argument list */
-#define EDIT_STDIN  2	    /* read file from stdin */
-#define EDIT_TAG    3	    /* tag name argument given, use tagname */
-#define EDIT_QF	    4	    /* start in quickfix mode */
-    int		edit_type = EDIT_NONE;  /* type of editing to do */
-#ifdef FEAT_DIFF
-    int		diff_mode = FALSE;	/* start with 'diff' set */
-#endif
-    int		evim_mode = FALSE;	/* started as "evim" */
-    int		stdout_isatty;		/* is stdout a terminal? */
-    int		input_isatty;		/* is active input a terminal? */
-#ifdef MSWIN
-    int		full_path = FALSE;
-#endif
-#ifdef FEAT_CLIENTSERVER
-    char_u	*serverStr = NULL;
-    char_u	*serverName_arg = NULL;	/* cmdline arg for server name */
-    int		serverArg = FALSE;	/* TRUE when argument for a server */
-    char_u	*servername = NULL;	/* allocated name for our server */
-#endif
-#if (!defined(UNIX) && !defined(__EMX__)) || defined(ARCHIE)
-    int		literal = FALSE;	/* don't expand file names */
-#endif
-
-    /*
-     * Do any system-specific initialisations.  These can NOT use IObuff or
-     * NameBuff.  Thus emsg2() cannot be called!
-     */
-    mch_early_init();
-
-#ifdef FEAT_TCL
-    vim_tcl_init(argv[0]);
-#endif
-
-#ifdef MEM_PROFILE
-    atexit(vim_mem_profile_dump);
-#endif
-
-#ifdef STARTUPTIME
-    time_fd = fopen(STARTUPTIME, "a");
-    TIME_MSG("--- VIM STARTING ---");
-#endif
-
-#ifdef __EMX__
-    _wildcard(&argc, &argv);
-#endif
-
-#ifdef FEAT_MBYTE
-    (void)mb_init();	/* init mb_bytelen_tab[] to ones */
-#endif
-
-#ifdef __QNXNTO__
-    qnx_init();		/* PhAttach() for clipboard, (and gui) */
-#endif
-
-#ifdef MAC_OS_CLASSIC
-    /* Macintosh needs this before any memory is allocated. */
-    gui_prepare(&argc, argv);	/* Prepare for possibly starting GUI sometime */
-    TIME_MSG("GUI prepared");
-#endif
-
-    /* Init the table of Normal mode commands. */
-    init_normal_cmds();
-
-#if defined(HAVE_DATE_TIME) && defined(VMS) && defined(VAXC)
-    make_version();
-#endif
-
-    /*
-     * Allocate space for the generic buffers (needed for set_init_1() and
-     * EMSG2()).
-     */
-    if ((IObuff = alloc(IOSIZE)) == NULL
-	    || (NameBuff = alloc(MAXPATHL)) == NULL)
-	mch_exit(0);
-
-    TIME_MSG("Allocated generic buffers");
-
-#ifdef NBDEBUG
-    /* Wait a moment for debugging NetBeans.  Must be after allocating
-     * NameBuff. */
-    nbdebug_log_init("SPRO_GVIM_DEBUG", "SPRO_GVIM_DLEVEL");
-    nbdebug_wait(WT_ENV | WT_WAIT | WT_STOP, "SPRO_GVIM_WAIT", 20);
-#endif
-
-#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)
-    /*
-     * Setup to use the current locale (for ctype() and many other things).
-     * NOTE: Translated messages with encodings other than latin1 will not
-     * work until set_init_1() has been called!
-     */
-    setlocale(LC_ALL, "");
-
-# ifdef FEAT_GETTEXT
-    {
-	int	mustfree = FALSE;
-
-#  ifdef DYNAMIC_GETTEXT
-	/* Initialize the gettext library */
-	dyn_libintl_init(NULL);
-#  endif
-	/* expand_env() doesn't work yet, because chartab[] is not initialized
-	 * yet, call vim_getenv() directly */
-	p = vim_getenv((char_u *)"VIMRUNTIME", &mustfree);
-	if (p != NULL && *p != NUL)
-	{
-	    STRCPY(NameBuff, p);
-	    STRCAT(NameBuff, "/lang");
-	    bindtextdomain(VIMPACKAGE, (char *)NameBuff);
-	}
-	if (mustfree)
-	    vim_free(p);
-	textdomain(VIMPACKAGE);
-    }
-# endif
-    TIME_MSG("locale set");
-#endif
-
-#ifdef FEAT_GUI
-    gui.dofork = TRUE;		    /* default is to use fork() */
-#endif
-
-#if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER)
-    /*
-     * Get the name of the display, before gui_prepare() removes it from
-     * argv[].  Used for the xterm-clipboard display.
-     *
-     * Also find the --server... arguments
-     */
-    for (i = 1; i < argc; i++)
-    {
-	if (STRCMP(argv[i], "--") == 0)
-	    break;
-# ifdef FEAT_XCLIPBOARD
-	else if (STRICMP(argv[i], "-display") == 0
-#  ifdef FEAT_GUI_GTK
-		|| STRICMP(argv[i], "--display") == 0
-#  endif
-		)
-	{
-	    if (i == argc - 1)
-		mainerr_arg_missing((char_u *)argv[i]);
-	    xterm_display = argv[++i];
-	}
-# endif
-# ifdef FEAT_CLIENTSERVER
-	else if (STRICMP(argv[i], "--servername") == 0)
-	{
-	    if (i == argc - 1)
-		mainerr_arg_missing((char_u *)argv[i]);
-	    serverName_arg = (char_u *)argv[++i];
-	}
-	else if (STRICMP(argv[i], "--serverlist") == 0
-		 || STRICMP(argv[i], "--remote-send") == 0
-		 || STRICMP(argv[i], "--remote-expr") == 0
-		 || STRICMP(argv[i], "--remote") == 0
-		 || STRICMP(argv[i], "--remote-silent") == 0)
-	    serverArg = TRUE;
-	else if (STRICMP(argv[i], "--remote-wait") == 0
-		|| STRICMP(argv[i], "--remote-wait-silent") == 0)
-	{
-	    serverArg = TRUE;
-#ifdef FEAT_GUI
-	    /* don't fork() when starting the GUI to edit the files ourself */
-	    gui.dofork = FALSE;
-#endif
-	}
-# endif
-# ifdef FEAT_GUI_GTK
-	else if (STRICMP(argv[i], "--socketid") == 0)
-	{
-	    unsigned int    socket_id;
-	    int		    count;
-
-	    if (i == argc - 1)
-		mainerr_arg_missing((char_u *)argv[i]);
-	    if (STRNICMP(argv[i+1], "0x", 2) == 0)
-		count = sscanf(&(argv[i + 1][2]), "%x", &socket_id);
-	    else
-		count = sscanf(argv[i+1], "%u", &socket_id);
-	    if (count != 1)
-		mainerr(ME_INVALID_ARG, (char_u *)argv[i]);
-	    else
-		gtk_socket_id = socket_id;
-	    i++;
-	}
-	else if (STRICMP(argv[i], "--echo-wid") == 0)
-	    echo_wid_arg = TRUE;
-# endif
-    }
-#endif
-
-#ifdef FEAT_SUN_WORKSHOP
-    findYourself(argv[0]);
-#endif
-#if defined(FEAT_GUI) && !defined(MAC_OS_CLASSIC)
-    gui_prepare(&argc, argv);	/* Prepare for possibly starting GUI sometime */
-    TIME_MSG("GUI prepared");
-#endif
-
-#ifdef FEAT_CLIPBOARD
-    clip_init(FALSE);		/* Initialise clipboard stuff */
-    TIME_MSG("clipboard setup");
-#endif
-
-    /*
-     * Check if we have an interactive window.
-     * On the Amiga: If there is no window, we open one with a newcli command
-     * (needed for :! to * work). mch_check_win() will also handle the -d or
-     * -dev argument.
-     */
-    stdout_isatty = (mch_check_win(argc, argv) != FAIL);
-    TIME_MSG("window checked");
-
-    /*
-     * Allocate the first window and buffer. Can't do much without it.
-     */
-    win_alloc_first();
-
-    init_yank();		/* init yank buffers */
-
-    /* Init the argument list to empty. */
-    alist_init(&global_alist);
-
-    /*
-     * Set the default values for the options.
-     * NOTE: Non-latin1 translated messages are working only after this,
-     * because this is where "has_mbyte" will be set, which is used by
-     * msg_outtrans_len_attr().
-     * First find out the home directory, needed to expand "~" in options.
-     */
-    init_homedir();		/* find real value of $HOME */
-    set_init_1();
-    TIME_MSG("inits 1");
-
-#ifdef FEAT_EVAL
-    set_lang_var();		/* set v:lang and v:ctype */
-#endif
-
-#ifdef FEAT_CLIENTSERVER
-    /*
-     * Do the client-server stuff, unless "--servername ''" was used.
-     */
-    if (serverName_arg == NULL || *serverName_arg != NUL)
-    {
-# ifdef WIN32
-	/* Initialise the client/server messaging infrastructure. */
-	serverInitMessaging();
-# endif
-
-	/*
-	 * When a command server argument was found, execute it.  This may
-	 * exit Vim when it was successful.
-	 */
-	if (serverArg)
-	    cmdsrv_main(&argc, argv, serverName_arg, &serverStr);
-
-	/* If we're still running, get the name to register ourselves.
-	 * On Win32 can register right now, for X11 need to setup the
-	 * clipboard first, it's further down. */
-	servername = serverMakeName(serverName_arg, argv[0]);
-# ifdef WIN32
-	if (servername != NULL)
-	{
-	    serverSetName(servername);
-	    vim_free(servername);
-	}
-# endif
-    }
-#endif
-
-    /*
-     * Check for: [r][e][g][vi|vim|view][diff][ex[im]]
-     * If the executable name starts with "r" we disable shell commands.
-     * If the next character is "e" we run in Easy mode.
-     * If the next character is "g" we run the GUI version.
-     * If the next characters are "view" we start in readonly mode.
-     * If the next characters are "diff" or "vimdiff" we start in diff mode.
-     * If the next characters are "ex" we start in Ex mode.  If it's followed
-     * by "im" use improved Ex mode.
-     */
-    initstr = gettail((char_u *)argv[0]);
-
-#ifdef MACOS_X_UNIX
-    /* An issue has been seen when launching Vim in such a way that
-     * $PWD/$ARGV[0] or $ARGV[0] is not the absolute path to the
-     * executable or a symbolic link of it. Until this issue is resolved
-     * we prohibit the GUI from being used.
-     */
-    if (STRCMP(initstr, argv[0]) == 0)
-	disallow_gui = TRUE;
-#endif
-
-#ifdef FEAT_EVAL
-    set_vim_var_string(VV_PROGNAME, initstr, -1);
-#endif
-
-    /* TODO: On MacOS X default to gui if argv[0] ends in:
-     *       /vim.app/Contents/MacOS/Vim */
-
-    if (TOLOWER_ASC(initstr[0]) == 'r')
-    {
-	restricted = TRUE;
-	++initstr;
-    }
-
-    /* Avoid using evim mode for "editor". */
-    if (TOLOWER_ASC(initstr[0]) == 'e'
-	    && (TOLOWER_ASC(initstr[1]) == 'v'
-					   || TOLOWER_ASC(initstr[1]) == 'g'))
-    {
-#ifdef FEAT_GUI
-	gui.starting = TRUE;
-#endif
-	evim_mode = TRUE;
-	++initstr;
-    }
-
-    if (TOLOWER_ASC(initstr[0]) == 'g')
-    {
-	main_start_gui();
-#ifdef FEAT_GUI
-	++initstr;
-#endif
-    }
-
-    if (STRNICMP(initstr, "view", 4) == 0)
-    {
-	readonlymode = TRUE;
-	curbuf->b_p_ro = TRUE;
-	p_uc = 10000;			/* don't update very often */
-	initstr += 4;
-    }
-    else if (STRNICMP(initstr, "vim", 3) == 0)
-	initstr += 3;
-
-    /* Catch "[r][g]vimdiff" and "[r][g]viewdiff". */
-    if (STRICMP(initstr, "diff") == 0)
-    {
-#ifdef FEAT_DIFF
-	diff_mode = TRUE;
-#else
-	mch_errmsg(_("This Vim was not compiled with the diff feature."));
-	mch_errmsg("\n");
-	mch_exit(2);
-#endif
-    }
-
-    if (STRNICMP(initstr, "ex", 2) == 0)
-    {
-	if (STRNICMP(initstr + 2, "im", 2) == 0)
-	    exmode_active = EXMODE_VIM;
-	else
-	    exmode_active = EXMODE_NORMAL;
-	change_compatible(TRUE);	/* set 'compatible' */
-    }
-
-    initstr = gettail((char_u *)argv[0]);
-    ++argv;
-    --argc;
-
-    /*
-     * Process the command line arguments.
-     */
-    argv_idx = 1;	    /* active option letter is argv[0][argv_idx] */
-    while (argc > 0)
-    {
-	/*
-	 * "+" or "+{number}" or "+/{pat}" or "+{command}" argument.
-	 */
-	if (argv[0][0] == '+' && !had_minmin)
-	{
-	    if (n_commands >= MAX_ARG_CMDS)
-		mainerr(ME_EXTRA_CMD, NULL);
-	    argv_idx = -1;	    /* skip to next argument */
-	    if (argv[0][1] == NUL)
-		commands[n_commands++] = (char_u *)"$";
-	    else
-		commands[n_commands++] = (char_u *)&(argv[0][1]);
-	}
-
-	/*
-	 * Optional argument.
-	 */
-	else if (argv[0][0] == '-' && !had_minmin)
-	{
-	    want_argument = FALSE;
-	    c = argv[0][argv_idx++];
-#ifdef VMS
-	    /*
-	     * VMS only uses upper case command lines.  Interpret "-X" as "-x"
-	     * and "-/X" as "-X".
-	     */
-	    if (c == '/')
-	    {
-		c = argv[0][argv_idx++];
-		c = TOUPPER_ASC(c);
-	    }
-	    else
-		c = TOLOWER_ASC(c);
-#endif
-	    switch (c)
-	    {
-	    case NUL:		/* "vim -"  read from stdin */
-				/* "ex -" silent mode */
-		if (exmode_active)
-		    silent_mode = TRUE;
-		else
-		{
-		    if (edit_type != EDIT_NONE)
-			mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
-		    edit_type = EDIT_STDIN;
-		    read_cmd_fd = 2;	/* read from stderr instead of stdin */
-		}
-		argv_idx = -1;		/* skip to next argument */
-		break;
-
-	    case '-':		/* "--" don't take any more options */
-				/* "--help" give help message */
-				/* "--version" give version message */
-				/* "--literal" take files literally */
-				/* "--nofork" don't fork */
-				/* "--noplugin[s]" skip plugins */
-				/* "--cmd <cmd>" execute cmd before vimrc */
-		if (STRICMP(argv[0] + argv_idx, "help") == 0)
-		    usage();
-		else if (STRICMP(argv[0] + argv_idx, "version") == 0)
-		{
-		    Columns = 80;	/* need to init Columns */
-		    info_message = TRUE; /* use mch_msg(), not mch_errmsg() */
-		    list_version();
-		    msg_putchar('\n');
-		    msg_didout = FALSE;
-		    mch_exit(0);
-		}
-		else if (STRNICMP(argv[0] + argv_idx, "literal", 7) == 0)
-		{
-#if (!defined(UNIX) && !defined(__EMX__)) || defined(ARCHIE)
-		    literal = TRUE;
-#endif
-		}
-		else if (STRNICMP(argv[0] + argv_idx, "nofork", 6) == 0)
-		{
-#ifdef FEAT_GUI
-		    gui.dofork = FALSE;	/* don't fork() when starting GUI */
-#endif
-		}
-		else if (STRNICMP(argv[0] + argv_idx, "noplugin", 8) == 0)
-		    p_lpl = FALSE;
-#ifdef FEAT_PRECOMMANDS
-		else if (STRNICMP(argv[0] + argv_idx, "cmd", 3) == 0)
-		{
-		    want_argument = TRUE;
-		    argv_idx += 3;
-		}
-#endif
-#ifdef FEAT_CLIENTSERVER
-		else if (STRNICMP(argv[0] + argv_idx, "serverlist", 10) == 0)
-		    ; /* already processed -- no arg */
-		else if (STRNICMP(argv[0] + argv_idx, "servername", 10) == 0
-		       || STRNICMP(argv[0] + argv_idx, "serversend", 10) == 0)
-		{
-		    /* already processed -- snatch the following arg */
-		    if (argc > 1)
-		    {
-			--argc;
-			++argv;
-		    }
-		}
-#endif
-#ifdef FEAT_GUI_GTK
-		else if (STRNICMP(argv[0] + argv_idx, "socketid", 8) == 0)
-		{
-		    /* already processed -- snatch the following arg */
-		    if (argc > 1)
-		    {
-			--argc;
-			++argv;
-		    }
-		}
-		else if (STRNICMP(argv[0] + argv_idx, "echo-wid", 8) == 0)
-		{
-		    /* already processed, skip */
-		}
-#endif
-		else
-		{
-		    if (argv[0][argv_idx])
-			mainerr(ME_UNKNOWN_OPTION, (char_u *)argv[0]);
-		    had_minmin = TRUE;
-		}
-		if (!want_argument)
-		    argv_idx = -1;	/* skip to next argument */
-		break;
-
-	    case 'A':		/* "-A" start in Arabic mode */
-#ifdef FEAT_ARABIC
-		set_option_value((char_u *)"arabic", 1L, NULL, 0);
-#else
-		mch_errmsg(_(e_noarabic));
-		mch_exit(2);
-#endif
-		break;
-
-	    case 'b':		/* "-b" binary mode */
-		bin_mode = TRUE;    /* postpone to after reading .exrc files */
-		break;
-
-	    case 'C':		/* "-C"  Compatible */
-		change_compatible(TRUE);
-		break;
-
-	    case 'e':		/* "-e" Ex mode */
-		exmode_active = EXMODE_NORMAL;
-		break;
-
-	    case 'E':		/* "-E" Improved Ex mode */
-		exmode_active = EXMODE_VIM;
-		break;
-
-	    case 'f':		/* "-f"  GUI: run in foreground.  Amiga: open
-				window directly, not with newcli */
-#ifdef FEAT_GUI
-		gui.dofork = FALSE;	/* don't fork() when starting GUI */
-#endif
-		break;
-
-	    case 'g':		/* "-g" start GUI */
-		main_start_gui();
-		break;
-
-	    case 'F':		/* "-F" start in Farsi mode: rl + fkmap set */
-#ifdef FEAT_FKMAP
-		curwin->w_p_rl = p_fkmap = TRUE;
-#else
-		mch_errmsg(_(e_nofarsi));
-		mch_exit(2);
-#endif
-		break;
-
-	    case 'h':		/* "-h" give help message */
-#ifdef FEAT_GUI_GNOME
-		/* Tell usage() to exit for "gvim". */
-		gui.starting = FALSE;
-#endif
-		usage();
-		break;
-
-	    case 'H':		/* "-H" start in Hebrew mode: rl + hkmap set */
-#ifdef FEAT_RIGHTLEFT
-		curwin->w_p_rl = p_hkmap = TRUE;
-#else
-		mch_errmsg(_(e_nohebrew));
-		mch_exit(2);
-#endif
-		break;
-
-	    case 'l':		/* "-l" lisp mode, 'lisp' and 'showmatch' on */
-#ifdef FEAT_LISP
-		set_option_value((char_u *)"lisp", 1L, NULL, 0);
-		p_sm = TRUE;
-#endif
-		break;
-
-#ifdef TARGET_API_MAC_OSX
-		/* For some reason on MacOS X, an argument like:
-		   -psn_0_10223617 is passed in when invoke from Finder
-		   or with the 'open' command */
-	    case 'p':
-		argv_idx = -1; /* bypass full -psn */
-		main_start_gui();
-		break;
-#endif
-	    case 'M':		/* "-M"  no changes or writing of files */
-		reset_modifiable();
-		/* FALLTRHOUGH */
-
-	    case 'm':		/* "-m"  no writing of files */
-		p_write = FALSE;
-		break;
-
-	    case 'y':		/* "-y"  easy mode */
-#ifdef FEAT_GUI
-		gui.starting = TRUE;	/* start GUI a bit later */
-#endif
-		evim_mode = TRUE;
-		break;
-
-	    case 'N':		/* "-N"  Nocompatible */
-		change_compatible(FALSE);
-		break;
-
-	    case 'n':		/* "-n" no swap file */
-		no_swap_file = TRUE;
-		break;
-
-	    case 'o':		/* "-o[N]" open N horizontal split windows */
-#ifdef FEAT_WINDOWS
-		/* default is 0: open window for each file */
-		window_count = get_number_arg((char_u *)argv[0], &argv_idx, 0);
-		vert_windows = FALSE;
-#endif
-		break;
-
-		case 'O':	/* "-O[N]" open N vertical split windows */
-#if defined(FEAT_VERTSPLIT) && defined(FEAT_WINDOWS)
-		/* default is 0: open window for each file */
-		window_count = get_number_arg((char_u *)argv[0], &argv_idx, 0);
-		vert_windows = TRUE;
-#endif
-		break;
-
-#ifdef FEAT_QUICKFIX
-	    case 'q':		/* "-q" QuickFix mode */
-		if (edit_type != EDIT_NONE)
-		    mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
-		edit_type = EDIT_QF;
-		if (argv[0][argv_idx])		/* "-q{errorfile}" */
-		{
-		    use_ef = (char_u *)argv[0] + argv_idx;
-		    argv_idx = -1;
-		}
-		else if (argc > 1)		/* "-q {errorfile}" */
-		    want_argument = TRUE;
-		break;
-#endif
-
-	    case 'R':		/* "-R" readonly mode */
-		readonlymode = TRUE;
-		curbuf->b_p_ro = TRUE;
-		p_uc = 10000;			/* don't update very often */
-		break;
-
-	    case 'r':		/* "-r" recovery mode */
-	    case 'L':		/* "-L" recovery mode */
-		recoverymode = 1;
-		break;
-
-	    case 's':
-		if (exmode_active)	/* "-s" silent (batch) mode */
-		    silent_mode = TRUE;
-		else		/* "-s {scriptin}" read from script file */
-		    want_argument = TRUE;
-		break;
-
-	    case 't':		/* "-t {tag}" or "-t{tag}" jump to tag */
-		if (edit_type != EDIT_NONE)
-		    mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
-		edit_type = EDIT_TAG;
-		if (argv[0][argv_idx])		/* "-t{tag}" */
-		{
-		    tagname = (char_u *)argv[0] + argv_idx;
-		    argv_idx = -1;
-		}
-		else				/* "-t {tag}" */
-		    want_argument = TRUE;
-		break;
-
-#ifdef FEAT_EVAL
-	    case 'D':		/* "-D"		Debugging */
-		use_debug_break_level = 9999;
-		break;
-#endif
-#ifdef FEAT_DIFF
-	    case 'd':		/* "-d"		'diff' */
-# ifdef AMIGA
-		/* check for "-dev {device}" */
-		if (argv[0][argv_idx] == 'e' && argv[0][argv_idx + 1] == 'v')
-		    want_argument = TRUE;
-		else
-# endif
-		    diff_mode = TRUE;
-		break;
-#endif
-	    case 'V':		/* "-V{N}"	Verbose level */
-		/* default is 10: a little bit verbose */
-		p_verbose = get_number_arg((char_u *)argv[0], &argv_idx, 10);
-		break;
-
-	    case 'v':		/* "-v"  Vi-mode (as if called "vi") */
-		exmode_active = 0;
-#ifdef FEAT_GUI
-		gui.starting = FALSE;	/* don't start GUI */
-#endif
-		break;
-
-	    case 'w':		/* "-w{number}"	set window height */
-				/* "-w {scriptout}"	write to script */
-		if (vim_isdigit(((char_u *)argv[0])[argv_idx]))
-		{
-		    argv_idx = -1;
-		    break;			/* not implemented, ignored */
-		}
-		want_argument = TRUE;
-		break;
-
-#ifdef FEAT_CRYPT
-	    case 'x':		/* "-x"  encrypted reading/writing of files */
-		ask_for_key = TRUE;
-		break;
-#endif
-
-	    case 'X':		/* "-X"  don't connect to X server */
-#if (defined(UNIX) || defined(VMS)) && defined(FEAT_X11)
-		x_no_connect = TRUE;
-#endif
-		break;
-
-	    case 'Z':		/* "-Z"  restricted mode */
-		restricted = TRUE;
-		break;
-
-	    case 'c':		/* "-c {command}" execute command */
-	    case 'S':		/* "-S {file}" execute Vim script */
-	    case 'i':		/* "-i {viminfo}" use for viminfo */
-#ifndef FEAT_DIFF
-	    case 'd':		/* "-d {device}" device (for Amiga) */
-#endif
-	    case 'T':		/* "-T {terminal}" terminal name */
-	    case 'u':		/* "-u {vimrc}" vim inits file */
-	    case 'U':		/* "-U {gvimrc}" gvim inits file */
-	    case 'W':		/* "-W {scriptout}" overwrite */
-#ifdef FEAT_GUI_W32
-	    case 'P':		/* "-P {parent title}" MDI parent */
-#endif
-		want_argument = TRUE;
-		break;
-
-	    default:
-		mainerr(ME_UNKNOWN_OPTION, (char_u *)argv[0]);
-	    }
-
-	    /*
-	     * Handle options with argument.
-	     */
-	    if (want_argument)
-	    {
-		/*
-		 * Check for garbage immediately after the option letter.
-		 */
-		if (argv[0][argv_idx] != NUL)
-		    mainerr(ME_GARBAGE, (char_u *)argv[0]);
-
-		--argc;
-		if (argc < 1 && c != 'S')
-		    mainerr_arg_missing((char_u *)argv[0]);
-		++argv;
-		argv_idx = -1;
-
-		switch (c)
-		{
-		case 'c':	/* "-c {command}" execute command */
-		case 'S':	/* "-S {file}" execute Vim script */
-		    if (n_commands >= MAX_ARG_CMDS)
-			mainerr(ME_EXTRA_CMD, NULL);
-		    if (c == 'S')
-		    {
-			char	*a;
-
-			if (argc < 1)
-			    /* "-S" without argument: use default session file
-			     * name. */
-			    a = SESSION_FILE;
-			else if (argv[0][0] == '-')
-			{
-			    /* "-S" followed by another option: use default
-			     * session file name. */
-			    a = SESSION_FILE;
-			    ++argc;
-			    --argv;
-			}
-			else
-			    a = argv[0];
-			p = alloc((unsigned)(STRLEN(a) + 4));
-			if (p == NULL)
-			    mch_exit(2);
-			sprintf((char *)p, "so %s", a);
-			commands[n_commands++] = p;
-		    }
-		    else
-			commands[n_commands++] = (char_u *)argv[0];
-		    break;
-
-#ifdef FEAT_PRECOMMANDS
-		case '-':	/* "--cmd {command}" execute command */
-		    if (p_commands >= MAX_ARG_CMDS)
-			mainerr(ME_EXTRA_CMD, NULL);
-		    pre_commands[p_commands++] = (char_u *)argv[0];
-		    break;
-#endif
-
-	    /*	case 'd':   -d {device} is handled in mch_check_win() for the
-	     *		    Amiga */
-
-#ifdef FEAT_QUICKFIX
-		case 'q':	/* "-q {errorfile}" QuickFix mode */
-		    use_ef = (char_u *)argv[0];
-		    break;
-#endif
-
-		case 'i':	/* "-i {viminfo}" use for viminfo */
-		    use_viminfo = (char_u *)argv[0];
-		    break;
-
-		case 's':	/* "-s {scriptin}" read from script file */
-		    if (scriptin[0] != NULL)
-		    {
-scripterror:
-			mch_errmsg(_("Attempt to open script file again: \""));
-			mch_errmsg(argv[-1]);
-			mch_errmsg(" ");
-			mch_errmsg(argv[0]);
-			mch_errmsg("\"\n");
-			mch_exit(2);
-		    }
-		    if ((scriptin[0] = mch_fopen(argv[0], READBIN)) == NULL)
-		    {
-			mch_errmsg(_("Cannot open for reading: \""));
-			mch_errmsg(argv[0]);
-			mch_errmsg("\"\n");
-			mch_exit(2);
-		    }
-		    if (save_typebuf() == FAIL)
-			mch_exit(2);	/* out of memory */
-		    break;
-
-		case 't':	/* "-t {tag}" */
-		    tagname = (char_u *)argv[0];
-		    break;
-
-		case 'T':	/* "-T {terminal}" terminal name */
-		    /*
-		     * The -T term option is always available and when
-		     * HAVE_TERMLIB is supported it overrides the environment
-		     * variable TERM.
-		     */
-#ifdef FEAT_GUI
-		    if (term_is_gui((char_u *)argv[0]))
-			gui.starting = TRUE;	/* start GUI a bit later */
-		    else
-#endif
-			term = (char_u *)argv[0];
-		    break;
-
-		case 'u':	/* "-u {vimrc}" vim inits file */
-		    use_vimrc = (char_u *)argv[0];
-		    break;
-
-		case 'U':	/* "-U {gvimrc}" gvim inits file */
-#ifdef FEAT_GUI
-		    use_gvimrc = (char_u *)argv[0];
-#endif
-		    break;
-
-		case 'w':	/* "-w {scriptout}" append to script file */
-		case 'W':	/* "-W {scriptout}" overwrite script file */
-		    if (scriptout != NULL)
-			goto scripterror;
-		    if ((scriptout = mch_fopen(argv[0],
-				    c == 'w' ? APPENDBIN : WRITEBIN)) == NULL)
-		    {
-			mch_errmsg(_("Cannot open for script output: \""));
-			mch_errmsg(argv[0]);
-			mch_errmsg("\"\n");
-			mch_exit(2);
-		    }
-		    break;
-
-#ifdef FEAT_GUI_W32
-		case 'P':		/* "-P {parent title}" MDI parent */
-		    gui_mch_set_parent(argv[0]);
-		    break;
-#endif
-		}
-	    }
-	}
-
-	/*
-	 * File name argument.
-	 */
-	else
-	{
-	    argv_idx = -1;	    /* skip to next argument */
-
-	    /* Check for only one type of editing. */
-	    if (edit_type != EDIT_NONE && edit_type != EDIT_FILE)
-		mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
-	    edit_type = EDIT_FILE;
-
-#ifdef MSWIN
-	    /* Remember if the argument was a full path before changing
-	     * slashes to backslashes. */
-	    if (argv[0][0] != NUL && argv[0][1] == ':' && argv[0][2] == '\\')
-		full_path = TRUE;
-#endif
-
-	    /* Add the file to the global argument list. */
-	    if (ga_grow(&global_alist.al_ga, 1) == FAIL
-		    || (p = vim_strsave((char_u *)argv[0])) == NULL)
-		mch_exit(2);
-#ifdef FEAT_DIFF
-	    if (diff_mode && mch_isdir(p) && GARGCOUNT > 0
-				      && !mch_isdir(alist_name(&GARGLIST[0])))
-	    {
-		char_u	    *r;
-
-		r = concat_fnames(p, gettail(alist_name(&GARGLIST[0])), TRUE);
-		if (r != NULL)
-		{
-		    vim_free(p);
-		    p = r;
-		}
-	    }
-#endif
-#if defined(__CYGWIN32__) && !defined(WIN32)
-	    /*
-	     * If vim is invoked by non-Cygwin tools, convert away any
-	     * DOS paths, so things like .swp files are created correctly.
-	     * Look for evidence of non-Cygwin paths before we bother.
-	     * This is only for when using the Unix files.
-	     */
-	    if (strpbrk(p, "\\:") != NULL)
-	    {
-		char posix_path[PATH_MAX];
-
-		cygwin_conv_to_posix_path(p, posix_path);
-		vim_free(p);
-		p = vim_strsave(posix_path);
-		if (p == NULL)
-		    mch_exit(2);
-	    }
-#endif
-	    alist_add(&global_alist, p,
-#if (!defined(UNIX) && !defined(__EMX__)) || defined(ARCHIE)
-		    literal ? 2 : 0	/* add buffer number after expanding */
-#else
-		    2		/* add buffer number now and use curbuf */
-#endif
-		    );
-	}
-
-	/*
-	 * If there are no more letters after the current "-", go to next
-	 * argument.  argv_idx is set to -1 when the current argument is to be
-	 * skipped.
-	 */
-	if (argv_idx <= 0 || argv[0][argv_idx] == NUL)
-	{
-	    --argc;
-	    ++argv;
-	    argv_idx = 1;
-	}
-    }
-    TIME_MSG("parsing arguments");
-
-    /*
-     * On some systems, when we compile with the GUI, we always use it.  On Mac
-     * there is no terminal version, and on Windows we can't figure out how to
-     * fork one off with :gui.
-     */
-#ifdef ALWAYS_USE_GUI
-    gui.starting = TRUE;
-#else
-# if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK)
-    /*
-     * Check if the GUI can be started.  Reset gui.starting if not.
-     * Don't know about other systems, stay on the safe side and don't check.
-     */
-    if (gui.starting && gui_init_check() == FAIL)
-    {
-	gui.starting = FALSE;
-
-	/* When running "evim" or "gvim -y" we need the menus, exit if we
-	 * don't have them. */
-	if (evim_mode)
-	    mch_exit(1);
-    }
-# endif
-#endif
-
-    /* "-b" argument used.  Check before expanding file names, because for
-     * Win32 this makes us edit a shortcut file itself, instead of the file it
-     * links to. */
-    if (bin_mode)
-    {
-	set_options_bin(curbuf->b_p_bin, 1, 0);
-	curbuf->b_p_bin = 1;	    /* binary file I/O */
-    }
-
-    if (GARGCOUNT > 0)
-    {
-#if (!defined(UNIX) && !defined(__EMX__)) || defined(ARCHIE)
-	/*
-	 * Expand wildcards in file names.
-	 */
-	if (!literal)
-	{
-	    /* Temporarily add '(' and ')' to 'isfname'.  These are valid
-	     * filename characters but are excluded from 'isfname' to make
-	     * "gf" work on a file name in parenthesis (e.g.: see vim.h). */
-	    do_cmdline_cmd((char_u *)":set isf+=(,)");
-	    alist_expand();
-	    do_cmdline_cmd((char_u *)":set isf&");
-	}
-#endif
-	fname = alist_name(&GARGLIST[0]);
-    }
-    if (GARGCOUNT > 1)
-	printf(_("%d files to edit\n"), GARGCOUNT);
-#ifdef MSWIN
-    else if (GARGCOUNT == 1 && full_path)
-    {
-	/*
-	 * If there is one filename, fully qualified, we have very probably
-	 * been invoked from explorer, so change to the file's directory.
-	 * Hint: to avoid this when typing a command use a forward slash.
-	 * If the cd fails, it doesn't matter.
-	 */
-	(void)vim_chdirfile(fname);
-    }
-#endif
-    TIME_MSG("expanding arguments");
-
-#ifdef FEAT_DIFF
-    if (diff_mode)
-    {
-	if (window_count == -1)
-	    window_count = 0;		/* open up to 3 files in a window */
-	if (vert_windows == MAYBE)
-	    vert_windows = TRUE;	/* use vertical split */
-    }
-#endif
-
-    ++RedrawingDisabled;
-
-    /*
-     * When listing swap file names, don't do cursor positioning et. al.
-     */
-    if (recoverymode && fname == NULL)
-	want_full_screen = FALSE;
-
-    /*
-     * When certain to start the GUI, don't check capabilities of terminal.
-     * For GTK we can't be sure, but when started from the desktop it doesn't
-     * make sense to try using a terminal.
-     */
-#if defined(ALWAYS_USE_GUI) || defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK)
-    if (gui.starting
-# ifdef FEAT_GUI_GTK
-	    && !isatty(2)
-# endif
-	    )
-	want_full_screen = FALSE;
-#endif
-
-#if defined(FEAT_GUI_MAC) && defined(MACOS_X_UNIX)
-    /* When the GUI is started from Finder, need to display messages in a
-     * message box.  isatty(2) returns TRUE anyway, thus we need to check the
-     * name to know we're not started from a terminal. */
-    if (gui.starting && (!isatty(2) || strcmp("/dev/console", ttyname(2)) == 0))
-	want_full_screen = FALSE;
-#endif
-
-    /*
-     * mch_init() sets up the terminal (window) for use.  This must be
-     * done after resetting full_screen, otherwise it may move the cursor
-     * (MSDOS).
-     * Note that we may use mch_exit() before mch_init()!
-     */
-    mch_init();
-    TIME_MSG("shell init");
-
-#ifdef USE_XSMP
-    /*
-     * For want of anywhere else to do it, try to connect to xsmp here.
-     * Fitting it in after gui_mch_init, but before gui_init (via termcapinit).
-     * Hijacking -X 'no X connection' to also disable XSMP connection as that
-     * has a similar delay upon failure.
-     * Only try if SESSION_MANAGER is set to something non-null.
-     */
-    if (!x_no_connect)
-    {
-	p = (char_u *)getenv("SESSION_MANAGER");
-	if (p != NULL && *p != NUL)
-	{
-	    xsmp_init();
-	    TIME_MSG("xsmp init");
-	}
-    }
-#endif
-
-    /*
-     * Print a warning if stdout is not a terminal.
-     * When starting in Ex mode and commands come from a file, set Silent mode.
-     */
-    input_isatty = mch_input_isatty();
-    if (exmode_active)
-    {
-	if (!input_isatty)
-	    silent_mode = TRUE;
-    }
-    else if (want_full_screen && (!stdout_isatty || !input_isatty)
-#ifdef FEAT_GUI
-	    /* don't want the delay when started from the desktop */
-	    && !gui.starting
-#endif
-	    )
-    {
-	if (!stdout_isatty)
-	    mch_errmsg(_("Vim: Warning: Output is not to a terminal\n"));
-	if (!input_isatty)
-	    mch_errmsg(_("Vim: Warning: Input is not from a terminal\n"));
-	out_flush();
-	if (scriptin[0] == NULL)
-	    ui_delay(2000L, TRUE);
-	TIME_MSG("Warning delay");
-    }
-
-    if (want_full_screen)
-    {
-	termcapinit(term);	/* set terminal name and get terminal
-				   capabilities (will set full_screen) */
-	screen_start();		/* don't know where cursor is now */
-	TIME_MSG("Termcap init");
-    }
-
-    /*
-     * Set the default values for the options that use Rows and Columns.
-     */
-    ui_get_shellsize();		/* inits Rows and Columns */
-#ifdef FEAT_NETBEANS_INTG
-    if (usingNetbeans)
-	Columns += 2;		/* leave room for glyph gutter */
-#endif
-    firstwin->w_height = Rows - p_ch;
-    topframe->fr_height = Rows - p_ch;
-#ifdef FEAT_VERTSPLIT
-    firstwin->w_width = Columns;
-    topframe->fr_width = Columns;
-#endif
-#ifdef FEAT_DIFF
-    /* Set the 'diff' option now, so that it can be checked for in a .vimrc
-     * file.  There is no buffer yet though. */
-    if (diff_mode)
-	diff_win_options(firstwin, FALSE);
-#endif
-
-    cmdline_row = Rows - p_ch;
-    msg_row = cmdline_row;
-    screenalloc(FALSE);		/* allocate screen buffers */
-    set_init_2();
-    TIME_MSG("inits 2");
-
-    msg_scroll = TRUE;
-    no_wait_return = TRUE;
-
-    init_mappings();		/* set up initial mappings */
-
-    init_highlight(TRUE, FALSE); /* set the default highlight groups */
-    TIME_MSG("init highlight");
-#ifdef CURSOR_SHAPE
-    parse_shape_opt(SHAPE_CURSOR); /* set cursor shapes from 'guicursor' */
-#endif
-#ifdef FEAT_MOUSESHAPE
-    parse_shape_opt(SHAPE_MOUSE);  /* set mouse shapes from 'mouseshape' */
-#endif
-#ifdef FEAT_PRINTER
-    parse_list_options(p_popt, printer_opts, OPT_PRINT_NUM_OPTIONS);
-#endif
-
-#ifdef FEAT_EVAL
-    /* Set the break level after the terminal is initialized. */
-    debug_break_level = use_debug_break_level;
-#endif
-
-#ifdef FEAT_PRECOMMANDS
-    if (p_commands > 0)
-    {
-	curwin->w_cursor.lnum = 0; /* just in case.. */
-	sourcing_name = (char_u *)_("pre-vimrc command line");
-# ifdef FEAT_EVAL
-	current_SID = SID_CMDARG;
-# endif
-	for (i = 0; i < p_commands; ++i)
-	    do_cmdline_cmd(pre_commands[i]);
-	sourcing_name = NULL;
-# ifdef FEAT_EVAL
-	current_SID = 0;
-# endif
-    }
-#endif
-
-    /*
-     * For "evim" source evim.vim first of all, so that the user can overrule
-     * any things he doesn't like.
-     */
-    if (evim_mode)
-    {
-	(void)do_source((char_u *)EVIM_FILE, FALSE, FALSE);
-	TIME_MSG("source evim file");
-    }
-
-    /*
-     * If -u option given, use only the initializations from that file and
-     * nothing else.
-     */
-    if (use_vimrc != NULL)
-    {
-	if (STRCMP(use_vimrc, "NONE") == 0 || STRCMP(use_vimrc, "NORC") == 0)
-	{
-#ifdef FEAT_GUI
-	    if (use_gvimrc == NULL)	    /* don't load gvimrc either */
-		use_gvimrc = use_vimrc;
-#endif
-	    if (use_vimrc[2] == 'N')
-		p_lpl = FALSE;		    /* don't load plugins either */
-	}
-	else
-	{
-	    if (do_source(use_vimrc, FALSE, FALSE) != OK)
-		EMSG2(_("E282: Cannot read from \"%s\""), use_vimrc);
-	}
-    }
-    else if (!silent_mode)
-    {
-#ifdef AMIGA
-	struct Process	*proc = (struct Process *)FindTask(0L);
-	APTR		save_winptr = proc->pr_WindowPtr;
-
-	/* Avoid a requester here for a volume that doesn't exist. */
-	proc->pr_WindowPtr = (APTR)-1L;
-#endif
-
-	/*
-	 * Get system wide defaults, if the file name is defined.
-	 */
-#ifdef SYS_VIMRC_FILE
-	(void)do_source((char_u *)SYS_VIMRC_FILE, FALSE, FALSE);
-#endif
-
-	/*
-	 * Try to read initialization commands from the following places:
-	 * - environment variable VIMINIT
-	 * - user vimrc file (s:.vimrc for Amiga, ~/.vimrc otherwise)
-	 * - second user vimrc file ($VIM/.vimrc for Dos)
-	 * - environment variable EXINIT
-	 * - user exrc file (s:.exrc for Amiga, ~/.exrc otherwise)
-	 * - second user exrc file ($VIM/.exrc for Dos)
-	 * The first that exists is used, the rest is ignored.
-	 */
-	if (process_env((char_u *)"VIMINIT", TRUE) != OK)
-	{
-	    if (do_source((char_u *)USR_VIMRC_FILE, TRUE, TRUE) == FAIL
-#ifdef USR_VIMRC_FILE2
-		&& do_source((char_u *)USR_VIMRC_FILE2, TRUE, TRUE) == FAIL
-#endif
-#ifdef USR_VIMRC_FILE3
-		&& do_source((char_u *)USR_VIMRC_FILE3, TRUE, TRUE) == FAIL
-#endif
-		&& process_env((char_u *)"EXINIT", FALSE) == FAIL
-		&& do_source((char_u *)USR_EXRC_FILE, FALSE, FALSE) == FAIL)
-	    {
-#ifdef USR_EXRC_FILE2
-		(void)do_source((char_u *)USR_EXRC_FILE2, FALSE, FALSE);
-#endif
-	    }
-	}
-
-	/*
-	 * Read initialization commands from ".vimrc" or ".exrc" in current
-	 * directory.  This is only done if the 'exrc' option is set.
-	 * Because of security reasons we disallow shell and write commands
-	 * now, except for unix if the file is owned by the user or 'secure'
-	 * option has been reset in environmet of global ".exrc" or ".vimrc".
-	 * Only do this if VIMRC_FILE is not the same as USR_VIMRC_FILE or
-	 * SYS_VIMRC_FILE.
-	 */
-	if (p_exrc)
-	{
-#if defined(UNIX) || defined(VMS)
-	    /* If ".vimrc" file is not owned by user, set 'secure' mode. */
-	    if (!file_owned(VIMRC_FILE))
-#endif
-		secure = p_secure;
-
-	    i = FAIL;
-	    if (fullpathcmp((char_u *)USR_VIMRC_FILE,
-				      (char_u *)VIMRC_FILE, FALSE) != FPC_SAME
-#ifdef USR_VIMRC_FILE2
-		    && fullpathcmp((char_u *)USR_VIMRC_FILE2,
-				      (char_u *)VIMRC_FILE, FALSE) != FPC_SAME
-#endif
-#ifdef USR_VIMRC_FILE3
-		    && fullpathcmp((char_u *)USR_VIMRC_FILE3,
-				      (char_u *)VIMRC_FILE, FALSE) != FPC_SAME
-#endif
-#ifdef SYS_VIMRC_FILE
-		    && fullpathcmp((char_u *)SYS_VIMRC_FILE,
-				      (char_u *)VIMRC_FILE, FALSE) != FPC_SAME
-#endif
-				)
-		i = do_source((char_u *)VIMRC_FILE, TRUE, TRUE);
-
-	    if (i == FAIL)
-	    {
-#if defined(UNIX) || defined(VMS)
-		/* if ".exrc" is not owned by user set 'secure' mode */
-		if (!file_owned(EXRC_FILE))
-		    secure = p_secure;
-		else
-		    secure = 0;
-#endif
-		if (	   fullpathcmp((char_u *)USR_EXRC_FILE,
-				      (char_u *)EXRC_FILE, FALSE) != FPC_SAME
-#ifdef USR_EXRC_FILE2
-			&& fullpathcmp((char_u *)USR_EXRC_FILE2,
-				      (char_u *)EXRC_FILE, FALSE) != FPC_SAME
-#endif
-				)
-		    (void)do_source((char_u *)EXRC_FILE, FALSE, FALSE);
-	    }
-	}
-	if (secure == 2)
-	    need_wait_return = TRUE;
-	secure = 0;
-#ifdef AMIGA
-	proc->pr_WindowPtr = save_winptr;
-#endif
-    }
-    TIME_MSG("sourcing vimrc file(s)");
-
-#ifdef FEAT_EVAL
-    /*
-     * Read all the plugin files.
-     * Only when compiled with +eval, since most plugins need it.
-     */
-    if (p_lpl)
-    {
-	cmd_runtime((char_u *)"plugin/*.vim", TRUE);
-	TIME_MSG("loading plugins");
-    }
-#endif
-
-    /*
-     * Recovery mode without a file name: List swap files.
-     * This uses the 'dir' option, therefore it must be after the
-     * initializations.
-     */
-    if (recoverymode && fname == NULL)
-    {
-	recover_names(NULL, TRUE, 0);
-	mch_exit(0);
-    }
-
-    /*
-     * Set a few option defaults after reading .vimrc files:
-     * 'title' and 'icon', Unix: 'shellpipe' and 'shellredir'.
-     */
-    set_init_3();
-    TIME_MSG("inits 3");
-
-    /*
-     * "-n" argument: Disable swap file by setting 'updatecount' to 0.
-     * Note that this overrides anything from a vimrc file.
-     */
-    if (no_swap_file)
-	p_uc = 0;
-
-#ifdef FEAT_FKMAP
-    if (curwin->w_p_rl && p_altkeymap)
-    {
-	p_hkmap = FALSE;	/* Reset the Hebrew keymap mode */
-# ifdef FEAT_ARABIC
-	curwin->w_p_arab = FALSE; /* Reset the Arabic keymap mode */
-# endif
-	p_fkmap = TRUE;		/* Set the Farsi keymap mode */
-    }
-#endif
-
-#ifdef FEAT_GUI
-    if (gui.starting)
-    {
-#if defined(UNIX) || defined(VMS)
-	/* When something caused a message from a vimrc script, need to output
-	 * an extra newline before the shell prompt. */
-	if (did_emsg || msg_didout)
-	    putchar('\n');
-#endif
-
-	gui_start();		/* will set full_screen to TRUE */
-	TIME_MSG("starting GUI");
-
-	/* When running "evim" or "gvim -y" we need the menus, exit if we
-	 * don't have them. */
-	if (!gui.in_use && evim_mode)
-	    mch_exit(1);
-    }
-#endif
-
-#ifdef SPAWNO		/* special MSDOS swapping library */
-    init_SPAWNO("", SWAP_ANY);
-#endif
-
-#ifdef FEAT_VIMINFO
-    /*
-     * Read in registers, history etc, but not marks, from the viminfo file
-     */
-    if (*p_viminfo != NUL)
-    {
-	read_viminfo(NULL, TRUE, FALSE, FALSE);
-	TIME_MSG("reading viminfo");
-    }
-#endif
-
-#ifdef FEAT_QUICKFIX
-    /*
-     * "-q errorfile": Load the error file now.
-     * If the error file can't be read, exit before doing anything else.
-     */
-    if (edit_type == EDIT_QF)
-    {
-	if (use_ef != NULL)
-	    set_string_option_direct((char_u *)"ef", -1, use_ef, OPT_FREE);
-	if (qf_init(p_ef, p_efm, TRUE) < 0)
-	{
-	    out_char('\n');
-	    mch_exit(3);
-	}
-	TIME_MSG("reading errorfile");
-    }
-#endif
-
-    /*
-     * Start putting things on the screen.
-     * Scroll screen down before drawing over it
-     * Clear screen now, so file message will not be cleared.
-     */
-    starting = NO_BUFFERS;
-    no_wait_return = FALSE;
-    if (!exmode_active)
-	msg_scroll = FALSE;
-
-#ifdef FEAT_GUI
-    /*
-     * This seems to be required to make callbacks to be called now, instead
-     * of after things have been put on the screen, which then may be deleted
-     * when getting a resize callback.
-     * For the Mac this handles putting files dropped on the Vim icon to
-     * global_alist.
-     */
-    if (gui.in_use)
-    {
-# ifdef FEAT_SUN_WORKSHOP
-	if (!usingSunWorkShop)
-# endif
-	    gui_wait_for_chars(50L);
-	TIME_MSG("GUI delay");
-    }
-#endif
-
-#if defined(FEAT_GUI_PHOTON) && defined(FEAT_CLIPBOARD)
-    qnx_clip_init();
-#endif
-
-#ifdef FEAT_XCLIPBOARD
-    /* Start using the X clipboard, unless the GUI was started. */
-# ifdef FEAT_GUI
-    if (!gui.in_use)
-# endif
-    {
-	setup_term_clip();
-	TIME_MSG("setup clipboard");
-    }
-#endif
-
-#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)
-    /*
-     * Register for remote command execution with :serversend and --remote
-     * unless there was a -X or a --servername '' on the command line.
-     * Only register nongui-vim's with an explicit --servername argument.
-     */
-    if (X_DISPLAY != NULL && servername != NULL && (
-# ifdef FEAT_GUI
-		gui.in_use ||
-# endif
-		serverName_arg != NULL))
-    {
-	(void)serverRegisterName(X_DISPLAY, servername);
-	vim_free(servername);
-	TIME_MSG("register server name");
-    }
-    else
-	serverDelayedStartName = servername;
-#endif
-
-#ifdef FEAT_CLIENTSERVER
-    /*
-     * Execute command ourselves if we're here because the send failed (or
-     * else we would have exited above).
-     */
-    if (serverStr != NULL)
-	server_to_input_buf(serverStr);
-#endif
-
-    /*
-     * If "-" argument given: Read file from stdin.
-     * Do this before starting Raw mode, because it may change things that the
-     * writing end of the pipe doesn't like, e.g., in case stdin and stderr
-     * are the same terminal: "cat | vim -".
-     * Using autocommands here may cause trouble...
-     */
-    if (edit_type == EDIT_STDIN && !recoverymode)
-    {
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-	/* When getting the ATTENTION prompt here, use a dialog */
-	swap_exists_action = SEA_DIALOG;
-#endif
-	no_wait_return = TRUE;
-	i = msg_didany;
-	set_buflisted(TRUE);
-	(void)open_buffer(TRUE, NULL);	/* create memfile and read file */
-	no_wait_return = FALSE;
-	msg_didany = i;
-	TIME_MSG("reading stdin");
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-	check_swap_exists_action();
-#endif
-#if !(defined(AMIGA) || defined(MACOS))
-	/*
-	 * Close stdin and dup it from stderr.  Required for GPM to work
-	 * properly, and for running external commands.
-	 * Is there any other system that cannot do this?
-	 */
-	close(0);
-	dup(2);
-#endif
-    }
-
-#if defined(UNIX) || defined(VMS)
-    /* When switching screens and something caused a message from a vimrc
-     * script, need to output an extra newline on exit. */
-    if ((did_emsg || msg_didout) && *T_TI != NUL)
-	newline_on_exit = TRUE;
-#endif
-
-    /*
-     * When done something that is not allowed or error message call
-     * wait_return.  This must be done before starttermcap(), because it may
-     * switch to another screen. It must be done after settmode(TMODE_RAW),
-     * because we want to react on a single key stroke.
-     * Call settmode and starttermcap here, so the T_KS and T_TI may be
-     * defined by termcapinit and redifined in .exrc.
-     */
-    settmode(TMODE_RAW);
-    TIME_MSG("setting raw mode");
-
-    if (need_wait_return || msg_didany)
-    {
-	wait_return(TRUE);
-	TIME_MSG("waiting for return");
-    }
-
-    starttermcap();	    /* start termcap if not done by wait_return() */
-    TIME_MSG("start termcap");
-
-#ifdef FEAT_MOUSE
-    setmouse();				/* may start using the mouse */
-#endif
-    if (scroll_region)
-	scroll_region_reset();		/* In case Rows changed */
-
-    scroll_start();
-
-    /*
-     * Don't clear the screen when starting in Ex mode, unless using the GUI.
-     */
-    if (exmode_active
-#ifdef FEAT_GUI
-			&& !gui.in_use
-#endif
-					)
-	must_redraw = CLEAR;
-    else
-    {
-	screenclear();			/* clear screen */
-	TIME_MSG("clearing screen");
-    }
-
-#ifdef FEAT_CRYPT
-    if (ask_for_key)
-    {
-	(void)get_crypt_key(TRUE, TRUE);
-	TIME_MSG("getting crypt key");
-    }
-#endif
-
-    no_wait_return = TRUE;
-
-#ifdef FEAT_WINDOWS
-    /*
-     * Create the number of windows that was requested.
-     */
-    if (window_count == -1)	/* was not set */
-	window_count = 1;
-    if (window_count == 0)
-	window_count = GARGCOUNT;
-    if (window_count > 1)
-    {
-	/* Don't change the windows if there was a command in .vimrc that
-	 * already split some windows */
-	if (vert_windows == MAYBE)
-	    vert_windows = FALSE;
-	if (firstwin->w_next == NULL)
-	{
-	    window_count = make_windows(window_count, vert_windows);
-	    TIME_MSG("making windows");
-	}
-	else
-	    window_count = win_count();
-    }
-    else
-	window_count = 1;
-#endif
-
-    if (recoverymode)			/* do recover */
-    {
-	msg_scroll = TRUE;		/* scroll message up */
-	ml_recover();
-	if (curbuf->b_ml.ml_mfp == NULL) /* failed */
-	    getout(1);
-	do_modelines();			/* do modelines */
-    }
-    else
-    {
-	/*
-	 * Open a buffer for windows that don't have one yet.
-	 * Commands in the .vimrc might have loaded a file or split the window.
-	 * Watch out for autocommands that delete a window.
-	 */
-#ifdef FEAT_AUTOCMD
-	/*
-	 * Don't execute Win/Buf Enter/Leave autocommands here
-	 */
-	++autocmd_no_enter;
-	++autocmd_no_leave;
-#endif
-#ifdef FEAT_WINDOWS
-	for (curwin = firstwin; curwin != NULL; curwin = W_NEXT(curwin))
-#endif
-	{
-	    curbuf = curwin->w_buffer;
-	    if (curbuf->b_ml.ml_mfp == NULL)
-	    {
-#ifdef FEAT_FOLDING
-		/* Set 'foldlevel' to 'foldlevelstart' if it's not negative. */
-		if (p_fdls >= 0)
-		    curwin->w_p_fdl = p_fdls;
-#endif
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-		/* When getting the ATTENTION prompt here, use a dialog */
-		swap_exists_action = SEA_DIALOG;
-#endif
-		set_buflisted(TRUE);
-		(void)open_buffer(FALSE, NULL); /* create memfile, read file */
-
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-		check_swap_exists_action();
-#endif
-#ifdef FEAT_AUTOCMD
-		curwin = firstwin;	    /* start again */
-#endif
-	    }
-#ifdef FEAT_WINDOWS
-	    ui_breakcheck();
-	    if (got_int)
-	    {
-		(void)vgetc();	/* only break the file loading, not the rest */
-		break;
-	    }
-#endif
-	}
-#ifdef FEAT_AUTOCMD
-	--autocmd_no_enter;
-	--autocmd_no_leave;
-#endif
-#ifdef FEAT_WINDOWS
-	curwin = firstwin;
-	curbuf = curwin->w_buffer;
-#endif
-    }
-    TIME_MSG("opening buffers");
-
-    /* Ex starts at last line of the file */
-    if (exmode_active)
-	curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
-
-#ifdef FEAT_AUTOCMD
-    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);
-    TIME_MSG("BufEnter autocommands");
-#endif
-    setpcmark();
-
-#ifdef FEAT_QUICKFIX
-    /*
-     * When started with "-q errorfile" jump to first error now.
-     */
-    if (edit_type == EDIT_QF)
-    {
-	qf_jump(0, 0, FALSE);
-	TIME_MSG("jump to first error");
-    }
-#endif
-
-#ifdef FEAT_WINDOWS
-    /*
-     * If opened more than one window, start editing files in the other
-     * windows.  Make_windows() has already opened the windows.
-     */
-# ifdef FEAT_AUTOCMD
-    /*
-     * Don't execute Win/Buf Enter/Leave autocommands here
-     */
-    ++autocmd_no_enter;
-    ++autocmd_no_leave;
-# endif
-    arg_idx = 1;
-    for (i = 1; i < window_count; ++i)
-    {
-	if (curwin->w_next == NULL)	    /* just checking */
-	    break;
-	win_enter(curwin->w_next, FALSE);
-
-	/* Only open the file if there is no file in this window yet (that can
-	 * happen when .vimrc contains ":sall") */
-	if (curbuf == firstwin->w_buffer || curbuf->b_ffname == NULL)
-	{
-	    curwin->w_arg_idx = arg_idx;
-	    /* edit file from arg list, if there is one */
-	    (void)do_ecmd(0, arg_idx < GARGCOUNT
-			  ? alist_name(&GARGLIST[arg_idx]) : NULL,
-			  NULL, NULL, ECMD_LASTL, ECMD_HIDE);
-	    if (arg_idx == GARGCOUNT - 1)
-		arg_had_last = TRUE;
-	    ++arg_idx;
-	}
-	ui_breakcheck();
-	if (got_int)
-	{
-	    (void)vgetc();	/* only break the file loading, not the rest */
-	    break;
-	}
-    }
-# ifdef FEAT_AUTOCMD
-    --autocmd_no_enter;
-# endif
-    win_enter(firstwin, FALSE);		/* back to first window */
-# ifdef FEAT_AUTOCMD
-    --autocmd_no_leave;
-# endif
-    TIME_MSG("editing files in windows");
-    if (window_count > 1)
-	win_equal(curwin, FALSE, 'b');	/* adjust heights */
-#endif /* FEAT_WINDOWS */
-
-#ifdef FEAT_DIFF
-    if (diff_mode)
-    {
-	win_T	*wp;
-
-	/* set options in each window for "vimdiff". */
-	for (wp = firstwin; wp != NULL; wp = wp->w_next)
-	    diff_win_options(wp, TRUE);
-    }
-#endif
-
-    /*
-     * Shorten any of the filenames, but only when absolute.
-     */
-    shorten_fnames(FALSE);
-
-    /*
-     * Need to jump to the tag before executing the '-c command'.
-     * Makes "vim -c '/return' -t main" work.
-     */
-    if (tagname != NULL)
-    {
-	STRCPY(IObuff, "ta ");
-
-	STRNCAT(IObuff, tagname, IOSIZE - 4);
-	IObuff[IOSIZE - 1] = NUL;
-	do_cmdline_cmd(IObuff);
-	TIME_MSG("jumping to tag");
-    }
-
-    if (n_commands > 0)
-    {
-	/*
-	 * We start commands on line 0, make "vim +/pat file" match a
-	 * pattern on line 1.
-	 */
-	msg_scroll = TRUE;
-	if (tagname == NULL)
-	    curwin->w_cursor.lnum = 0;
-	sourcing_name = (char_u *)"command line";
-#ifdef FEAT_EVAL
-	current_SID = SID_CARG;
-#endif
-	for (i = 0; i < n_commands; ++i)
-	    do_cmdline_cmd(commands[i]);
-	sourcing_name = NULL;
-#ifdef FEAT_EVAL
-	current_SID = 0;
-#endif
-	if (curwin->w_cursor.lnum == 0)
-	    curwin->w_cursor.lnum = 1;
-
-	if (!exmode_active)
-	    msg_scroll = FALSE;
-
-#ifdef FEAT_QUICKFIX
-	/* When started with "-q errorfile" jump to first error again. */
-	if (edit_type == EDIT_QF)
-	    qf_jump(0, 0, FALSE);
-#endif
-	TIME_MSG("executing command arguments");
-    }
-
-    RedrawingDisabled = 0;
-    redraw_all_later(NOT_VALID);
-    no_wait_return = FALSE;
-    starting = 0;
-
-    /* start in insert mode */
-    if (p_im)
-	need_start_insertmode = TRUE;
-
-#ifdef FEAT_AUTOCMD
-    apply_autocmds(EVENT_VIMENTER, NULL, NULL, FALSE, curbuf);
-    TIME_MSG("VimEnter autocommands");
-#endif
-
-#if defined(FEAT_DIFF) && defined(FEAT_SCROLLBIND)
-    /* When a startup script or session file setup for diff'ing and
-     * scrollbind, sync the scrollbind now. */
-    if (curwin->w_p_diff && curwin->w_p_scb)
-    {
-	update_topline();
-	check_scrollbind((linenr_T)0, 0L);
-	TIME_MSG("diff scrollbinding");
-    }
-#endif
-
-#if defined(WIN3264) && !defined(FEAT_GUI_W32)
-    mch_set_winsize_now();	    /* Allow winsize changes from now on */
-#endif
-
-    /* If ":startinsert" command used, stuff a dummy command to be able to
-     * call normal_cmd(), which will then start Insert mode. */
-    if (restart_edit != 0)
-	stuffcharReadbuff(K_IGNORE);
-
-#ifdef FEAT_NETBEANS_INTG
-    if (usingNetbeans)
-	/* Tell the client that it can start sending commands. */
-	netbeans_startup_done();
-#endif
-
-    TIME_MSG("before starting main loop");
-
-    /*
-     * Call the main command loop.  This never returns.
-     */
-    main_loop(FALSE);
-
-    return 0;
-}
-#endif /* PROTO */
-
-/*
- * Main loop: Execute Normal mode commands until exiting Vim.
- * Also used to handle commands in the command-line window, until the window
- * is closed.
- */
-    void
-main_loop(cmdwin)
-    int		cmdwin;	/* TRUE when working in the command-line window */
-{
-    oparg_T	oa;	/* operator arguments */
-
-#if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)
-    /* Setup to catch a terminating error from the X server.  Just ignore
-     * it, restore the state and continue.  This might not always work
-     * properly, but at least we don't exit unexpectedly when the X server
-     * exists while Vim is running in a console. */
-    if (!cmdwin && SETJMP(x_jump_env))
-    {
-	State = NORMAL;
-# ifdef FEAT_VISUAL
-	VIsual_active = FALSE;
-# endif
-	got_int = TRUE;
-	need_wait_return = FALSE;
-	global_busy = FALSE;
-	exmode_active = 0;
-	skip_redraw = FALSE;
-	RedrawingDisabled = 0;
-	no_wait_return = 0;
-# ifdef FEAT_EVAL
-	emsg_skip = 0;
-# endif
-	emsg_off = 0;
-# ifdef FEAT_MOUSE
-	setmouse();
-# endif
-	settmode(TMODE_RAW);
-	starttermcap();
-	scroll_start();
-	redraw_later_clear();
-    }
-#endif
-
-    clear_oparg(&oa);
-    while (!cmdwin
-#ifdef FEAT_CMDWIN
-	    || cmdwin_result == 0
-#endif
-	    )
-    {
-	if (stuff_empty())
-	{
-	    did_check_timestamps = FALSE;
-	    if (need_check_timestamps)
-		check_timestamps(FALSE);
-	    if (need_wait_return)	/* if wait_return still needed ... */
-		wait_return(FALSE);	/* ... call it now */
-	    if (need_start_insertmode && goto_im()
-#ifdef FEAT_VISUAL
-		    && !VIsual_active
-#endif
-		    )
-	    {
-		need_start_insertmode = FALSE;
-		stuffReadbuff((char_u *)"i");	/* start insert mode next */
-		/* skip the fileinfo message now, because it would be shown
-		 * after insert mode finishes! */
-		need_fileinfo = FALSE;
-	    }
-	}
-	if (got_int && !global_busy)
-	{
-	    if (!quit_more)
-		(void)vgetc();		/* flush all buffers */
-	    got_int = FALSE;
-	}
-	if (!exmode_active)
-	    msg_scroll = FALSE;
-	quit_more = FALSE;
-
-	/*
-	 * If skip redraw is set (for ":" in wait_return()), don't redraw now.
-	 * If there is nothing in the stuff_buffer or do_redraw is TRUE,
-	 * update cursor and redraw.
-	 */
-	if (skip_redraw || exmode_active)
-	    skip_redraw = FALSE;
-	else if (do_redraw || stuff_empty())
-	{
-#if defined(FEAT_FOLDING) && defined(FEAT_VISUAL)
-	    /* Include a closed fold completely in the Visual area. */
-	    foldAdjustVisual();
-#endif
-#ifdef FEAT_FOLDING
-	    /*
-	     * When 'foldclose' is set, apply 'foldlevel' to folds that don't
-	     * contain the cursor.
-	     * When 'foldopen' is "all", open the fold(s) under the cursor.
-	     * This may mark the window for redrawing.
-	     */
-	    if (hasAnyFolding(curwin) && !char_avail())
-	    {
-		foldCheckClose();
-		if (fdo_flags & FDO_ALL)
-		    foldOpenCursor();
-	    }
-#endif
-
-	    /*
-	     * Before redrawing, make sure w_topline is correct, and w_leftcol
-	     * if lines don't wrap, and w_skipcol if lines wrap.
-	     */
-	    update_topline();
-	    validate_cursor();
-
-#ifdef FEAT_VISUAL
-	    if (VIsual_active)
-		update_curbuf(INVERTED);/* update inverted part */
-	    else
-#endif
-		if (must_redraw)
-		update_screen(0);
-	    else if (redraw_cmdline || clear_cmdline)
-		showmode();
-#ifdef FEAT_WINDOWS
-	    redraw_statuslines();
-#endif
-#ifdef FEAT_TITLE
-	    if (need_maketitle)
-		maketitle();
-#endif
-	    /* display message after redraw */
-	    if (keep_msg != NULL)
-	    {
-		char_u *p;
-
-		/* msg_attr_keep() will set keep_msg to NULL, must free the
-		 * string here. */
-		p = keep_msg;
-		msg_attr(p, keep_msg_attr);
-		vim_free(p);
-	    }
-	    if (need_fileinfo)		/* show file info after redraw */
-	    {
-		fileinfo(FALSE, TRUE, FALSE);
-		need_fileinfo = FALSE;
-	    }
-
-	    emsg_on_display = FALSE;	/* can delete error message now */
-	    did_emsg = FALSE;
-	    msg_didany = FALSE;		/* reset lines_left in msg_start() */
-	    showruler(FALSE);
-
-	    setcursor();
-	    cursor_on();
-
-	    do_redraw = FALSE;
-	}
-#ifdef FEAT_GUI
-	if (need_mouse_correct)
-	    gui_mouse_correct();
-#endif
-
-	/*
-	 * Update w_curswant if w_set_curswant has been set.
-	 * Postponed until here to avoid computing w_virtcol too often.
-	 */
-	update_curswant();
-
-	/*
-	 * If we're invoked as ex, do a round of ex commands.
-	 * Otherwise, get and execute a normal mode command.
-	 */
-	if (exmode_active)
-	    do_exmode(exmode_active == EXMODE_VIM);
-	else
-	    normal_cmd(&oa, TRUE);
-    }
-}
-
-
-#if defined(USE_XSMP) || defined(FEAT_GUI_MSWIN) || defined(PROTO)
-/*
- * Exit, but leave behind swap files for modified buffers.
- */
-    void
-getout_preserve_modified(exitval)
-    int		exitval;
-{
-# if defined(SIGHUP) && defined(SIG_IGN)
-    /* Ignore SIGHUP, because a dropped connection causes a read error, which
-     * makes Vim exit and then handling SIGHUP causes various reentrance
-     * problems. */
-    signal(SIGHUP, SIG_IGN);
-# endif
-
-    ml_close_notmod();		    /* close all not-modified buffers */
-    ml_sync_all(FALSE, FALSE);	    /* preserve all swap files */
-    ml_close_all(FALSE);	    /* close all memfiles, without deleting */
-    getout(exitval);		    /* exit Vim properly */
-}
-#endif
-
-
-/* Exit properly */
-    void
-getout(exitval)
-    int		exitval;
-{
-#ifdef FEAT_AUTOCMD
-    buf_T	*buf;
-    win_T	*wp;
-#endif
-
-    exiting = TRUE;
-
-    /* Position the cursor on the last screen line, below all the text */
-#ifdef FEAT_GUI
-    if (!gui.in_use)
-#endif
-	windgoto((int)Rows - 1, 0);
-
-#ifdef FEAT_GUI
-    msg_didany = FALSE;
-#endif
-
-#ifdef FEAT_AUTOCMD
-    /* Trigger BufWinLeave for all windows, but only once per buffer. */
-    for (wp = firstwin; wp != NULL; )
-    {
-	buf = wp->w_buffer;
-	if (buf->b_changedtick != -1)
-	{
-	    apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,
-								  FALSE, buf);
-	    buf->b_changedtick = -1;	/* note that we did it already */
-	    wp = firstwin;		/* restart, window may be closed */
-	}
-	else
-	    wp = wp->w_next;
-    }
-    /* Trigger BufUnload for buffers that are loaded */
-    for (buf = firstbuf; buf != NULL; buf = buf->b_next)
-	if (buf->b_ml.ml_mfp != NULL)
-	{
-	    apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,
-								  FALSE, buf);
-	    if (!buf_valid(buf))	/* autocmd may delete the buffer */
-		break;
-	}
-    apply_autocmds(EVENT_VIMLEAVEPRE, NULL, NULL, FALSE, curbuf);
-#endif
-
-#ifdef FEAT_VIMINFO
-    if (*p_viminfo != NUL)
-	/* Write out the registers, history, marks etc, to the viminfo file */
-	write_viminfo(NULL, FALSE);
-#endif
-
-#ifdef FEAT_AUTOCMD
-    apply_autocmds(EVENT_VIMLEAVE, NULL, NULL, FALSE, curbuf);
-#endif
-
-    if (did_emsg
-#ifdef FEAT_GUI
-	    || (gui.in_use && msg_didany && p_verbose > 0)
-#endif
-	    )
-    {
-	/* give the user a chance to read the (error) message */
-	no_wait_return = FALSE;
-	wait_return(FALSE);
-    }
-
-#ifdef FEAT_AUTOCMD
-    /* Position the cursor again, the autocommands may have moved it */
-# ifdef FEAT_GUI
-    if (!gui.in_use)
-# endif
-	windgoto((int)Rows - 1, 0);
-#endif
-
-#ifdef FEAT_TCL
-    tcl_end();
-#endif
-#ifdef FEAT_RUBY
-    ruby_end();
-#endif
-#ifdef FEAT_PYTHON
-    python_end();
-#endif
-#ifdef FEAT_PERL
-    perl_end();
-#endif
-#if defined(USE_ICONV) && defined(DYNAMIC_ICONV)
-    iconv_end();
-#endif
-#ifdef FEAT_NETBEANS_INTG
-    netbeans_end();
-#endif
-
-    mch_exit(exitval);
-}
-
-/*
- * Get a (optional) count for a Vim argument.
- */
-    static int
-get_number_arg(p, idx, def)
-    char_u	*p;	    /* pointer to argument */
-    int		*idx;	    /* index in argument, is incremented */
-    int		def;	    /* default value */
-{
-    if (vim_isdigit(p[*idx]))
-    {
-	def = atoi((char *)&(p[*idx]));
-	while (vim_isdigit(p[*idx]))
-	    *idx = *idx + 1;
-    }
-    return def;
-}
-
-/*
- * Setup to start using the GUI.  Exit with an error when not available.
- */
-    static void
-main_start_gui()
-{
-#ifdef FEAT_GUI
-    gui.starting = TRUE;	/* start GUI a bit later */
-#else
-    mch_errmsg(_(e_nogvim));
-    mch_errmsg("\n");
-    mch_exit(2);
-#endif
-}
-
-/*
- * Get an evironment variable, and execute it as Ex commands.
- * Returns FAIL if the environment variable was not executed, OK otherwise.
- */
-    int
-process_env(env, is_viminit)
-    char_u	*env;
-    int		is_viminit; /* when TRUE, called for VIMINIT */
-{
-    char_u	*initstr;
-    char_u	*save_sourcing_name;
-    linenr_T	save_sourcing_lnum;
-#ifdef FEAT_EVAL
-    scid_T	save_sid;
-#endif
-
-    if ((initstr = mch_getenv(env)) != NULL && *initstr != NUL)
-    {
-	if (is_viminit)
-	    vimrc_found();
-	save_sourcing_name = sourcing_name;
-	save_sourcing_lnum = sourcing_lnum;
-	sourcing_name = env;
-	sourcing_lnum = 0;
-#ifdef FEAT_EVAL
-	save_sid = current_SID;
-	current_SID = SID_ENV;
-#endif
-	do_cmdline_cmd(initstr);
-	sourcing_name = save_sourcing_name;
-	sourcing_lnum = save_sourcing_lnum;
-#ifdef FEAT_EVAL
-	current_SID = save_sid;;
-#endif
-	return OK;
-    }
-    return FAIL;
-}
-
-#if defined(UNIX) || defined(VMS)
-/*
- * Return TRUE if we are certain the user owns the file "fname".
- * Used for ".vimrc" and ".exrc".
- * Use both stat() and lstat() for extra security.
- */
-    static int
-file_owned(fname)
-    char	*fname;
-{
-    struct stat s;
-# ifdef UNIX
-    uid_t	uid = getuid();
-# else	 /* VMS */
-    uid_t	uid = ((getgid() << 16) | getuid());
-# endif
-
-    return !(mch_stat(fname, &s) != 0 || s.st_uid != uid
-# ifdef HAVE_LSTAT
-	    || mch_lstat(fname, &s) != 0 || s.st_uid != uid
-# endif
-	    );
-}
-#endif
-
-/*
- * Give an error message main_errors["n"] and exit.
- */
-    static void
-mainerr(n, str)
-    int		n;	/* one of the ME_ defines */
-    char_u	*str;	/* extra argument or NULL */
-{
-#if defined(UNIX) || defined(__EMX__) || defined(VMS)
-    reset_signals();		/* kill us with CTRL-C here, if you like */
-#endif
-
-    mch_errmsg(longVersion);
-    mch_errmsg("\n");
-    mch_errmsg(_(main_errors[n]));
-    if (str != NULL)
-    {
-	mch_errmsg(": \"");
-	mch_errmsg((char *)str);
-	mch_errmsg("\"");
-    }
-    mch_errmsg(_("\nMore info with: \"vim -h\"\n"));
-
-    mch_exit(1);
-}
-
-    void
-mainerr_arg_missing(str)
-    char_u	*str;
-{
-    mainerr(ME_ARG_MISSING, str);
-}
-
-/*
- * print a message with three spaces prepended and '\n' appended.
- */
-    static void
-main_msg(s)
-    char *s;
-{
-    mch_msg("   ");
-    mch_msg(s);
-    mch_msg("\n");
-}
-
-/*
- * Print messages for "vim -h" or "vim --help" and exit.
- */
-    static void
-usage()
-{
-    int		i;
-    static char	*(use[]) =
-    {
-	N_("[file ..]       edit specified file(s)"),
-	N_("-               read text from stdin"),
-	N_("-t tag          edit file where tag is defined"),
-#ifdef FEAT_QUICKFIX
-	N_("-q [errorfile]  edit file with first error")
-#endif
-    };
-
-#if defined(UNIX) || defined(__EMX__) || defined(VMS)
-    reset_signals();		/* kill us with CTRL-C here, if you like */
-#endif
-
-    mch_msg(longVersion);
-    mch_msg(_("\n\nusage:"));
-    for (i = 0; ; ++i)
-    {
-	mch_msg(_(" vim [arguments] "));
-	mch_msg(_(use[i]));
-	if (i == (sizeof(use) / sizeof(char_u *)) - 1)
-	    break;
-	mch_msg(_("\n   or:"));
-    }
-
-    mch_msg(_("\n\nArguments:\n"));
-    main_msg(_("--\t\t\tOnly file names after this"));
-#if (!defined(UNIX) && !defined(__EMX__)) || defined(ARCHIE)
-    main_msg(_("--literal\t\tDon't expand wildcards"));
-#endif
-#ifdef FEAT_OLE
-    main_msg(_("-register\t\tRegister this gvim for OLE"));
-    main_msg(_("-unregister\t\tUnregister gvim for OLE"));
-#endif
-#ifdef FEAT_GUI
-    main_msg(_("-g\t\t\tRun using GUI (like \"gvim\")"));
-    main_msg(_("-f  or  --nofork\tForeground: Don't fork when starting GUI"));
-#endif
-    main_msg(_("-v\t\t\tVi mode (like \"vi\")"));
-    main_msg(_("-e\t\t\tEx mode (like \"ex\")"));
-    main_msg(_("-s\t\t\tSilent (batch) mode (only for \"ex\")"));
-#ifdef FEAT_DIFF
-    main_msg(_("-d\t\t\tDiff mode (like \"vimdiff\")"));
-#endif
-    main_msg(_("-y\t\t\tEasy mode (like \"evim\", modeless)"));
-    main_msg(_("-R\t\t\tReadonly mode (like \"view\")"));
-    main_msg(_("-Z\t\t\tRestricted mode (like \"rvim\")"));
-    main_msg(_("-m\t\t\tModifications (writing files) not allowed"));
-    main_msg(_("-M\t\t\tModifications in text not allowed"));
-    main_msg(_("-b\t\t\tBinary mode"));
-#ifdef FEAT_LISP
-    main_msg(_("-l\t\t\tLisp mode"));
-#endif
-    main_msg(_("-C\t\t\tCompatible with Vi: 'compatible'"));
-    main_msg(_("-N\t\t\tNot fully Vi compatible: 'nocompatible'"));
-    main_msg(_("-V[N]\t\tVerbose level"));
-    main_msg(_("-D\t\t\tDebugging mode"));
-    main_msg(_("-n\t\t\tNo swap file, use memory only"));
-    main_msg(_("-r\t\t\tList swap files and exit"));
-    main_msg(_("-r (with file name)\tRecover crashed session"));
-    main_msg(_("-L\t\t\tSame as -r"));
-#ifdef AMIGA
-    main_msg(_("-f\t\t\tDon't use newcli to open window"));
-    main_msg(_("-dev <device>\t\tUse <device> for I/O"));
-#endif
-#ifdef FEAT_ARABIC
-    main_msg(_("-A\t\t\tstart in Arabic mode"));
-#endif
-#ifdef FEAT_RIGHTLEFT
-    main_msg(_("-H\t\t\tStart in Hebrew mode"));
-#endif
-#ifdef FEAT_FKMAP
-    main_msg(_("-F\t\t\tStart in Farsi mode"));
-#endif
-    main_msg(_("-T <terminal>\tSet terminal type to <terminal>"));
-    main_msg(_("-u <vimrc>\t\tUse <vimrc> instead of any .vimrc"));
-#ifdef FEAT_GUI
-    main_msg(_("-U <gvimrc>\t\tUse <gvimrc> instead of any .gvimrc"));
-#endif
-    main_msg(_("--noplugin\t\tDon't load plugin scripts"));
-    main_msg(_("-o[N]\t\tOpen N windows (default: one for each file)"));
-    main_msg(_("-O[N]\t\tLike -o but split vertically"));
-    main_msg(_("+\t\t\tStart at end of file"));
-    main_msg(_("+<lnum>\t\tStart at line <lnum>"));
-#ifdef FEAT_PRECOMMANDS
-    main_msg(_("--cmd <command>\tExecute <command> before loading any vimrc file"));
-#endif
-    main_msg(_("-c <command>\t\tExecute <command> after loading the first file"));
-    main_msg(_("-S <session>\t\tSource file <session> after loading the first file"));
-    main_msg(_("-s <scriptin>\tRead Normal mode commands from file <scriptin>"));
-    main_msg(_("-w <scriptout>\tAppend all typed commands to file <scriptout>"));
-    main_msg(_("-W <scriptout>\tWrite all typed commands to file <scriptout>"));
-#ifdef FEAT_CRYPT
-    main_msg(_("-x\t\t\tEdit encrypted files"));
-#endif
-#if (defined(UNIX) || defined(VMS)) && defined(FEAT_X11)
-# if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)
-    main_msg(_("-display <display>\tConnect vim to this particular X-server"));
-# endif
-    main_msg(_("-X\t\t\tDo not connect to X server"));
-#endif
-#ifdef FEAT_CLIENTSERVER
-    main_msg(_("--remote <files>\tEdit <files> in a Vim server if possible"));
-    main_msg(_("--remote-silent <files>  Same, don't complain if there is no server"));
-    main_msg(_("--remote-wait <files>  As --remote but wait for files to have been edited"));
-    main_msg(_("--remote-wait-silent <files>  Same, don't complain if there is no server"));
-    main_msg(_("--remote-send <keys>\tSend <keys> to a Vim server and exit"));
-    main_msg(_("--remote-expr <expr>\tEvaluate <expr> in a Vim server and print result"));
-    main_msg(_("--serverlist\t\tList available Vim server names and exit"));
-    main_msg(_("--servername <name>\tSend to/become the Vim server <name>"));
-#endif
-#ifdef FEAT_VIMINFO
-    main_msg(_("-i <viminfo>\t\tUse <viminfo> instead of .viminfo"));
-#endif
-    main_msg(_("-h  or  --help\tPrint Help (this message) and exit"));
-    main_msg(_("--version\t\tPrint version information and exit"));
-
-#ifdef FEAT_GUI_X11
-# ifdef FEAT_GUI_MOTIF
-    mch_msg(_("\nArguments recognised by gvim (Motif version):\n"));
-# else
-#  ifdef FEAT_GUI_ATHENA
-#   ifdef FEAT_GUI_NEXTAW
-    mch_msg(_("\nArguments recognised by gvim (neXtaw version):\n"));
-#   else
-    mch_msg(_("\nArguments recognised by gvim (Athena version):\n"));
-#   endif
-#  endif
-# endif
-    main_msg(_("-display <display>\tRun vim on <display>"));
-    main_msg(_("-iconic\t\tStart vim iconified"));
-# if 0
-    main_msg(_("-name <name>\t\tUse resource as if vim was <name>"));
-    mch_msg(_("\t\t\t  (Unimplemented)\n"));
-# endif
-    main_msg(_("-background <color>\tUse <color> for the background (also: -bg)"));
-    main_msg(_("-foreground <color>\tUse <color> for normal text (also: -fg)"));
-    main_msg(_("-font <font>\t\tUse <font> for normal text (also: -fn)"));
-    main_msg(_("-boldfont <font>\tUse <font> for bold text"));
-    main_msg(_("-italicfont <font>\tUse <font> for italic text"));
-    main_msg(_("-geometry <geom>\tUse <geom> for initial geometry (also: -geom)"));
-    main_msg(_("-borderwidth <width>\tUse a border width of <width> (also: -bw)"));
-    main_msg(_("-scrollbarwidth <width>  Use a scrollbar width of <width> (also: -sw)"));
-# ifdef FEAT_GUI_ATHENA
-    main_msg(_("-menuheight <height>\tUse a menu bar height of <height> (also: -mh)"));
-# endif
-    main_msg(_("-reverse\t\tUse reverse video (also: -rv)"));
-    main_msg(_("+reverse\t\tDon't use reverse video (also: +rv)"));
-    main_msg(_("-xrm <resource>\tSet the specified resource"));
-#endif /* FEAT_GUI_X11 */
-#if defined(FEAT_GUI) && defined(RISCOS)
-    mch_msg(_("\nArguments recognised by gvim (RISC OS version):\n"));
-    main_msg(_("--columns <number>\tInitial width of window in columns"));
-    main_msg(_("--rows <number>\tInitial height of window in rows"));
-#endif
-#ifdef FEAT_GUI_GTK
-    mch_msg(_("\nArguments recognised by gvim (GTK+ version):\n"));
-    main_msg(_("-font <font>\t\tUse <font> for normal text (also: -fn)"));
-    main_msg(_("-geometry <geom>\tUse <geom> for initial geometry (also: -geom)"));
-    main_msg(_("-reverse\t\tUse reverse video (also: -rv)"));
-    main_msg(_("-display <display>\tRun vim on <display> (also: --display)"));
-# ifdef HAVE_GTK2
-    main_msg(_("--role <role>\tSet a unique role to identify the main window"));
-# endif
-    main_msg(_("--socketid <xid>\tOpen Vim inside another GTK widget"));
-#endif
-#ifdef FEAT_GUI_W32
-    main_msg(_("-P <parent title>\tOpen Vim inside parent application"));
-#endif
-
-#ifdef FEAT_GUI_GNOME
-    /* Gnome gives extra messages for --help if we continue, but not for -h. */
-    if (gui.starting)
-	mch_msg("\n");
-    else
-#endif
-	mch_exit(0);
-}
-
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-/*
- * Check the result of the ATTENTION dialog:
- * When "Quit" selected, exit Vim.
- * When "Recover" selected, recover the file.
- */
-    static void
-check_swap_exists_action()
-{
-    if (swap_exists_action == SEA_QUIT)
-	getout(1);
-    handle_swap_exists(NULL);
-}
-#endif
-
-#if defined(STARTUPTIME) || defined(PROTO)
-static void time_diff __ARGS((struct timeval *then, struct timeval *now));
-
-static struct timeval	prev_timeval;
-
-/*
- * Save the previous time before doing something that could nest.
- * set "*tv_rel" to the time elapsed so far.
- */
-    void
-time_push(tv_rel, tv_start)
-    void	*tv_rel, *tv_start;
-{
-    *((struct timeval *)tv_rel) = prev_timeval;
-    gettimeofday(&prev_timeval, NULL);
-    ((struct timeval *)tv_rel)->tv_usec = prev_timeval.tv_usec
-					- ((struct timeval *)tv_rel)->tv_usec;
-    ((struct timeval *)tv_rel)->tv_sec = prev_timeval.tv_sec
-					 - ((struct timeval *)tv_rel)->tv_sec;
-    if (((struct timeval *)tv_rel)->tv_usec < 0)
-    {
-	((struct timeval *)tv_rel)->tv_usec += 1000000;
-	--((struct timeval *)tv_rel)->tv_sec;
-    }
-    *(struct timeval *)tv_start = prev_timeval;
-}
-
-/*
- * Compute the previous time after doing something that could nest.
- * Subtract "*tp" from prev_timeval;
- * Note: The arguments are (void *) to avoid trouble with systems that don't
- * have struct timeval.
- */
-    void
-time_pop(tp)
-    void	*tp;	/* actually (struct timeval *) */
-{
-    prev_timeval.tv_usec -= ((struct timeval *)tp)->tv_usec;
-    prev_timeval.tv_sec -= ((struct timeval *)tp)->tv_sec;
-    if (prev_timeval.tv_usec < 0)
-    {
-	prev_timeval.tv_usec += 1000000;
-	--prev_timeval.tv_sec;
-    }
-}
-
-    static void
-time_diff(then, now)
-    struct timeval	*then;
-    struct timeval	*now;
-{
-    long	usec;
-    long	msec;
-
-    usec = now->tv_usec - then->tv_usec;
-    msec = (now->tv_sec - then->tv_sec) * 1000L + usec / 1000L,
-    usec = usec % 1000L;
-    fprintf(time_fd, "%03ld.%03ld", msec, usec >= 0 ? usec : usec + 1000L);
-}
-
-    void
-time_msg(msg, tv_start)
-    char	*msg;
-    void	*tv_start;  /* only for do_source: start time; actually
-			       (struct timeval *) */
-{
-    static struct timeval	start;
-    struct timeval		now;
-
-    if (time_fd != NULL)
-    {
-	if (strstr(msg, "STARTING") != NULL)
-	{
-	    gettimeofday(&start, NULL);
-	    prev_timeval = start;
-	    fprintf(time_fd, "\n\ntimes in msec\n");
-	    fprintf(time_fd, " clock   self+sourced   self:  sourced script\n");
-	    fprintf(time_fd, " clock   elapsed:              other lines\n\n");
-	}
-	gettimeofday(&now, NULL);
-	time_diff(&start, &now);
-	if (((struct timeval *)tv_start) != NULL)
-	{
-	    fprintf(time_fd, "  ");
-	    time_diff(((struct timeval *)tv_start), &now);
-	}
-	fprintf(time_fd, "  ");
-	time_diff(&prev_timeval, &now);
-	prev_timeval = now;
-	fprintf(time_fd, ": %s\n", msg);
-    }
-}
-
-# ifdef WIN3264
-/*
- * Windows doesn't have gettimeofday(), although it does have struct timeval.
- */
-    int
-gettimeofday(struct timeval *tv, char *dummy)
-{
-    long t = clock();
-    tv->tv_sec = t / CLOCKS_PER_SEC;
-    tv->tv_usec = (t - tv->tv_sec * CLOCKS_PER_SEC) * 1000000 / CLOCKS_PER_SEC;
-    return 0;
-}
-# endif
-
-#endif
-
-#if defined(FEAT_CLIENTSERVER) || defined(PROTO)
-
-/*
- * Common code for the X command server and the Win32 command server.
- */
-
-static char_u *build_drop_cmd __ARGS((int filec, char **filev, int sendReply));
-
-    static void
-cmdsrv_main(argc, argv, serverName_arg, serverStr)
-    int		*argc;
-    char	**argv;
-    char_u	*serverName_arg;
-    char_u	**serverStr;
-{
-    char_u	*res;
-    int		i;
-    char_u	*sname;
-    int		ret;
-    int		didone = FALSE;
-    int		exiterr = 0;
-    char	**newArgV = argv + 1;
-    int		newArgC = 1,
-		Argc = *argc;
-    int		argtype;
-#define ARGTYPE_OTHER		0
-#define ARGTYPE_EDIT		1
-#define ARGTYPE_EDIT_WAIT	2
-#define ARGTYPE_SEND		3
-    int		silent = FALSE;
-# ifndef FEAT_X11
-    HWND	srv;
-# else
-    Window	srv;
-
-    setup_term_clip();
-# endif
-
-    sname = serverMakeName(serverName_arg, argv[0]);
-    if (sname == NULL)
-	return;
-
-    /*
-     * Execute the command server related arguments and remove them
-     * from the argc/argv array; We may have to return into main()
-     */
-    for (i = 1; i < Argc; i++)
-    {
-	res = NULL;
-	if (STRCMP(argv[i], "--") == 0)	/* end of options */
-	{
-	    for (; i < *argc; i++)
-	    {
-		*newArgV++ = argv[i];
-		newArgC++;
-	    }
-	    break;
-	}
-
-	if (STRICMP(argv[i], "--remote") == 0)
-	    argtype = ARGTYPE_EDIT;
-	else if (STRICMP(argv[i], "--remote-silent") == 0)
-	{
-	    argtype = ARGTYPE_EDIT;
-	    silent = TRUE;
-	}
-	else if (STRICMP(argv[i], "--remote-wait") == 0)
-	    argtype = ARGTYPE_EDIT_WAIT;
-	else if (STRICMP(argv[i], "--remote-wait-silent") == 0)
-	{
-	    argtype = ARGTYPE_EDIT_WAIT;
-	    silent = TRUE;
-	}
-	else if (STRICMP(argv[i], "--remote-send") == 0)
-	    argtype = ARGTYPE_SEND;
-	else
-	    argtype = ARGTYPE_OTHER;
-	if (argtype != ARGTYPE_OTHER)
-	{
-	    if (i == *argc - 1)
-		mainerr_arg_missing((char_u *)argv[i]);
-	    if (argtype == ARGTYPE_SEND)
-	    {
-		*serverStr = (char_u *)argv[i + 1];
-		i++;
-	    }
-	    else
-	    {
-		*serverStr = build_drop_cmd(*argc - i - 1, argv + i + 1,
-						argtype == ARGTYPE_EDIT_WAIT);
-		if (*serverStr == NULL)
-		{
-		    /* Probably out of memory, exit. */
-		    didone = TRUE;
-		    exiterr = 1;
-		    break;
-		}
-		Argc = i;
-	    }
-# ifdef FEAT_X11
-	    if (xterm_dpy == NULL)
-	    {
-		mch_errmsg(_("No display"));
-		ret = -1;
-	    }
-	    else
-		ret = serverSendToVim(xterm_dpy, sname, *serverStr,
-						    NULL, &srv, 0, 0, silent);
-# else
-	    /* Win32 always works? */
-	    ret = serverSendToVim(sname, *serverStr, NULL, &srv, 0, silent);
-# endif
-	    if (ret < 0)
-	    {
-		if (argtype == ARGTYPE_SEND)
-		{
-		    /* Failed to send, abort. */
-		    mch_errmsg(_(": Send failed.\n"));
-		    didone = TRUE;
-		    exiterr = 1;
-		}
-		else if (!silent)
-		    /* Let vim start normally.  */
-		    mch_errmsg(_(": Send failed. Trying to execute locally\n"));
-		break;
-	    }
-
-# ifdef FEAT_GUI_W32
-	    /* Guess that when the server name starts with "g" it's a GUI
-	     * server, which we can bring to the foreground here.
-	     * Foreground() in the server doesn't work very well. */
-	    if (argtype != ARGTYPE_SEND && TOUPPER_ASC(*sname) == 'G')
-		SetForegroundWindow(srv);
-# endif
-
-	    /*
-	     * For --remote-wait: Wait until the server did edit each
-	     * file.  Also detect that the server no longer runs.
-	     */
-	    if (ret >= 0 && argtype == ARGTYPE_EDIT_WAIT)
-	    {
-		int	numFiles = *argc - i - 1;
-		int	j;
-		char_u  *done = alloc(numFiles);
-		char_u  *p;
-# ifdef FEAT_GUI_W32
-		NOTIFYICONDATA ni;
-		int	count = 0;
-		extern HWND message_window;
-# endif
-
-		if (numFiles > 0 && argv[i + 1][0] == '+')
-		    /* Skip "+cmd" argument, don't wait for it to be edited. */
-		    --numFiles;
-
-# ifdef FEAT_GUI_W32
-		ni.cbSize = sizeof(ni);
-		ni.hWnd = message_window;
-		ni.uID = 0;
-		ni.uFlags = NIF_ICON|NIF_TIP;
-		ni.hIcon = LoadIcon((HINSTANCE)GetModuleHandle(0), "IDR_VIM");
-		sprintf(ni.szTip, _("%d of %d edited"), count, numFiles);
-		Shell_NotifyIcon(NIM_ADD, &ni);
-# endif
-
-		/* Wait for all files to unload in remote */
-		memset(done, 0, numFiles);
-		while (memchr(done, 0, numFiles) != NULL)
-		{
-# ifdef WIN32
-		    p = serverGetReply(srv, NULL, TRUE, TRUE);
-		    if (p == NULL)
-			break;
-# else
-		    if (serverReadReply(xterm_dpy, srv, &p, TRUE) < 0)
-			break;
-# endif
-		    j = atoi((char *)p);
-		    if (j >= 0 && j < numFiles)
-		    {
-# ifdef FEAT_GUI_W32
-			++count;
-			sprintf(ni.szTip, _("%d of %d edited"),
-							     count, numFiles);
-			Shell_NotifyIcon(NIM_MODIFY, &ni);
-# endif
-			done[j] = 1;
-		    }
-		}
-# ifdef FEAT_GUI_W32
-		Shell_NotifyIcon(NIM_DELETE, &ni);
-# endif
-	    }
-	}
-	else if (STRICMP(argv[i], "--remote-expr") == 0)
-	{
-	    if (i == *argc - 1)
-		mainerr_arg_missing((char_u *)argv[i]);
-# ifdef WIN32
-	    /* Win32 always works? */
-	    if (serverSendToVim(sname, (char_u *)argv[i + 1],
-						    &res, NULL, 1, FALSE) < 0)
-# else
-	    if (xterm_dpy == NULL)
-		mch_errmsg(_("No display: Send expression failed.\n"));
-	    else if (serverSendToVim(xterm_dpy, sname, (char_u *)argv[i + 1],
-						 &res, NULL, 1, 1, FALSE) < 0)
-# endif
-	    {
-		if (res != NULL && *res != NUL)
-		{
-		    /* Output error from remote */
-		    mch_errmsg((char *)res);
-		    vim_free(res);
-		    res = NULL;
-		}
-		mch_errmsg(_(": Send expression failed.\n"));
-	    }
-	}
-	else if (STRICMP(argv[i], "--serverlist") == 0)
-	{
-# ifdef WIN32
-	    /* Win32 always works? */
-	    res = serverGetVimNames();
-# else
-	    if (xterm_dpy != NULL)
-		res = serverGetVimNames(xterm_dpy);
-# endif
-	    if (called_emsg)
-		mch_errmsg("\n");
-	}
-	else if (STRICMP(argv[i], "--servername") == 0)
-	{
-	    /* Alredy processed. Take it out of the command line */
-	    i++;
-	    continue;
-	}
-	else
-	{
-	    *newArgV++ = argv[i];
-	    newArgC++;
-	    continue;
-	}
-	didone = TRUE;
-	if (res != NULL && *res != NUL)
-	{
-	    mch_msg((char *)res);
-	    if (res[STRLEN(res) - 1] != '\n')
-		mch_msg("\n");
-	}
-	vim_free(res);
-    }
-
-    if (didone)
-    {
-	display_errors();	/* display any collected messages */
-	exit(exiterr);	/* Mission accomplished - get out */
-    }
-
-    /* Return back into main() */
-    *argc = newArgC;
-    vim_free(sname);
-}
-
-/*
- * Build a ":drop" command to send to a Vim server.
- */
-    static char_u *
-build_drop_cmd(filec, filev, sendReply)
-    int		filec;
-    char	**filev;
-    int		sendReply;
-{
-    garray_T	ga;
-    int		i;
-    char_u	*inicmd = NULL;
-    char_u	*p;
-    char_u	cwd[MAXPATHL];
-
-    if (filec > 0 && filev[0][0] == '+')
-    {
-	inicmd = (char_u *)filev[0] + 1;
-	filev++;
-	filec--;
-    }
-    /* Check if we have at least one argument. */
-    if (filec <= 0)
-	mainerr_arg_missing((char_u *)filev[-1]);
-    if (mch_dirname(cwd, MAXPATHL) != OK)
-	return NULL;
-    if ((p = vim_strsave_escaped_ext(cwd, PATH_ESC_CHARS, TRUE)) == NULL)
-	return NULL;
-    ga_init2(&ga, 1, 100);
-    ga_concat(&ga, (char_u *)"<C-\\><C-N>:cd ");
-    ga_concat(&ga, p);
-    /* Call inputsave() so that a prompt for an encryption key works. */
-    ga_concat(&ga, (char_u *)"<CR>:if exists('*inputsave')|call inputsave()|endif|drop");
-    vim_free(p);
-    for (i = 0; i < filec; i++)
-    {
-	/* On Unix the shell has already expanded the wildcards, don't want to
-	 * do it again in the Vim server.  On MS-Windows only need to escape a
-	 * space. */
-	p = vim_strsave_escaped((char_u *)filev[i],
-#ifdef UNIX
-		PATH_ESC_CHARS
-#else
-		(char_u *)" "
-#endif
-		);
-	if (p == NULL)
-	{
-	    vim_free(ga.ga_data);
-	    return NULL;
-	}
-	ga_concat(&ga, (char_u *)" ");
-	ga_concat(&ga, p);
-	vim_free(p);
-    }
-    /* The :drop commands goes to Insert mode when 'insertmode' is set, use
-     * CTRL-\ CTRL-N again. */
-    ga_concat(&ga, (char_u *)"|if exists('*inputrestore')|call inputrestore()|endif<CR>");
-    ga_concat(&ga, (char_u *)"<C-\\><C-N>:cd -");
-    if (sendReply)
-	ga_concat(&ga, (char_u *)"<CR>:call SetupRemoteReplies()");
-    ga_concat(&ga, (char_u *)"<CR>:");
-    if (inicmd != NULL)
-    {
-	/* Can't use <CR> after "inicmd", because an "startinsert" would cause
-	 * the following commands to be inserted as text.  Use a "|",
-	 * hopefully "inicmd" does allow this... */
-	ga_concat(&ga, inicmd);
-	ga_concat(&ga, (char_u *)"|");
-    }
-    /* Bring the window to the foreground, goto Insert mode when 'im' set and
-     * clear command line. */
-    ga_concat(&ga, (char_u *)"cal foreground()|if &im|star|en|ec<CR>");
-    ga_append(&ga, NUL);
-    return ga.ga_data;
-}
-
-/*
- * Replace termcodes such as <CR> and insert as key presses if there is room.
- */
-    void
-server_to_input_buf(str)
-    char_u	*str;
-{
-    char_u      *ptr = NULL;
-    char_u      *cpo_save = p_cpo;
-
-    /* Set 'cpoptions' the way we want it.
-     *    B set - backslashes are *not* treated specially
-     *    k set - keycodes are *not* reverse-engineered
-     *    < unset - <Key> sequences *are* interpreted
-     *  The last parameter of replace_termcodes() is TRUE so that the <lt>
-     *  sequence is recognised - needed for a real backslash.
-     */
-    p_cpo = (char_u *)"Bk";
-    str = replace_termcodes((char_u *)str, &ptr, FALSE, TRUE);
-    p_cpo = cpo_save;
-
-    if (*ptr != NUL)	/* trailing CTRL-V results in nothing */
-    {
-	/*
-	 * Add the string to the input stream.
-	 * Can't use add_to_input_buf() here, we now have K_SPECIAL bytes.
-	 *
-	 * First clear typed characters from the typeahead buffer, there could
-	 * be half a mapping there.  Then append to the existing string, so
-	 * that multiple commands from a client are concatenated.
-	 */
-	if (typebuf.tb_maplen < typebuf.tb_len)
-	    del_typebuf(typebuf.tb_len - typebuf.tb_maplen, typebuf.tb_maplen);
-	(void)ins_typebuf(str, REMAP_NONE, typebuf.tb_len, TRUE, FALSE);
-
-	/* Let input_available() know we inserted text in the typeahead
-	 * buffer. */
-	received_from_client = TRUE;
-    }
-    vim_free((char_u *)ptr);
-}
-
-/*
- * Evaluate an expression that the client sent to a string.
- * Handles disabling error messages and disables debugging, otherwise Vim
- * hangs, waiting for "cont" to be typed.
- */
-    char_u *
-eval_client_expr_to_string(expr)
-    char_u *expr;
-{
-    char_u	*res;
-    int		save_dbl = debug_break_level;
-    int		save_ro = redir_off;
-
-    debug_break_level = -1;
-    redir_off = 0;
-    ++emsg_skip;
-
-    res = eval_to_string(expr, NULL);
-
-    debug_break_level = save_dbl;
-    redir_off = save_ro;
-    --emsg_skip;
-
-    return res;
-}
-
-
-/*
- * Make our basic server name: use the specified "arg" if given, otherwise use
- * the tail of the command "cmd" we were started with.
- * Return the name in allocated memory.  This doesn't include a serial number.
- */
-    static char_u *
-serverMakeName(arg, cmd)
-    char_u	*arg;
-    char	*cmd;
-{
-    char_u *p;
-
-    if (arg != NULL && *arg != NUL)
-	p = vim_strsave_up(arg);
-    else
-    {
-	p = vim_strsave_up(gettail((char_u *)cmd));
-	/* Remove .exe or .bat from the name. */
-	if (p != NULL && vim_strchr(p, '.') != NULL)
-	    *vim_strchr(p, '.') = NUL;
-    }
-    return p;
-}
-#endif /* FEAT_CLIENTSERVER */
-
-/*
- * When FEAT_FKMAP is defined, also compile the Farsi source code.
- */
-#if defined(FEAT_FKMAP) || defined(PROTO)
-# include "farsi.c"
-#endif
-
-/*
- * When FEAT_ARABIC is defined, also compile the Arabic source code.
- */
-#if defined(FEAT_ARABIC) || defined(PROTO)
-# include "arabic.c"
-#endif
diff -Nur vim63/src/Make_container.mak vim63-bonobo/src/Make_container.mak
--- vim63/src/Make_container.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/Make_container.mak	2005-09-09 20:14:02.692590928 +0200
@@ -0,0 +1,11 @@
+gnomeccFlags = `pkg-config --cflags libgnomeui-2.0 libgnome-2.0`
+ccFlags = -g -c ${gnomeccFlags}
+ldFlags = `pkg-config --libs libgnomeui-2.0 libgnome-2.0`
+
+all: container
+
+container: container.o
+	gcc -o container ${ldFlags} container.o
+
+%.o: %.c
+	gcc ${ccFlags} $< -o $@
diff -Nur vim63/src/Makefile vim63-bonobo/src/Makefile
--- vim63/src/Makefile	2005-09-09 20:11:10.529763000 +0200
+++ vim63-bonobo/src/Makefile	2005-09-09 20:14:02.695590472 +0200
@@ -1103,6 +1103,18 @@
 GTK_MAN_TARGETS = installghelplinks
 GTK_TESTTARGET = gui
 
+### Bonobo GUI
+BONOBO_SRC	= $(GTK_SRC)
+BONOBO_OBJ	= $(GTK_OBJ)
+BONOBO_DEFS	= $(GTK_DEFS) 
+BONOBO_IPATH	= $(GTK_IPATH)
+BONOBO_LIBS_DIR	=  $(GTK_LIBS_DIR)
+BONOBO_LIBS1	= $(GTK_LIBS1)
+BONOBO_LIBS2	=  $(GTK_LIBS2)
+BONOBO_TARGETS	=  $(GTK_TARGETS) vim-factory
+BONOBO_MAN_TARGETS =  $(GTK_MAN_TARGETS)
+BONOBO_TESTTARGET =  $(GTK_TESTTARGET)
+
 ### Motif GUI
 MOTIF_SRC	= gui.c gui_motif.c gui_x11.c pty.c gui_beval.c
 MOTIF_OBJ	= objects/gui.o objects/gui_motif.o objects/gui_x11.o \
@@ -1385,6 +1397,10 @@
 	objects/fileio.o \
 	objects/fold.o \
 	objects/getchar.o \
+        objects/gtkhtml_editor.o \
+        objects/gtkhtml_editor_common.o \
+        objects/gtkhtml_editor_skels.o \
+        objects/gtkhtml_editor_stubs.o \
 	$(HANGULIN_OBJ) \
 	objects/if_cscope.o \
 	objects/if_xcmdsrv.o \
@@ -1413,6 +1429,9 @@
 	objects/term.o \
 	objects/ui.o \
 	objects/undo.o \
+ 	objects/vim_bonobo_main.o \
+ 	objects/vim_bonobo_factory.o \
+ 	objects/vim_bonobo_control.o \
 	objects/window.o \
 	$(GUI_OBJ) \
 	$(PERL_OBJ) \
@@ -1422,7 +1441,7 @@
 	$(OS_EXTRA_OBJ) \
 	$(WORKSHOP_OBJ) \
 	$(NETBEANS_OBJ) \
-	$(WSDEBUG_OBJ)
+ 	$(WSDEBUG_OBJ)
 
 PRO_AUTO = \
 	buffer.pro \
@@ -1480,7 +1499,7 @@
 	os_mswin.pro os_beos.pro os_vms.pro os_riscos.pro $(PERL_PRO)
 
 # Default target is making the executable and tools
-all: $(VIMTARGET) $(TOOLS) languages
+all: $(VIMTARGET) $(TOOLS) $(EXTRA_TARGETS) languages
 
 tools: $(TOOLS)
 
@@ -1658,6 +1677,10 @@
 testclean:
 	cd testdir; $(MAKE) -f Makefile clean
 
+vim-factory: objects/vim_proxy_factory.o
+	gcc -o vim-factory $(ALL_LIB_DIRS) $(LDFLAGS) objects/vim_proxy_factory.o $(ALL_LIBS)
+
+
 #
 # Avoid overwriting an existing executable, somebody might be running it and
 # overwriting it could cause it to crash.  Deleting it is OK, it won't be
@@ -1684,6 +1707,23 @@
 # may create a link to the new executable from /usr/bin/vi
 	-$(LINKIT)
 
+Vim_Control.server: Vim_Control.server.in auto/config.mk
+	rm -f Vim_Control.server Vim_Control.server.tmp
+	sed -e 's,@DEST_BIN\@,$(DEST_BIN),g' \
+	    -e 's,@VIMNAME\@,$(VIMNAME),g' \
+		Vim_Control.server.in >Vim_Control.server.tmp
+	mv Vim_Control.server.tmp Vim_Control.server
+
+installbonobo: installvimbin
+# 	install factory to destbin
+	$(INSTALL_PROG) vim-factory $(DEST_BIN)
+	$(STRIP) $(DEST_BIN)/vim-factory
+	
+# 	install server file to /usr/lib/bonobo/servers (modulo prefix)
+	-$(SHELL) ./mkinstalldirs $(DESTDIR)$(prefix)/lib/bonobo/servers
+	$(INSTALL_PROG) Vim_Control.server $(DESTDIR)$(prefix)/lib/bonobo/servers
+
+
 # install the help files; first adjust the contents for the location
 installruntime: $(HELPSOURCE)/vim.1 $(DEST_MAN) $(DEST_VIM) $(DEST_RT) \
 		$(DEST_HELP) $(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND) \
@@ -2078,6 +2118,7 @@
 	if test -d $(PODIR); then \
 		cd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) clean; \
 	fi
+	-rm -f Vim_Control.server vim-factory vim-component
 
 # Make a shadow directory for compilation on another system or with different
 # features.
@@ -2285,6 +2326,18 @@
 objects/gui_mac.o: gui_mac.c
 	$(CCC) -o $@ gui_mac.c
 
+objects/gtkhtml_editor.o: gtkhtml_editor.c
+	$(CCC) -o $@ gtkhtml_editor.c
+
+objects/gtkhtml_editor_common.o: gtkhtml_editor_common.c
+	$(CCC) -o $@ gtkhtml_editor_common.c
+
+objects/gtkhtml_editor_skels.o: gtkhtml_editor_skels.c
+	$(CCC) -o $@ gtkhtml_editor_skels.c
+
+objects/gtkhtml_editor_stubs.o: gtkhtml_editor_stubs.c
+	$(CCC) -o $@ gtkhtml_editor_stubs.c
+
 objects/hangulin.o: hangulin.c
 	$(CCC) -o $@ hangulin.c
 
@@ -2408,6 +2461,18 @@
 objects/undo.o: undo.c
 	$(CCC) -o $@ undo.c
 
+objects/vim_bonobo_control.o: vim_bonobo_control.c
+	$(CCC) -o $@ vim_bonobo_control.c
+
+objects/vim_bonobo_factory.o: vim_bonobo_factory.c
+	$(CCC) -o $@ vim_bonobo_factory.c
+
+objects/vim_bonobo_main.o: vim_bonobo_main.c
+	$(CCC) -o $@ vim_bonobo_main.c
+
+objects/vim_proxy_factory.o: vim_proxy_factory.c
+	$(CCC) -o $@ vim_proxy_factory.c
+
 objects/window.o: window.c
 	$(CCC) -o $@ window.c
 
diff -Nur vim63/src/mbyte.c vim63-bonobo/src/mbyte.c
--- vim63/src/mbyte.c	2005-09-09 20:11:10.575756000 +0200
+++ vim63-bonobo/src/mbyte.c	2005-09-09 20:14:02.751581960 +0200
@@ -3382,8 +3382,8 @@
     /* This flag is used in changed() at next call. */
     xim_changed_while_preediting = TRUE;
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*
@@ -4515,7 +4515,11 @@
 	    if (gui.fontset != NOFONTSET
 		    && gui.fontset->type == GDK_FONT_FONTSET)
 	    {
+#ifdef FEAT_GUI_COMPONENT
+		widget = gui.drawarea;
+#else
 		widget = gui.mainwin;
+#endif
 		gdk_window_get_size(widget->window, &width, &height);
 
 		attrmask |= (int)GDK_IC_STATUS_AREA;
@@ -5121,9 +5125,15 @@
 	while (event_queue != NULL && processing_queued_event)
 	{
 	    GdkEvent *ev = event_queue->data;
-
+            GtkWidget *output;
+            
 	    gboolean *ret;
-	    gtk_signal_emit_by_name((GtkObject*)gui.mainwin, "key_press_event",
+#ifdef FEAT_GUI_COMPONENT
+            output = gui.drawarea;
+#else
+            output = gui.mainwin;
+#endif
+	    gtk_signal_emit_by_name((GtkObject*)output, "key_press_event",
 								    ev, &ret);
 	    gdk_event_free(ev);
 	    event_queue = event_queue->next;
@@ -5135,8 +5145,8 @@
 	    key_press_event_queue = NULL;
 	}
     }
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*
@@ -5292,7 +5302,11 @@
 	GtkWidget	*widget = gui.drawarea;
 
 	attr->style = (GdkIMStyle)xim_input_style;
+#ifdef FEAT_GUI_COMPONENT
+	attr->client_window = gui.drawarea->window;
+#else
 	attr->client_window = gui.mainwin->window;
+#endif
 
 	if ((colormap = gtk_widget_get_colormap(widget)) !=
 	    gtk_widget_get_default_colormap())
@@ -5339,7 +5353,11 @@
 	    }
 	    else
 	    {
+#ifdef FEAT_GUI_COMPONENT
+		gdk_window_get_size(gui.drawarea->window, &width, &height);
+#else
 		gdk_window_get_size(gui.mainwin->window, &width, &height);
+#endif
 		attrmask |= (int)GDK_IC_STATUS_AREA_REQ;
 		attr->status_area.x = 0;
 		attr->status_area.y = height - gui.char_height - 1;
diff -Nur vim63/src/mbyte.c.orig vim63-bonobo/src/mbyte.c.orig
--- vim63/src/mbyte.c.orig	2005-09-09 20:11:10.134823000 +0200
+++ vim63-bonobo/src/mbyte.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,5870 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- * Multibyte extensions partly by Sung-Hoon Baek
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-/*
- * mbyte.c: Code specifically for handling multi-byte characters.
- *
- * The encoding used in the core is set with 'encoding'.  When 'encoding' is
- * changed, the following four variables are set (for speed).
- * Currently these types of character encodings are supported:
- *
- * "enc_dbcs"	    When non-zero it tells the type of double byte character
- *		    encoding (Chinese, Korean, Japanese, etc.).
- *		    The cell width on the display is equal to the number of
- *		    bytes.  (exception: DBCS_JPNU with first byte 0x8e)
- *		    Recognizing the first or second byte is difficult, it
- *		    requires checking a byte sequence from the start.
- * "enc_utf8"	    When TRUE use Unicode characters in UTF-8 encoding.
- *		    The cell width on the display needs to be determined from
- *		    the character value.
- *		    Recognizing bytes is easy: 0xxx.xxxx is a single-byte
- *		    char, 10xx.xxxx is a trailing byte, 11xx.xxxx is a leading
- *		    byte of a multi-byte character.
- *		    To make things complicated, up to two composing characters
- *		    are allowed.  These are drawn on top of the first char.
- *		    For most editing the sequence of bytes with composing
- *		    characters included is considered to be one character.
- * "enc_unicode"    When 2 use 16-bit Unicode characters (or UTF-16).
- *		    When 4 use 32-but Unicode characters.
- *		    Internally characters are stored in UTF-8 encoding to
- *		    avoid NUL bytes.  Conversion happens when doing I/O.
- *		    "enc_utf8" will also be TRUE.
- *
- * "has_mbyte" is set when "enc_dbcs" or "enc_utf8" is non-zero.
- *
- * If none of these is TRUE, 8-bit bytes are used for a character.  The
- * encoding isn't currently specified (TODO).
- *
- * 'encoding' specifies the encoding used in the core.  This is in registers,
- * text manipulation, buffers, etc.  Conversion has to be done when characters
- * in another encoding are received or send:
- *
- *		       clipboard
- *			   ^
- *			   | (2)
- *			   V
- *		   +---------------+
- *	      (1)  |		   | (3)
- *  keyboard ----->|	 core	   |-----> display
- *		   |		   |
- *		   +---------------+
- *			   ^
- *			   | (4)
- *			   V
- *			 file
- *
- * (1) Typed characters arrive in the current locale.  Conversion is to be
- *     done when 'encoding' is different from 'termencoding'.
- * (2) Text will be made available with the encoding specified with
- *     'encoding'.  If this is not sufficient, system-specific conversion
- *     might be required.
- * (3) For the GUI the correct font must be selected, no conversion done.
- *     Otherwise, conversion is to be done when 'encoding' differs from
- *     'termencoding'.  (Different in the GTK+ 2 port -- 'termencoding'
- *     is always used for both input and output and must always be set to
- *     "utf-8".  gui_mch_init() does this automatically.)
- * (4) The encoding of the file is specified with 'fileencoding'.  Conversion
- *     is to be done when it's different from 'encoding'.
- *
- * The viminfo file is a special case: Only text is converted, not file names.
- * Vim scripts may contain an ":encoding" command.  This has an effect for
- * some commands, like ":menutrans"
- */
-
-#include "vim.h"
-
-#ifdef WIN32UNIX
-# ifndef WIN32_LEAN_AND_MEAN
-#  define WIN32_LEAN_AND_MEAN
-# endif
-# include <windows.h>
-# ifdef WIN32
-#  undef WIN32	    /* Some windows.h define WIN32, we don't want that here. */
-# endif
-#endif
-
-#if (defined(WIN3264) || defined(WIN32UNIX)) && !defined(__MINGW32__)
-# include <winnls.h>
-#endif
-
-#ifdef FEAT_GUI_X11
-# include <X11/Intrinsic.h>
-#endif
-#ifdef X_LOCALE
-#include <X11/Xlocale.h>
-#endif
-
-#if defined(FEAT_XIM) && defined(HAVE_GTK2)
-# include <gdk/gdkkeysyms.h>
-# ifdef WIN3264
-#  include <gdk/gdkwin32.h>
-# else
-#  include <gdk/gdkx.h>
-# endif
-#endif
-
-#ifdef HAVE_WCHAR_H
-# include <wchar.h>
-#endif
-
-#if 0
-/* This has been disabled, because several people reported problems with the
- * wcwidth() and iswprint() library functions, esp. for Hebrew. */
-# ifdef __STDC_ISO_10646__
-#  define USE_WCHAR_FUNCTIONS
-# endif
-#endif
-
-#if defined(FEAT_MBYTE) || defined(PROTO)
-
-static int enc_canon_search __ARGS((char_u *name));
-static int dbcs_char2len __ARGS((int c));
-static int dbcs_char2bytes __ARGS((int c, char_u *buf));
-static int dbcs_ptr2len_check __ARGS((char_u *p));
-static int dbcs_char2cells __ARGS((int c));
-static int dbcs_ptr2char __ARGS((char_u *p));
-
-/* Lookup table to quickly get the length in bytes of a UTF-8 character from
- * the first byte of a UTF-8 string.  Bytes which are illegal when used as the
- * first byte have a one, because these will be used separately. */
-static char utf8len_tab[256] =
-{
-    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /*bogus*/
-    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /*bogus*/
-    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1,
-};
-
-/*
- * XIM often causes trouble.  Define XIM_DEBUG to get a log of XIM callbacks
- * in the "xim.log" file.
- */
-/* #define XIM_DEBUG */
-#ifdef XIM_DEBUG
-    static void
-xim_log(char *s, ...)
-{
-    va_list arglist;
-    static FILE *fd = NULL;
-
-    if (fd == (FILE *)-1)
-	return;
-    if (fd == NULL)
-    {
-	fd = fopen("xim.log", "w");
-	if (fd == NULL)
-	{
-	    EMSG("Cannot open xim.log");
-	    fd = (FILE *)-1;
-	    return;
-	}
-    }
-
-    va_start(arglist, s);
-    vfprintf(fd, s, arglist);
-    va_end(arglist);
-}
-#endif
-
-#endif
-
-#if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT) || defined(PROTO)
-/*
- * Canonical encoding names and their properties.
- * "iso-8859-n" is handled by enc_canonize() directly.
- */
-static struct
-{   char *name;		int prop;		int codepage;}
-enc_canon_table[] =
-{
-#define IDX_LATIN_1	0
-    {"latin1",		ENC_8BIT + ENC_LATIN1,	1252},
-#define IDX_ISO_2	1
-    {"iso-8859-2",	ENC_8BIT,		0},
-#define IDX_ISO_3	2
-    {"iso-8859-3",	ENC_8BIT,		0},
-#define IDX_ISO_4	3
-    {"iso-8859-4",	ENC_8BIT,		0},
-#define IDX_ISO_5	4
-    {"iso-8859-5",	ENC_8BIT,		0},
-#define IDX_ISO_6	5
-    {"iso-8859-6",	ENC_8BIT,		0},
-#define IDX_ISO_7	6
-    {"iso-8859-7",	ENC_8BIT,		0},
-#define IDX_CP1255	7
-    {"cp1255",		ENC_8BIT,		1255}, /* close to iso-8859-8 */
-#define IDX_ISO_8	8
-    {"iso-8859-8",	ENC_8BIT,		0},
-#define IDX_ISO_9	9
-    {"iso-8859-9",	ENC_8BIT,		0},
-#define IDX_ISO_10	10
-    {"iso-8859-10",	ENC_8BIT,		0},
-#define IDX_ISO_11	11
-    {"iso-8859-11",	ENC_8BIT,		0},
-#define IDX_ISO_13	12
-    {"iso-8859-13",	ENC_8BIT,		0},
-#define IDX_ISO_14	13
-    {"iso-8859-14",	ENC_8BIT,		0},
-#define IDX_ISO_15	14
-    {"iso-8859-15",	ENC_8BIT,		0},
-#define IDX_KOI8_R	15
-    {"koi8-r",		ENC_8BIT,		0},
-#define IDX_KOI8_U	16
-    {"koi8-u",		ENC_8BIT,		0},
-#define IDX_UTF8	17
-    {"utf-8",		ENC_UNICODE,		0},
-#define IDX_UCS2	18
-    {"ucs-2",		ENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE, 0},
-#define IDX_UCS2LE	19
-    {"ucs-2le",		ENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE, 0},
-#define IDX_UTF16	20
-    {"utf-16",		ENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD, 0},
-#define IDX_UTF16LE	21
-    {"utf-16le",	ENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD, 0},
-#define IDX_UCS4	22
-    {"ucs-4",		ENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE, 0},
-#define IDX_UCS4LE	23
-    {"ucs-4le",		ENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE, 0},
-#define IDX_DEBUG	24
-    {"debug",		ENC_DBCS,		DBCS_DEBUG},
-#define IDX_CP932	25
-    {"cp932",		ENC_DBCS,		DBCS_JPN},
-#define IDX_CP949	26
-    {"cp949",		ENC_DBCS,		DBCS_KOR},
-#define IDX_CP936	27
-    {"cp936",		ENC_DBCS,		DBCS_CHS},
-#define IDX_CP950	28
-    {"cp950",		ENC_DBCS,		DBCS_CHT},
-#define IDX_EUC_JP	29
-    {"euc-jp",		ENC_DBCS,		DBCS_JPNU},
-#define IDX_SJIS	30
-    {"sjis",		ENC_DBCS,		DBCS_JPN},
-#define IDX_EUC_KR	31
-    {"euc-kr",		ENC_DBCS,		DBCS_KORU},
-#define IDX_EUC_CN	32
-    {"euc-cn",		ENC_DBCS,		DBCS_CHSU},
-#define IDX_EUC_TW	33
-    {"euc-tw",		ENC_DBCS,		DBCS_CHTU},
-#define IDX_BIG5	34
-    {"big5",		ENC_DBCS,		DBCS_CHT},
-#define IDX_CP1251	35
-    {"cp1251",		ENC_8BIT,		1251},
-#define IDX_MACROMAN	36
-    {"macroman",	ENC_8BIT + ENC_MACROMAN, 0},
-#define IDX_COUNT	37
-};
-
-/*
- * Aliases for encoding names.
- */
-static struct
-{   char *name;		int canon;}
-enc_alias_table[] =
-{
-    {"ansi",		IDX_LATIN_1},
-    {"iso-8859-1",	IDX_LATIN_1},
-    {"latin2",		IDX_ISO_2},
-    {"latin3",		IDX_ISO_3},
-    {"latin4",		IDX_ISO_4},
-    {"cyrillic",	IDX_ISO_5},
-    {"arabic",		IDX_ISO_6},
-    {"greek",		IDX_ISO_7},
-#ifdef WIN3264
-    {"hebrew",		IDX_CP1255},
-#else
-    {"hebrew",		IDX_ISO_8},
-#endif
-    {"latin5",		IDX_ISO_9},
-    {"turkish",		IDX_ISO_9}, /* ? */
-    {"latin6",		IDX_ISO_10},
-    {"nordic",		IDX_ISO_10}, /* ? */
-    {"thai",		IDX_ISO_11}, /* ? */
-    {"latin7",		IDX_ISO_13},
-    {"latin8",		IDX_ISO_14},
-    {"latin9",		IDX_ISO_15},
-    {"utf8",		IDX_UTF8},
-    {"unicode",		IDX_UCS2},
-    {"ucs2",		IDX_UCS2},
-    {"ucs2be",		IDX_UCS2},
-    {"ucs-2be",		IDX_UCS2},
-    {"ucs2le",		IDX_UCS2LE},
-    {"utf16",		IDX_UTF16},
-    {"utf16be",		IDX_UTF16},
-    {"utf-16be",	IDX_UTF16},
-    {"utf16le",		IDX_UTF16LE},
-    {"ucs4",		IDX_UCS4},
-    {"ucs4be",		IDX_UCS4},
-    {"ucs-4be",		IDX_UCS4},
-    {"ucs4le",		IDX_UCS4LE},
-    {"932",		IDX_CP932},
-    {"949",		IDX_CP949},
-    {"936",		IDX_CP936},
-    {"950",		IDX_CP950},
-    {"eucjp",		IDX_EUC_JP},
-    {"unix-jis",	IDX_EUC_JP},
-    {"ujis",		IDX_EUC_JP},
-    {"shift-jis",	IDX_SJIS},
-    {"euckr",		IDX_EUC_KR},
-    {"5601",		IDX_EUC_KR},	/* Sun: KS C 5601 */
-    {"euccn",		IDX_EUC_CN},
-    {"gb2312",		IDX_EUC_CN},
-    {"euctw",		IDX_EUC_TW},
-#if defined(WIN3264) || defined(WIN32UNIX) || defined(MACOS)
-    {"japan",		IDX_CP932},
-    {"korea",		IDX_CP949},
-    {"prc",		IDX_CP936},
-    {"chinese",		IDX_CP936},
-    {"taiwan",		IDX_CP950},
-    {"big5",		IDX_CP950},
-#else
-    {"japan",		IDX_EUC_JP},
-    {"korea",		IDX_EUC_KR},
-    {"prc",		IDX_EUC_CN},
-    {"chinese",		IDX_EUC_CN},
-    {"taiwan",		IDX_EUC_TW},
-    {"cp950",		IDX_BIG5},
-    {"950",		IDX_BIG5},
-#endif
-    {"mac",		IDX_MACROMAN},
-    {NULL,		0}
-};
-
-#ifndef CP_UTF8
-# define CP_UTF8 65001	/* magic number from winnls.h */
-#endif
-
-/*
- * Find encoding "name" in the list of canonical encoding names.
- * Returns -1 if not found.
- */
-    static int
-enc_canon_search(name)
-    char_u	*name;
-{
-    int		i;
-
-    for (i = 0; i < IDX_COUNT; ++i)
-	if (STRCMP(name, enc_canon_table[i].name) == 0)
-	    return i;
-    return -1;
-}
-
-#endif
-
-#if defined(FEAT_MBYTE) || defined(PROTO)
-
-/*
- * Find canonical encoding "name" in the list and return its properties.
- * Returns 0 if not found.
- */
-    int
-enc_canon_props(name)
-    char_u	*name;
-{
-    int		i;
-
-    i = enc_canon_search(name);
-    if (i >= 0)
-	return enc_canon_table[i].prop;
-#ifdef WIN3264
-    if (name[0] == 'c' && name[1] == 'p' && VIM_ISDIGIT(name[2]))
-    {
-	CPINFO	cpinfo;
-
-	/* Get info on this codepage to find out what it is. */
-	if (GetCPInfo(atoi(name + 2), &cpinfo) != 0)
-	{
-	    if (cpinfo.MaxCharSize == 1) /* some single-byte encoding */
-		return ENC_8BIT;
-	    if (cpinfo.MaxCharSize == 2
-		    && (cpinfo.LeadByte[0] != 0 || cpinfo.LeadByte[1] != 0))
-		/* must be a DBCS encoding */
-		return ENC_DBCS;
-	}
-	return 0;
-    }
-#endif
-    if (STRNCMP(name, "2byte-", 6) == 0)
-	return ENC_DBCS;
-    if (STRNCMP(name, "8bit-", 5) == 0 || STRNCMP(name, "iso-8859-", 9) == 0)
-	return ENC_8BIT;
-    return 0;
-}
-
-/*
- * Set up for using multi-byte characters.
- * Called in three cases:
- * - by main() to initialize (p_enc == NULL)
- * - by set_init_1() after 'encoding' was set to its default.
- * - by do_set() when 'encoding' has been set.
- * p_enc must have been passed through enc_canonize() already.
- * Sets the "enc_unicode", "enc_utf8", "enc_dbcs" and "has_mbyte" flags.
- * Fills mb_bytelen_tab[] and returns NULL when there are no problems.
- * When there is something wrong: Returns an error message and doesn't change
- * anything.
- */
-    char_u *
-mb_init()
-{
-    int		i;
-    int		idx;
-    int		n;
-    int		enc_dbcs_new = 0;
-#if defined(USE_ICONV) && !defined(WIN3264) && !defined(WIN32UNIX) \
-	&& !defined(MACOS)
-# define LEN_FROM_CONV
-    vimconv_T	vimconv;
-    char_u	*p;
-#endif
-
-    if (p_enc == NULL)
-    {
-	/* Just starting up: set the whole table to one's. */
-	for (i = 0; i < 256; ++i)
-	    mb_bytelen_tab[i] = 1;
-	input_conv.vc_type = CONV_NONE;
-	input_conv.vc_factor = 1;
-	output_conv.vc_type = CONV_NONE;
-	return NULL;
-    }
-
-#ifdef WIN3264
-    if (p_enc[0] == 'c' && p_enc[1] == 'p' && VIM_ISDIGIT(p_enc[2]))
-    {
-	CPINFO	cpinfo;
-
-	/* Get info on this codepage to find out what it is. */
-	if (GetCPInfo(atoi(p_enc + 2), &cpinfo) != 0)
-	{
-	    if (cpinfo.MaxCharSize == 1)
-	    {
-		/* some single-byte encoding */
-		enc_unicode = 0;
-		enc_utf8 = FALSE;
-	    }
-	    else if (cpinfo.MaxCharSize == 2
-		    && (cpinfo.LeadByte[0] != 0 || cpinfo.LeadByte[1] != 0))
-	    {
-		/* must be a DBCS encoding, check below */
-		enc_dbcs_new = atoi(p_enc + 2);
-	    }
-	    else
-		goto codepage_invalid;
-	}
-	else if (GetLastError() == ERROR_INVALID_PARAMETER)
-	{
-codepage_invalid:
-	    return (char_u *)N_("E543: Not a valid codepage");
-	}
-    }
-#endif
-    else if (STRNCMP(p_enc, "8bit-", 5) == 0
-	    || STRNCMP(p_enc, "iso-8859-", 9) == 0)
-    {
-	/* Accept any "8bit-" or "iso-8859-" name. */
-	enc_unicode = 0;
-	enc_utf8 = FALSE;
-    }
-    else if (STRNCMP(p_enc, "2byte-", 6) == 0)
-    {
-#ifdef WIN3264
-	/* Windows: accept only valid codepage numbers, check below. */
-	if (p_enc[6] != 'c' || p_enc[7] != 'p'
-				      || (enc_dbcs_new = atoi(p_enc + 8)) == 0)
-	    return e_invarg;
-#else
-	/* Unix: accept any "2byte-" name, assume current locale. */
-	enc_dbcs_new = DBCS_2BYTE;
-#endif
-    }
-    else if ((idx = enc_canon_search(p_enc)) >= 0)
-    {
-	i = enc_canon_table[idx].prop;
-	if (i & ENC_UNICODE)
-	{
-	    /* Unicode */
-	    enc_utf8 = TRUE;
-	    if (i & (ENC_2BYTE | ENC_2WORD))
-		enc_unicode = 2;
-	    else if (i & ENC_4BYTE)
-		enc_unicode = 4;
-	    else
-		enc_unicode = 0;
-	}
-	else if (i & ENC_DBCS)
-	{
-	    /* 2byte, handle below */
-	    enc_dbcs_new = enc_canon_table[idx].codepage;
-	}
-	else
-	{
-	    /* Must be 8-bit. */
-	    enc_unicode = 0;
-	    enc_utf8 = FALSE;
-	}
-    }
-    else    /* Don't know what encoding this is, reject it. */
-	return e_invarg;
-
-    if (enc_dbcs_new != 0)
-    {
-#ifdef WIN3264
-	/* Check if the DBCS code page is OK. */
-	if (!IsValidCodePage(enc_dbcs_new))
-	    goto codepage_invalid;
-#endif
-	enc_unicode = 0;
-	enc_utf8 = FALSE;
-    }
-    enc_dbcs = enc_dbcs_new;
-    has_mbyte = (enc_dbcs != 0 || enc_utf8);
-
-#ifdef WIN3264
-    enc_codepage = encname2codepage(p_enc);
-#endif
-
-    /*
-     * Set the function pointers.
-     */
-    if (enc_utf8)
-    {
-	mb_ptr2len_check = utfc_ptr2len_check;
-	mb_char2len = utf_char2len;
-	mb_char2bytes = utf_char2bytes;
-	mb_ptr2cells = utf_ptr2cells;
-	mb_char2cells = utf_char2cells;
-	mb_off2cells = utf_off2cells;
-	mb_ptr2char = utf_ptr2char;
-	mb_head_off = utf_head_off;
-    }
-    else if (enc_dbcs != 0)
-    {
-	mb_ptr2len_check = dbcs_ptr2len_check;
-	mb_char2len = dbcs_char2len;
-	mb_char2bytes = dbcs_char2bytes;
-	mb_ptr2cells = dbcs_ptr2cells;
-	mb_char2cells = dbcs_char2cells;
-	mb_off2cells = dbcs_off2cells;
-	mb_ptr2char = dbcs_ptr2char;
-	mb_head_off = dbcs_head_off;
-    }
-    else
-    {
-	mb_ptr2len_check = latin_ptr2len_check;
-	mb_char2len = latin_char2len;
-	mb_char2bytes = latin_char2bytes;
-	mb_ptr2cells = latin_ptr2cells;
-	mb_char2cells = latin_char2cells;
-	mb_off2cells = latin_off2cells;
-	mb_ptr2char = latin_ptr2char;
-	mb_head_off = latin_head_off;
-    }
-
-    /*
-     * Fill the mb_bytelen_tab[] for MB_BYTE2LEN().
-     */
-#ifdef LEN_FROM_CONV
-    /* When 'encoding' is different from the current locale mblen() won't
-     * work.  Use conversion to "utf-8" instead. */
-    vimconv.vc_type = CONV_NONE;
-    if (enc_dbcs)
-    {
-	p = enc_locale();
-	if (p == NULL || STRCMP(p, p_enc) != 0)
-	{
-	    convert_setup(&vimconv, p_enc, (char_u *)"utf-8");
-	    vimconv.vc_fail = TRUE;
-	}
-	vim_free(p);
-    }
-#endif
-
-    for (i = 0; i < 256; ++i)
-    {
-	/* Our own function to reliably check the length of UTF-8 characters,
-	 * independent of mblen(). */
-	if (enc_utf8)
-	    n = utf8len_tab[i];
-	else if (enc_dbcs == 0)
-	    n = 1;
-	else
-	{
-#if defined(WIN3264) || defined(WIN32UNIX)
-	    /* enc_dbcs is set by setting 'fileencoding'.  It becomes a Windows
-	     * CodePage identifier, which we can pass directly in to Windows
-	     * API */
-	    n = IsDBCSLeadByteEx(enc_dbcs, (BYTE)i) ? 2 : 1;
-#else
-# ifdef MACOS
-	    /*
-	     * if mblen() is not available, character which MSB is turned on
-	     * are treated as leading byte character. (note : This assumption
-	     * is not always true.)
-	     */
-	    n = (i & 0x80) ? 2 : 1;
-# else
-	    char buf[MB_MAXBYTES];
-# ifdef X_LOCALE
-#  ifndef mblen
-#   define mblen _Xmblen
-#  endif
-# endif
-	    if (i == NUL)	/* just in case mblen() can't handle "" */
-		n = 1;
-	    else
-	    {
-		buf[0] = i;
-		buf[1] = 0;
-#ifdef LEN_FROM_CONV
-		if (vimconv.vc_type != CONV_NONE)
-		{
-		    /*
-		     * string_convert() should fail when converting the first
-		     * byte of a double-byte character.
-		     */
-		    p = string_convert(&vimconv, (char_u *)buf, NULL);
-		    if (p != NULL)
-		    {
-			vim_free(p);
-			n = 1;
-		    }
-		    else
-			n = 2;
-		}
-		else
-#endif
-		{
-		    /*
-		     * mblen() should return -1 for invalid (means the leading
-		     * multibyte) character.  However there are some platforms
-		     * where mblen() returns 0 for invalid character.
-		     * Therefore, following condition includes 0.
-		     */
-		    if (mblen(buf, (size_t)1) <= 0)
-			n = 2;
-		    else
-			n = 1;
-		}
-	    }
-# endif
-#endif
-	}
-
-	mb_bytelen_tab[i] = n;
-    }
-
-#ifdef LEN_FROM_CONV
-    convert_setup(&vimconv, NULL, NULL);
-#endif
-
-    /* The cell width depends on the type of multi-byte characters. */
-    (void)init_chartab();
-
-    /* When enc_utf8 is set or reset, (de)allocate ScreenLinesUC[] */
-    screenalloc(FALSE);
-
-    /* When using Unicode, set default for 'fileencodings'. */
-    if (enc_utf8 && !option_was_set((char_u *)"fencs"))
-	set_string_option_direct((char_u *)"fencs", -1,
-				 (char_u *)"ucs-bom,utf-8,latin1", OPT_FREE);
-#if defined(HAVE_BIND_TEXTDOMAIN_CODESET) && defined(FEAT_GETTEXT)
-    /* GNU gettext 0.10.37 supports this feature: set the codeset used for
-     * translated messages independently from the current locale. */
-    (void)bind_textdomain_codeset(VIMPACKAGE,
-					  enc_utf8 ? "utf-8" : (char *)p_enc);
-#endif
-
-#ifdef FEAT_AUTOCMD
-    /* Fire an autocommand to let people do custom font setup. This must be
-     * after Vim has been setup for the new encoding. */
-    apply_autocmds(EVENT_ENCODINGCHANGED, NULL, (char_u *)"", FALSE, curbuf);
-#endif
-
-    return NULL;
-}
-
-/*
- * Return the size of the BOM for the current buffer:
- * 0 - no BOM
- * 2 - UCS-2 or UTF-16 BOM
- * 4 - UCS-4 BOM
- * 3 - UTF-8 BOM
- */
-    int
-bomb_size()
-{
-    int n = 0;
-
-    if (curbuf->b_p_bomb && !curbuf->b_p_bin)
-    {
-	if (*curbuf->b_p_fenc == NUL)
-	{
-	    if (enc_utf8)
-	    {
-		if (enc_unicode != 0)
-		    n = enc_unicode;
-		else
-		    n = 3;
-	    }
-	}
-	else if (STRCMP(curbuf->b_p_fenc, "utf-8") == 0)
-	    n = 3;
-	else if (STRNCMP(curbuf->b_p_fenc, "ucs-2", 5) == 0
-		|| STRNCMP(curbuf->b_p_fenc, "utf-16", 6) == 0)
-	    n = 2;
-	else if (STRNCMP(curbuf->b_p_fenc, "ucs-4", 5) == 0)
-	    n = 4;
-    }
-    return n;
-}
-
-/*
- * Get class of pointer:
- * 0 for blank or NUL
- * 1 for punctuation
- * 2 for an (ASCII) word character
- * >2 for other word characters
- */
-    int
-mb_get_class(p)
-    char_u	*p;
-{
-    if (MB_BYTE2LEN(p[0]) == 1)
-    {
-	if (p[0] == NUL || vim_iswhite(p[0]))
-	    return 0;
-	if (vim_iswordc(p[0]))
-	    return 2;
-	return 1;
-    }
-    if (enc_dbcs != 0 && p[0] != NUL && p[1] != NUL)
-	return dbcs_class(p[0], p[1]);
-    if (enc_utf8)
-	return utf_class(utf_ptr2char(p));
-    return 0;
-}
-
-/*
- * Get class of a double-byte character.  This always returns 3 or bigger.
- * TODO: Should return 1 for punctuation.
- */
-    int
-dbcs_class(lead, trail)
-    unsigned	lead;
-    unsigned	trail;
-{
-    switch (enc_dbcs)
-    {
-	/* please add classfy routine for your language in here */
-
-	case DBCS_JPNU:	/* ? */
-	case DBCS_JPN:
-	    {
-		/* JIS code classification */
-		unsigned char lb = lead;
-		unsigned char tb = trail;
-
-		/* convert process code to JIS */
-# if defined(WIN3264) || defined(WIN32UNIX) || defined(MACOS)
-		/* process code is SJIS */
-		if (lb <= 0x9f)
-		    lb = (lb - 0x81) * 2 + 0x21;
-		else
-		    lb = (lb - 0xc1) * 2 + 0x21;
-		if (tb <= 0x7e)
-		    tb -= 0x1f;
-		else if (tb <= 0x9e)
-		    tb -= 0x20;
-		else
-		{
-		    tb -= 0x7e;
-		    lb += 1;
-		}
-# else
-		/*
-		 * XXX: Code page identification can not use with all
-		 *	    system! So, some other encoding information
-		 *	    will be needed.
-		 *	    In japanese: SJIS,EUC,UNICODE,(JIS)
-		 *	    Note that JIS-code system don't use as
-		 *	    process code in most system because it uses
-		 *	    escape sequences(JIS is context depend encoding).
-		 */
-		/* assume process code is JAPANESE-EUC */
-		lb &= 0x7f;
-		tb &= 0x7f;
-# endif
-		/* exceptions */
-		switch (lb << 8 | tb)
-		{
-		    case 0x2121: /* ZENKAKU space */
-			return 0;
-		    case 0x2122: /* KU-TEN (Japanese comma) */
-		    case 0x2123: /* TOU-TEN (Japanese period) */
-		    case 0x2124: /* ZENKAKU comma */
-		    case 0x2125: /* ZENKAKU period */
-			return 1;
-		    case 0x213c: /* prolongedsound handled as KATAKANA */
-			return 13;
-		}
-		/* sieved by KU code */
-		switch (lb)
-		{
-		    case 0x21:
-		    case 0x22:
-			/* special symbols */
-			return 10;
-		    case 0x23:
-			/* alpha-numeric */
-			return 11;
-		    case 0x24:
-			/* hiragana */
-			return 12;
-		    case 0x25:
-			/* katakana */
-			return 13;
-		    case 0x26:
-			/* greek */
-			return 14;
-		    case 0x27:
-			/* russian */
-			return 15;
-		    case 0x28:
-			/* lines */
-			return 16;
-		    default:
-			/* kanji */
-			return 17;
-		}
-	    }
-
-	case DBCS_KORU:	/* ? */
-	case DBCS_KOR:
-	    {
-		/* KS code classification */
-		unsigned char c1 = lead;
-		unsigned char c2 = trail;
-
-		/*
-		 * 20 : Hangul
-		 * 21 : Hanja
-		 * 22 : Symbols
-		 * 23 : Alpha-numeric/Roman Letter (Full width)
-		 * 24 : Hangul Letter(Alphabet)
-		 * 25 : Roman Numeral/Greek Letter
-		 * 26 : Box Drawings
-		 * 27 : Unit Symbols
-		 * 28 : Circled/Parenthesized Letter
-		 * 29 : Hirigana/Katakana
-		 * 30 : Cyrillic Letter
-		 */
-
-		if (c1 >= 0xB0 && c1 <= 0xC8)
-		    /* Hangul */
-		    return 20;
-#if defined(WIN3264) || defined(WIN32UNIX)
-		else if (c1 <= 0xA0 || c2 <= 0xA0)
-		    /* Extended Hangul Region : MS UHC(Unified Hangul Code) */
-		    /* c1: 0x81-0xA0 with c2: 0x41-0x5A, 0x61-0x7A, 0x81-0xFE
-		     * c1: 0xA1-0xC6 with c2: 0x41-0x5A, 0x61-0x7A, 0x81-0xA0
-		     */
-		    return 20;
-#endif
-
-		else if (c1 >= 0xCA && c1 <= 0xFD)
-		    /* Hanja */
-		    return 21;
-		else switch (c1)
-		{
-		    case 0xA1:
-		    case 0xA2:
-			/* Symbols */
-			return 22;
-		    case 0xA3:
-			/* Alpha-numeric */
-			return 23;
-		    case 0xA4:
-			/* Hangul Letter(Alphabet) */
-			return 24;
-		    case 0xA5:
-			/* Roman Numeral/Greek Letter */
-			return 25;
-		    case 0xA6:
-			/* Box Drawings */
-			return 26;
-		    case 0xA7:
-			/* Unit Symbols */
-			return 27;
-		    case 0xA8:
-		    case 0xA9:
-			if (c2 <= 0xAF)
-			    return 25;  /* Roman Letter */
-			else if (c2 >= 0xF6)
-			    return 22;  /* Symbols */
-			else
-			    /* Circled/Parenthesized Letter */
-			    return 28;
-		    case 0xAA:
-		    case 0xAB:
-			/* Hirigana/Katakana */
-			return 29;
-		    case 0xAC:
-			/* Cyrillic Letter */
-			return 30;
-		}
-	    }
-	default:
-	    break;
-    }
-    return 3;
-}
-
-/*
- * mb_char2len() function pointer.
- * Return length in bytes of character "c".
- * Returns 1 for a single-byte character.
- */
-/* ARGSUSED */
-    int
-latin_char2len(c)
-    int		c;
-{
-    return 1;
-}
-
-    static int
-dbcs_char2len(c)
-    int		c;
-{
-    if (c >= 0x100)
-	return 2;
-    return 1;
-}
-
-/*
- * mb_char2bytes() function pointer.
- * Convert a character to its bytes.
- * Returns the length in bytes.
- */
-    int
-latin_char2bytes(c, buf)
-    int		c;
-    char_u	*buf;
-{
-    buf[0] = c;
-    return 1;
-}
-
-    static int
-dbcs_char2bytes(c, buf)
-    int		c;
-    char_u	*buf;
-{
-    if (c >= 0x100)
-    {
-	buf[0] = (unsigned)c >> 8;
-	buf[1] = c;
-	return 2;
-    }
-    buf[0] = c;
-    return 1;
-}
-
-/*
- * mb_ptr2len_check() function pointer.
- * Get byte length of character at "*p" but stop at a NUL.
- * For UTF-8 this includes following composing characters.
- * Returns 0 when *p is NUL.
- *
- */
-    int
-latin_ptr2len_check(p)
-    char_u	*p;
-{
-    return MB_BYTE2LEN(*p);
-}
-
-    static int
-dbcs_ptr2len_check(p)
-    char_u	*p;
-{
-    int		len;
-
-    /* Check if second byte is not missing. */
-    len = MB_BYTE2LEN(*p);
-    if (len == 2 && p[1] == NUL)
-	len = 1;
-    return len;
-}
-
-struct interval
-{
-    unsigned short first;
-    unsigned short last;
-};
-static int intable __ARGS((struct interval *table, size_t size, int c));
-
-/*
- * Return TRUE if "c" is in "table[size / sizeof(struct interval)]".
- */
-    static int
-intable(table, size, c)
-    struct interval	*table;
-    size_t		size;
-    int			c;
-{
-    int mid, bot, top;
-
-    /* first quick check for Latin1 etc. characters */
-    if (c < table[0].first)
-	return FALSE;
-
-    /* binary search in table */
-    bot = 0;
-    top = size / sizeof(struct interval) - 1;
-    while (top >= bot)
-    {
-	mid = (bot + top) / 2;
-	if (table[mid].last < c)
-	    bot = mid + 1;
-	else if (table[mid].first > c)
-	    top = mid - 1;
-	else
-	    return TRUE;
-    }
-    return FALSE;
-}
-
-/*
- * For UTF-8 character "c" return 2 for a double-width character, 1 for others.
- * Returns 4 or 6 for an unprintable character.
- * Is only correct for characters >= 0x80.
- * When p_ambw is "double", return 2 for a character with East Asian Width
- * class 'A'(mbiguous).
- */
-    int
-utf_char2cells(c)
-    int		c;
-{
-    /* sorted list of non-overlapping intervals of East Asian Ambiguous
-     * characters, generated with:
-     * "uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c" */
-    static struct interval ambiguous[] = {
-	{0x00A1, 0x00A1}, {0x00A4, 0x00A4}, {0x00A7, 0x00A8},
-	{0x00AA, 0x00AA}, {0x00AE, 0x00AE}, {0x00B0, 0x00B4},
-	{0x00B6, 0x00BA}, {0x00BC, 0x00BF}, {0x00C6, 0x00C6},
-	{0x00D0, 0x00D0}, {0x00D7, 0x00D8}, {0x00DE, 0x00E1},
-	{0x00E6, 0x00E6}, {0x00E8, 0x00EA}, {0x00EC, 0x00ED},
-	{0x00F0, 0x00F0}, {0x00F2, 0x00F3}, {0x00F7, 0x00FA},
-	{0x00FC, 0x00FC}, {0x00FE, 0x00FE}, {0x0101, 0x0101},
-	{0x0111, 0x0111}, {0x0113, 0x0113}, {0x011B, 0x011B},
-	{0x0126, 0x0127}, {0x012B, 0x012B}, {0x0131, 0x0133},
-	{0x0138, 0x0138}, {0x013F, 0x0142}, {0x0144, 0x0144},
-	{0x0148, 0x014B}, {0x014D, 0x014D}, {0x0152, 0x0153},
-	{0x0166, 0x0167}, {0x016B, 0x016B}, {0x01CE, 0x01CE},
-	{0x01D0, 0x01D0}, {0x01D2, 0x01D2}, {0x01D4, 0x01D4},
-	{0x01D6, 0x01D6}, {0x01D8, 0x01D8}, {0x01DA, 0x01DA},
-	{0x01DC, 0x01DC}, {0x0251, 0x0251}, {0x0261, 0x0261},
-	{0x02C4, 0x02C4}, {0x02C7, 0x02C7}, {0x02C9, 0x02CB},
-	{0x02CD, 0x02CD}, {0x02D0, 0x02D0}, {0x02D8, 0x02DB},
-	{0x02DD, 0x02DD}, {0x02DF, 0x02DF}, {0x0391, 0x03A1},
-	{0x03A3, 0x03A9}, {0x03B1, 0x03C1}, {0x03C3, 0x03C9},
-	{0x0401, 0x0401}, {0x0410, 0x044F}, {0x0451, 0x0451},
-	{0x2010, 0x2010}, {0x2013, 0x2016}, {0x2018, 0x2019},
-	{0x201C, 0x201D}, {0x2020, 0x2022}, {0x2024, 0x2027},
-	{0x2030, 0x2030}, {0x2032, 0x2033}, {0x2035, 0x2035},
-	{0x203B, 0x203B}, {0x203E, 0x203E}, {0x2074, 0x2074},
-	{0x207F, 0x207F}, {0x2081, 0x2084}, {0x20AC, 0x20AC},
-	{0x2103, 0x2103}, {0x2105, 0x2105}, {0x2109, 0x2109},
-	{0x2113, 0x2113}, {0x2116, 0x2116}, {0x2121, 0x2122},
-	{0x2126, 0x2126}, {0x212B, 0x212B}, {0x2153, 0x2154},
-	{0x215B, 0x215E}, {0x2160, 0x216B}, {0x2170, 0x2179},
-	{0x2190, 0x2199}, {0x21B8, 0x21B9}, {0x21D2, 0x21D2},
-	{0x21D4, 0x21D4}, {0x21E7, 0x21E7}, {0x2200, 0x2200},
-	{0x2202, 0x2203}, {0x2207, 0x2208}, {0x220B, 0x220B},
-	{0x220F, 0x220F}, {0x2211, 0x2211}, {0x2215, 0x2215},
-	{0x221A, 0x221A}, {0x221D, 0x2220}, {0x2223, 0x2223},
-	{0x2225, 0x2225}, {0x2227, 0x222C}, {0x222E, 0x222E},
-	{0x2234, 0x2237}, {0x223C, 0x223D}, {0x2248, 0x2248},
-	{0x224C, 0x224C}, {0x2252, 0x2252}, {0x2260, 0x2261},
-	{0x2264, 0x2267}, {0x226A, 0x226B}, {0x226E, 0x226F},
-	{0x2282, 0x2283}, {0x2286, 0x2287}, {0x2295, 0x2295},
-	{0x2299, 0x2299}, {0x22A5, 0x22A5}, {0x22BF, 0x22BF},
-	{0x2312, 0x2312}, {0x2460, 0x24E9}, {0x24EB, 0x254B},
-	{0x2550, 0x2573}, {0x2580, 0x258F}, {0x2592, 0x2595},
-	{0x25A0, 0x25A1}, {0x25A3, 0x25A9}, {0x25B2, 0x25B3},
-	{0x25B6, 0x25B7}, {0x25BC, 0x25BD}, {0x25C0, 0x25C1},
-	{0x25C6, 0x25C8}, {0x25CB, 0x25CB}, {0x25CE, 0x25D1},
-	{0x25E2, 0x25E5}, {0x25EF, 0x25EF}, {0x2605, 0x2606},
-	{0x2609, 0x2609}, {0x260E, 0x260F}, {0x2614, 0x2615},
-	{0x261C, 0x261C}, {0x261E, 0x261E}, {0x2640, 0x2640},
-	{0x2642, 0x2642}, {0x2660, 0x2661}, {0x2663, 0x2665},
-	{0x2667, 0x266A}, {0x266C, 0x266D}, {0x266F, 0x266F},
-	{0x273D, 0x273D}, {0x2776, 0x277F}, {0xE000, 0xF8FF},
-	{0xFFFD, 0xFFFD}, /* {0xF0000, 0xFFFFD}, {0x100000, 0x10FFFD} */
-    };
-
-    if (c >= 0x100)
-    {
-#ifdef USE_WCHAR_FUNCTIONS
-	/*
-	 * Assume the library function wcwidth() works better than our own
-	 * stuff.  It should return 1 for ambiguous width chars!
-	 */
-	int	n = wcwidth(c);
-
-	if (n < 0)
-	    return 6;		/* unprintable, displays <xxxx> */
-	if (n > 1)
-	    return n;
-#else
-	if (!utf_printable(c))
-	    return 6;		/* unprintable, displays <xxxx> */
-	if (c >= 0x1100
-	    && (c <= 0x115f			/* Hangul Jamo */
-		|| c == 0x2329
-		|| c == 0x232a
-		|| (c >= 0x2e80 && c <= 0xa4cf
-		    && c != 0x303f)		/* CJK ... Yi */
-		|| (c >= 0xac00 && c <= 0xd7a3)	/* Hangul Syllables */
-		|| (c >= 0xf900 && c <= 0xfaff)	/* CJK Compatibility
-						   Ideographs */
-		|| (c >= 0xfe30 && c <= 0xfe6f)	/* CJK Compatibility Forms */
-		|| (c >= 0xff00 && c <= 0xff60)	/* Fullwidth Forms */
-		|| (c >= 0xffe0 && c <= 0xffe6)
-		|| (c >= 0x20000 && c <= 0x2fffd)
-		|| (c >= 0x30000 && c <= 0x3fffd)))
-	    return 2;
-#endif
-    }
-
-    /* Characters below 0x100 are influenced by 'isprint' option */
-    else if (c >= 0x80 && !vim_isprintc(c))
-	return 4;		/* unprintable, displays <xx> */
-
-    if (c >= 0x80 && *p_ambw == 'd' && intable(ambiguous, sizeof(ambiguous), c))
-	return 2;
-
-    return 1;
-}
-
-/*
- * mb_ptr2cells() function pointer.
- * Return the number of display cells character at "*p" occupies.
- * This doesn't take care of unprintable characters, use ptr2cells() for that.
- */
-/*ARGSUSED*/
-    int
-latin_ptr2cells(p)
-    char_u	*p;
-{
-    return 1;
-}
-
-    int
-utf_ptr2cells(p)
-    char_u	*p;
-{
-    int		c;
-
-    /* Need to convert to a wide character. */
-    if (*p >= 0x80)
-    {
-	c = utf_ptr2char(p);
-	/* An illegal byte is displayed as <xx>. */
-	if (utf_ptr2len_check(p) == 1 || c == NUL)
-	    return 4;
-	/* If the char is ASCII it must be an overlong sequence. */
-	if (c < 0x80)
-	    return char2cells(c);
-	return utf_char2cells(c);
-    }
-    return 1;
-}
-
-    int
-dbcs_ptr2cells(p)
-    char_u	*p;
-{
-    /* Number of cells is equal to number of bytes, except for euc-jp when
-     * the first byte is 0x8e. */
-    if (enc_dbcs == DBCS_JPNU && *p == 0x8e)
-	return 1;
-    return MB_BYTE2LEN(*p);
-}
-
-/*
- * mb_char2cells() function pointer.
- * Return the number of display cells character "c" occupies.
- * Only takes care of multi-byte chars, not "^C" and such.
- */
-/*ARGSUSED*/
-    int
-latin_char2cells(c)
-    int		c;
-{
-    return 1;
-}
-
-    static int
-dbcs_char2cells(c)
-    int		c;
-{
-    /* Number of cells is equal to number of bytes, except for euc-jp when
-     * the first byte is 0x8e. */
-    if (enc_dbcs == DBCS_JPNU && ((unsigned)c >> 8) == 0x8e)
-	return 1;
-    /* use the first byte */
-    return MB_BYTE2LEN((unsigned)c >> 8);
-}
-
-/*
- * mb_off2cells() function pointer.
- * Return number of display cells for char at ScreenLines[off].
- * Caller must make sure "off" and "off + 1" are valid!
- */
-/*ARGSUSED*/
-    int
-latin_off2cells(off)
-    unsigned	off;
-{
-    return 1;
-}
-
-    int
-dbcs_off2cells(off)
-    unsigned	off;
-{
-    /* Number of cells is equal to number of bytes, except for euc-jp when
-     * the first byte is 0x8e. */
-    if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
-	return 1;
-    return MB_BYTE2LEN(ScreenLines[off]);
-}
-
-    int
-utf_off2cells(off)
-    unsigned	off;
-{
-    return ScreenLines[off + 1] == 0 ? 2 : 1;
-}
-
-/*
- * mb_ptr2char() function pointer.
- * Convert a byte sequence into a character.
- */
-    int
-latin_ptr2char(p)
-    char_u	*p;
-{
-    return *p;
-}
-
-    static int
-dbcs_ptr2char(p)
-    char_u	*p;
-{
-    if (MB_BYTE2LEN(*p) > 1 && p[1] != NUL)
-	return (p[0] << 8) + p[1];
-    return *p;
-}
-
-/*
- * Convert a UTF-8 byte sequence to a wide character.
- * If the sequence is illegal or truncated by a NUL the first byte is
- * returned.
- * Does not include composing characters, of course.
- */
-    int
-utf_ptr2char(p)
-    char_u	*p;
-{
-    int		len;
-
-    if (p[0] < 0x80)	/* be quick for ASCII */
-	return p[0];
-
-    len = utf8len_tab[p[0]];
-    if ((p[1] & 0xc0) == 0x80)
-    {
-	if (len == 2)
-	    return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);
-	if ((p[2] & 0xc0) == 0x80)
-	{
-	    if (len == 3)
-		return ((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6)
-		    + (p[2] & 0x3f);
-	    if ((p[3] & 0xc0) == 0x80)
-	    {
-		if (len == 4)
-		    return ((p[0] & 0x07) << 18) + ((p[1] & 0x3f) << 12)
-			+ ((p[2] & 0x3f) << 6) + (p[3] & 0x3f);
-		if ((p[4] & 0xc0) == 0x80)
-		{
-		    if (len == 5)
-			return ((p[0] & 0x03) << 24) + ((p[1] & 0x3f) << 18)
-			    + ((p[2] & 0x3f) << 12) + ((p[3] & 0x3f) << 6)
-			    + (p[4] & 0x3f);
-		    if ((p[5] & 0xc0) == 0x80 && len == 6)
-			return ((p[0] & 0x01) << 30) + ((p[1] & 0x3f) << 24)
-			    + ((p[2] & 0x3f) << 18) + ((p[3] & 0x3f) << 12)
-			    + ((p[4] & 0x3f) << 6) + (p[5] & 0x3f);
-		}
-	    }
-	}
-    }
-    /* Illegal value, just return the first byte */
-    return p[0];
-}
-
-/*
- * Get character at **pp and advance *pp to the next character.
- * Note: composing characters are skipped!
- */
-    int
-mb_ptr2char_adv(pp)
-    char_u	**pp;
-{
-    int		c;
-
-    c = (*mb_ptr2char)(*pp);
-    *pp += (*mb_ptr2len_check)(*pp);
-    return c;
-}
-
-#if defined(FEAT_ARABIC) || defined(PROTO)
-/*
- * Check whether we are dealing with Arabic combining characters.
- * Note: these are NOT really composing characters!
- */
-    int
-arabic_combine(one, two)
-    int		one;	    /* first character */
-    int		two;	    /* character just after "one" */
-{
-    if (one == a_LAM)
-	return arabic_maycombine(two);
-    return FALSE;
-}
-
-/*
- * Check whether we are dealing with a character that could be regarded as an
- * Arabic combining character, need to check the character before this.
- */
-    int
-arabic_maycombine(two)
-    int		two;
-{
-    if (p_arshape && !p_tbidi)
-	return (two == a_ALEF_MADDA
-		    || two == a_ALEF_HAMZA_ABOVE
-		    || two == a_ALEF_HAMZA_BELOW
-		    || two == a_ALEF);
-    return FALSE;
-}
-
-/*
- * Check if the character pointed to by "p2" is a composing character when it
- * comes after "p1".  For Arabic sometimes "ab" is replaced with "c", which
- * behaves like a composing character.
- */
-    int
-utf_composinglike(p1, p2)
-    char_u	*p1;
-    char_u	*p2;
-{
-    int		c2;
-
-    c2 = utf_ptr2char(p2);
-    if (utf_iscomposing(c2))
-	return TRUE;
-    if (!arabic_maycombine(c2))
-	return FALSE;
-    return arabic_combine(utf_ptr2char(p1), c2);
-}
-#endif
-
-/*
- * Convert a UTF-8 byte string to a wide chararacter.  Also get up to two
- * composing characters.
- */
-    int
-utfc_ptr2char(p, p1, p2)
-    char_u	*p;
-    int		*p1;	/* return: first composing char or 0 */
-    int		*p2;	/* return: second composing char or 0 */
-{
-    int		len;
-    int		c;
-    int		cc;
-
-    c = utf_ptr2char(p);
-    len = utf_ptr2len_check(p);
-    /* Only accept a composing char when the first char isn't illegal. */
-    if ((len > 1 || *p < 0x80)
-	    && p[len] >= 0x80
-	    && UTF_COMPOSINGLIKE(p, p + len))
-    {
-	*p1 = utf_ptr2char(p + len);
-	len += utf_ptr2len_check(p + len);
-	if (p[len] >= 0x80 && utf_iscomposing(cc = utf_ptr2char(p + len)))
-	    *p2 = cc;
-	else
-	    *p2 = 0;
-    }
-    else
-    {
-	*p1 = 0;
-	*p2 = 0;
-    }
-    return c;
-}
-
-/*
- * Convert a UTF-8 byte string to a wide chararacter.  Also get up to two
- * composing characters.  Use no more than p[maxlen].
- */
-    int
-utfc_ptr2char_len(p, p1, p2, maxlen)
-    char_u	*p;
-    int		*p1;	/* return: first composing char or 0 */
-    int		*p2;	/* return: second composing char or 0 */
-    int		maxlen;
-{
-    int		len;
-    int		c;
-    int		cc;
-
-    c = utf_ptr2char(p);
-    len = utf_ptr2len_check_len(p, maxlen);
-    /* Only accept a composing char when the first char isn't illegal. */
-    if ((len > 1 || *p < 0x80)
-	    && len < maxlen
-	    && p[len] >= 0x80
-	    && UTF_COMPOSINGLIKE(p, p + len))
-    {
-	*p1 = utf_ptr2char(p + len);
-	len += utf_ptr2len_check_len(p + len, maxlen - len);
-	if (len < maxlen
-		&& p[len] >= 0x80
-		&& utf_iscomposing(cc = utf_ptr2char(p + len)))
-	    *p2 = cc;
-	else
-	    *p2 = 0;
-    }
-    else
-    {
-	*p1 = 0;
-	*p2 = 0;
-    }
-    return c;
-}
-
-/*
- * Convert the character at screen position "off" to a sequence of bytes.
- * Includes the composing characters.
- * "buf" must at least have the length MB_MAXBYTES.
- * Returns the produced number of bytes.
- */
-    int
-utfc_char2bytes(off, buf)
-    int		off;
-    char_u	*buf;
-{
-    int		len;
-
-    len = utf_char2bytes(ScreenLinesUC[off], buf);
-    if (ScreenLinesC1[off] != 0)
-    {
-	len += utf_char2bytes(ScreenLinesC1[off], buf + len);
-	if (ScreenLinesC2[off] != 0)
-	    len += utf_char2bytes(ScreenLinesC2[off], buf + len);
-    }
-    return len;
-}
-
-/*
- * Get the length of a UTF-8 byte sequence, not including any following
- * composing characters.
- * Returns 0 for "".
- * Returns 1 for an illegal byte sequence.
- */
-    int
-utf_ptr2len_check(p)
-    char_u	*p;
-{
-    int		len;
-    int		i;
-
-    if (*p == NUL)
-	return 0;
-    len = utf8len_tab[*p];
-    for (i = 1; i < len; ++i)
-	if ((p[i] & 0xc0) != 0x80)
-	    return 1;
-    return len;
-}
-
-/*
- * Return length of UTF-8 character, obtained from the first byte.
- * "b" must be between 0 and 255!
- */
-    int
-utf_byte2len(b)
-    int		b;
-{
-    return utf8len_tab[b];
-}
-
-/*
- * Get the length of UTF-8 byte sequence "p[size]".  Does not include any
- * following composing characters.
- * Returns 1 for "".
- * Returns 1 for an illegal byte sequence.
- * Returns number > "size" for an incomplete byte sequence.
- */
-    int
-utf_ptr2len_check_len(p, size)
-    char_u	*p;
-    int		size;
-{
-    int		len;
-    int		i;
-
-    if (*p == NUL)
-	return 1;
-    len = utf8len_tab[*p];
-    if (len > size)
-	return len;	/* incomplete byte sequence. */
-    for (i = 1; i < len; ++i)
-	if ((p[i] & 0xc0) != 0x80)
-	    return 1;
-    return len;
-}
-
-/*
- * Return the number of bytes the UTF-8 encoding of the character at "p" takes.
- * This includes following composing characters.
- */
-    int
-utfc_ptr2len_check(p)
-    char_u	*p;
-{
-    int		len;
-#ifdef FEAT_ARABIC
-    int		prevlen;
-#endif
-
-    if (*p == NUL)
-	return 0;
-    if (p[0] < 0x80 && p[1] < 0x80)	/* be quick for ASCII */
-	return 1;
-
-    /* Skip over first UTF-8 char, stopping at a NUL byte. */
-    len = utf_ptr2len_check(p);
-
-    /* Check for illegal byte. */
-    if (len == 1 && p[0] >= 0x80)
-	return 1;
-
-    /*
-     * Check for composing characters.  We can handle only the first two, but
-     * skip all of them (otherwise the cursor would get stuck).
-     */
-#ifdef FEAT_ARABIC
-    prevlen = 0;
-#endif
-    for (;;)
-    {
-	if (p[len] < 0x80 || !UTF_COMPOSINGLIKE(p + prevlen, p + len))
-	    return len;
-
-	/* Skip over composing char */
-#ifdef FEAT_ARABIC
-	prevlen = len;
-#endif
-	len += utf_ptr2len_check(p + len);
-    }
-}
-
-/*
- * Return the number of bytes the UTF-8 encoding of the character at "p[size]"
- * takes.  This includes following composing characters.
- * Returns 1 for an illegal char or an incomplete byte sequence.
- */
-    int
-utfc_ptr2len_check_len(p, size)
-    char_u	*p;
-    int		size;
-{
-    int		len;
-#ifdef FEAT_ARABIC
-    int		prevlen;
-#endif
-
-    if (*p == NUL)
-	return 0;
-    if (p[0] < 0x80 && (size == 1 || p[1] < 0x80)) /* be quick for ASCII */
-	return 1;
-
-    /* Skip over first UTF-8 char, stopping at a NUL byte. */
-    len = utf_ptr2len_check_len(p, size);
-
-    /* Check for illegal byte and incomplete byte sequence. */
-    if ((len == 1 && p[0] >= 0x80) || len > size)
-	return 1;
-
-    /*
-     * Check for composing characters.  We can handle only the first two, but
-     * skip all of them (otherwise the cursor would get stuck).
-     */
-#ifdef FEAT_ARABIC
-    prevlen = 0;
-#endif
-    while (len < size)
-    {
-	if (p[len] < 0x80 || !UTF_COMPOSINGLIKE(p + prevlen, p + len))
-	    break;
-
-	/* Skip over composing char */
-#ifdef FEAT_ARABIC
-	prevlen = len;
-#endif
-	len += utf_ptr2len_check_len(p + len, size - len);
-    }
-    return len;
-}
-
-/*
- * Return the number of bytes the UTF-8 encoding of character "c" takes.
- * This does not include composing characters.
- */
-    int
-utf_char2len(c)
-    int		c;
-{
-    if (c < 0x80)
-	return 1;
-    if (c < 0x800)
-	return 2;
-    if (c < 0x10000)
-	return 3;
-    if (c < 0x200000)
-	return 4;
-    if (c < 0x4000000)
-	return 5;
-    return 6;
-}
-
-/*
- * Convert Unicode character "c" to UTF-8 string in "buf[]".
- * Returns the number of bytes.
- * This does not include composing characters.
- */
-    int
-utf_char2bytes(c, buf)
-    int		c;
-    char_u	*buf;
-{
-    if (c < 0x80)		/* 7 bits */
-    {
-	buf[0] = c;
-	return 1;
-    }
-    if (c < 0x800)		/* 11 bits */
-    {
-	buf[0] = 0xc0 + ((unsigned)c >> 6);
-	buf[1] = 0x80 + (c & 0x3f);
-	return 2;
-    }
-    if (c < 0x10000)		/* 16 bits */
-    {
-	buf[0] = 0xe0 + ((unsigned)c >> 12);
-	buf[1] = 0x80 + (((unsigned)c >> 6) & 0x3f);
-	buf[2] = 0x80 + (c & 0x3f);
-	return 3;
-    }
-    if (c < 0x200000)		/* 21 bits */
-    {
-	buf[0] = 0xf0 + ((unsigned)c >> 18);
-	buf[1] = 0x80 + (((unsigned)c >> 12) & 0x3f);
-	buf[2] = 0x80 + (((unsigned)c >> 6) & 0x3f);
-	buf[3] = 0x80 + (c & 0x3f);
-	return 4;
-    }
-    if (c < 0x4000000)		/* 26 bits */
-    {
-	buf[0] = 0xf8 + ((unsigned)c >> 24);
-	buf[1] = 0x80 + (((unsigned)c >> 18) & 0x3f);
-	buf[2] = 0x80 + (((unsigned)c >> 12) & 0x3f);
-	buf[3] = 0x80 + (((unsigned)c >> 6) & 0x3f);
-	buf[4] = 0x80 + (c & 0x3f);
-	return 5;
-    }
-				/* 31 bits */
-    buf[0] = 0xfc + ((unsigned)c >> 30);
-    buf[1] = 0x80 + (((unsigned)c >> 24) & 0x3f);
-    buf[2] = 0x80 + (((unsigned)c >> 18) & 0x3f);
-    buf[3] = 0x80 + (((unsigned)c >> 12) & 0x3f);
-    buf[4] = 0x80 + (((unsigned)c >> 6) & 0x3f);
-    buf[5] = 0x80 + (c & 0x3f);
-    return 6;
-}
-
-/*
- * Return TRUE if "c" is a composing UTF-8 character.  This means it will be
- * drawn on top of the preceding character.
- * Based on code from Markus Kuhn.
- */
-    int
-utf_iscomposing(c)
-    int		c;
-{
-    /* sorted list of non-overlapping intervals */
-    static struct interval combining[] =
-    {
-	{0x0300, 0x034f}, {0x0360, 0x036f}, {0x0483, 0x0486}, {0x0488, 0x0489},
-	{0x0591, 0x05a1}, {0x05a3, 0x05b9}, {0x05bb, 0x05bd}, {0x05bf, 0x05bf},
-	{0x05c1, 0x05c2}, {0x05c4, 0x05c4}, {0x0610, 0x0615}, {0x064b, 0x0658},
-	{0x0670, 0x0670}, {0x06d6, 0x06dc}, {0x06de, 0x06e4}, {0x06e7, 0x06e8},
-	{0x06ea, 0x06ed}, {0x0711, 0x0711}, {0x0730, 0x074a}, {0x07a6, 0x07b0},
-	{0x0901, 0x0903}, {0x093c, 0x093c}, {0x093e, 0x094d}, {0x0951, 0x0954},
-	{0x0962, 0x0963}, {0x0981, 0x0983}, {0x09bc, 0x09bc}, {0x09be, 0x09c4},
-	{0x09c7, 0x09c8}, {0x09cb, 0x09cd}, {0x09d7, 0x09d7}, {0x09e2, 0x09e3},
-	{0x0a01, 0x0a03}, {0x0a3c, 0x0a3c}, {0x0a3e, 0x0a42}, {0x0a47, 0x0a48},
-	{0x0a4b, 0x0a4d}, {0x0a70, 0x0a71}, {0x0a81, 0x0a83}, {0x0abc, 0x0abc},
-	{0x0abe, 0x0ac5}, {0x0ac7, 0x0ac9}, {0x0acb, 0x0acd}, {0x0ae2, 0x0ae3},
-	{0x0b01, 0x0b03}, {0x0b3c, 0x0b3c}, {0x0b3e, 0x0b43}, {0x0b47, 0x0b48},
-	{0x0b4b, 0x0b4d}, {0x0b56, 0x0b57}, {0x0b82, 0x0b82}, {0x0bbe, 0x0bc2},
-	{0x0bc6, 0x0bc8}, {0x0bca, 0x0bcd}, {0x0bd7, 0x0bd7}, {0x0c01, 0x0c03},
-	{0x0c3e, 0x0c44}, {0x0c46, 0x0c48}, {0x0c4a, 0x0c4d}, {0x0c55, 0x0c56},
-	{0x0c82, 0x0c83}, {0x0cbc, 0x0cbc}, {0x0cbe, 0x0cc4}, {0x0cc6, 0x0cc8},
-	{0x0cca, 0x0ccd}, {0x0cd5, 0x0cd6}, {0x0d02, 0x0d03}, {0x0d3e, 0x0d43},
-	{0x0d46, 0x0d48}, {0x0d4a, 0x0d4d}, {0x0d57, 0x0d57}, {0x0d82, 0x0d83},
-	{0x0dca, 0x0dca}, {0x0dcf, 0x0dd4}, {0x0dd6, 0x0dd6}, {0x0dd8, 0x0ddf},
-	{0x0df2, 0x0df3}, {0x0e31, 0x0e31}, {0x0e34, 0x0e3a}, {0x0e47, 0x0e4e},
-	{0x0eb1, 0x0eb1}, {0x0eb4, 0x0eb9}, {0x0ebb, 0x0ebc}, {0x0ec8, 0x0ecd},
-	{0x0f18, 0x0f19}, {0x0f35, 0x0f35}, {0x0f37, 0x0f37}, {0x0f39, 0x0f39},
-	{0x0f3e, 0x0f3f}, {0x0f71, 0x0f84}, {0x0f86, 0x0f87}, {0x0f90, 0x0f97},
-	{0x0f99, 0x0fbc}, {0x0fc6, 0x0fc6}, {0x102c, 0x1032}, {0x1036, 0x1039},
-	{0x1056, 0x1059}, {0x1712, 0x1714}, {0x1732, 0x1734}, {0x1752, 0x1753},
-	{0x1772, 0x1773}, {0x17b6, 0x17d3}, {0x17dd, 0x17dd}, {0x180b, 0x180d},
-	{0x18a9, 0x18a9}, {0x1920, 0x192b}, {0x1930, 0x193b}, {0x20d0, 0x20ea},
-	{0x302a, 0x302f}, {0x3099, 0x309a}, {0xfb1e, 0xfb1e}, {0xfe00, 0xfe0f},
-	{0xfe20, 0xfe23},
-    };
-
-    return intable(combining, sizeof(combining), c);
-}
-
-/*
- * Return TRUE for characters that can be displayed in a normal way.
- * Only for characters of 0x100 and above!
- */
-    int
-utf_printable(c)
-    int		c;
-{
-#ifdef USE_WCHAR_FUNCTIONS
-    /*
-     * Assume the iswprint() library function works better than our own stuff.
-     */
-    return iswprint(c);
-#else
-    /* Sorted list of non-overlapping intervals.
-     * 0xd800-0xdfff is reserved for UTF-16, actually illegal. */
-    static struct interval nonprint[] =
-    {
-	{0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},
-	{0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},
-	{0xfffe, 0xffff}
-    };
-
-    return !intable(nonprint, sizeof(nonprint), c);
-#endif
-}
-
-/*
- * Get class of a Unicode character.
- * 0: white space
- * 1: punctuation
- * 2 or bigger: some class of word character.
- */
-    int
-utf_class(c)
-    int		c;
-{
-    /* sorted list of non-overlapping intervals */
-    static struct clinterval
-    {
-	unsigned short first;
-	unsigned short last;
-	unsigned short class;
-    } classes[] =
-    {
-	{0x037e, 0x037e, 1},		/* Greek question mark */
-	{0x0387, 0x0387, 1},		/* Greek ano teleia */
-	{0x055a, 0x055f, 1},		/* Armenian punctuation */
-	{0x0589, 0x0589, 1},		/* Armenian full stop */
-	{0x05be, 0x05be, 1},
-	{0x05c0, 0x05c0, 1},
-	{0x05c3, 0x05c3, 1},
-	{0x05f3, 0x05f4, 1},
-	{0x060c, 0x060c, 1},
-	{0x061b, 0x061b, 1},
-	{0x061f, 0x061f, 1},
-	{0x066a, 0x066d, 1},
-	{0x06d4, 0x06d4, 1},
-	{0x0700, 0x070d, 1},		/* Syriac punctuation */
-	{0x0964, 0x0965, 1},
-	{0x0970, 0x0970, 1},
-	{0x0df4, 0x0df4, 1},
-	{0x0e4f, 0x0e4f, 1},
-	{0x0e5a, 0x0e5b, 1},
-	{0x0f04, 0x0f12, 1},
-	{0x0f3a, 0x0f3d, 1},
-	{0x0f85, 0x0f85, 1},
-	{0x104a, 0x104f, 1},		/* Myanmar punctuation */
-	{0x10fb, 0x10fb, 1},		/* Georgian punctuation */
-	{0x1361, 0x1368, 1},		/* Ethiopic punctuation */
-	{0x166d, 0x166e, 1},		/* Canadian Syl. punctuation */
-	{0x1680, 0x1680, 0},
-	{0x169b, 0x169c, 1},
-	{0x16eb, 0x16ed, 1},
-	{0x1735, 0x1736, 1},
-	{0x17d4, 0x17dc, 1},		/* Khmer punctuation */
-	{0x1800, 0x180a, 1},		/* Mongolian punctuation */
-	{0x2000, 0x200b, 0},		/* spaces */
-	{0x200c, 0x2027, 1},		/* punctuation and symbols */
-	{0x2028, 0x2029, 0},
-	{0x202a, 0x202e, 1},		/* punctuation and symbols */
-	{0x202f, 0x202f, 0},
-	{0x2030, 0x205e, 1},		/* punctuation and symbols */
-	{0x205f, 0x205f, 0},
-	{0x2060, 0x27ff, 1},		/* punctuation and symbols */
-	{0x2070, 0x207f, 0x2070},	/* superscript */
-	{0x2080, 0x208f, 0x2080},	/* subscript */
-	{0x2983, 0x2998, 1},
-	{0x29d8, 0x29db, 1},
-	{0x29fc, 0x29fd, 1},
-	{0x3000, 0x3000, 0},		/* ideographic space */
-	{0x3001, 0x3020, 1},		/* ideographic punctuation */
-	{0x3030, 0x3030, 1},
-	{0x303d, 0x303d, 1},
-	{0x3040, 0x309f, 0x3040},	/* Hiragana */
-	{0x30a0, 0x30ff, 0x30a0},	/* Katakana */
-	{0x3300, 0x9fff, 0x4e00},	/* CJK Ideographs */
-	{0xac00, 0xd7a3, 0xac00},	/* Hangul Syllables */
-	{0xf900, 0xfaff, 0x4e00},	/* CJK Ideographs */
-	{0xfd3e, 0xfd3f, 1},
-	{0xfe30, 0xfe6b, 1},		/* punctuation forms */
-	{0xff00, 0xff0f, 1},		/* half/fullwidth ASCII */
-	{0xff1a, 0xff20, 1},		/* half/fullwidth ASCII */
-	{0xff3b, 0xff40, 1},		/* half/fullwidth ASCII */
-	{0xff5b, 0xff65, 1},		/* half/fullwidth ASCII */
-    };
-    int bot = 0;
-    int top = sizeof(classes) / sizeof(struct clinterval) - 1;
-    int mid;
-
-    /* First quick check for Latin1 characters, use 'iskeyword'. */
-    if (c < 0x100)
-    {
-	if (c == ' ' || c == '\t' || c == NUL)
-	    return 0;	    /* blank */
-	if (vim_iswordc(c))
-	    return 2;	    /* word character */
-	return 1;	    /* punctuation */
-    }
-
-    /* binary search in table */
-    while (top >= bot)
-    {
-	mid = (bot + top) / 2;
-	if (classes[mid].last < c)
-	    bot = mid + 1;
-	else if (classes[mid].first > c)
-	    top = mid - 1;
-	else
-	    return (int)classes[mid].class;
-    }
-
-    /* most other characters are "word" characters */
-    return 2;
-}
-
-/*
- * Code for Unicode case-dependent operations.  Based on notes in
- * http://www.unicode.org/Public/UNIDATA/CaseFolding.txt
- * This code uses simple case folding, not full case folding.
- */
-
-/*
- * The following table is built by foldExtract.pl < CaseFolding.txt .
- * It must be in numeric order, because we use binary search on it.
- * An entry such as {0x41,0x5a,1,32} means that UCS-4 characters in the range
- * from 0x41 to 0x5a inclusive, stepping by 1, are folded by adding 32.
- */
-
-typedef struct
-{
-    int rangeStart;
-    int rangeEnd;
-    int step;
-    int offset;
-} convertStruct;
-
-convertStruct foldCase[] =
-{
-	{0x41,0x5a,1,32}, {0xc0,0xd6,1,32}, {0xd8,0xde,1,32},
-	{0x100,0x12e,2,1}, {0x130,0x130,-1,-199}, {0x132,0x136,2,1},
-	{0x139,0x147,2,1}, {0x14a,0x176,2,1}, {0x178,0x178,-1,-121},
-	{0x179,0x17d,2,1}, {0x181,0x181,-1,210}, {0x182,0x184,2,1},
-	{0x186,0x186,-1,206}, {0x187,0x187,-1,1}, {0x189,0x18a,1,205},
-	{0x18b,0x18b,-1,1}, {0x18e,0x18e,-1,79}, {0x18f,0x18f,-1,202},
-	{0x190,0x190,-1,203}, {0x191,0x191,-1,1}, {0x193,0x193,-1,205},
-	{0x194,0x194,-1,207}, {0x196,0x196,-1,211}, {0x197,0x197,-1,209},
-	{0x198,0x198,-1,1}, {0x19c,0x19c,-1,211}, {0x19d,0x19d,-1,213},
-	{0x19f,0x19f,-1,214}, {0x1a0,0x1a4,2,1}, {0x1a6,0x1a6,-1,218},
-	{0x1a7,0x1a7,-1,1}, {0x1a9,0x1a9,-1,218}, {0x1ac,0x1ac,-1,1},
-	{0x1ae,0x1ae,-1,218}, {0x1af,0x1af,-1,1}, {0x1b1,0x1b2,1,217},
-	{0x1b3,0x1b5,2,1}, {0x1b7,0x1b7,-1,219}, {0x1b8,0x1bc,4,1},
-	{0x1c4,0x1c4,-1,2}, {0x1c5,0x1c5,-1,1}, {0x1c7,0x1c7,-1,2},
-	{0x1c8,0x1c8,-1,1}, {0x1ca,0x1ca,-1,2}, {0x1cb,0x1db,2,1},
-	{0x1de,0x1ee,2,1}, {0x1f1,0x1f1,-1,2}, {0x1f2,0x1f4,2,1},
-	{0x1f6,0x1f6,-1,-97}, {0x1f7,0x1f7,-1,-56}, {0x1f8,0x21e,2,1},
-	{0x220,0x220,-1,-130}, {0x222,0x232,2,1}, {0x386,0x386,-1,38},
-	{0x388,0x38a,1,37}, {0x38c,0x38c,-1,64}, {0x38e,0x38f,1,63},
-	{0x391,0x3a1,1,32}, {0x3a3,0x3ab,1,32}, {0x3d8,0x3ee,2,1},
-	{0x3f4,0x3f4,-1,-60}, {0x3f7,0x3f7,-1,1}, {0x3f9,0x3f9,-1,-7},
-	{0x3fa,0x3fa,-1,1}, {0x400,0x40f,1,80}, {0x410,0x42f,1,32},
-	{0x460,0x480,2,1}, {0x48a,0x4be,2,1}, {0x4c1,0x4cd,2,1},
-	{0x4d0,0x4f4,2,1}, {0x4f8,0x500,8,1}, {0x502,0x50e,2,1},
-	{0x531,0x556,1,48}, {0x1e00,0x1e94,2,1}, {0x1ea0,0x1ef8,2,1},
-	{0x1f08,0x1f0f,1,-8}, {0x1f18,0x1f1d,1,-8}, {0x1f28,0x1f2f,1,-8},
-	{0x1f38,0x1f3f,1,-8}, {0x1f48,0x1f4d,1,-8}, {0x1f59,0x1f5f,2,-8},
-	{0x1f68,0x1f6f,1,-8}, {0x1f88,0x1f8f,1,-8}, {0x1f98,0x1f9f,1,-8},
-	{0x1fa8,0x1faf,1,-8}, {0x1fb8,0x1fb9,1,-8}, {0x1fba,0x1fbb,1,-74},
-	{0x1fbc,0x1fbc,-1,-9}, {0x1fc8,0x1fcb,1,-86}, {0x1fcc,0x1fcc,-1,-9},
-	{0x1fd8,0x1fd9,1,-8}, {0x1fda,0x1fdb,1,-100}, {0x1fe8,0x1fe9,1,-8},
-	{0x1fea,0x1feb,1,-112}, {0x1fec,0x1fec,-1,-7}, {0x1ff8,0x1ff9,1,-128},
-	{0x1ffa,0x1ffb,1,-126}, {0x1ffc,0x1ffc,-1,-9}, {0x2126,0x2126,-1,-7517},
-	{0x212a,0x212a,-1,-8383}, {0x212b,0x212b,-1,-8262},
-	{0x2160,0x216f,1,16}, {0x24b6,0x24cf,1,26}, {0xff21,0xff3a,1,32},
-	{0x10400,0x10427,1,40}
-};
-
-static int utf_convert(int a, convertStruct table[], int tableSize);
-
-/*
- * Generic conversion function for case operations.
- * Return the converted equivalent of "a", which is a UCS-4 character.  Use
- * the given conversion "table".  Uses binary search on "table".
- */
-    static int
-utf_convert(a, table, tableSize)
-    int			a;
-    convertStruct	table[];
-    int			tableSize;
-{
-    int start, mid, end; /* indices into table */
-
-    start = 0;
-    end = tableSize / sizeof(convertStruct);
-    while (start < end)
-    {
-	/* need to search further */
-	mid = (end + start) /2;
-	if (table[mid].rangeEnd < a)
-	    start = mid + 1;
-	else
-	    end = mid;
-    }
-    if (table[start].rangeStart <= a && a <= table[start].rangeEnd
-	    && (a - table[start].rangeStart) % table[start].step == 0)
-	return (a + table[start].offset);
-    else
-	return a;
-}
-
-/*
- * Return the folded-case equivalent of "a", which is a UCS-4 character.  Uses
- * simple case folding.
- */
-    int
-utf_fold(a)
-    int		a;
-{
-    return utf_convert(a, foldCase, sizeof(foldCase));
-}
-
-/*
- * The following tables are built by upperLowerExtract.pl < UnicodeData.txt .
- * They must be in numeric order, because we use binary search on them.
- * An entry such as {0x41,0x5a,1,32} means that UCS-4 characters in the range
- * from 0x41 to 0x5a inclusive, stepping by 1, are switched to lower (for
- * example) by adding 32.
- */
-convertStruct toLower[] =
-{
-	{0x41,0x5a,1,32}, {0xc0,0xd6,1,32}, {0xd8,0xde,1,32},
-	{0x100,0x12e,2,1}, {0x130,0x130,-1,-199}, {0x132,0x136,2,1},
-	{0x139,0x147,2,1}, {0x14a,0x176,2,1}, {0x178,0x178,-1,-121},
-	{0x179,0x17d,2,1}, {0x181,0x181,-1,210}, {0x182,0x184,2,1},
-	{0x186,0x186,-1,206}, {0x187,0x187,-1,1}, {0x189,0x18a,1,205},
-	{0x18b,0x18b,-1,1}, {0x18e,0x18e,-1,79}, {0x18f,0x18f,-1,202},
-	{0x190,0x190,-1,203}, {0x191,0x191,-1,1}, {0x193,0x193,-1,205},
-	{0x194,0x194,-1,207}, {0x196,0x196,-1,211}, {0x197,0x197,-1,209},
-	{0x198,0x198,-1,1}, {0x19c,0x19c,-1,211}, {0x19d,0x19d,-1,213},
-	{0x19f,0x19f,-1,214}, {0x1a0,0x1a4,2,1}, {0x1a6,0x1a6,-1,218},
-	{0x1a7,0x1a7,-1,1}, {0x1a9,0x1a9,-1,218}, {0x1ac,0x1ac,-1,1},
-	{0x1ae,0x1ae,-1,218}, {0x1af,0x1af,-1,1}, {0x1b1,0x1b2,1,217},
-	{0x1b3,0x1b5,2,1}, {0x1b7,0x1b7,-1,219}, {0x1b8,0x1bc,4,1},
-	{0x1c4,0x1ca,3,2}, {0x1cd,0x1db,2,1}, {0x1de,0x1ee,2,1},
-	{0x1f1,0x1f1,-1,2}, {0x1f4,0x1f4,-1,1}, {0x1f6,0x1f6,-1,-97},
-	{0x1f7,0x1f7,-1,-56}, {0x1f8,0x21e,2,1}, {0x220,0x220,-1,-130},
-	{0x222,0x232,2,1}, {0x386,0x386,-1,38}, {0x388,0x38a,1,37},
-	{0x38c,0x38c,-1,64}, {0x38e,0x38f,1,63}, {0x391,0x3a1,1,32},
-	{0x3a3,0x3ab,1,32}, {0x3d8,0x3ee,2,1}, {0x3f4,0x3f4,-1,-60},
-	{0x3f7,0x3f7,-1,1}, {0x3f9,0x3f9,-1,-7}, {0x3fa,0x3fa,-1,1},
-	{0x400,0x40f,1,80}, {0x410,0x42f,1,32}, {0x460,0x480,2,1},
-	{0x48a,0x4be,2,1}, {0x4c1,0x4cd,2,1}, {0x4d0,0x4f4,2,1},
-	{0x4f8,0x500,8,1}, {0x502,0x50e,2,1}, {0x531,0x556,1,48},
-	{0x1e00,0x1e94,2,1}, {0x1ea0,0x1ef8,2,1}, {0x1f08,0x1f0f,1,-8},
-	{0x1f18,0x1f1d,1,-8}, {0x1f28,0x1f2f,1,-8}, {0x1f38,0x1f3f,1,-8},
-	{0x1f48,0x1f4d,1,-8}, {0x1f59,0x1f5f,2,-8}, {0x1f68,0x1f6f,1,-8},
-	{0x1fb8,0x1fb9,1,-8}, {0x1fba,0x1fbb,1,-74}, {0x1fc8,0x1fcb,1,-86},
-	{0x1fd8,0x1fd9,1,-8}, {0x1fda,0x1fdb,1,-100}, {0x1fe8,0x1fe9,1,-8},
-	{0x1fea,0x1feb,1,-112}, {0x1fec,0x1fec,-1,-7}, {0x1ff8,0x1ff9,1,-128},
-	{0x1ffa,0x1ffb,1,-126}, {0x2126,0x2126,-1,-7517}, {0x212a,0x212a,-1,-8383},
-	{0x212b,0x212b,-1,-8262}, {0xff21,0xff3a,1,32}, {0x10400,0x10427,1,40}
-};
-
-convertStruct toUpper[] =
-{
-	{0x61,0x7a,1,-32}, {0xb5,0xb5,-1,743}, {0xe0,0xf6,1,-32},
-	{0xf8,0xfe,1,-32}, {0xff,0xff,-1,121}, {0x101,0x12f,2,-1},
-	{0x131,0x131,-1,-232}, {0x133,0x137,2,-1}, {0x13a,0x148,2,-1},
-	{0x14b,0x177,2,-1}, {0x17a,0x17e,2,-1}, {0x17f,0x17f,-1,-300},
-	{0x183,0x185,2,-1}, {0x188,0x18c,4,-1}, {0x192,0x192,-1,-1},
-	{0x195,0x195,-1,97}, {0x199,0x199,-1,-1}, {0x19e,0x19e,-1,130},
-	{0x1a1,0x1a5,2,-1}, {0x1a8,0x1ad,5,-1}, {0x1b0,0x1b4,4,-1},
-	{0x1b6,0x1b9,3,-1}, {0x1bd,0x1bd,-1,-1}, {0x1bf,0x1bf,-1,56},
-	{0x1c5,0x1c6,1,-1}, {0x1c8,0x1c9,1,-1}, {0x1cb,0x1cc,1,-1},
-	{0x1ce,0x1dc,2,-1}, {0x1dd,0x1dd,-1,-79}, {0x1df,0x1ef,2,-1},
-	{0x1f2,0x1f3,1,-1}, {0x1f5,0x1f9,4,-1}, {0x1fb,0x21f,2,-1},
-	{0x223,0x233,2,-1}, {0x253,0x253,-1,-210}, {0x254,0x254,-1,-206},
-	{0x256,0x257,1,-205}, {0x259,0x259,-1,-202}, {0x25b,0x25b,-1,-203},
-	{0x260,0x260,-1,-205}, {0x263,0x263,-1,-207}, {0x268,0x268,-1,-209},
-	{0x269,0x26f,6,-211}, {0x272,0x272,-1,-213}, {0x275,0x275,-1,-214},
-	{0x280,0x283,3,-218}, {0x288,0x288,-1,-218}, {0x28a,0x28b,1,-217},
-	{0x292,0x292,-1,-219}, {0x3ac,0x3ac,-1,-38}, {0x3ad,0x3af,1,-37},
-	{0x3b1,0x3c1,1,-32}, {0x3c2,0x3c2,-1,-31}, {0x3c3,0x3cb,1,-32},
-	{0x3cc,0x3cc,-1,-64}, {0x3cd,0x3ce,1,-63}, {0x3d0,0x3d0,-1,-62},
-	{0x3d1,0x3d1,-1,-57}, {0x3d5,0x3d5,-1,-47}, {0x3d6,0x3d6,-1,-54},
-	{0x3d9,0x3ef,2,-1}, {0x3f0,0x3f0,-1,-86}, {0x3f1,0x3f1,-1,-80},
-	{0x3f2,0x3f2,-1,7}, {0x3f5,0x3f5,-1,-96}, {0x3f8,0x3fb,3,-1},
-	{0x430,0x44f,1,-32}, {0x450,0x45f,1,-80}, {0x461,0x481,2,-1},
-	{0x48b,0x4bf,2,-1}, {0x4c2,0x4ce,2,-1}, {0x4d1,0x4f5,2,-1},
-	{0x4f9,0x501,8,-1}, {0x503,0x50f,2,-1}, {0x561,0x586,1,-48},
-	{0x1e01,0x1e95,2,-1}, {0x1e9b,0x1e9b,-1,-59}, {0x1ea1,0x1ef9,2,-1},
-	{0x1f00,0x1f07,1,8}, {0x1f10,0x1f15,1,8}, {0x1f20,0x1f27,1,8},
-	{0x1f30,0x1f37,1,8}, {0x1f40,0x1f45,1,8}, {0x1f51,0x1f57,2,8},
-	{0x1f60,0x1f67,1,8}, {0x1f70,0x1f71,1,74}, {0x1f72,0x1f75,1,86},
-	{0x1f76,0x1f77,1,100}, {0x1f78,0x1f79,1,128}, {0x1f7a,0x1f7b,1,112},
-	{0x1f7c,0x1f7d,1,126}, {0x1f80,0x1f87,1,8}, {0x1f90,0x1f97,1,8},
-	{0x1fa0,0x1fa7,1,8}, {0x1fb0,0x1fb1,1,8}, {0x1fb3,0x1fb3,-1,9},
-	{0x1fbe,0x1fbe,-1,-7205}, {0x1fc3,0x1fc3,-1,9}, {0x1fd0,0x1fd1,1,8},
-	{0x1fe0,0x1fe1,1,8}, {0x1fe5,0x1fe5,-1,7}, {0x1ff3,0x1ff3,-1,9},
-	{0xff41,0xff5a,1,-32}, {0x10428,0x1044f,1,-40}
-};
-
-/*
- * Return the upper-case equivalent of "a", which is a UCS-4 character.  Use
- * simple case folding.
- */
-    int
-utf_toupper(a)
-    int		a;
-{
-    /* If 'casemap' contains "keepascii" use ASCII style toupper(). */
-    if (a < 128 && (cmp_flags & CMP_KEEPASCII))
-	return TOUPPER_ASC(a);
-
-#if defined(HAVE_TOWUPPER) && defined(__STDC__ISO_10646__)
-    /* If towupper() is availble and handles Unicode, use it. */
-    if (!(cmp_flags & CMP_INTERNAL))
-	return towupper(a);
-#endif
-
-    /* For characters below 128 use locale sensitive toupper(). */
-    if (a < 128)
-	return TOUPPER_LOC(a);
-
-    /* For any other characters use the above mapping table. */
-    return utf_convert(a, toUpper, sizeof(toUpper));
-}
-
-    int
-utf_islower(a)
-    int		a;
-{
-    return (utf_toupper(a) != a);
-}
-
-/*
- * Return the lower-case equivalent of "a", which is a UCS-4 character.  Use
- * simple case folding.
- */
-    int
-utf_tolower(a)
-    int		a;
-{
-    /* If 'casemap' contains "keepascii" use ASCII style tolower(). */
-    if (a < 128 && (cmp_flags & CMP_KEEPASCII))
-	return TOLOWER_ASC(a);
-
-#if defined(HAVE_TOWLOWER) && defined(__STDC__ISO_10646__)
-    /* If towlower() is availble and handles Unicode, use it. */
-    if (!(cmp_flags & CMP_INTERNAL))
-	return towlower(a);
-#endif
-
-    /* For characters below 128 use locale sensitive tolower(). */
-    if (a < 128)
-	return TOLOWER_LOC(a);
-
-    /* For any other characters use the above mapping table. */
-    return utf_convert(a, toLower, sizeof(toLower));
-}
-
-    int
-utf_isupper(a)
-    int		a;
-{
-    return (utf_tolower(a) != a);
-}
-
-/*
- * Version of strnicmp() that handles multi-byte characters.
- * Needed for Big5, Sjift-JIS and UTF-8 encoding.  Other DBCS encodings can
- * probably use strnicmp(), because there are no ASCII characters in the
- * second byte.
- * Returns zero if s1 and s2 are equal (ignoring case), the difference between
- * two characters otherwise.
- */
-    int
-mb_strnicmp(s1, s2, n)
-    char_u	*s1, *s2;
-    int		n;
-{
-    int		i, j, l;
-    int		cdiff;
-
-    for (i = 0; i < n; i += l)
-    {
-	if (s1[i] == NUL && s2[i] == NUL)   /* both strings end */
-	    return 0;
-	if (enc_utf8)
-	{
-	    l = utf_byte2len(s1[i]);
-	    if (l > n - i)
-		l = n - i;		    /* incomplete character */
-	    /* Check directly first, it's faster. */
-	    for (j = 0; j < l; ++j)
-		if (s1[i + j] != s2[i + j])
-		    break;
-	    if (j < l)
-	    {
-		/* If one of the two characters is incomplete return -1. */
-		if (i + utf_byte2len(s1[i]) > n || i + utf_byte2len(s2[i]) > n)
-		    return -1;
-		cdiff = utf_fold(utf_ptr2char(s1 + i))
-					     - utf_fold(utf_ptr2char(s2 + i));
-		if (cdiff != 0)
-		    return cdiff;
-	    }
-	}
-	else
-	{
-	    l = (*mb_ptr2len_check)(s1 + i);
-	    if (l <= 1)
-	    {
-		/* Single byte: first check normally, then with ignore case. */
-		if (s1[i] != s2[i])
-		{
-		    cdiff = TOLOWER_LOC(s1[i]) - TOLOWER_LOC(s2[i]);
-		    if (cdiff != 0)
-			return cdiff;
-		}
-	    }
-	    else
-	    {
-		/* For non-Unicode multi-byte don't ignore case. */
-		if (l > n - i)
-		    l = n - i;
-		cdiff = STRNCMP(s1 + i, s2 + i, l);
-		if (cdiff != 0)
-		    return cdiff;
-	    }
-	}
-    }
-    return 0;
-}
-
-/*
- * "g8": show bytes of the UTF-8 char under the cursor.  Doesn't matter what
- * 'encoding' has been set to.
- */
-    void
-show_utf8()
-{
-    int		len;
-    char_u	*line;
-    int		clen;
-    int		i;
-
-    /* Get the byte length of the char under the cursor, including composing
-     * characters. */
-    line = ml_get_cursor();
-    len = utfc_ptr2len_check(line);
-    if (len == 0)
-    {
-	MSG("NUL");
-	return;
-    }
-
-    IObuff[0] = NUL;
-    clen = 0;
-    for (i = 0; i < len; ++i)
-    {
-	if (clen == 0)
-	{
-	    /* start of (composing) character, get its length */
-	    if (i > 0)
-		STRCAT(IObuff, "+ ");
-	    clen = utf_ptr2len_check(line + i);
-	}
-	sprintf((char *)IObuff + STRLEN(IObuff), "%02x ", line[i]);
-	--clen;
-    }
-
-    msg(IObuff);
-}
-
-/*
- * mb_head_off() function pointer.
- * Return offset from "p" to the first byte of the character it points into.
- * Returns 0 when already at the first byte of a character.
- */
-/*ARGSUSED*/
-    int
-latin_head_off(base, p)
-    char_u	*base;
-    char_u	*p;
-{
-    return 0;
-}
-
-    int
-dbcs_head_off(base, p)
-    char_u	*base;
-    char_u	*p;
-{
-    char_u	*q;
-
-    /* It can't be a trailing byte when not using DBCS, at the start of the
-     * string or the previous byte can't start a double-byte. */
-    if (p <= base || MB_BYTE2LEN(p[-1]) == 1)
-	return 0;
-
-    /* This is slow: need to start at the base and go forward until the
-     * byte we are looking for.  Return 1 when we went past it, 0 otherwise. */
-    q = base;
-    while (q < p)
-	q += dbcs_ptr2len_check(q);
-    return (q == p) ? 0 : 1;
-}
-
-#if defined(FEAT_CLIPBOARD) || defined(FEAT_GUI) || defined(FEAT_RIGHTLEFT) \
-	|| defined(PROTO)
-/*
- * Special version of dbcs_head_off() that works for ScreenLines[], where
- * single-width DBCS_JPNU characters are stored separately.
- */
-    int
-dbcs_screen_head_off(base, p)
-    char_u	*base;
-    char_u	*p;
-{
-    char_u	*q;
-
-    /* It can't be a trailing byte when not using DBCS, at the start of the
-     * string or the previous byte can't start a double-byte.
-     * For euc-jp an 0x8e byte in the previous cell always means we have a
-     * lead byte in the current cell. */
-    if (p <= base
-	    || (enc_dbcs == DBCS_JPNU && p[-1] == 0x8e)
-	    || MB_BYTE2LEN(p[-1]) == 1)
-	return 0;
-
-    /* This is slow: need to start at the base and go forward until the
-     * byte we are looking for.  Return 1 when we went past it, 0 otherwise.
-     * For DBCS_JPNU look out for 0x8e, which means the second byte is not
-     * stored as the next byte. */
-    q = base;
-    while (q < p)
-    {
-	if (enc_dbcs == DBCS_JPNU && *q == 0x8e)
-	    ++q;
-	else
-	    q += dbcs_ptr2len_check(q);
-    }
-    return (q == p) ? 0 : 1;
-}
-#endif
-
-    int
-utf_head_off(base, p)
-    char_u	*base;
-    char_u	*p;
-{
-    char_u	*q;
-    char_u	*s;
-    int		c;
-#ifdef FEAT_ARABIC
-    char_u	*j;
-#endif
-
-    if (*p < 0x80)		/* be quick for ASCII */
-	return 0;
-
-    /* Skip backwards over trailing bytes: 10xx.xxxx
-     * Skip backwards again if on a composing char. */
-    for (q = p; ; --q)
-    {
-	/* Move s to the last byte of this char. */
-	for (s = q; (s[1] & 0xc0) == 0x80; ++s)
-	    ;
-	/* Move q to the first byte of this char. */
-	while (q > base && (*q & 0xc0) == 0x80)
-	    --q;
-	/* Check for illegal sequence. Do allow an illegal byte after where we
-	 * started. */
-	if (utf8len_tab[*q] != (int)(s - q + 1)
-				       && utf8len_tab[*q] != (int)(p - q + 1))
-	    return 0;
-
-	if (q <= base)
-	    break;
-
-	c = utf_ptr2char(q);
-	if (utf_iscomposing(c))
-	    continue;
-
-#ifdef FEAT_ARABIC
-	if (arabic_maycombine(c))
-	{
-	    /* Advance to get a sneak-peak at the next char */
-	    j = q;
-	    --j;
-	    /* Move j to the first byte of this char. */
-	    while (j > base && (*j & 0xc0) == 0x80)
-		--j;
-	    if (arabic_combine(utf_ptr2char(j), c))
-		continue;
-	}
-#endif
-	break;
-    }
-
-    return (int)(p - q);
-}
-
-/*
- * Return the offset from "p" to the first byte of a character.  When "p" is
- * at the start of a character 0 is returned, otherwise the offset to the next
- * character.  Can start anywhere in a stream of bytes.
- */
-    int
-mb_off_next(base, p)
-    char_u	*base;
-    char_u	*p;
-{
-    int		i;
-    int		j;
-
-    if (enc_utf8)
-    {
-	if (*p < 0x80)		/* be quick for ASCII */
-	    return 0;
-
-	/* Find the next character that isn't 10xx.xxxx */
-	for (i = 0; (p[i] & 0xc0) == 0x80; ++i)
-	    ;
-	if (i > 0)
-	{
-	    /* Check for illegal sequence. */
-	    for (j = 0; p - j > base; ++j)
-		if ((p[-j] & 0xc0) != 0x80)
-		    break;
-	    if (utf8len_tab[p[-j]] != i + j)
-		return 0;
-	}
-	return i;
-    }
-
-    /* Only need to check if we're on a trail byte, it doesn't matter if we
-     * want the offset to the next or current character. */
-    return (*mb_head_off)(base, p);
-}
-
-/*
- * Return the offset from "p" to the last byte of the character it points
- * into.  Can start anywhere in a stream of bytes.
- */
-    int
-mb_tail_off(base, p)
-    char_u	*base;
-    char_u	*p;
-{
-    int		i;
-    int		j;
-
-    if (*p == NUL)
-	return 0;
-
-    if (enc_utf8)
-    {
-	/* Find the last character that is 10xx.xxxx */
-	for (i = 0; (p[i + 1] & 0xc0) == 0x80; ++i)
-	    ;
-	/* Check for illegal sequence. */
-	for (j = 0; p - j > base; ++j)
-	    if ((p[-j] & 0xc0) != 0x80)
-		break;
-	if (utf8len_tab[p[-j]] != i + j + 1)
-	    return 0;
-	return i;
-    }
-
-    /* It can't be the first byte if a double-byte when not using DBCS, at the
-     * end of the string or the byte can't start a double-byte. */
-    if (enc_dbcs == 0 || p[1] == NUL || MB_BYTE2LEN(*p) == 1)
-	return 0;
-
-    /* Return 1 when on the lead byte, 0 when on the tail byte. */
-    return 1 - dbcs_head_off(base, p);
-}
-
-#if (defined(HAVE_GTK2) && defined(FEAT_TOOLBAR)) || defined(PROTO)
-/*
- * Return TRUE if string "s" is a valid utf-8 string.
- * When "end" is NULL stop at the first NUL.
- * When "end" is positive stop there.
- */
-    int
-utf_valid_string(s, end)
-    char_u	*s;
-    char_u	*end;
-{
-    int		l;
-    char_u	*p = s;
-
-    while (end == NULL ? *p != NUL : p < end)
-    {
-	if ((*p & 0xc0) == 0x80)
-	    return FALSE;	/* invalid lead byte */
-	l = utf8len_tab[*p];
-	if (end != NULL && p + l > end)
-	    return FALSE;	/* incomplete byte sequence */
-	++p;
-	while (--l > 0)
-	    if ((*p++ & 0xc0) != 0x80)
-		return FALSE;	/* invalid trail byte */
-    }
-    return TRUE;
-}
-#endif
-
-#if defined(FEAT_GUI) || defined(PROTO)
-/*
- * Special version of mb_tail_off() for use in ScreenLines[].
- */
-    int
-dbcs_screen_tail_off(base, p)
-    char_u	*base;
-    char_u	*p;
-{
-    /* It can't be the first byte if a double-byte when not using DBCS, at the
-     * end of the string or the byte can't start a double-byte.
-     * For euc-jp an 0x8e byte always means we have a lead byte in the current
-     * cell. */
-    if (*p == NUL || p[1] == NUL
-	    || (enc_dbcs == DBCS_JPNU && *p == 0x8e)
-	    || MB_BYTE2LEN(*p) == 1)
-	return 0;
-
-    /* Return 1 when on the lead byte, 0 when on the tail byte. */
-    return 1 - dbcs_screen_head_off(base, p);
-}
-#endif
-
-/*
- * If the cursor moves on an trail byte, set the cursor on the lead byte.
- * Thus it moves left if necessary.
- * Return TRUE when the cursor was adjusted.
- */
-    void
-mb_adjust_cursor()
-{
-    mb_adjustpos(&curwin->w_cursor);
-}
-
-/*
- * Adjust position "*lp" to point to the first byte of a multi-byte character.
- * If it points to a tail byte it's moved backwards to the head byte.
- */
-    void
-mb_adjustpos(lp)
-    pos_T	*lp;
-{
-    char_u	*p;
-
-    if (lp->col > 0
-#ifdef FEAT_VIRTUALEDIT
-	    || lp->coladd > 1
-#endif
-	    )
-    {
-	p = ml_get(lp->lnum);
-	lp->col -= (*mb_head_off)(p, p + lp->col);
-#ifdef FEAT_VIRTUALEDIT
-	/* Reset "coladd" when the cursor would be on the right half of a
-	 * double-wide character. */
-	if (lp->coladd == 1
-		&& p[lp->col] != TAB
-		&& vim_isprintc((*mb_ptr2char)(p + lp->col))
-		&& ptr2cells(p + lp->col) > 1)
-	    lp->coladd = 0;
-#endif
-    }
-}
-
-/*
- * Return a pointer to the character before "*p", if there is one.
- */
-    char_u *
-mb_prevptr(line, p)
-    char_u *line;	/* start of the string */
-    char_u *p;
-{
-    if (p > line)
-	p = p - (*mb_head_off)(line, p - 1) - 1;
-    return p;
-}
-
-/*
- * Return the character length of "str".  multi-byte characters counts as one.
- */
-    int
-mb_charlen(str)
-    char_u	*str;
-{
-    int count;
-
-    if (str == NULL)
-	return 0;
-
-    for (count = 0; *str != NUL; count++)
-	str += (*mb_ptr2len_check)(str);
-
-    return count;
-}
-
-/*
- * Try to un-escape a multi-byte character.
- * Used for the "to" and "from" part of a mapping.
- * Return the un-escaped string if it is a multi-byte character, and advance
- * "pp" to just after the bytes that formed it.
- * Return NULL if no multi-byte char was found.
- */
-    char_u *
-mb_unescape(pp)
-    char_u **pp;
-{
-    static char_u	buf[MB_MAXBYTES + 1];
-    int			n, m = 0;
-    char_u		*str = *pp;
-
-    /* Must translate K_SPECIAL KS_SPECIAL KE_FILLER to K_SPECIAL and CSI
-     * KS_EXTRA KE_CSI to CSI. */
-    for (n = 0; str[n] != NUL && m <= MB_MAXBYTES; ++n)
-    {
-	if (str[n] == K_SPECIAL
-		&& str[n + 1] == KS_SPECIAL
-		&& str[n + 2] == KE_FILLER)
-	{
-	    buf[m++] = K_SPECIAL;
-	    n += 2;
-	}
-# ifdef FEAT_GUI
-	else if (str[n] == CSI
-		&& str[n + 1] == KS_EXTRA
-		&& str[n + 2] == (int)KE_CSI)
-	{
-	    buf[m++] = CSI;
-	    n += 2;
-	}
-# endif
-	else if (str[n] == K_SPECIAL
-# ifdef FEAT_GUI
-		|| str[n] == CSI
-# endif
-		)
-	    break;		/* a special key can't be a multibyte char */
-	else
-	    buf[m++] = str[n];
-	buf[m] = NUL;
-
-	/* Return a multi-byte character if it's found.  An illegal sequence
-	 * will result in a 1 here. */
-	if ((*mb_ptr2len_check)(buf) > 1)
-	{
-	    *pp = str + n + 1;
-	    return buf;
-	}
-    }
-    return NULL;
-}
-
-/*
- * Return TRUE if the character at "row"/"col" on the screen is the left side
- * of a double-width character.
- * Caller must make sure "row" and "col" are not invalid!
- */
-    int
-mb_lefthalve(row, col)
-    int	    row;
-    int	    col;
-{
-#ifdef FEAT_HANGULIN
-    if (composing_hangul)
-	return TRUE;
-#endif
-    if (enc_dbcs != 0)
-	return dbcs_off2cells(LineOffset[row] + col) > 1;
-    if (enc_utf8)
-	return (col + 1 < Columns
-		&& ScreenLines[LineOffset[row] + col + 1] == 0);
-    return FALSE;
-}
-
-# if defined(FEAT_CLIPBOARD) || defined(FEAT_GUI) || defined(FEAT_RIGHTLEFT) \
-	|| defined(PROTO)
-/*
- * Correct a position on the screen, if it's the right halve of a double-wide
- * char move it to the left halve.  Returns the corrected column.
- */
-    int
-mb_fix_col(col, row)
-    int		col;
-    int		row;
-{
-    col = check_col(col);
-    row = check_row(row);
-    if (has_mbyte && ScreenLines != NULL && col > 0
-	    && ((enc_dbcs
-		    && ScreenLines[LineOffset[row] + col] != NUL
-		    && dbcs_screen_head_off(ScreenLines + LineOffset[row],
-					 ScreenLines + LineOffset[row] + col))
-		|| (enc_utf8 && ScreenLines[LineOffset[row] + col] == 0)))
-	--col;
-    return col;
-}
-# endif
-#endif
-
-#if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT) || defined(PROTO)
-static int enc_alias_search __ARGS((char_u *name));
-
-/*
- * Skip the Vim specific head of a 'encoding' name.
- */
-    char_u *
-enc_skip(p)
-    char_u	*p;
-{
-    if (STRNCMP(p, "2byte-", 6) == 0)
-	return p + 6;
-    if (STRNCMP(p, "8bit-", 5) == 0)
-	return p + 5;
-    return p;
-}
-
-/*
- * Find the canonical name for encoding "enc".
- * When the name isn't recognized, returns "enc" itself, but with all lower
- * case characters and '_' replaced with '-'.
- * Returns an allocated string.  NULL for out-of-memory.
- */
-    char_u *
-enc_canonize(enc)
-    char_u	*enc;
-{
-    char_u	*r;
-    char_u	*p, *s;
-    int		i;
-
-    /* copy "enc" to allocted memory, with room for two '-' */
-    r = alloc((unsigned)(STRLEN(enc) + 3));
-    if (r != NULL)
-    {
-	/* Make it all lower case and replace '_' with '-'. */
-	p = r;
-	for (s = enc; *s != NUL; ++s)
-	{
-	    if (*s == '_')
-		*p++ = '-';
-	    else
-		*p++ = TOLOWER_ASC(*s);
-	}
-	*p = NUL;
-
-	/* Skip "2byte-" and "8bit-". */
-	p = enc_skip(r);
-
-	/* "iso8859" -> "iso-8859" */
-	if (STRNCMP(p, "iso8859", 7) == 0)
-	{
-	    mch_memmove(p + 4, p + 3, STRLEN(p + 2));
-	    p[3] = '-';
-	}
-
-	/* "iso-8859n" -> "iso-8859-n" */
-	if (STRNCMP(p, "iso-8859", 8) == 0 && p[8] != '-')
-	{
-	    mch_memmove(p + 9, p + 8, STRLEN(p + 7));
-	    p[8] = '-';
-	}
-
-	/* "latin-N" -> "latinN" */
-	if (STRNCMP(p, "latin-", 6) == 0)
-	    mch_memmove(p + 5, p + 6, STRLEN(p + 5));
-
-	if (enc_canon_search(p) >= 0)
-	{
-	    /* canonical name can be used unmodified */
-	    if (p != r)
-		mch_memmove(r, p, STRLEN(p) + 1);
-	}
-	else if ((i = enc_alias_search(p)) >= 0)
-	{
-	    /* alias recognized, get canonical name */
-	    vim_free(r);
-	    r = vim_strsave((char_u *)enc_canon_table[i].name);
-	}
-    }
-    return r;
-}
-
-/*
- * Search for an encoding alias of "name".
- * Returns -1 when not found.
- */
-    static int
-enc_alias_search(name)
-    char_u	*name;
-{
-    int		i;
-
-    for (i = 0; enc_alias_table[i].name != NULL; ++i)
-	if (STRCMP(name, enc_alias_table[i].name) == 0)
-	    return enc_alias_table[i].canon;
-    return -1;
-}
-#endif
-
-#if defined(FEAT_MBYTE) || defined(PROTO)
-
-#ifdef HAVE_LANGINFO_H
-# include <langinfo.h>
-#endif
-
-/*
- * Get the canonicalized encoding of the current locale.
- * Returns an allocated string when successful, NULL when not.
- */
-    char_u *
-enc_locale()
-{
-#ifndef WIN3264
-    char	*s;
-    char	*p;
-    int		i;
-#endif
-    char	buf[50];
-#ifdef WIN3264
-    long	acp = GetACP();
-
-    if (acp == 1200)
-	STRCPY(buf, "ucs-2le");
-    else if (acp == 1252)
-	STRCPY(buf, "latin1");
-    else
-	sprintf(buf, "cp%ld", acp);
-#else
-# ifdef HAVE_NL_LANGINFO_CODESET
-    if ((s = nl_langinfo(CODESET)) == NULL || *s == NUL)
-# endif
-# if defined(HAVE_LOCALE_H) || defined(X_LOCALE)
-	if ((s = setlocale(LC_CTYPE, NULL)) == NULL || *s == NUL)
-# endif
-	    if ((s = getenv("LC_ALL")) == NULL || *s == NUL)
-		if ((s = getenv("LC_CTYPE")) == NULL || *s == NUL)
-		    s = getenv("LANG");
-
-    if (s == NULL || *s == NUL)
-	return FAIL;
-
-    /* The most generic locale format is:
-     * language[_territory][.codeset][@modifier][+special][,[sponsor][_revision]]
-     * If there is a '.' remove the part before it.
-     * if there is something after the codeset, remove it.
-     * Make the name lowercase and replace '_' with '-'.
-     * Exception: "ja_JP.EUC" == "euc-jp", "zh_CN.EUC" = "euc-cn",
-     * "ko_KR.EUC" == "euc-kr"
-     */
-    if ((p = (char *)vim_strchr((char_u *)s, '.')) != NULL)
-    {
-	if (p > s + 2 && STRNICMP(p + 1, "EUC", 3) == 0
-			&& !isalnum((int)p[4]) && p[4] != '-' && p[-3] == '_')
-	{
-	    /* copy "XY.EUC" to "euc-XY" to buf[10] */
-	    STRCPY(buf + 10, "euc-");
-	    buf[14] = p[-2];
-	    buf[15] = p[-1];
-	    buf[16] = 0;
-	    s = buf + 10;
-	}
-	else
-	    s = p + 1;
-    }
-    for (i = 0; s[i] != NUL && i < sizeof(buf) - 1; ++i)
-    {
-	if (s[i] == '_' || s[i] == '-')
-	    buf[i] = '-';
-	else if (isalnum((int)s[i]))
-	    buf[i] = TOLOWER_ASC(s[i]);
-	else
-	    break;
-    }
-    buf[i] = NUL;
-#endif
-
-    return enc_canonize((char_u *)buf);
-}
-
-#if defined(WIN3264) || defined(PROTO)
-/*
- * Convert an encoding name to an MS-Windows codepage.
- * Returns zero if no codepage can be figured out.
- */
-    int
-encname2codepage(name)
-    char_u	*name;
-{
-    int		cp;
-    char_u	*p = name;
-    int		idx;
-
-    if (STRNCMP(p, "8bit-", 5) == 0)
-	p += 5;
-    else if (STRNCMP(p_enc, "2byte-", 6) == 0)
-	p += 6;
-
-    if (p[0] == 'c' && p[1] == 'p')
-	cp = atoi(p + 2);
-    else if ((idx = enc_canon_search(p)) >= 0)
-	cp = enc_canon_table[idx].codepage;
-    else
-	return 0;
-    if (IsValidCodePage(cp))
-	return cp;
-    return 0;
-}
-#endif
-
-# if defined(USE_ICONV) || defined(PROTO)
-
-static char_u *iconv_string __ARGS((vimconv_T *vcp, char_u *str, int slen, int *unconvlenp));
-
-/*
- * Call iconv_open() with a check if iconv() works properly (there are broken
- * versions).
- * Returns (void *)-1 if failed.
- * (should return iconv_t, but that causes problems with prototypes).
- */
-    void *
-my_iconv_open(to, from)
-    char_u	*to;
-    char_u	*from;
-{
-    iconv_t	fd;
-#define ICONV_TESTLEN 400
-    char_u	tobuf[ICONV_TESTLEN];
-    char	*p;
-    size_t	tolen;
-    static int	iconv_ok = -1;
-
-    if (iconv_ok == FALSE)
-	return (void *)-1;	/* detected a broken iconv() previously */
-
-#ifdef DYNAMIC_ICONV
-    /* Check if the iconv.dll can be found. */
-    if (!iconv_enabled(TRUE))
-	return (void *)-1;
-#endif
-
-    fd = iconv_open((char *)enc_skip(to), (char *)enc_skip(from));
-
-    if (fd != (iconv_t)-1 && iconv_ok == -1)
-    {
-	/*
-	 * Do a dummy iconv() call to check if it actually works.  There is a
-	 * version of iconv() on Linux that is broken.  We can't ignore it,
-	 * because it's wide-spread.  The symptoms are that after outputting
-	 * the initial shift state the "to" pointer is NULL and conversion
-	 * stops for no apparent reason after about 8160 characters.
-	 */
-	p = (char *)tobuf;
-	tolen = ICONV_TESTLEN;
-	(void)iconv(fd, NULL, NULL, &p, &tolen);
-	if (p == NULL)
-	{
-	    iconv_ok = FALSE;
-	    iconv_close(fd);
-	    fd = (iconv_t)-1;
-	}
-	else
-	    iconv_ok = TRUE;
-    }
-
-    return (void *)fd;
-}
-
-/*
- * Convert the string "str[slen]" with iconv().
- * If "unconvlenp" is not NULL handle the string ending in an incomplete
- * sequence and set "*unconvlenp" to the length of it.
- * Returns the converted string in allocated memory.  NULL for an error.
- */
-    static char_u *
-iconv_string(vcp, str, slen, unconvlenp)
-    vimconv_T	*vcp;
-    char_u	*str;
-    int		slen;
-    int		*unconvlenp;
-{
-    const char	*from;
-    size_t	fromlen;
-    char	*to;
-    size_t	tolen;
-    size_t	len = 0;
-    size_t	done = 0;
-    char_u	*result = NULL;
-    char_u	*p;
-    int		l;
-
-    from = (char *)str;
-    fromlen = slen;
-    for (;;)
-    {
-	if (len == 0 || ICONV_ERRNO == ICONV_E2BIG)
-	{
-	    /* Allocate enough room for most conversions.  When re-allocating
-	     * increase the buffer size. */
-	    len = len + fromlen * 2 + 40;
-	    p = alloc((unsigned)len);
-	    if (p != NULL && done > 0)
-		mch_memmove(p, result, done);
-	    vim_free(result);
-	    result = p;
-	    if (result == NULL)	/* out of memory */
-		break;
-	}
-
-	to = (char *)result + done;
-	tolen = len - done - 2;
-	/* Avoid a warning for systems with a wrong iconv() prototype by
-	 * casting the second argument to void *. */
-	if (iconv(vcp->vc_fd, (void *)&from, &fromlen, &to, &tolen)
-								!= (size_t)-1)
-	{
-	    /* Finished, append a NUL. */
-	    *to = NUL;
-	    break;
-	}
-
-	/* Check both ICONV_EINVAL and EINVAL, because the dynamically loaded
-	 * iconv library may use one of them. */
-	if (!vcp->vc_fail && unconvlenp != NULL
-		&& (ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL))
-	{
-	    /* Handle an incomplete sequence at the end. */
-	    *to = NUL;
-	    *unconvlenp = fromlen;
-	    break;
-	}
-
-	/* Check both ICONV_EILSEQ and EILSEQ, because the dynamically loaded
-	 * iconv library may use one of them. */
-	else if (!vcp->vc_fail
-		&& (ICONV_ERRNO == ICONV_EILSEQ || ICONV_ERRNO == EILSEQ
-		    || ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL))
-	{
-	    /* Can't convert: insert a '?' and skip a character.  This assumes
-	     * conversion from 'encoding' to something else.  In other
-	     * situations we don't know what to skip anyway. */
-	    *to++ = '?';
-	    if ((*mb_ptr2cells)((char_u *)from) > 1)
-		*to++ = '?';
-	    if (enc_utf8)
-		l = utfc_ptr2len_check_len((char_u *)from, fromlen);
-	    else
-	    {
-		l = (*mb_ptr2len_check)((char_u *)from);
-		if (l > fromlen)
-		    l = fromlen;
-	    }
-	    from += l;
-	    fromlen -= l;
-	}
-	else if (ICONV_ERRNO != ICONV_E2BIG)
-	{
-	    /* conversion failed */
-	    vim_free(result);
-	    result = NULL;
-	    break;
-	}
-	/* Not enough room or skipping illegal sequence. */
-	done = to - (char *)result;
-    }
-    return result;
-}
-
-#  if defined(DYNAMIC_ICONV) || defined(PROTO)
-/*
- * Dynamically load the "iconv.dll" on Win32.
- */
-
-#ifndef DYNAMIC_ICONV	    /* just generating prototypes */
-# define HINSTANCE int
-#endif
-HINSTANCE hIconvDLL = 0;
-HINSTANCE hMsvcrtDLL = 0;
-
-#  ifndef DYNAMIC_ICONV_DLL
-#   define DYNAMIC_ICONV_DLL "iconv.dll"
-#   define DYNAMIC_ICONV_DLL_ALT "libiconv.dll"
-#  endif
-#  ifndef DYNAMIC_MSVCRT_DLL
-#   define DYNAMIC_MSVCRT_DLL "msvcrt.dll"
-#  endif
-
-/*
- * Try opening the iconv.dll and return TRUE if iconv() can be used.
- */
-    int
-iconv_enabled(verbose)
-    int		verbose;
-{
-    if (hIconvDLL != 0 && hMsvcrtDLL != 0)
-	return TRUE;
-    hIconvDLL = LoadLibrary(DYNAMIC_ICONV_DLL);
-    if (hIconvDLL == 0)		/* sometimes it's called libiconv.dll */
-	hIconvDLL = LoadLibrary(DYNAMIC_ICONV_DLL_ALT);
-    if (hIconvDLL != 0)
-	hMsvcrtDLL = LoadLibrary(DYNAMIC_MSVCRT_DLL);
-    if (hIconvDLL == 0 || hMsvcrtDLL == 0)
-    {
-	/* Only give the message when 'verbose' is set, otherwise it might be
-	 * done whenever a conversion is attempted. */
-	if (verbose && p_verbose > 0)
-	    EMSG2(_(e_loadlib),
-		    hIconvDLL == 0 ? DYNAMIC_ICONV_DLL : DYNAMIC_MSVCRT_DLL);
-	iconv_end();
-	return FALSE;
-    }
-
-    *((FARPROC*)&iconv)		= GetProcAddress(hIconvDLL, "libiconv");
-    *((FARPROC*)&iconv_open)	= GetProcAddress(hIconvDLL, "libiconv_open");
-    *((FARPROC*)&iconv_close)	= GetProcAddress(hIconvDLL, "libiconv_close");
-    *((FARPROC*)&iconvctl)	= GetProcAddress(hIconvDLL, "libiconvctl");
-    *((FARPROC*)&iconv_errno)	= GetProcAddress(hMsvcrtDLL, "_errno");
-    if (iconv == NULL || iconv_open == NULL || iconv_close == NULL
-	    || iconvctl == NULL || iconv_errno == NULL)
-    {
-	iconv_end();
-	if (verbose && p_verbose > 0)
-	    EMSG2(_(e_loadfunc), "for libiconv");
-	return FALSE;
-    }
-    return TRUE;
-}
-
-    void
-iconv_end()
-{
-    /* Don't use iconv() when inputting or outputting characters. */
-    if (input_conv.vc_type == CONV_ICONV)
-	convert_setup(&input_conv, NULL, NULL);
-    if (output_conv.vc_type == CONV_ICONV)
-	convert_setup(&output_conv, NULL, NULL);
-
-    if (hIconvDLL != 0)
-	FreeLibrary(hIconvDLL);
-    if (hMsvcrtDLL != 0)
-	FreeLibrary(hMsvcrtDLL);
-    hIconvDLL = 0;
-    hMsvcrtDLL = 0;
-}
-#  endif /* DYNAMIC_ICONV */
-# endif /* USE_ICONV */
-
-#endif /* FEAT_MBYTE */
-
-#if defined(FEAT_XIM) || defined(PROTO)
-
-# ifdef FEAT_GUI_GTK
-static int xim_has_preediting INIT(= FALSE);  /* IM current status */
-
-/*
- * Set preedit_start_col to the current cursor position.
- */
-    static void
-init_preedit_start_col(void)
-{
-    if (State & CMDLINE)
-	preedit_start_col = cmdline_getvcol_cursor();
-    else if (curwin != NULL)
-	getvcol(curwin, &curwin->w_cursor, &preedit_start_col, NULL, NULL);
-    /* Prevent that preediting marks the buffer as changed. */
-    xim_changed_while_preediting = curbuf->b_changed;
-}
-# endif
-
-# if defined(HAVE_GTK2) && !defined(PROTO)
-
-static int im_is_active	       = FALSE;	/* IM is enabled for current mode    */
-static int im_preedit_cursor   = 0;	/* cursor offset in characters       */
-static int im_preedit_trailing = 0;	/* number of characters after cursor */
-
-static unsigned long im_commit_handler_id  = 0;
-static unsigned int  im_activatekey_keyval = GDK_VoidSymbol;
-static unsigned int  im_activatekey_state  = 0;
-
-    void
-im_set_active(int active)
-{
-    int was_active;
-
-    was_active = !!im_is_active;
-    im_is_active = (active && !p_imdisable);
-
-    if (im_is_active != was_active)
-	xim_reset();
-}
-
-    void
-xim_set_focus(int focus)
-{
-    if (xic != NULL)
-    {
-	if (focus)
-	    gtk_im_context_focus_in(xic);
-	else
-	    gtk_im_context_focus_out(xic);
-    }
-}
-
-    void
-im_set_position(int row, int col)
-{
-    if (xic != NULL)
-    {
-	GdkRectangle area;
-
-	area.x = FILL_X(col);
-	area.y = FILL_Y(row);
-	area.width  = gui.char_width * (mb_lefthalve(row, col) ? 2 : 1);
-	area.height = gui.char_height;
-
-	gtk_im_context_set_cursor_location(xic, &area);
-    }
-}
-
-#  if 0 || defined(PROTO) /* apparently only used in gui_x11.c */
-    void
-xim_set_preedit(void)
-{
-    im_set_position(gui.row, gui.col);
-}
-#  endif
-
-    static void
-im_add_to_input(char_u *str, int len)
-{
-    /* Convert from 'termencoding' (always "utf-8") to 'encoding' */
-    if (input_conv.vc_type != CONV_NONE)
-    {
-	str = string_convert(&input_conv, str, &len);
-	g_return_if_fail(str != NULL);
-    }
-
-    add_to_input_buf_csi(str, len);
-
-    if (input_conv.vc_type != CONV_NONE)
-	vim_free(str);
-
-    if (p_mh) /* blank out the pointer if necessary */
-	gui_mch_mousehide(TRUE);
-}
-
-    static void
-im_delete_preedit(void)
-{
-    char_u bskey[]  = {CSI, 'k', 'b'};
-    char_u delkey[] = {CSI, 'k', 'D'};
-
-    if (State & NORMAL)
-    {
-	im_preedit_cursor = 0;
-	return;
-    }
-    for (; im_preedit_cursor > 0; --im_preedit_cursor)
-	add_to_input_buf(bskey, (int)sizeof(bskey));
-
-    for (; im_preedit_trailing > 0; --im_preedit_trailing)
-	add_to_input_buf(delkey, (int)sizeof(delkey));
-}
-
-    static void
-im_correct_cursor(int num_move_back)
-{
-    char_u backkey[] = {CSI, 'k', 'l'};
-
-    if (State & NORMAL)
-	return;
-#  ifdef FEAT_RIGHTLEFT
-    if ((State & CMDLINE) == 0 && curwin != NULL && curwin->w_p_rl)
-	backkey[2] = 'r';
-#  endif
-    for (; num_move_back > 0; --num_move_back)
-	add_to_input_buf(backkey, (int)sizeof(backkey));
-}
-
-static int xim_expected_char = NUL;
-static int xim_ignored_char = FALSE;
-
-/*
- * Update the mode and cursor while in an IM callback.
- */
-    static void
-im_show_info(void)
-{
-    int	    old_vgetc_busy;
-    old_vgetc_busy = vgetc_busy;
-    vgetc_busy = TRUE;
-    showmode();
-    vgetc_busy = old_vgetc_busy;
-    setcursor();
-    out_flush();
-}
-
-/*
- * Callback invoked when the user finished preediting.
- * Put the final string into the input buffer.
- */
-/*ARGSUSED0*/
-    static void
-im_commit_cb(GtkIMContext *context, const gchar *str, gpointer data)
-{
-    int	slen = (int)STRLEN(str);
-    int	add_to_input = TRUE;
-    int	clen;
-    int	len = slen;
-    int	commit_with_preedit = TRUE;
-    char_u	*im_str, *p;
-
-#ifdef XIM_DEBUG
-    xim_log("im_commit_cb(): %s\n", str);
-#endif
-
-    /* The imhangul module doesn't reset the preedit string before
-     * committing.  Call im_delete_preedit() to work around that. */
-    im_delete_preedit();
-
-    /* Indicate that preediting has finished. */
-    if (preedit_start_col == MAXCOL)
-    {
-	init_preedit_start_col();
-	commit_with_preedit = FALSE;
-    }
-
-    /* The thing which setting "preedit_start_col" to MAXCOL means that
-     * "preedit_start_col" will be set forcely when calling
-     * preedit_changed_cb() next time.
-     * "preedit_start_col" should not reset with MAXCOL on this part. Vim
-     * is simulating the preediting by using add_to_input_str(). when
-     * preedit begin immediately before committed, the typebuf is not
-     * flushed to screen, then it can't get correct "preedit_start_col".
-     * Thus, it should calculate the cells by adding cells of the committed
-     * string. */
-    if (input_conv.vc_type != CONV_NONE)
-    {
-	im_str = string_convert(&input_conv, (char_u *)str, &len);
-	g_return_if_fail(im_str != NULL);
-    }
-    else
-	im_str = (char_u *)str;
-    clen = 0;
-    for (p = im_str; p < im_str + len; p += (*mb_ptr2len_check)(p))
-	clen += (*mb_ptr2cells)(p);
-    if (input_conv.vc_type != CONV_NONE)
-	vim_free(im_str);
-    preedit_start_col += clen;
-
-    /* Is this a single character that matches a keypad key that's just
-     * been pressed?  If so, we don't want it to be entered as such - let
-     * us carry on processing the raw keycode so that it may be used in
-     * mappings as <kSomething>. */
-    if (xim_expected_char != NUL)
-    {
-	/* We're currently processing a keypad or other special key */
-	if (slen == 1 && str[0] == xim_expected_char)
-	{
-	    /* It's a match - don't do it here */
-	    xim_ignored_char = TRUE;
-	    add_to_input = FALSE;
-	}
-	else
-	{
-	    /* Not a match */
-	    xim_ignored_char = FALSE;
-	}
-    }
-
-    if (add_to_input)
-	im_add_to_input((char_u *)str, slen);
-
-    /* Inserting chars while "im_is_active" is set does not cause a change of
-     * buffer.  When the chars are committed the buffer must be marked as
-     * changed. */
-    if (!commit_with_preedit)
-	preedit_start_col = MAXCOL;
-
-    /* This flag is used in changed() at next call. */
-    xim_changed_while_preediting = TRUE;
-
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
-}
-
-/*
- * Callback invoked after start to the preedit.
- */
-/*ARGSUSED*/
-    static void
-im_preedit_start_cb(GtkIMContext *context, gpointer data)
-{
-#ifdef XIM_DEBUG
-    xim_log("im_preedit_start_cb()\n");
-#endif
-
-    im_is_active = TRUE;
-    gui_update_cursor(TRUE, FALSE);
-}
-
-/*
- * Callback invoked after end to the preedit.
- */
-/*ARGSUSED*/
-    static void
-im_preedit_end_cb(GtkIMContext *context, gpointer data)
-{
-#ifdef XIM_DEBUG
-    xim_log("im_preedit_end_cb()\n");
-#endif
-    im_delete_preedit();
-
-    /* Indicate that preediting has finished */
-    preedit_start_col = MAXCOL;
-    xim_has_preediting = FALSE;
-
-    im_is_active = FALSE;
-    gui_update_cursor(TRUE, FALSE);
-    im_show_info();
-}
-
-/*
- * Callback invoked after changes to the preedit string.  If the preedit
- * string was empty before, remember the preedit start column so we know
- * where to apply feedback attributes.  Delete the previous preedit string
- * if there was one, save the new preedit cursor offset, and put the new
- * string into the input buffer.
- *
- * TODO: The pragmatic "put into input buffer" approach used here has
- *       several fundamental problems:
- *
- * - The characters in the preedit string are subject to remapping.
- *   That's broken, only the finally committed string should be remapped.
- *
- * - There is a race condition involved:  The retrieved value for the
- *   current cursor position will be wrong if any unprocessed characters
- *   are still queued in the input buffer.
- *
- * - Due to the lack of synchronization between the file buffer in memory
- *   and any typed characters, it's practically impossible to implement the
- *   "retrieve_surrounding" and "delete_surrounding" signals reliably.  IM
- *   modules for languages such as Thai are likely to rely on this feature
- *   for proper operation.
- *
- * Conclusions:  I think support for preediting needs to be moved to the
- * core parts of Vim.  Ideally, until it has been committed, the preediting
- * string should only be displayed and not affect the buffer content at all.
- * The question how to deal with the synchronization issue still remains.
- * Circumventing the input buffer is probably not desirable.  Anyway, I think
- * implementing "retrieve_surrounding" is the only hard problem.
- *
- * One way to solve all of this in a clean manner would be to queue all key
- * press/release events "as is" in the input buffer, and apply the IM filtering
- * at the receiving end of the queue.  This, however, would have a rather large
- * impact on the code base.  If there is an easy way to force processing of all
- * remaining input from within the "retrieve_surrounding" signal handler, this
- * might not be necessary.  Gotta ask on vim-dev for opinions.
- */
-/*ARGSUSED1*/
-    static void
-im_preedit_changed_cb(GtkIMContext *context, gpointer data)
-{
-    char    *preedit_string = NULL;
-    int	    cursor_index    = 0;
-    int	    num_move_back   = 0;
-    char_u  *str;
-    char_u  *p;
-    int	    i;
-
-    gtk_im_context_get_preedit_string(context,
-				      &preedit_string, NULL,
-				      &cursor_index);
-
-#ifdef XIM_DEBUG
-    xim_log("im_preedit_changed_cb(): %s\n", preedit_string);
-#endif
-
-    g_return_if_fail(preedit_string != NULL); /* just in case */
-
-    /* If preedit_start_col is MAXCOL set it to the current cursor position. */
-    if (preedit_start_col == MAXCOL && preedit_string[0] != '\0')
-    {
-	xim_has_preediting = TRUE;
-
-	/* Urgh, this breaks if the input buffer isn't empty now */
-	init_preedit_start_col();
-    }
-    else if (cursor_index == 0 && preedit_string[0] == '\0')
-    {
-	if (preedit_start_col == MAXCOL)
-	    xim_has_preediting = FALSE;
-
-	/* If at the start position (after typing backspace)
-	 * preedit_start_col must be reset. */
-	preedit_start_col = MAXCOL;
-    }
-
-    im_delete_preedit();
-
-    /*
-     * Compute the end of the preediting area: "preedit_end_col".
-     * According to the documentation of gtk_im_context_get_preedit_string(),
-     * the cursor_pos output argument returns the offset in bytes.  This is
-     * unfortunately not true -- real life shows the offset is in characters,
-     * and the GTK+ source code agrees with me.  Will file a bug later.
-     */
-    if (preedit_start_col != MAXCOL)
-	preedit_end_col = preedit_start_col;
-    str = (char_u *)preedit_string;
-    for (p = str, i = 0; *p != NUL; p += utf_byte2len(*p), ++i)
-    {
-	int is_composing;
-
-	is_composing = ((*p & 0x80) != 0 && utf_iscomposing(utf_ptr2char(p)));
-	/*
-	 * These offsets are used as counters when generating <BS> and <Del>
-	 * to delete the preedit string.  So don't count composing characters
-	 * unless 'delcombine' is enabled.
-	 */
-	if (!is_composing || p_deco)
-	{
-	    if (i < cursor_index)
-		++im_preedit_cursor;
-	    else
-		++im_preedit_trailing;
-	}
-	if (!is_composing && i >= cursor_index)
-	{
-	    /* This is essentially the same as im_preedit_trailing, except
-	     * composing characters are not counted even if p_deco is set. */
-	    ++num_move_back;
-	}
-	if (preedit_start_col != MAXCOL)
-	    preedit_end_col += utf_ptr2cells(p);
-    }
-
-    if (p > str)
-    {
-	im_add_to_input(str, (int)(p - str));
-	im_correct_cursor(num_move_back);
-    }
-
-    g_free(preedit_string);
-
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
-}
-
-/*
- * Translate the Pango attributes at iter to Vim highlighting attributes.
- * Ignore attributes not supported by Vim highlighting.  This shouldn't have
- * too much impact -- right now we handle even more attributes than necessary
- * for the IM modules I tested with.
- */
-    static int
-translate_pango_attributes(PangoAttrIterator *iter)
-{
-    PangoAttribute  *attr;
-    int		    char_attr = HL_NORMAL;
-
-    attr = pango_attr_iterator_get(iter, PANGO_ATTR_UNDERLINE);
-    if (attr != NULL && ((PangoAttrInt *)attr)->value
-						 != (int)PANGO_UNDERLINE_NONE)
-	char_attr |= HL_UNDERLINE;
-
-    attr = pango_attr_iterator_get(iter, PANGO_ATTR_WEIGHT);
-    if (attr != NULL && ((PangoAttrInt *)attr)->value >= (int)PANGO_WEIGHT_BOLD)
-	char_attr |= HL_BOLD;
-
-    attr = pango_attr_iterator_get(iter, PANGO_ATTR_STYLE);
-    if (attr != NULL && ((PangoAttrInt *)attr)->value
-						   != (int)PANGO_STYLE_NORMAL)
-	char_attr |= HL_ITALIC;
-
-    attr = pango_attr_iterator_get(iter, PANGO_ATTR_BACKGROUND);
-    if (attr != NULL)
-    {
-	const PangoColor *color = &((PangoAttrColor *)attr)->color;
-
-	/* Assume inverse if black background is requested */
-	if ((color->red | color->green | color->blue) == 0)
-	    char_attr |= HL_INVERSE;
-    }
-
-    return char_attr;
-}
-
-/*
- * Retrieve the highlighting attributes at column col in the preedit string.
- * Return -1 if not in preediting mode or if col is out of range.
- */
-    int
-im_get_feedback_attr(int col)
-{
-    char	    *preedit_string = NULL;
-    PangoAttrList   *attr_list	    = NULL;
-    int		    char_attr	    = -1;
-
-    if (xic == NULL)
-	return char_attr;
-
-    gtk_im_context_get_preedit_string(xic, &preedit_string, &attr_list, NULL);
-
-    if (preedit_string != NULL && attr_list != NULL)
-    {
-	int index;
-
-	/* Get the byte index as used by PangoAttrIterator */
-	for (index = 0; col > 0 && preedit_string[index] != '\0'; --col)
-	    index += utfc_ptr2len_check((char_u *)preedit_string + index);
-
-	if (preedit_string[index] != '\0')
-	{
-	    PangoAttrIterator	*iter;
-	    int			start, end;
-
-	    char_attr = HL_NORMAL;
-	    iter = pango_attr_list_get_iterator(attr_list);
-
-	    /* Extract all relevant attributes from the list. */
-	    do
-	    {
-		pango_attr_iterator_range(iter, &start, &end);
-
-		if (index >= start && index < end)
-		    char_attr |= translate_pango_attributes(iter);
-	    }
-	    while (pango_attr_iterator_next(iter));
-
-	    pango_attr_iterator_destroy(iter);
-	}
-    }
-
-    if (attr_list != NULL)
-	pango_attr_list_unref(attr_list);
-    g_free(preedit_string);
-
-    return char_attr;
-}
-
-    void
-xim_init(void)
-{
-#ifdef XIM_DEBUG
-    xim_log("xim_init()\n");
-#endif
-
-    g_return_if_fail(gui.drawarea != NULL);
-    g_return_if_fail(gui.drawarea->window != NULL);
-
-    xic = gtk_im_multicontext_new();
-    g_object_ref(xic);
-
-    im_commit_handler_id = g_signal_connect(G_OBJECT(xic), "commit",
-					    G_CALLBACK(&im_commit_cb), NULL);
-    g_signal_connect(G_OBJECT(xic), "preedit_changed",
-		     G_CALLBACK(&im_preedit_changed_cb), NULL);
-    g_signal_connect(G_OBJECT(xic), "preedit_start",
-		     G_CALLBACK(&im_preedit_start_cb), NULL);
-    g_signal_connect(G_OBJECT(xic), "preedit_end",
-		     G_CALLBACK(&im_preedit_end_cb), NULL);
-
-    gtk_im_context_set_client_window(xic, gui.drawarea->window);
-}
-
-    void
-im_shutdown(void)
-{
-#ifdef XIM_DEBUG
-    xim_log("im_shutdown()\n");
-#endif
-
-    if (xic != NULL)
-    {
-	gtk_im_context_focus_out(xic);
-	g_object_unref(xic);
-	xic = NULL;
-    }
-    im_is_active = FALSE;
-    im_commit_handler_id = 0;
-    preedit_start_col = MAXCOL;
-    xim_has_preediting = FALSE;
-}
-
-/*
- * Convert the string argument to keyval and state for GdkEventKey.
- * If str is valid return TRUE, otherwise FALSE.
- *
- * See 'imactivatekey' for documentation of the format.
- */
-    static int
-im_string_to_keyval(const char *str, unsigned int *keyval, unsigned int *state)
-{
-    const char	    *mods_end;
-    unsigned	    tmp_keyval;
-    unsigned	    tmp_state = 0;
-
-    mods_end = strrchr(str, '-');
-    mods_end = (mods_end != NULL) ? mods_end + 1 : str;
-
-    /* Parse modifier keys */
-    while (str < mods_end)
-	switch (*str++)
-	{
-	    case '-':							break;
-	    case 'S': case 's': tmp_state |= (unsigned)GDK_SHIFT_MASK;	break;
-	    case 'L': case 'l': tmp_state |= (unsigned)GDK_LOCK_MASK;	break;
-	    case 'C': case 'c': tmp_state |= (unsigned)GDK_CONTROL_MASK;break;
-	    case '1':		tmp_state |= (unsigned)GDK_MOD1_MASK;	break;
-	    case '2':		tmp_state |= (unsigned)GDK_MOD2_MASK;	break;
-	    case '3':		tmp_state |= (unsigned)GDK_MOD3_MASK;	break;
-	    case '4':		tmp_state |= (unsigned)GDK_MOD4_MASK;	break;
-	    case '5':		tmp_state |= (unsigned)GDK_MOD5_MASK;	break;
-	    default:
-		return FALSE;
-	}
-
-    tmp_keyval = gdk_keyval_from_name(str);
-
-    if (tmp_keyval == 0 || tmp_keyval == GDK_VoidSymbol)
-	return FALSE;
-
-    if (keyval != NULL)
-	*keyval = tmp_keyval;
-    if (state != NULL)
-	*state = tmp_state;
-
-    return TRUE;
-}
-
-/*
- * Return TRUE if p_imak is valid, otherwise FALSE.  As a special case, an
- * empty string is also regarded as valid.
- *
- * Note: The numerical key value of p_imak is cached if it was valid; thus
- * boldly assuming im_xim_isvalid_imactivate() will always be called whenever
- * 'imak' changes.  This is currently the case but not obvious -- should
- * probably rename the function for clarity.
- */
-    int
-im_xim_isvalid_imactivate(void)
-{
-    if (p_imak[0] == NUL)
-    {
-	im_activatekey_keyval = GDK_VoidSymbol;
-	im_activatekey_state  = 0;
-	return TRUE;
-    }
-
-    return im_string_to_keyval((const char *)p_imak,
-			       &im_activatekey_keyval,
-			       &im_activatekey_state);
-}
-
-    static void
-im_synthesize_keypress(unsigned int keyval, unsigned int state)
-{
-    GdkEventKey *event;
-
-#  ifdef HAVE_GTK_MULTIHEAD
-    event = (GdkEventKey *)gdk_event_new(GDK_KEY_PRESS);
-    g_object_ref(gui.drawarea->window); /* unreffed by gdk_event_free() */
-#  else
-    event = (GdkEventKey *)g_malloc0((gulong)sizeof(GdkEvent));
-    event->type = GDK_KEY_PRESS;
-#  endif
-    event->window = gui.drawarea->window;
-    event->send_event = TRUE;
-    event->time = GDK_CURRENT_TIME;
-    event->state  = state;
-    event->keyval = keyval;
-    event->hardware_keycode = /* needed for XIM */
-	XKeysymToKeycode(GDK_WINDOW_XDISPLAY(event->window), (KeySym)keyval);
-    event->length = 0;
-    event->string = NULL;
-
-    gtk_im_context_filter_keypress(xic, event);
-
-    /* For consistency, also send the corresponding release event. */
-    event->type = GDK_KEY_RELEASE;
-    event->send_event = FALSE;
-    gtk_im_context_filter_keypress(xic, event);
-
-#  ifdef HAVE_GTK_MULTIHEAD
-    gdk_event_free((GdkEvent *)event);
-#  else
-    g_free(event);
-#  endif
-}
-
-    void
-xim_reset(void)
-{
-    if (xic != NULL)
-    {
-	/*
-	 * The third-party imhangul module (and maybe others too) ignores
-	 * gtk_im_context_reset() or at least doesn't reset the active state.
-	 * Thus sending imactivatekey would turn it off if it was on before,
-	 * which is clearly not what we want.  Fortunately we can work around
-	 * that for imhangul by sending GDK_Escape, but I don't know if it
-	 * works with all IM modules that support an activation key :/
-	 *
-	 * An alternative approach would be to destroy the IM context and
-	 * recreate it.  But that means loading/unloading the IM module on
-	 * every mode switch, which causes a quite noticable delay even on
-	 * my rather fast box...
-	 * *
-	 * Moreover, there are some XIM which cannot respond to
-	 * im_synthesize_keypress(). we hope that they reset by
-	 * xim_shutdown().
-	 */
-	if (im_activatekey_keyval != GDK_VoidSymbol && im_is_active)
-	    im_synthesize_keypress(GDK_Escape, 0U);
-
-	gtk_im_context_reset(xic);
-
-	/*
-	 * HACK for Ami: This sequence of function calls makes Ami handle
-	 * the IM reset gratiously, without breaking loads of other stuff.
-	 * It seems to force English mode as well, which is exactly what we
-	 * want because it makes the Ami status display work reliably.
-	 */
-	gtk_im_context_set_use_preedit(xic, FALSE);
-
-	if (p_imdisable)
-	    im_shutdown();
-	else
-	{
-	    gtk_im_context_set_use_preedit(xic, TRUE);
-	    xim_set_focus(gui.in_focus);
-
-	    if (im_activatekey_keyval != GDK_VoidSymbol)
-	    {
-		if (im_is_active)
-		{
-		    g_signal_handler_block(xic, im_commit_handler_id);
-		    im_synthesize_keypress(im_activatekey_keyval,
-						    im_activatekey_state);
-		    g_signal_handler_unblock(xic, im_commit_handler_id);
-		}
-	    }
-	    else
-	    {
-		im_shutdown();
-		xim_init();
-		xim_set_focus(gui.in_focus);
-	    }
-	}
-    }
-
-    preedit_start_col = MAXCOL;
-    xim_has_preediting = FALSE;
-}
-
-    int
-xim_queue_key_press_event(GdkEventKey *event, int down)
-{
-    if (down)
-    {
-	/*
-	 * Workaround GTK2 XIM 'feature' that always converts keypad keys to
-	 * chars., even when not part of an IM sequence (ref. feature of
-	 * gdk/gdkkeyuni.c).
-	 * Flag any keypad keys that might represent a single char.
-	 * If this (on its own - i.e., not part of an IM sequence) is
-	 * committed while we're processing one of these keys, we can ignore
-	 * that commit and go ahead & process it ourselves.  That way we can
-	 * still distinguish keypad keys for use in mappings.
-	 */
-	switch (event->keyval)
-	{
-	    case GDK_KP_Add:      xim_expected_char = '+';  break;
-	    case GDK_KP_Subtract: xim_expected_char = '-';  break;
-	    case GDK_KP_Divide:   xim_expected_char = '/';  break;
-	    case GDK_KP_Multiply: xim_expected_char = '*';  break;
-	    case GDK_KP_Decimal:  xim_expected_char = '.';  break;
-	    case GDK_KP_Equal:    xim_expected_char = '=';  break;
-	    case GDK_KP_0:	  xim_expected_char = '0';  break;
-	    case GDK_KP_1:	  xim_expected_char = '1';  break;
-	    case GDK_KP_2:	  xim_expected_char = '2';  break;
-	    case GDK_KP_3:	  xim_expected_char = '3';  break;
-	    case GDK_KP_4:	  xim_expected_char = '4';  break;
-	    case GDK_KP_5:	  xim_expected_char = '5';  break;
-	    case GDK_KP_6:	  xim_expected_char = '6';  break;
-	    case GDK_KP_7:	  xim_expected_char = '7';  break;
-	    case GDK_KP_8:	  xim_expected_char = '8';  break;
-	    case GDK_KP_9:	  xim_expected_char = '9';  break;
-	    default:		  xim_expected_char = NUL;
-	}
-	xim_ignored_char = FALSE;
-    }
-
-    /*
-     * When typing fFtT, XIM may be activated. Thus it must pass
-     * gtk_im_context_filter_keypress() in Normal mode.
-     * And while doing :sh too.
-     */
-    if (xic != NULL && !p_imdisable
-		    && (State & (INSERT | CMDLINE | NORMAL | EXTERNCMD)) != 0)
-    {
-	/*
-	 * Filter 'imactivatekey' and map it to CTRL-^.  This way, Vim is
-	 * always aware of the current status of IM, and can even emulate
-	 * the activation key for modules that don't support one.
-	 */
-	if (event->keyval == im_activatekey_keyval
-	     && (event->state & im_activatekey_state) == im_activatekey_state)
-	{
-	    unsigned int state_mask;
-
-	    /* Require the state of the 3 most used modifiers to match exactly.
-	     * Otherwise e.g. <S-C-space> would be unusable for other purposes
-	     * if the IM activate key is <S-space>. */
-	    state_mask  = im_activatekey_state;
-	    state_mask |= ((int)GDK_SHIFT_MASK | (int)GDK_CONTROL_MASK
-							| (int)GDK_MOD1_MASK);
-
-	    if ((event->state & state_mask) != im_activatekey_state)
-		return FALSE;
-
-	    /* Don't send it a second time on GDK_KEY_RELEASE. */
-	    if (event->type != GDK_KEY_PRESS)
-		return TRUE;
-
-	    if (map_to_exists_mode((char_u *)"", LANGMAP))
-	    {
-		im_set_active(FALSE);
-
-		/* ":lmap" mappings exists, toggle use of mappings. */
-		State ^= LANGMAP;
-		if (State & LANGMAP)
-		{
-		    curbuf->b_p_iminsert = B_IMODE_NONE;
-		    State &= ~LANGMAP;
-		}
-		else
-		{
-		    curbuf->b_p_iminsert = B_IMODE_LMAP;
-		    State |= LANGMAP;
-		}
-		return TRUE;
-	    }
-
-	    return gtk_im_context_filter_keypress(xic, event);
-	}
-
-	/* Don't filter events through the IM context if IM isn't active
-	 * right now.  Unlike with GTK+ 1.2 we cannot rely on the IM module
-	 * not doing anything before the activation key was sent. */
-	if (im_activatekey_keyval == GDK_VoidSymbol || im_is_active)
-	{
-	    int imresult = gtk_im_context_filter_keypress(xic, event);
-
-	    /* Some XIM send following sequence:
-	     * 1. preedited string.
-	     * 2. committed string.
-	     * 3. line changed key.
-	     * 4. preedited string.
-	     * 5. remove preedited string.
-	     * if 3, Vim can't move back the above line for 5.
-	     * thus, this part should not parse the key. */
-	    if (!imresult && preedit_start_col != MAXCOL
-					       && event->keyval == GDK_Return)
-	    {
-		im_synthesize_keypress(GDK_Return, 0U);
-		return FALSE;
-	    }
-
-	    /* If XIM tried to commit a keypad key as a single char.,
-	     * ignore it so we can use the keypad key 'raw', for mappings. */
-	    if (xim_expected_char != NUL && xim_ignored_char)
-		/* We had a keypad key, and XIM tried to thieve it */
-		return FALSE;
-
-	    /* Normal processing */
-	    return imresult;
-	}
-    }
-
-    return FALSE;
-}
-
-    int
-im_get_status(void)
-{
-    return im_is_active;
-}
-
-# else /* !HAVE_GTK2 */
-
-static int	xim_is_active = FALSE;  /* XIM should be active in the current
-					   mode */
-static int	xim_has_focus = FALSE;	/* XIM is really being used for Vim */
-#ifdef FEAT_GUI_X11
-static XIMStyle	input_style;
-static int	status_area_enabled = TRUE;
-#endif
-
-#ifdef FEAT_GUI_GTK
-# ifdef WIN3264
-#  include <gdk/gdkwin32.h>
-# else
-#  include <gdk/gdkx.h>
-# endif
-#else
-# ifdef PROTO
-/* Define a few things to be able to generate prototypes while not configured
- * for GTK. */
-#  define GSList int
-#  define gboolean int
-   typedef int GdkEvent;
-   typedef int GdkEventKey;
-#  define GdkIC int
-# endif
-#endif
-
-#if defined(FEAT_GUI_GTK) || defined(PROTO)
-static int	preedit_buf_len = 0;
-static int	xim_can_preediting INIT(= FALSE);	/* XIM in showmode() */
-static int	xim_input_style;
-#ifndef FEAT_GUI_GTK
-# define gboolean int
-#endif
-static gboolean	use_status_area = 0;
-
-static int im_xim_str2keycode __ARGS((unsigned int *code, unsigned int *state));
-static void im_xim_send_event_imactivate __ARGS((void));
-
-/*
- * Convert string to keycode and state for XKeyEvent.
- * When string is valid return OK, when invalid return FAIL.
- *
- * See 'imactivatekey' documentation for the format.
- */
-    static int
-im_xim_str2keycode(code, state)
-    unsigned int *code;
-    unsigned int *state;
-{
-    int		retval = OK;
-    int		len;
-    unsigned	keycode = 0, keystate = 0;
-    Window	window;
-    Display	*display;
-    char_u	*flag_end;
-    char_u	*str;
-
-    if (*p_imak != NUL)
-    {
-	len = STRLEN(p_imak);
-	for (flag_end = p_imak + len - 1;
-			    flag_end > p_imak && *flag_end != '-'; --flag_end)
-	    ;
-
-	/* Parse modifier keys */
-	for (str = p_imak; str < flag_end; ++str)
-	{
-	    switch (*str)
-	    {
-		case 's': case 'S':
-		    keystate |= ShiftMask;
-		    break;
-		case 'l': case 'L':
-		    keystate |= LockMask;
-		    break;
-		case 'c': case 'C':
-		    keystate |= ControlMask;
-		    break;
-		case '1':
-		    keystate |= Mod1Mask;
-		    break;
-		case '2':
-		    keystate |= Mod2Mask;
-		    break;
-		case '3':
-		    keystate |= Mod3Mask;
-		    break;
-		case '4':
-		    keystate |= Mod4Mask;
-		    break;
-		case '5':
-		    keystate |= Mod5Mask;
-		    break;
-		case '-':
-		    break;
-		default:
-		    retval = FAIL;
-	    }
-	}
-	if (*str == '-')
-	    ++str;
-
-	/* Get keycode from string. */
-	gui_get_x11_windis(&window, &display);
-	if (display)
-	    keycode = XKeysymToKeycode(display, XStringToKeysym((char *)str));
-	if (keycode == 0)
-	    retval = FAIL;
-
-	if (code != NULL)
-	    *code = keycode;
-	if (state != NULL)
-	    *state = keystate;
-    }
-    return retval;
-}
-
-    static void
-im_xim_send_event_imactivate()
-{
-    /* Force turn on preedit state by symulate keypress event.
-     * Keycode and state is specified by 'imactivatekey'.
-     */
-    XKeyEvent ev;
-
-    gui_get_x11_windis(&ev.window, &ev.display);
-    ev.root = RootWindow(ev.display, DefaultScreen(ev.display));
-    ev.subwindow = None;
-    ev.time = CurrentTime;
-    ev.x = 1;
-    ev.y = 1;
-    ev.x_root = 1;
-    ev.y_root = 1;
-    ev.same_screen = 1;
-    ev.type = KeyPress;
-    if (im_xim_str2keycode(&ev.keycode, &ev.state) == OK)
-	XSendEvent(ev.display, ev.window, 1, KeyPressMask, (XEvent*)&ev);
-}
-
-/*
- * Return TRUE if 'imactivatekey' has a valid value.
- */
-    int
-im_xim_isvalid_imactivate()
-{
-    return im_xim_str2keycode(NULL, NULL) == OK;
-}
-#endif /* FEAT_GUI_GTK */
-
-/*
- * Switch using XIM on/off.  This is used by the code that changes "State".
- */
-    void
-im_set_active(active)
-    int		active;
-{
-    if (xic == NULL)
-	return;
-
-    /* If 'imdisable' is set, XIM is never active. */
-    if (p_imdisable)
-	active = FALSE;
-#ifndef FEAT_GUI_GTK
-    else if (input_style & XIMPreeditPosition)
-	/* There is a problem in switching XIM off when preediting is used,
-	 * and it is not clear how this can be solved.  For now, keep XIM on
-	 * all the time, like it was done in Vim 5.8. */
-	active = TRUE;
-#endif
-
-    /* Remember the active state, it is needed when Vim gets keyboard focus. */
-    xim_is_active = active;
-
-#ifdef FEAT_GUI_GTK
-    /* When 'imactivatekey' has valid key-string, try to control XIM preedit
-     * state.  When 'imactivatekey' has no or invalid string, try old XIM
-     * focus control.
-     */
-    if (*p_imak != NUL)
-    {
-	/* BASIC STRATEGY:
-	 * Destroy old Input Context (XIC), and create new one.  New XIC
-	 * would have a state of preedit that is off.  When argument:active
-	 * is false, that's all.  Else argument:active is true, send a key
-	 * event specified by 'imactivatekey' to activate XIM preedit state.
-	 */
-
-	xim_is_active = TRUE; /* Disable old XIM focus control */
-	/* If we can monitor preedit state with preedit callback functions,
-	 * try least creation of new XIC.
-	 */
-	if (xim_input_style & (int)GDK_IM_PREEDIT_CALLBACKS)
-	{
-	    if (xim_can_preediting && !active)
-	    {
-		/* Force turn off preedit state.  With some IM
-		 * implementations, we cannot turn off preedit state by
-		 * symulate keypress event.  It is why using such a method
-		 * that destroy old IC (input context), and create new one.
-		 * When create new IC, its preedit state is usually off.
-		 */
-		xim_reset();
-		xim_set_focus(FALSE);
-		gdk_ic_destroy(xic);
-		xim_init();
-		xim_can_preediting = FALSE;
-	    }
-	    else if (!xim_can_preediting && active)
-		im_xim_send_event_imactivate();
-	}
-	else
-	{
-	    /* First, force destroy old IC, and create new one.  It
-	     * symulates "turning off preedit state".
-	     */
-	    xim_set_focus(FALSE);
-	    gdk_ic_destroy(xic);
-	    xim_init();
-	    xim_can_preediting = FALSE;
-
-	    /* 2nd, when requested to activate IM, symulate this by sending
-	     * the event.
-	     */
-	    if (active)
-	    {
-		im_xim_send_event_imactivate();
-		xim_can_preediting = TRUE;
-	    }
-	}
-    }
-    else
-    {
-# ifndef XIMPreeditUnKnown
-	/* X11R5 doesn't have these, it looks safe enough to define here. */
-	typedef unsigned long XIMPreeditState;
-#  define XIMPreeditUnKnown	0L
-#  define XIMPreeditEnable	1L
-#  define XIMPreeditDisable	(1L<<1)
-#  define XNPreeditState	"preeditState"
-# endif
-	XIMPreeditState preedit_state = XIMPreeditUnKnown;
-	XVaNestedList preedit_attr;
-	XIC pxic;
-
-	preedit_attr = XVaCreateNestedList(0,
-				XNPreeditState, &preedit_state,
-				NULL);
-	pxic = ((GdkICPrivate *)xic)->xic;
-
-	if (!XGetICValues(pxic, XNPreeditAttributes, preedit_attr, NULL))
-	{
-	    XFree(preedit_attr);
-	    preedit_attr = XVaCreateNestedList(0,
-				XNPreeditState,
-				active ? XIMPreeditEnable : XIMPreeditDisable,
-				NULL);
-	    XSetICValues(pxic, XNPreeditAttributes, preedit_attr, NULL);
-	    xim_can_preediting = active;
-	    xim_is_active = active;
-	}
-	XFree(preedit_attr);
-    }
-    if (xim_input_style & XIMPreeditCallbacks)
-    {
-	preedit_buf_len = 0;
-	init_preedit_start_col();
-    }
-#else
-# if 0
-	/* When had tested kinput2 + canna + Athena GUI version with
-	 * 'imactivatekey' is "s-space", im_xim_send_event_imactivate() did not
-	 * work correctly.  It just inserted one space.  I don't know why we
-	 * couldn't switch state of XIM preediting.  This is reason why these
-	 * codes are commented out.
-	 */
-	/* First, force destroy old IC, and create new one.  It symulates
-	 * "turning off preedit state".
-	 */
-	xim_set_focus(FALSE);
-	XDestroyIC(xic);
-	xic = NULL;
-	xim_init();
-
-	/* 2nd, when requested to activate IM, symulate this by sending the
-	 * event.
-	 */
-	if (active)
-	    im_xim_send_event_imactivate();
-# endif
-#endif
-    xim_set_preedit();
-}
-
-/*
- * Adjust using XIM for gaining or losing keyboard focus.  Also called when
- * "xim_is_active" changes.
- */
-    void
-xim_set_focus(focus)
-    int		focus;
-{
-    if (xic == NULL)
-	return;
-
-    /*
-     * XIM only gets focus when the Vim window has keyboard focus and XIM has
-     * been set active for the current mode.
-     */
-    if (focus && xim_is_active)
-    {
-	if (!xim_has_focus)
-	{
-	    xim_has_focus = TRUE;
-#ifdef FEAT_GUI_GTK
-	    gdk_im_begin(xic, gui.drawarea->window);
-#else
-	    XSetICFocus(xic);
-#endif
-	}
-    }
-    else
-    {
-	if (xim_has_focus)
-	{
-	    xim_has_focus = FALSE;
-#ifdef FEAT_GUI_GTK
-	    gdk_im_end();
-#else
-	    XUnsetICFocus(xic);
-#endif
-	}
-    }
-}
-
-/*ARGSUSED*/
-    void
-im_set_position(row, col)
-    int		row;
-    int		col;
-{
-    xim_set_preedit();
-}
-
-/*
- * Set the XIM to the current cursor position.
- */
-    void
-xim_set_preedit()
-{
-    if (xic == NULL)
-	return;
-
-    xim_set_focus(TRUE);
-
-#ifdef FEAT_GUI_GTK
-    if (gdk_im_ready())
-    {
-	int		attrmask;
-	GdkICAttr	*attr;
-
-	if (!xic_attr)
-	    return;
-
-	attr = xic_attr;
-	attrmask = 0;
-
-# ifdef FEAT_XFONTSET
-	if ((xim_input_style & (int)GDK_IM_PREEDIT_POSITION)
-		&& gui.fontset != NOFONTSET
-		&& gui.fontset->type == GDK_FONT_FONTSET)
-	{
-	    if (!xim_has_focus)
-	    {
-		if (attr->spot_location.y >= 0)
-		{
-		    attr->spot_location.x = 0;
-		    attr->spot_location.y = -100;
-		    attrmask |= (int)GDK_IC_SPOT_LOCATION;
-		}
-	    }
-	    else
-	    {
-		gint	width, height;
-
-		if (attr->spot_location.x != TEXT_X(gui.col)
-		    || attr->spot_location.y != TEXT_Y(gui.row))
-		{
-		    attr->spot_location.x = TEXT_X(gui.col);
-		    attr->spot_location.y = TEXT_Y(gui.row);
-		    attrmask |= (int)GDK_IC_SPOT_LOCATION;
-		}
-
-		gdk_window_get_size(gui.drawarea->window, &width, &height);
-		width -= 2 * gui.border_offset;
-		height -= 2 * gui.border_offset;
-		if (xim_input_style & (int)GDK_IM_STATUS_AREA)
-		    height -= gui.char_height;
-		if (attr->preedit_area.width != width
-		    || attr->preedit_area.height != height)
-		{
-		    attr->preedit_area.x = gui.border_offset;
-		    attr->preedit_area.y = gui.border_offset;
-		    attr->preedit_area.width = width;
-		    attr->preedit_area.height = height;
-		    attrmask |= (int)GDK_IC_PREEDIT_AREA;
-		}
-
-		if (attr->preedit_fontset != gui.current_font)
-		{
-		    attr->preedit_fontset = gui.current_font;
-		    attrmask |= (int)GDK_IC_PREEDIT_FONTSET;
-		}
-	    }
-	}
-# endif /* FEAT_XFONTSET */
-
-	if (xim_fg_color == INVALCOLOR)
-	{
-	    xim_fg_color = gui.def_norm_pixel;
-	    xim_bg_color = gui.def_back_pixel;
-	}
-	if (attr->preedit_foreground.pixel != xim_fg_color)
-	{
-	    attr->preedit_foreground.pixel = xim_fg_color;
-	    attrmask |= (int)GDK_IC_PREEDIT_FOREGROUND;
-	}
-	if (attr->preedit_background.pixel != xim_bg_color)
-	{
-	    attr->preedit_background.pixel = xim_bg_color;
-	    attrmask |= (int)GDK_IC_PREEDIT_BACKGROUND;
-	}
-
-	if (attrmask != 0)
-	    gdk_ic_set_attr(xic, attr, (GdkICAttributesType)attrmask);
-    }
-#else /* FEAT_GUI_GTK */
-    {
-	XVaNestedList attr_list;
-	XRectangle spot_area;
-	XPoint over_spot;
-	int line_space;
-
-	if (!xim_has_focus)
-	{
-	    /* hide XIM cursor */
-	    over_spot.x = 0;
-	    over_spot.y = -100; /* arbitrary invisible position */
-	    attr_list = (XVaNestedList) XVaCreateNestedList(0,
-							    XNSpotLocation,
-							    &over_spot,
-							    NULL);
-	    XSetICValues(xic, XNPreeditAttributes, attr_list, NULL);
-	    XFree(attr_list);
-	    return;
-	}
-
-	if (input_style & XIMPreeditPosition)
-	{
-	    if (xim_fg_color == INVALCOLOR)
-	    {
-		xim_fg_color = gui.def_norm_pixel;
-		xim_bg_color = gui.def_back_pixel;
-	    }
-	    over_spot.x = TEXT_X(gui.col);
-	    over_spot.y = TEXT_Y(gui.row);
-	    spot_area.x = 0;
-	    spot_area.y = 0;
-	    spot_area.height = gui.char_height * Rows;
-	    spot_area.width  = gui.char_width * Columns;
-	    line_space = gui.char_height;
-	    attr_list = (XVaNestedList) XVaCreateNestedList(0,
-					    XNSpotLocation, &over_spot,
-					    XNForeground, (Pixel) xim_fg_color,
-					    XNBackground, (Pixel) xim_bg_color,
-					    XNArea, &spot_area,
-					    XNLineSpace, line_space,
-					    NULL);
-	    if (XSetICValues(xic, XNPreeditAttributes, attr_list, NULL))
-		EMSG(_("E284: Cannot set IC values"));
-	    XFree(attr_list);
-	}
-    }
-#endif /* FEAT_GUI_GTK */
-}
-
-/*
- * Set up the status area.
- *
- * This should use a separate Widget, but that seems not possible, because
- * preedit_area and status_area should be set to the same window as for the
- * text input.  Unfortunately this means the status area pollutes the text
- * window...
- */
-    void
-xim_set_status_area()
-{
-    if (xic == NULL)
-	return;
-
-#ifdef FEAT_GUI_GTK
-# if defined(FEAT_XFONTSET)
-    if (use_status_area)
-    {
-	GdkICAttr	*attr;
-	int		style;
-	gint		width, height;
-	GtkWidget	*widget;
-	int		attrmask;
-
-	if (!xic_attr)
-	    return;
-
-	attr = xic_attr;
-	attrmask = 0;
-	style = (int)gdk_ic_get_style(xic);
-	if ((style & (int)GDK_IM_STATUS_MASK) == (int)GDK_IM_STATUS_AREA)
-	{
-	    if (gui.fontset != NOFONTSET
-		    && gui.fontset->type == GDK_FONT_FONTSET)
-	    {
-		widget = gui.mainwin;
-		gdk_window_get_size(widget->window, &width, &height);
-
-		attrmask |= (int)GDK_IC_STATUS_AREA;
-		attr->status_area.x = 0;
-		attr->status_area.y = height - gui.char_height - 1;
-		attr->status_area.width = width;
-		attr->status_area.height = gui.char_height;
-	    }
-	}
-	if (attrmask != 0)
-	    gdk_ic_set_attr(xic, attr, (GdkICAttributesType)attrmask);
-    }
-# endif
-#else
-    {
-	XVaNestedList preedit_list = 0, status_list = 0, list = 0;
-	XRectangle pre_area, status_area;
-
-	if (input_style & XIMStatusArea)
-	{
-	    if (input_style & XIMPreeditArea)
-	    {
-		XRectangle *needed_rect;
-
-		/* to get status_area width */
-		status_list = XVaCreateNestedList(0, XNAreaNeeded,
-						  &needed_rect, NULL);
-		XGetICValues(xic, XNStatusAttributes, status_list, NULL);
-		XFree(status_list);
-
-		status_area.width = needed_rect->width;
-	    }
-	    else
-		status_area.width = gui.char_width * Columns;
-
-	    status_area.x = 0;
-	    status_area.y = gui.char_height * Rows + gui.border_offset;
-	    if (gui.which_scrollbars[SBAR_BOTTOM])
-		status_area.y += gui.scrollbar_height;
-#ifdef FEAT_MENU
-	    if (gui.menu_is_active)
-		status_area.y += gui.menu_height;
-#endif
-	    status_area.height = gui.char_height;
-	    status_list = XVaCreateNestedList(0, XNArea, &status_area, NULL);
-	}
-	else
-	{
-	    status_area.x = 0;
-	    status_area.y = gui.char_height * Rows + gui.border_offset;
-	    if (gui.which_scrollbars[SBAR_BOTTOM])
-		status_area.y += gui.scrollbar_height;
-#ifdef FEAT_MENU
-	    if (gui.menu_is_active)
-		status_area.y += gui.menu_height;
-#endif
-	    status_area.width = 0;
-	    status_area.height = gui.char_height;
-	}
-
-	if (input_style & XIMPreeditArea)   /* off-the-spot */
-	{
-	    pre_area.x = status_area.x + status_area.width;
-	    pre_area.y = gui.char_height * Rows + gui.border_offset;
-	    pre_area.width = gui.char_width * Columns - pre_area.x;
-	    if (gui.which_scrollbars[SBAR_BOTTOM])
-		pre_area.y += gui.scrollbar_height;
-#ifdef FEAT_MENU
-	    if (gui.menu_is_active)
-		pre_area.y += gui.menu_height;
-#endif
-	    pre_area.height = gui.char_height;
-	    preedit_list = XVaCreateNestedList(0, XNArea, &pre_area, NULL);
-	}
-	else if (input_style & XIMPreeditPosition)   /* over-the-spot */
-	{
-	    pre_area.x = 0;
-	    pre_area.y = 0;
-	    pre_area.height = gui.char_height * Rows;
-	    pre_area.width = gui.char_width * Columns;
-	    preedit_list = XVaCreateNestedList(0, XNArea, &pre_area, NULL);
-	}
-
-	if (preedit_list && status_list)
-	    list = XVaCreateNestedList(0, XNPreeditAttributes, preedit_list,
-				       XNStatusAttributes, status_list, NULL);
-	else if (preedit_list)
-	    list = XVaCreateNestedList(0, XNPreeditAttributes, preedit_list,
-				       NULL);
-	else if (status_list)
-	    list = XVaCreateNestedList(0, XNStatusAttributes, status_list,
-				       NULL);
-	else
-	    list = NULL;
-
-	if (list)
-	{
-	    XSetICValues(xic, XNVaNestedList, list, NULL);
-	    XFree(list);
-	}
-	if (status_list)
-	    XFree(status_list);
-	if (preedit_list)
-	    XFree(preedit_list);
-    }
-#endif
-}
-
-#if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK)
-static char e_xim[] = N_("E285: Failed to create input context");
-#endif
-
-#if defined(FEAT_GUI_X11) || defined(PROTO)
-# if defined(XtSpecificationRelease) && XtSpecificationRelease >= 6 && !defined(sun)
-#  define USE_X11R6_XIM
-# endif
-
-static int xim_real_init __ARGS((Window x11_window, Display *x11_display));
-
-
-#ifdef USE_X11R6_XIM
-static void xim_instantiate_cb __ARGS((Display *display, XPointer client_data, XPointer	call_data));
-static void xim_destroy_cb __ARGS((XIM im, XPointer client_data, XPointer call_data));
-
-/*ARGSUSED*/
-    static void
-xim_instantiate_cb(display, client_data, call_data)
-    Display	*display;
-    XPointer	client_data;
-    XPointer	call_data;
-{
-    Window	x11_window;
-    Display	*x11_display;
-
-#ifdef XIM_DEBUG
-    xim_log("xim_instantiate_cb()\n");
-#endif
-
-    gui_get_x11_windis(&x11_window, &x11_display);
-    if (display != x11_display)
-	return;
-
-    xim_real_init(x11_window, x11_display);
-    gui_set_shellsize(FALSE, FALSE);
-    if (xic != NULL)
-	XUnregisterIMInstantiateCallback(x11_display, NULL, NULL, NULL,
-					 xim_instantiate_cb, NULL);
-}
-
-/*ARGSUSED*/
-    static void
-xim_destroy_cb(im, client_data, call_data)
-    XIM		im;
-    XPointer	client_data;
-    XPointer	call_data;
-{
-    Window	x11_window;
-    Display	*x11_display;
-
-#ifdef XIM_DEBUG
-    xim_log("xim_destroy_cb()\n");
-#endif
-    gui_get_x11_windis(&x11_window, &x11_display);
-
-    xic = NULL;
-    status_area_enabled = FALSE;
-
-    gui_set_shellsize(FALSE, FALSE);
-
-    XRegisterIMInstantiateCallback(x11_display, NULL, NULL, NULL,
-				   xim_instantiate_cb, NULL);
-}
-#endif
-
-    void
-xim_init()
-{
-    Window	x11_window;
-    Display	*x11_display;
-
-#ifdef XIM_DEBUG
-    xim_log("xim_init()\n");
-#endif
-
-    gui_get_x11_windis(&x11_window, &x11_display);
-
-    xic = NULL;
-
-    if (xim_real_init(x11_window, x11_display))
-	return;
-
-    gui_set_shellsize(FALSE, FALSE);
-
-#ifdef USE_X11R6_XIM
-    XRegisterIMInstantiateCallback(x11_display, NULL, NULL, NULL,
-				   xim_instantiate_cb, NULL);
-#endif
-}
-
-    static int
-xim_real_init(x11_window, x11_display)
-    Window	x11_window;
-    Display	*x11_display;
-{
-    int		i;
-    char	*p,
-		*s,
-		*ns,
-		*end,
-		tmp[1024];
-#define IMLEN_MAX 40
-    char	buf[IMLEN_MAX + 7];
-    XIM		xim = NULL;
-    XIMStyles	*xim_styles;
-    XIMStyle	this_input_style = 0;
-    Boolean	found;
-    XPoint	over_spot;
-    XVaNestedList preedit_list, status_list;
-
-    input_style = 0;
-    status_area_enabled = FALSE;
-
-    if (xic != NULL)
-	return FALSE;
-
-    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
-    {
-	strcpy(tmp, gui.rsrc_input_method);
-	for (ns = s = tmp; ns != NULL && *s != NUL;)
-	{
-	    s = (char *)skipwhite((char_u *)s);
-	    if (*s == NUL)
-		break;
-	    if ((ns = end = strchr(s, ',')) == NULL)
-		end = s + strlen(s);
-	    while (isspace(((char_u *)end)[-1]))
-		end--;
-	    *end = NUL;
-
-	    if (strlen(s) <= IMLEN_MAX)
-	    {
-		strcpy(buf, "@im=");
-		strcat(buf, s);
-		if ((p = XSetLocaleModifiers(buf)) != NULL && *p != NUL
-			&& (xim = XOpenIM(x11_display, NULL, NULL, NULL))
-								      != NULL)
-		    break;
-	    }
-
-	    s = ns + 1;
-	}
-    }
-
-    if (xim == NULL && (p = XSetLocaleModifiers("")) != NULL && *p != NUL)
-	xim = XOpenIM(x11_display, NULL, NULL, NULL);
-
-    /* This is supposed to be useful to obtain characters through
-     * XmbLookupString() without really using a XIM. */
-    if (xim == NULL && (p = XSetLocaleModifiers("@im=none")) != NULL
-								 && *p != NUL)
-	xim = XOpenIM(x11_display, NULL, NULL, NULL);
-
-    if (xim == NULL)
-    {
-	/* Only give this message when verbose is set, because too many people
-	 * got this message when they didn't want to use a XIM. */
-	if (p_verbose > 0)
-	    EMSG(_("E286: Failed to open input method"));
-	return FALSE;
-    }
-
-#ifdef USE_X11R6_XIM
-    {
-	XIMCallback destroy_cb;
-
-	destroy_cb.callback = xim_destroy_cb;
-	destroy_cb.client_data = NULL;
-	if (XSetIMValues(xim, XNDestroyCallback, &destroy_cb, NULL))
-	    EMSG(_("E287: Warning: Could not set destroy callback to IM"));
-    }
-#endif
-
-    if (XGetIMValues(xim, XNQueryInputStyle, &xim_styles, NULL) || !xim_styles)
-    {
-	EMSG(_("E288: input method doesn't support any style"));
-	XCloseIM(xim);
-	return FALSE;
-    }
-
-    found = False;
-    strcpy(tmp, gui.rsrc_preedit_type_name);
-    for (s = tmp; s && !found; )
-    {
-	while (*s && isspace((unsigned char)*s))
-	    s++;
-	if (!*s)
-	    break;
-	if ((ns = end = strchr(s, ',')) != 0)
-	    ns++;
-	else
-	    end = s + strlen(s);
-	while (isspace((unsigned char)*end))
-	    end--;
-	*end = '\0';
-
-	if (!strcmp(s, "OverTheSpot"))
-	    this_input_style = (XIMPreeditPosition | XIMStatusArea);
-	else if (!strcmp(s, "OffTheSpot"))
-	    this_input_style = (XIMPreeditArea | XIMStatusArea);
-	else if (!strcmp(s, "Root"))
-	    this_input_style = (XIMPreeditNothing | XIMStatusNothing);
-
-	for (i = 0; (unsigned short)i < xim_styles->count_styles; i++)
-	{
-	    if (this_input_style == xim_styles->supported_styles[i])
-	    {
-		found = True;
-		break;
-	    }
-	}
-	if (!found)
-	    for (i = 0; (unsigned short)i < xim_styles->count_styles; i++)
-	    {
-		if ((xim_styles->supported_styles[i] & this_input_style)
-			== (this_input_style & ~XIMStatusArea))
-		{
-		    this_input_style &= ~XIMStatusArea;
-		    found = True;
-		    break;
-		}
-	    }
-
-	s = ns;
-    }
-    XFree(xim_styles);
-
-    if (!found)
-    {
-	/* Only give this message when verbose is set, because too many people
-	 * got this message when they didn't want to use a XIM. */
-	if (p_verbose > 0)
-	    EMSG(_("E289: input method doesn't support my preedit type"));
-	XCloseIM(xim);
-	return FALSE;
-    }
-
-    over_spot.x = TEXT_X(gui.col);
-    over_spot.y = TEXT_Y(gui.row);
-    input_style = this_input_style;
-
-    /* A crash was reported when trying to pass gui.norm_font as XNFontSet,
-     * thus that has been removed.  Hopefully the default works... */
-#ifdef FEAT_XFONTSET
-    if (gui.fontset != NOFONTSET)
-    {
-	preedit_list = XVaCreateNestedList(0,
-				XNSpotLocation, &over_spot,
-				XNForeground, (Pixel)gui.def_norm_pixel,
-				XNBackground, (Pixel)gui.def_back_pixel,
-				XNFontSet, (XFontSet)gui.fontset,
-				NULL);
-	status_list = XVaCreateNestedList(0,
-				XNForeground, (Pixel)gui.def_norm_pixel,
-				XNBackground, (Pixel)gui.def_back_pixel,
-				XNFontSet, (XFontSet)gui.fontset,
-				NULL);
-    }
-    else
-#endif
-    {
-	preedit_list = XVaCreateNestedList(0,
-				XNSpotLocation, &over_spot,
-				XNForeground, (Pixel)gui.def_norm_pixel,
-				XNBackground, (Pixel)gui.def_back_pixel,
-				NULL);
-	status_list = XVaCreateNestedList(0,
-				XNForeground, (Pixel)gui.def_norm_pixel,
-				XNBackground, (Pixel)gui.def_back_pixel,
-				NULL);
-    }
-
-    xic = XCreateIC(xim,
-		    XNInputStyle, input_style,
-		    XNClientWindow, x11_window,
-		    XNFocusWindow, gui.wid,
-		    XNPreeditAttributes, preedit_list,
-		    XNStatusAttributes, status_list,
-		    NULL);
-    XFree(status_list);
-    XFree(preedit_list);
-    if (xic != NULL)
-    {
-	if (input_style & XIMStatusArea)
-	{
-	    xim_set_status_area();
-	    status_area_enabled = TRUE;
-	}
-	else
-	    gui_set_shellsize(FALSE, FALSE);
-    }
-    else
-    {
-	EMSG(_(e_xim));
-	XCloseIM(xim);
-	return FALSE;
-    }
-
-    return TRUE;
-}
-
-#endif /* FEAT_GUI_X11 */
-
-#if defined(FEAT_GUI_GTK) || defined(PROTO)
-
-# ifdef FEAT_XFONTSET
-static char e_overthespot[] = N_("E290: over-the-spot style requires fontset");
-# endif
-
-# ifdef PROTO
-typedef int GdkIC;
-# endif
-
-    void
-xim_decide_input_style()
-{
-    /* GDK_IM_STATUS_CALLBACKS was disabled, enabled it to allow Japanese
-     * OverTheSpot. */
-    int supported_style = (int)GDK_IM_PREEDIT_NONE |
-				 (int)GDK_IM_PREEDIT_NOTHING |
-				 (int)GDK_IM_PREEDIT_POSITION |
-				 (int)GDK_IM_PREEDIT_CALLBACKS |
-				 (int)GDK_IM_STATUS_CALLBACKS |
-				 (int)GDK_IM_STATUS_AREA |
-				 (int)GDK_IM_STATUS_NONE |
-				 (int)GDK_IM_STATUS_NOTHING;
-
-#ifdef XIM_DEBUG
-    xim_log("xim_decide_input_style()\n");
-#endif
-
-    if (!gdk_im_ready())
-	xim_input_style = 0;
-    else
-    {
-	if (gtk_major_version > 1
-		|| (gtk_major_version == 1
-		    && (gtk_minor_version > 2
-			|| (gtk_minor_version == 2 && gtk_micro_version >= 3))))
-	    use_status_area = TRUE;
-	else
-	{
-	    EMSG(_("E291: Your GTK+ is older than 1.2.3. Status area disabled"));
-	    use_status_area = FALSE;
-	}
-#ifdef FEAT_XFONTSET
-	if (gui.fontset == NOFONTSET || gui.fontset->type != GDK_FONT_FONTSET)
-#endif
-	    supported_style &= ~((int)GDK_IM_PREEDIT_POSITION
-						   | (int)GDK_IM_STATUS_AREA);
-	if (!use_status_area)
-	    supported_style &= ~(int)GDK_IM_STATUS_AREA;
-	xim_input_style = (int)gdk_im_decide_style((GdkIMStyle)supported_style);
-    }
-}
-
-/*ARGSUSED*/
-    static void
-preedit_start_cbproc(XIC xic, XPointer client_data, XPointer call_data)
-{
-#ifdef XIM_DEBUG
-    xim_log("xim_decide_input_style()\n");
-#endif
-
-    draw_feedback = NULL;
-    xim_can_preediting = TRUE;
-    xim_has_preediting = TRUE;
-    gui_update_cursor(TRUE, FALSE);
-    if (showmode() > 0)
-    {
-	setcursor();
-	out_flush();
-    }
-}
-
-    static void
-xim_back_delete(int n)
-{
-    char_u str[3];
-
-    str[0] = CSI;
-    str[1] = 'k';
-    str[2] = 'b';
-    while (n-- > 0)
-	add_to_input_buf(str, 3);
-}
-
-static GSList *key_press_event_queue = NULL;
-static gboolean processing_queued_event = FALSE;
-
-/*ARGSUSED*/
-    static void
-preedit_draw_cbproc(XIC xic, XPointer client_data, XPointer call_data)
-{
-    XIMPreeditDrawCallbackStruct *draw_data;
-    XIMText	*text;
-    char	*src;
-    GSList	*event_queue;
-
-#ifdef XIM_DEBUG
-    xim_log("preedit_draw_cbproc()\n");
-#endif
-
-    draw_data = (XIMPreeditDrawCallbackStruct *) call_data;
-    text = (XIMText *) draw_data->text;
-
-    if ((text == NULL && draw_data->chg_length == preedit_buf_len)
-						      || preedit_buf_len == 0)
-    {
-	init_preedit_start_col();
-	vim_free(draw_feedback);
-	draw_feedback = NULL;
-    }
-    if (draw_data->chg_length > 0)
-    {
-	int bs_cnt;
-
-	if (draw_data->chg_length > preedit_buf_len)
-	    bs_cnt = preedit_buf_len;
-	else
-	    bs_cnt = draw_data->chg_length;
-	xim_back_delete(bs_cnt);
-	preedit_buf_len -= bs_cnt;
-    }
-    if (text != NULL)
-    {
-	int		len;
-#ifdef FEAT_MBYTE
-	char_u		*buf = NULL;
-	unsigned int	nfeedback = 0;
-#endif
-	char_u		*ptr;
-
-	src = text->string.multi_byte;
-	if (src != NULL && !text->encoding_is_wchar)
-	{
-	    len = strlen(src);
-	    ptr = (char_u *)src;
-	    /* Avoid the enter for decision */
-	    if (*ptr == '\n')
-		return;
-
-#ifdef FEAT_MBYTE
-	    if (input_conv.vc_type != CONV_NONE
-		    && (buf = string_convert(&input_conv,
-						 (char_u *)src, &len)) != NULL)
-	    {
-		/* Converted from 'termencoding' to 'encoding'. */
-		add_to_input_buf_csi(buf, len);
-		ptr = buf;
-	    }
-	    else
-#endif
-		add_to_input_buf_csi((char_u *)src, len);
-	    /* Add count of character to preedit_buf_len  */
-	    while (*ptr != NUL)
-	    {
-#ifdef FEAT_MBYTE
-		if (draw_data->text->feedback != NULL)
-		{
-		    if (draw_feedback == NULL)
-			draw_feedback = (char *)alloc(draw_data->chg_first
-							      + text->length);
-		    else
-			draw_feedback = realloc(draw_feedback,
-					 draw_data->chg_first + text->length);
-		    if (draw_feedback != NULL)
-		    {
-			draw_feedback[nfeedback + draw_data->chg_first]
-				       = draw_data->text->feedback[nfeedback];
-			nfeedback++;
-		    }
-		}
-		if (has_mbyte)
-		    ptr += mb_ptr2len_check(ptr);
-		else
-#endif
-		    ptr++;
-		preedit_buf_len++;
-	    }
-#ifdef FEAT_MBYTE
-	    vim_free(buf);
-#endif
-	    preedit_end_col = MAXCOL;
-	}
-    }
-    if (text != NULL || draw_data->chg_length > 0)
-    {
-	event_queue = key_press_event_queue;
-	processing_queued_event = TRUE;
-	while (event_queue != NULL && processing_queued_event)
-	{
-	    GdkEvent *ev = event_queue->data;
-
-	    gboolean *ret;
-	    gtk_signal_emit_by_name((GtkObject*)gui.mainwin, "key_press_event",
-								    ev, &ret);
-	    gdk_event_free(ev);
-	    event_queue = event_queue->next;
-	}
-	processing_queued_event = FALSE;
-	if (key_press_event_queue)
-	{
-	    g_slist_free(key_press_event_queue);
-	    key_press_event_queue = NULL;
-	}
-    }
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
-}
-
-/*
- * Retrieve the highlighting attributes at column col in the preedit string.
- * Return -1 if not in preediting mode or if col is out of range.
- */
-    int
-im_get_feedback_attr(int col)
-{
-    if (draw_feedback != NULL && col < preedit_buf_len)
-    {
-	if (draw_feedback[col] & XIMReverse)
-	    return HL_INVERSE;
-	else if (draw_feedback[col] & XIMUnderline)
-	    return HL_UNDERLINE;
-	else
-	    return hl_attr(HLF_V);
-    }
-
-    return -1;
-}
-
-/*ARGSUSED*/
-    static void
-preedit_caret_cbproc(XIC xic, XPointer client_data, XPointer call_data)
-{
-#ifdef XIM_DEBUG
-    xim_log("preedit_caret_cbproc()\n");
-#endif
-}
-
-/*ARGSUSED*/
-    static void
-preedit_done_cbproc(XIC xic, XPointer client_data, XPointer call_data)
-{
-#ifdef XIM_DEBUG
-    xim_log("preedit_done_cbproc()\n");
-#endif
-
-    vim_free(draw_feedback);
-    draw_feedback = NULL;
-    xim_can_preediting = FALSE;
-    xim_has_preediting = FALSE;
-    gui_update_cursor(TRUE, FALSE);
-    if (showmode() > 0)
-    {
-	setcursor();
-	out_flush();
-    }
-}
-
-    void
-xim_reset(void)
-{
-    char *text;
-
-#ifdef XIM_DEBUG
-    xim_log("xim_reset()\n");
-#endif
-
-    if (xic != NULL)
-    {
-	text = XmbResetIC(((GdkICPrivate *)xic)->xic);
-	if (text != NULL && !(xim_input_style & (int)GDK_IM_PREEDIT_CALLBACKS))
-	    add_to_input_buf_csi((char_u *)text, strlen(text));
-	else
-	    preedit_buf_len = 0;
-	if (text != NULL)
-	    XFree(text);
-    }
-}
-
-/*ARGSUSED*/
-    int
-xim_queue_key_press_event(GdkEventKey *event, int down)
-{
-#ifdef XIM_DEBUG
-    xim_log("xim_queue_key_press_event()\n");
-#endif
-
-    if (preedit_buf_len <= 0)
-	return FALSE;
-    if (processing_queued_event)
-	processing_queued_event = FALSE;
-
-    key_press_event_queue = g_slist_append(key_press_event_queue,
-					   gdk_event_copy((GdkEvent *)event));
-    return TRUE;
-}
-
-/*ARGSUSED*/
-    static void
-preedit_callback_setup(GdkIC *ic)
-{
-    XIC xxic;
-    XVaNestedList preedit_attr;
-    XIMCallback preedit_start_cb;
-    XIMCallback preedit_draw_cb;
-    XIMCallback preedit_caret_cb;
-    XIMCallback preedit_done_cb;
-
-    xxic = ((GdkICPrivate*)xic)->xic;
-    preedit_start_cb.callback = (XIMProc)preedit_start_cbproc;
-    preedit_draw_cb.callback = (XIMProc)preedit_draw_cbproc;
-    preedit_caret_cb.callback = (XIMProc)preedit_caret_cbproc;
-    preedit_done_cb.callback = (XIMProc)preedit_done_cbproc;
-    preedit_attr
-	= XVaCreateNestedList (0,
-			       XNPreeditStartCallback, &preedit_start_cb,
-			       XNPreeditDrawCallback, &preedit_draw_cb,
-			       XNPreeditCaretCallback, &preedit_caret_cb,
-			       XNPreeditDoneCallback, &preedit_done_cb,
-			       0);
-    XSetICValues (xxic, XNPreeditAttributes, preedit_attr, 0);
-    XFree(preedit_attr);
-}
-
-/*ARGSUSED*/
-    static void
-reset_state_setup(GdkIC *ic)
-{
-#ifdef USE_X11R6_XIM
-    /* don't change the input context when we call reset */
-    XSetICValues(((GdkICPrivate*)ic)->xic, XNResetState, XIMPreserveState, 0);
-#endif
-}
-
-    void
-xim_init(void)
-{
-#ifdef XIM_DEBUG
-    xim_log("xim_init()\n");
-#endif
-
-    xic = NULL;
-    xic_attr = NULL;
-
-    if (!gdk_im_ready())
-    {
-	if (p_verbose > 0)
-	    EMSG(_("E292: Input Method Server is not running"));
-	return;
-    }
-    if ((xic_attr = gdk_ic_attr_new()) != NULL)
-    {
-#ifdef FEAT_XFONTSET
-	gint width, height;
-#endif
-	int		mask;
-	GdkColormap	*colormap;
-	GdkICAttr	*attr = xic_attr;
-	int		attrmask = (int)GDK_IC_ALL_REQ;
-	GtkWidget	*widget = gui.drawarea;
-
-	attr->style = (GdkIMStyle)xim_input_style;
-	attr->client_window = gui.mainwin->window;
-
-	if ((colormap = gtk_widget_get_colormap(widget)) !=
-	    gtk_widget_get_default_colormap())
-	{
-	    attrmask |= (int)GDK_IC_PREEDIT_COLORMAP;
-	    attr->preedit_colormap = colormap;
-	}
-	attrmask |= (int)GDK_IC_PREEDIT_FOREGROUND;
-	attrmask |= (int)GDK_IC_PREEDIT_BACKGROUND;
-	attr->preedit_foreground = widget->style->fg[GTK_STATE_NORMAL];
-	attr->preedit_background = widget->style->base[GTK_STATE_NORMAL];
-
-#ifdef FEAT_XFONTSET
-	if ((xim_input_style & (int)GDK_IM_PREEDIT_MASK)
-					      == (int)GDK_IM_PREEDIT_POSITION)
-	{
-	    if (gui.fontset == NOFONTSET
-		    || gui.fontset->type != GDK_FONT_FONTSET)
-	    {
-		EMSG(_(e_overthespot));
-	    }
-	    else
-	    {
-		gdk_window_get_size(widget->window, &width, &height);
-
-		attrmask |= (int)GDK_IC_PREEDIT_POSITION_REQ;
-		attr->spot_location.x = TEXT_X(0);
-		attr->spot_location.y = TEXT_Y(0);
-		attr->preedit_area.x = gui.border_offset;
-		attr->preedit_area.y = gui.border_offset;
-		attr->preedit_area.width = width - 2*gui.border_offset;
-		attr->preedit_area.height = height - 2*gui.border_offset;
-		attr->preedit_fontset = gui.fontset;
-	    }
-	}
-
-	if ((xim_input_style & (int)GDK_IM_STATUS_MASK)
-						   == (int)GDK_IM_STATUS_AREA)
-	{
-	    if (gui.fontset == NOFONTSET
-		    || gui.fontset->type != GDK_FONT_FONTSET)
-	    {
-		EMSG(_(e_overthespot));
-	    }
-	    else
-	    {
-		gdk_window_get_size(gui.mainwin->window, &width, &height);
-		attrmask |= (int)GDK_IC_STATUS_AREA_REQ;
-		attr->status_area.x = 0;
-		attr->status_area.y = height - gui.char_height - 1;
-		attr->status_area.width = width;
-		attr->status_area.height = gui.char_height;
-		attr->status_fontset = gui.fontset;
-	    }
-	}
-	else if ((xim_input_style & (int)GDK_IM_STATUS_MASK)
-					      == (int)GDK_IM_STATUS_CALLBACKS)
-	{
-	    /* FIXME */
-	}
-#endif
-
-	xic = gdk_ic_new(attr, (GdkICAttributesType)attrmask);
-
-	if (xic == NULL)
-	    EMSG(_(e_xim));
-	else
-	{
-	    mask = (int)gdk_window_get_events(widget->window);
-	    mask |= (int)gdk_ic_get_events(xic);
-	    gdk_window_set_events(widget->window, (GdkEventMask)mask);
-	    if (xim_input_style & (int)GDK_IM_PREEDIT_CALLBACKS)
-		preedit_callback_setup(xic);
-	    reset_state_setup(xic);
-	}
-    }
-}
-
-    void
-im_shutdown(void)
-{
-#ifdef XIM_DEBUG
-    xim_log("im_shutdown()\n");
-#endif
-
-    if (xic != NULL)
-    {
-	gdk_im_end();
-	gdk_ic_destroy(xic);
-	xic = NULL;
-    }
-    xim_is_active = FALSE;
-    xim_can_preediting = FALSE;
-    preedit_start_col = MAXCOL;
-    xim_has_preediting = FALSE;
-}
-
-#endif /* FEAT_GUI_GTK */
-
-    int
-xim_get_status_area_height()
-{
-#ifdef FEAT_GUI_GTK
-    if (xim_input_style & (int)GDK_IM_STATUS_AREA)
-	return gui.char_height;
-#else
-    if (status_area_enabled)
-	return gui.char_height;
-#endif
-    return 0;
-}
-
-/*
- * Get IM status.  When IM is on, return TRUE.  Else return FALSE.
- * FIXME: This doesn't work correctly: Having focus doesn't always mean XIM is
- * active, when not having focus XIM may still be active (e.g., when using a
- * tear-off menu item).
- */
-    int
-im_get_status()
-{
-#  ifdef FEAT_GUI_GTK
-    if (xim_input_style & (int)GDK_IM_PREEDIT_CALLBACKS)
-	return xim_can_preediting;
-#  endif
-    return xim_has_focus;
-}
-
-# endif /* !HAVE_GTK2 */
-
-# if defined(FEAT_GUI_GTK) || defined(PROTO)
-    int
-im_is_preediting()
-{
-    return xim_has_preediting;
-}
-# endif
-#endif /* FEAT_XIM */
-
-#if defined(FEAT_MBYTE) || defined(PROTO)
-
-/*
- * Setup "vcp" for conversion from "from" to "to".
- * The names must have been made canonical with enc_canonize().
- * vcp->vc_type must have been initialized to CONV_NONE.
- * Note: cannot be used for conversion from/to ucs-2 and ucs-4 (will use utf-8
- * instead).
- * Afterwards invoke with "from" and "to" equal to NULL to cleanup.
- * Return FAIL when conversion is not supported, OK otherwise.
- */
-    int
-convert_setup(vcp, from, to)
-    vimconv_T	*vcp;
-    char_u	*from;
-    char_u	*to;
-{
-    int		from_prop;
-    int		to_prop;
-
-    /* Reset to no conversion. */
-# ifdef USE_ICONV
-    if (vcp->vc_type == CONV_ICONV && vcp->vc_fd != (iconv_t)-1)
-	iconv_close(vcp->vc_fd);
-# endif
-    vcp->vc_type = CONV_NONE;
-    vcp->vc_factor = 1;
-    vcp->vc_fail = FALSE;
-
-    /* No conversion when one of the names is empty or they are equal. */
-    if (from == NULL || *from == NUL || to == NULL || *to == NUL
-						     || STRCMP(from, to) == 0)
-	return OK;
-
-    from_prop = enc_canon_props(from);
-    to_prop = enc_canon_props(to);
-    if ((from_prop & ENC_LATIN1) && (to_prop & ENC_UNICODE))
-    {
-	/* Internal latin1 -> utf-8 conversion. */
-	vcp->vc_type = CONV_TO_UTF8;
-	vcp->vc_factor = 2;	/* up to twice as long */
-    }
-    else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_LATIN1))
-    {
-	/* Internal utf-8 -> latin1 conversion. */
-	vcp->vc_type = CONV_TO_LATIN1;
-    }
-#ifdef WIN3264
-    /* Win32-specific codepage <-> codepage conversion without iconv. */
-    else if (((from_prop & ENC_UNICODE) || encname2codepage(from) > 0)
-	    && ((to_prop & ENC_UNICODE) || encname2codepage(to) > 0))
-    {
-	vcp->vc_type = CONV_CODEPAGE;
-	vcp->vc_factor = 2;	/* up to twice as long */
-	vcp->vc_cpfrom = (from_prop & ENC_UNICODE) ? 0 : encname2codepage(from);
-	vcp->vc_cpto = (to_prop & ENC_UNICODE) ? 0 : encname2codepage(to);
-    }
-#endif
-#ifdef MACOS_X
-    else if ((from_prop & ENC_MACROMAN) && (to_prop & ENC_LATIN1))
-    {
-	vcp->vc_type = CONV_MAC_LATIN1;
-    }
-    else if ((from_prop & ENC_MACROMAN) && (to_prop & ENC_UNICODE))
-    {
-	vcp->vc_type = CONV_MAC_UTF8;
-	vcp->vc_factor = 2;	/* up to twice as long */
-    }
-    else if ((from_prop & ENC_LATIN1) && (to_prop & ENC_MACROMAN))
-    {
-	vcp->vc_type = CONV_LATIN1_MAC;
-    }
-    else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_MACROMAN))
-    {
-	vcp->vc_type = CONV_UTF8_MAC;
-    }
-#endif
-# ifdef USE_ICONV
-    else
-    {
-	/* Use iconv() for conversion. */
-	vcp->vc_fd = (iconv_t)my_iconv_open(
-		(to_prop & ENC_UNICODE) ? (char_u *)"utf-8" : to,
-		(from_prop & ENC_UNICODE) ? (char_u *)"utf-8" : from);
-	if (vcp->vc_fd != (iconv_t)-1)
-	{
-	    vcp->vc_type = CONV_ICONV;
-	    vcp->vc_factor = 4;	/* could be longer too... */
-	}
-    }
-# endif
-    if (vcp->vc_type == CONV_NONE)
-	return FAIL;
-    return OK;
-}
-
-#if defined(FEAT_GUI) || defined(AMIGA) || defined(WIN3264) \
-	|| defined(MSDOS) || defined(PROTO)
-/*
- * Do conversion on typed input characters in-place.
- * The input and output are not NUL terminated!
- * Returns the length after conversion.
- */
-    int
-convert_input(ptr, len, maxlen)
-    char_u	*ptr;
-    int		len;
-    int		maxlen;
-{
-    return convert_input_safe(ptr, len, maxlen, NULL, NULL);
-}
-#endif
-
-/*
- * Like convert_input(), but when there is an incomplete byte sequence at the
- * end return that as an allocated string in "restp" and set "*restlenp" to
- * the length.  If "restp" is NULL it is not used.
- */
-    int
-convert_input_safe(ptr, len, maxlen, restp, restlenp)
-    char_u	*ptr;
-    int		len;
-    int		maxlen;
-    char_u	**restp;
-    int		*restlenp;
-{
-    char_u	*d;
-    int		dlen = len;
-    int		unconvertlen = 0;
-
-    d = string_convert_ext(&input_conv, ptr, &dlen,
-					restp == NULL ? NULL : &unconvertlen);
-    if (d != NULL)
-    {
-	if (dlen <= maxlen)
-	{
-	    if (unconvertlen > 0)
-	    {
-		/* Move the unconverted characters to allocated memory. */
-		*restp = alloc(unconvertlen);
-		if (*restp != NULL)
-		    mch_memmove(*restp, ptr + len - unconvertlen, unconvertlen);
-		*restlenp = unconvertlen;
-	    }
-	    mch_memmove(ptr, d, dlen);
-	}
-	else
-	    /* result is too long, keep the unconverted text (the caller must
-	     * have done something wrong!) */
-	    dlen = len;
-	vim_free(d);
-    }
-    return dlen;
-}
-
-#if defined(MACOS_X)
-static char_u *mac_string_convert __ARGS((char_u *ptr, int len, int *lenp, int fail_on_error, CFStringEncoding from, CFStringEncoding to, int *unconvlenp));
-
-/*
- * A Mac version of string_convert_ext() for special cases.
- */
-    static char_u *
-mac_string_convert(ptr, len, lenp, fail_on_error, from, to, unconvlenp)
-    char_u		*ptr;
-    int			len;
-    int			*lenp;
-    int			fail_on_error;
-    CFStringEncoding	from;
-    CFStringEncoding	to;
-    int			*unconvlenp;
-{
-    char_u		*retval, *d;
-    CFStringRef		cfstr;
-    int			buflen, in, out, l, i;
-
-    if (unconvlenp != NULL)
-	*unconvlenp = 0;
-    cfstr = CFStringCreateWithBytes(NULL, ptr, len, from, 0);
-    /* When conversion failed, try excluding bytes from the end, helps when
-     * there is an incomplete byte sequence.  Only do up to 6 bytes to avoid
-     * looping a long time when there really is something unconvertable. */
-    while (cfstr == NULL && unconvlenp != NULL && len > 1 && *unconvlenp < 6)
-    {
-	--len;
-	++*unconvlenp;
-	cfstr = CFStringCreateWithBytes(NULL, ptr, len, from, 0);
-    }
-    if (cfstr == NULL)
-	return NULL;
-    if (to == kCFStringEncodingUTF8)
-	buflen = len * 6 + 1;
-    else
-	buflen = len + 1;
-    retval = alloc(buflen);
-    if (retval == NULL)
-    {
-	CFRelease(cfstr);
-	return NULL;
-    }
-    if (!CFStringGetCString(cfstr, retval, buflen, to))
-    {
-	CFRelease(cfstr);
-	if (fail_on_error)
-	{
-	    vim_free(retval);
-	    return NULL;
-	}
-
-	/* conversion failed for the whole string, but maybe it will work
-	 * for each character */
-	for (d = retval, in = 0, out = 0; in < len && out < buflen - 1;)
-	{
-	    if (from == kCFStringEncodingUTF8)
-		l = utf_ptr2len_check(ptr + in);
-	    else
-		l = 1;
-	    cfstr = CFStringCreateWithBytes(NULL, ptr + in, l, from, 0);
-	    if (cfstr == NULL)
-	    {
-		*d++ = '?';
-		out++;
-	    }
-	    else
-	    {
-		if (!CFStringGetCString(cfstr, d, buflen - out, to))
-		{
-		    *d++ = '?';
-		    out++;
-		}
-		else
-		{
-		    i = strlen(d);
-		    d += i;
-		    out += i;
-		}
-		CFRelease(cfstr);
-	    }
-	    in += l;
-	}
-	*d = NUL;
-	if (lenp != NULL)
-	    *lenp = out;
-	return retval;
-    }
-    CFRelease(cfstr);
-    if (lenp != NULL)
-	*lenp = strlen(retval);
-    return retval;
-}
-#endif
-
-/*
- * Convert text "ptr[*lenp]" according to "vcp".
- * Returns the result in allocated memory and sets "*lenp".
- * When "lenp" is NULL, use NUL terminated strings.
- * Illegal chars are often changed to "?", unless vcp->vc_fail is set.
- * When something goes wrong, NULL is returned and "*lenp" is unchanged.
- */
-    char_u *
-string_convert(vcp, ptr, lenp)
-    vimconv_T	*vcp;
-    char_u	*ptr;
-    int		*lenp;
-{
-    return string_convert_ext(vcp, ptr, lenp, NULL);
-}
-
-/*
- * Like string_convert(), but when "unconvlenp" is not NULL and there are is
- * an incomplete sequence at the end it is not converted and "*unconvlenp" is
- * set to the number of remaining bytes.
- */
-    char_u *
-string_convert_ext(vcp, ptr, lenp, unconvlenp)
-    vimconv_T	*vcp;
-    char_u	*ptr;
-    int		*lenp;
-    int		*unconvlenp;
-{
-    char_u	*retval = NULL;
-    char_u	*d;
-    int		len;
-    int		i;
-    int		l;
-    int		c;
-
-    if (lenp == NULL)
-	len = (int)STRLEN(ptr);
-    else
-	len = *lenp;
-    if (len == 0)
-	return vim_strsave((char_u *)"");
-
-    switch (vcp->vc_type)
-    {
-	case CONV_TO_UTF8:	/* latin1 to utf-8 conversion */
-	    retval = alloc(len * 2 + 1);
-	    if (retval == NULL)
-		break;
-	    d = retval;
-	    for (i = 0; i < len; ++i)
-	    {
-		if (ptr[i] < 0x80)
-		    *d++ = ptr[i];
-		else
-		{
-		    *d++ = 0xc0 + ((unsigned)ptr[i] >> 6);
-		    *d++ = 0x80 + (ptr[i] & 0x3f);
-		}
-	    }
-	    *d = NUL;
-	    if (lenp != NULL)
-		*lenp = (int)(d - retval);
-	    break;
-
-	case CONV_TO_LATIN1:	/* utf-8 to latin1 conversion */
-	    retval = alloc(len + 1);
-	    if (retval == NULL)
-		break;
-	    d = retval;
-	    for (i = 0; i < len; ++i)
-	    {
-		l = utf_ptr2len_check(ptr + i);
-		if (l == 0)
-		    *d++ = NUL;
-		else if (l == 1)
-		{
-		    if (unconvlenp != NULL && utf8len_tab[ptr[i]] > len - i)
-		    {
-			/* Incomplete sequence at the end. */
-			*unconvlenp = len - i;
-			break;
-		    }
-		    *d++ = ptr[i];
-		}
-		else
-		{
-		    c = utf_ptr2char(ptr + i);
-		    if (!utf_iscomposing(c))	/* skip composing chars */
-		    {
-			if (c < 0x100)
-			    *d++ = c;
-			else if (vcp->vc_fail)
-			{
-			    vim_free(retval);
-			    return NULL;
-			}
-			else
-			{
-			    *d++ = 0xbf;
-			    if (utf_char2cells(c) > 1)
-				*d++ = '?';
-			}
-		    }
-		    i += l - 1;
-		}
-	    }
-	    *d = NUL;
-	    if (lenp != NULL)
-		*lenp = (int)(d - retval);
-	    break;
-
-# ifdef MACOS_X
-	case CONV_MAC_LATIN1:
-	    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,
-					kCFStringEncodingMacRoman,
-					kCFStringEncodingISOLatin1,
-					unconvlenp);
-	    break;
-
-	case CONV_LATIN1_MAC:
-	    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,
-					kCFStringEncodingISOLatin1,
-					kCFStringEncodingMacRoman,
-					unconvlenp);
-	    break;
-
-	case CONV_MAC_UTF8:
-	    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,
-					kCFStringEncodingMacRoman,
-					kCFStringEncodingUTF8,
-					unconvlenp);
-	    break;
-
-	case CONV_UTF8_MAC:
-	    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,
-					kCFStringEncodingUTF8,
-					kCFStringEncodingMacRoman,
-					unconvlenp);
-	    break;
-# endif
-
-# ifdef USE_ICONV
-	case CONV_ICONV:	/* conversion with output_conv.vc_fd */
-	    retval = iconv_string(vcp, ptr, len, unconvlenp);
-	    if (retval != NULL && lenp != NULL)
-		*lenp = (int)STRLEN(retval);
-	    break;
-# endif
-# ifdef WIN3264
-	case CONV_CODEPAGE:		/* codepage -> codepage */
-	{
-	    int		retlen;
-	    int		tmp_len;
-	    short_u	*tmp;
-
-	    /* 1. codepage/UTF-8  ->  ucs-2. */
-	    if (vcp->vc_cpfrom == 0)
-		tmp_len = utf8_to_ucs2(ptr, len, NULL, NULL);
-	    else
-		tmp_len = MultiByteToWideChar(vcp->vc_cpfrom, 0,
-							      ptr, len, 0, 0);
-	    tmp = (short_u *)alloc(sizeof(short_u) * tmp_len);
-	    if (tmp == NULL)
-		break;
-	    if (vcp->vc_cpfrom == 0)
-		utf8_to_ucs2(ptr, len, tmp, unconvlenp);
-	    else
-		MultiByteToWideChar(vcp->vc_cpfrom, 0, ptr, len, tmp, tmp_len);
-
-	    /* 2. ucs-2  ->  codepage/UTF-8. */
-	    if (vcp->vc_cpto == 0)
-		retlen = ucs2_to_utf8(tmp, tmp_len, NULL);
-	    else
-		retlen = WideCharToMultiByte(vcp->vc_cpto, 0,
-						    tmp, tmp_len, 0, 0, 0, 0);
-	    retval = alloc(retlen + 1);
-	    if (retval != NULL)
-	    {
-		if (vcp->vc_cpto == 0)
-		    ucs2_to_utf8(tmp, tmp_len, retval);
-		else
-		    WideCharToMultiByte(vcp->vc_cpto, 0,
-					  tmp, tmp_len, retval, retlen, 0, 0);
-		retval[retlen] = NUL;
-		if (lenp != NULL)
-		    *lenp = retlen;
-	    }
-	    vim_free(tmp);
-	    break;
-	}
-# endif
-    }
-
-    return retval;
-}
-#endif
diff -Nur vim63/src/misc1.c vim63-bonobo/src/misc1.c
--- vim63/src/misc1.c	2005-09-09 20:11:10.581755000 +0200
+++ vim63-bonobo/src/misc1.c	2005-09-09 20:14:02.756581200 +0200
@@ -2371,6 +2371,11 @@
 #ifdef FEAT_TITLE
 	need_maketitle = TRUE;	    /* set window title later */
 #endif
+#if defined(FEAT_GUI_COMPONENT)
+        if( curbuf == persistent_buffer) {
+            component_set_dirty(TRUE);
+        }
+#endif
     }
     ++curbuf->b_changedtick;
     ++global_changedtick;
@@ -2710,6 +2715,11 @@
 #ifdef FEAT_TITLE
 	need_maketitle = TRUE;	    /* set window title later */
 #endif
+#if defined(FEAT_GUI_COMPONENT)
+        if( curbuf == persistent_buffer) {
+            component_set_dirty(FALSE);
+        }
+#endif
     }
     ++buf->b_changedtick;
     ++global_changedtick;
diff -Nur vim63/src/misc1.c.orig vim63-bonobo/src/misc1.c.orig
--- vim63/src/misc1.c.orig	2005-09-09 20:11:09.839868000 +0200
+++ vim63-bonobo/src/misc1.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,8466 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-
-/*
- * misc1.c: functions that didn't seem to fit elsewhere
- */
-
-#include "vim.h"
-#include "version.h"
-
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>		/* for chdir() */
-#endif
-
-static char_u *vim_version_dir __ARGS((char_u *vimdir));
-static char_u *remove_tail __ARGS((char_u *p, char_u *pend, char_u *name));
-#if defined(USE_EXE_NAME) && defined(MACOS_X)
-static char_u *remove_tail_with_ext __ARGS((char_u *p, char_u *pend, char_u *ext));
-#endif
-static int get_indent_str __ARGS((char_u *ptr, int ts));
-static int copy_indent __ARGS((int size, char_u	*src));
-
-/*
- * Count the size (in window cells) of the indent in the current line.
- */
-    int
-get_indent()
-{
-    return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts);
-}
-
-/*
- * Count the size (in window cells) of the indent in line "lnum".
- */
-    int
-get_indent_lnum(lnum)
-    linenr_T	lnum;
-{
-    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts);
-}
-
-#if defined(FEAT_FOLDING) || defined(PROTO)
-/*
- * Count the size (in window cells) of the indent in line "lnum" of buffer
- * "buf".
- */
-    int
-get_indent_buf(buf, lnum)
-    buf_T	*buf;
-    linenr_T	lnum;
-{
-    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts);
-}
-#endif
-
-/*
- * count the size (in window cells) of the indent in line "ptr", with
- * 'tabstop' at "ts"
- */
-    static int
-get_indent_str(ptr, ts)
-    char_u	*ptr;
-    int		ts;
-{
-    int		count = 0;
-
-    for ( ; *ptr; ++ptr)
-    {
-	if (*ptr == TAB)    /* count a tab for what it is worth */
-	    count += ts - (count % ts);
-	else if (*ptr == ' ')
-	    ++count;		/* count a space for one */
-	else
-	    break;
-    }
-    return (count);
-}
-
-/*
- * Set the indent of the current line.
- * Leaves the cursor on the first non-blank in the line.
- * Caller must take care of undo.
- * "flags":
- *	SIN_CHANGED:	call changed_bytes() if the line was changed.
- *	SIN_INSERT:	insert the indent in front of the line.
- *	SIN_UNDO:	save line for undo before changing it.
- * Returns TRUE if the line was changed.
- */
-    int
-set_indent(size, flags)
-    int		size;
-    int		flags;
-{
-    char_u	*p;
-    char_u	*newline;
-    char_u	*oldline;
-    char_u	*s;
-    int		todo;
-    int		ind_len;
-    int		line_len;
-    int		doit = FALSE;
-    int		ind_done;
-    int		tab_pad;
-
-    /*
-     * First check if there is anything to do and compute the number of
-     * characters needed for the indent.
-     */
-    todo = size;
-    ind_len = 0;
-    p = oldline = ml_get_curline();
-
-    /* Calculate the buffer size for the new indent, and check to see if it
-     * isn't already set */
-
-    /* if 'expandtab' isn't set: use TABs */
-    if (!curbuf->b_p_et)
-    {
-	/* If 'preserveindent' is set then reuse as much as possible of
-	 * the existing indent structure for the new indent */
-	if (!(flags & SIN_INSERT) && curbuf->b_p_pi)
-	{
-	    ind_done = 0;
-
-	    /* count as many characters as we can use */
-	    while (todo > 0 && vim_iswhite(*p))
-	    {
-		if (*p == TAB)
-		{
-		    tab_pad = (int)curbuf->b_p_ts
-					   - (ind_done % (int)curbuf->b_p_ts);
-		    /* stop if this tab will overshoot the target */
-		    if (todo < tab_pad)
-			break;
-		    todo -= tab_pad;
-		    ++ind_len;
-		    ind_done += tab_pad;
-		}
-		else
-		{
-		    --todo;
-		    ++ind_len;
-		    ++ind_done;
-		}
-		++p;
-	    }
-
-	    /* Fill to next tabstop with a tab, if possible */
-	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
-	    if (todo >= tab_pad)
-	    {
-		doit = TRUE;
-		todo -= tab_pad;
-		++ind_len;
-		/* ind_done += tab_pad; */
-	    }
-	}
-
-	/* count tabs required for indent */
-	while (todo >= (int)curbuf->b_p_ts)
-	{
-	    if (*p != TAB)
-		doit = TRUE;
-	    else
-		++p;
-	    todo -= (int)curbuf->b_p_ts;
-	    ++ind_len;
-	    /* ind_done += (int)curbuf->b_p_ts; */
-	}
-    }
-    /* count spaces required for indent */
-    while (todo > 0)
-    {
-	if (*p != ' ')
-	    doit = TRUE;
-	else
-	    ++p;
-	--todo;
-	++ind_len;
-	/* ++ind_done; */
-    }
-
-    /* Return if the indent is OK already. */
-    if (!doit && !vim_iswhite(*p) && !(flags & SIN_INSERT))
-	return FALSE;
-
-    /* Allocate memory for the new line. */
-    if (flags & SIN_INSERT)
-	p = oldline;
-    else
-	p = skipwhite(p);
-    line_len = (int)STRLEN(p) + 1;
-    newline = alloc(ind_len + line_len);
-    if (newline == NULL)
-	return FALSE;
-
-    /* Put the characters in the new line. */
-    s = newline;
-    todo = size;
-    /* if 'expandtab' isn't set: use TABs */
-    if (!curbuf->b_p_et)
-    {
-	/* If 'preserveindent' is set then reuse as much as possible of
-	 * the existing indent structure for the new indent */
-	if (!(flags & SIN_INSERT) && curbuf->b_p_pi)
-	{
-	    p = oldline;
-	    ind_done = 0;
-
-	    while (todo > 0 && vim_iswhite(*p))
-	    {
-		if (*p == TAB)
-		{
-		    tab_pad = (int)curbuf->b_p_ts
-					   - (ind_done % (int)curbuf->b_p_ts);
-		    /* stop if this tab will overshoot the target */
-		    if (todo < tab_pad)
-			break;
-		    todo -= tab_pad;
-		    ind_done += tab_pad;
-		}
-		else
-		{
-		    --todo;
-		    ++ind_done;
-		}
-		*s++ = *p++;
-	    }
-
-	    /* Fill to next tabstop with a tab, if possible */
-	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
-	    if (todo >= tab_pad)
-	    {
-		*s++ = TAB;
-		todo -= tab_pad;
-	    }
-
-	    p = skipwhite(p);
-	}
-
-	while (todo >= (int)curbuf->b_p_ts)
-	{
-	    *s++ = TAB;
-	    todo -= (int)curbuf->b_p_ts;
-	}
-    }
-    while (todo > 0)
-    {
-	*s++ = ' ';
-	--todo;
-    }
-    mch_memmove(s, p, (size_t)line_len);
-
-    /* Replace the line (unless undo fails). */
-    if (!(flags & SIN_UNDO) || u_savesub(curwin->w_cursor.lnum) == OK)
-    {
-	ml_replace(curwin->w_cursor.lnum, newline, FALSE);
-	if (flags & SIN_CHANGED)
-	    changed_bytes(curwin->w_cursor.lnum, 0);
-	/* Correct saved cursor position if it's after the indent. */
-	if (saved_cursor.lnum == curwin->w_cursor.lnum
-				&& saved_cursor.col >= (colnr_T)(p - oldline))
-	    saved_cursor.col += ind_len - (p - oldline);
-    }
-    else
-	vim_free(newline);
-
-    curwin->w_cursor.col = ind_len;
-    return TRUE;
-}
-
-/*
- * Copy the indent from ptr to the current line (and fill to size)
- * Leaves the cursor on the first non-blank in the line.
- * Returns TRUE if the line was changed.
- */
-    static int
-copy_indent(size, src)
-    int		size;
-    char_u	*src;
-{
-    char_u	*p = NULL;
-    char_u	*line = NULL;
-    char_u	*s;
-    int		todo;
-    int		ind_len;
-    int		line_len = 0;
-    int		tab_pad;
-    int		ind_done;
-    int		round;
-
-    /* Round 1: compute the number of characters needed for the indent
-     * Round 2: copy the characters. */
-    for (round = 1; round <= 2; ++round)
-    {
-	todo = size;
-	ind_len = 0;
-	ind_done = 0;
-	s = src;
-
-	/* Count/copy the usable portion of the source line */
-	while (todo > 0 && vim_iswhite(*s))
-	{
-	    if (*s == TAB)
-	    {
-		tab_pad = (int)curbuf->b_p_ts
-					   - (ind_done % (int)curbuf->b_p_ts);
-		/* Stop if this tab will overshoot the target */
-		if (todo < tab_pad)
-		    break;
-		todo -= tab_pad;
-		ind_done += tab_pad;
-	    }
-	    else
-	    {
-		--todo;
-		++ind_done;
-	    }
-	    ++ind_len;
-	    if (round == 2)
-		*p++ = *s;
-	    ++s;
-	}
-
-	/* Fill to next tabstop with a tab, if possible */
-	tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
-	if (todo >= tab_pad)
-	{
-	    todo -= tab_pad;
-	    ++ind_len;
-	    if (round == 2)
-		*p++ = TAB;
-	}
-
-	/* Add tabs required for indent */
-	while (todo >= (int)curbuf->b_p_ts)
-	{
-	    todo -= (int)curbuf->b_p_ts;
-	    ++ind_len;
-	    if (round == 2)
-		*p++ = TAB;
-	}
-
-	/* Count/add spaces required for indent */
-	while (todo > 0)
-	{
-	    --todo;
-	    ++ind_len;
-	    if (round == 2)
-		*p++ = ' ';
-	}
-
-	if (round == 1)
-	{
-	    /* Allocate memory for the result: the copied indent, new indent
-	     * and the rest of the line. */
-	    line_len = (int)STRLEN(ml_get_curline()) + 1;
-	    line = alloc(ind_len + line_len);
-	    if (line == NULL)
-		return FALSE;
-	    p = line;
-	}
-    }
-
-    /* Append the original line */
-    mch_memmove(p, ml_get_curline(), (size_t)line_len);
-
-    /* Replace the line */
-    ml_replace(curwin->w_cursor.lnum, line, FALSE);
-
-    /* Put the cursor after the indent. */
-    curwin->w_cursor.col = ind_len;
-    return TRUE;
-}
-
-/*
- * Return the indent of the current line after a number.  Return -1 if no
- * number was found.  Used for 'n' in 'formatoptions': numbered list.
- */
-    int
-get_number_indent(lnum)
-    linenr_T	lnum;
-{
-    char_u	*line;
-    char_u	*p;
-    colnr_T	col;
-    pos_T	pos;
-
-    if (lnum > curbuf->b_ml.ml_line_count)
-	return -1;
-    line = ml_get(lnum);
-    p = skipwhite(line);
-    if (!VIM_ISDIGIT(*p))
-	return -1;
-    p = skipdigits(p);
-    if (vim_strchr((char_u *)":.)]}\t ", *p) == NULL)
-	return -1;
-    p = skipwhite(p + 1);
-    if (*p == NUL)
-	return -1;
-    pos.lnum = lnum;
-    pos.col = (colnr_T)(p - line);
-    getvcol(curwin, &pos, &col, NULL, NULL);
-    return (int)col;
-}
-
-#if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)
-
-static int cin_is_cinword __ARGS((char_u *line));
-
-/*
- * Return TRUE if the string "line" starts with a word from 'cinwords'.
- */
-    static int
-cin_is_cinword(line)
-    char_u	*line;
-{
-    char_u	*cinw;
-    char_u	*cinw_buf;
-    int		cinw_len;
-    int		retval = FALSE;
-    int		len;
-
-    cinw_len = (int)STRLEN(curbuf->b_p_cinw) + 1;
-    cinw_buf = alloc((unsigned)cinw_len);
-    if (cinw_buf != NULL)
-    {
-	line = skipwhite(line);
-	for (cinw = curbuf->b_p_cinw; *cinw; )
-	{
-	    len = copy_option_part(&cinw, cinw_buf, cinw_len, ",");
-	    if (STRNCMP(line, cinw_buf, len) == 0
-		    && (!vim_iswordc(line[len]) || !vim_iswordc(line[len - 1])))
-	    {
-		retval = TRUE;
-		break;
-	    }
-	}
-	vim_free(cinw_buf);
-    }
-    return retval;
-}
-#endif
-
-/*
- * open_line: Add a new line below or above the current line.
- *
- * For VREPLACE mode, we only add a new line when we get to the end of the
- * file, otherwise we just start replacing the next line.
- *
- * Caller must take care of undo.  Since VREPLACE may affect any number of
- * lines however, it may call u_save_cursor() again when starting to change a
- * new line.
- * "flags": OPENLINE_DELSPACES	delete spaces after cursor
- *	    OPENLINE_DO_COM	format comments
- *	    OPENLINE_KEEPTRAIL	keep trailing spaces
- *	    OPENLINE_MARKFIX	adjust mark positions after the line break
- *
- * Return TRUE for success, FALSE for failure
- */
-    int
-open_line(dir, flags, old_indent)
-    int		dir;		/* FORWARD or BACKWARD */
-    int		flags;
-    int		old_indent;	/* indent for after ^^D in Insert mode */
-{
-    char_u	*saved_line;		/* copy of the original line */
-    char_u	*next_line = NULL;	/* copy of the next line */
-    char_u	*p_extra = NULL;	/* what goes to next line */
-    int		less_cols = 0;		/* less columns for mark in new line */
-    int		less_cols_off = 0;	/* columns to skip for mark adjust */
-    pos_T	old_cursor;		/* old cursor position */
-    int		newcol = 0;		/* new cursor column */
-    int		newindent = 0;		/* auto-indent of the new line */
-    int		n;
-    int		trunc_line = FALSE;	/* truncate current line afterwards */
-    int		retval = FALSE;		/* return value, default is FAIL */
-#ifdef FEAT_COMMENTS
-    int		extra_len = 0;		/* length of p_extra string */
-    int		lead_len;		/* length of comment leader */
-    char_u	*lead_flags;	/* position in 'comments' for comment leader */
-    char_u	*leader = NULL;		/* copy of comment leader */
-#endif
-    char_u	*allocated = NULL;	/* allocated memory */
-#if defined(FEAT_SMARTINDENT) || defined(FEAT_VREPLACE) || defined(FEAT_LISP) \
-	|| defined(FEAT_CINDENT) || defined(FEAT_COMMENTS)
-    char_u	*p;
-#endif
-    int		saved_char = NUL;	/* init for GCC */
-#if defined(FEAT_SMARTINDENT) || defined(FEAT_COMMENTS)
-    pos_T	*pos;
-#endif
-#ifdef FEAT_SMARTINDENT
-    int		do_si = (!p_paste && curbuf->b_p_si
-# ifdef FEAT_CINDENT
-					&& !curbuf->b_p_cin
-# endif
-			);
-    int		no_si = FALSE;		/* reset did_si afterwards */
-    int		first_char = NUL;	/* init for GCC */
-#endif
-#if defined(FEAT_VREPLACE) && (defined(FEAT_LISP) || defined(FEAT_CINDENT))
-    int		vreplace_mode;
-#endif
-    int		did_append;		/* appended a new line */
-    int		saved_pi = curbuf->b_p_pi; /* copy of preserveindent setting */
-
-    /*
-     * make a copy of the current line so we can mess with it
-     */
-    saved_line = vim_strsave(ml_get_curline());
-    if (saved_line == NULL)	    /* out of memory! */
-	return FALSE;
-
-#ifdef FEAT_VREPLACE
-    if (State & VREPLACE_FLAG)
-    {
-	/*
-	 * With VREPLACE we make a copy of the next line, which we will be
-	 * starting to replace.  First make the new line empty and let vim play
-	 * with the indenting and comment leader to its heart's content.  Then
-	 * we grab what it ended up putting on the new line, put back the
-	 * original line, and call ins_char() to put each new character onto
-	 * the line, replacing what was there before and pushing the right
-	 * stuff onto the replace stack.  -- webb.
-	 */
-	if (curwin->w_cursor.lnum < orig_line_count)
-	    next_line = vim_strsave(ml_get(curwin->w_cursor.lnum + 1));
-	else
-	    next_line = vim_strsave((char_u *)"");
-	if (next_line == NULL)	    /* out of memory! */
-	    goto theend;
-
-	/*
-	 * In VREPLACE mode, a NL replaces the rest of the line, and starts
-	 * replacing the next line, so push all of the characters left on the
-	 * line onto the replace stack.  We'll push any other characters that
-	 * might be replaced at the start of the next line (due to autoindent
-	 * etc) a bit later.
-	 */
-	replace_push(NUL);  /* Call twice because BS over NL expects it */
-	replace_push(NUL);
-	p = saved_line + curwin->w_cursor.col;
-	while (*p != NUL)
-	    replace_push(*p++);
-	saved_line[curwin->w_cursor.col] = NUL;
-    }
-#endif
-
-    if ((State & INSERT)
-#ifdef FEAT_VREPLACE
-	    && !(State & VREPLACE_FLAG)
-#endif
-	    )
-    {
-	p_extra = saved_line + curwin->w_cursor.col;
-#ifdef FEAT_SMARTINDENT
-	if (do_si)		/* need first char after new line break */
-	{
-	    p = skipwhite(p_extra);
-	    first_char = *p;
-	}
-#endif
-#ifdef FEAT_COMMENTS
-	extra_len = (int)STRLEN(p_extra);
-#endif
-	saved_char = *p_extra;
-	*p_extra = NUL;
-    }
-
-    u_clearline();		/* cannot do "U" command when adding lines */
-#ifdef FEAT_SMARTINDENT
-    did_si = FALSE;
-#endif
-    ai_col = 0;
-
-    /*
-     * If we just did an auto-indent, then we didn't type anything on
-     * the prior line, and it should be truncated.  Do this even if 'ai' is not
-     * set because automatically inserting a comment leader also sets did_ai.
-     */
-    if (dir == FORWARD && did_ai)
-	trunc_line = TRUE;
-
-    /*
-     * If 'autoindent' and/or 'smartindent' is set, try to figure out what
-     * indent to use for the new line.
-     */
-    if (curbuf->b_p_ai
-#ifdef FEAT_SMARTINDENT
-			|| do_si
-#endif
-					    )
-    {
-	/*
-	 * count white space on current line
-	 */
-	newindent = get_indent_str(saved_line, (int)curbuf->b_p_ts);
-	if (newindent == 0)
-	    newindent = old_indent;	/* for ^^D command in insert mode */
-
-#ifdef FEAT_SMARTINDENT
-	/*
-	 * Do smart indenting.
-	 * In insert/replace mode (only when dir == FORWARD)
-	 * we may move some text to the next line. If it starts with '{'
-	 * don't add an indent. Fixes inserting a NL before '{' in line
-	 *	"if (condition) {"
-	 */
-	if (!trunc_line && do_si && *saved_line != NUL
-				    && (p_extra == NULL || first_char != '{'))
-	{
-	    char_u  *ptr;
-	    char_u  last_char;
-
-	    old_cursor = curwin->w_cursor;
-	    ptr = saved_line;
-# ifdef FEAT_COMMENTS
-	    if (flags & OPENLINE_DO_COM)
-		lead_len = get_leader_len(ptr, NULL, FALSE);
-	    else
-		lead_len = 0;
-# endif
-	    if (dir == FORWARD)
-	    {
-		/*
-		 * Skip preprocessor directives, unless they are
-		 * recognised as comments.
-		 */
-		if (
-# ifdef FEAT_COMMENTS
-			lead_len == 0 &&
-# endif
-			ptr[0] == '#')
-		{
-		    while (ptr[0] == '#' && curwin->w_cursor.lnum > 1)
-			ptr = ml_get(--curwin->w_cursor.lnum);
-		    newindent = get_indent();
-		}
-# ifdef FEAT_COMMENTS
-		if (flags & OPENLINE_DO_COM)
-		    lead_len = get_leader_len(ptr, NULL, FALSE);
-		else
-		    lead_len = 0;
-		if (lead_len > 0)
-		{
-		    /*
-		     * This case gets the following right:
-		     *	    \*
-		     *	     * A comment (read '\' as '/').
-		     *	     *\
-		     * #define IN_THE_WAY
-		     *	    This should line up here;
-		     */
-		    p = skipwhite(ptr);
-		    if (p[0] == '/' && p[1] == '*')
-			p++;
-		    if (p[0] == '*')
-		    {
-			for (p++; *p; p++)
-			{
-			    if (p[0] == '/' && p[-1] == '*')
-			    {
-				/*
-				 * End of C comment, indent should line up
-				 * with the line containing the start of
-				 * the comment
-				 */
-				curwin->w_cursor.col = (colnr_T)(p - ptr);
-				if ((pos = findmatch(NULL, NUL)) != NULL)
-				{
-				    curwin->w_cursor.lnum = pos->lnum;
-				    newindent = get_indent();
-				}
-			    }
-			}
-		    }
-		}
-		else	/* Not a comment line */
-# endif
-		{
-		    /* Find last non-blank in line */
-		    p = ptr + STRLEN(ptr) - 1;
-		    while (p > ptr && vim_iswhite(*p))
-			--p;
-		    last_char = *p;
-
-		    /*
-		     * find the character just before the '{' or ';'
-		     */
-		    if (last_char == '{' || last_char == ';')
-		    {
-			if (p > ptr)
-			    --p;
-			while (p > ptr && vim_iswhite(*p))
-			    --p;
-		    }
-		    /*
-		     * Try to catch lines that are split over multiple
-		     * lines.  eg:
-		     *	    if (condition &&
-		     *			condition) {
-		     *		Should line up here!
-		     *	    }
-		     */
-		    if (*p == ')')
-		    {
-			curwin->w_cursor.col = (colnr_T)(p - ptr);
-			if ((pos = findmatch(NULL, '(')) != NULL)
-			{
-			    curwin->w_cursor.lnum = pos->lnum;
-			    newindent = get_indent();
-			    ptr = ml_get_curline();
-			}
-		    }
-		    /*
-		     * If last character is '{' do indent, without
-		     * checking for "if" and the like.
-		     */
-		    if (last_char == '{')
-		    {
-			did_si = TRUE;	/* do indent */
-			no_si = TRUE;	/* don't delete it when '{' typed */
-		    }
-		    /*
-		     * Look for "if" and the like, use 'cinwords'.
-		     * Don't do this if the previous line ended in ';' or
-		     * '}'.
-		     */
-		    else if (last_char != ';' && last_char != '}'
-						       && cin_is_cinword(ptr))
-			did_si = TRUE;
-		}
-	    }
-	    else /* dir == BACKWARD */
-	    {
-		/*
-		 * Skip preprocessor directives, unless they are
-		 * recognised as comments.
-		 */
-		if (
-# ifdef FEAT_COMMENTS
-			lead_len == 0 &&
-# endif
-			ptr[0] == '#')
-		{
-		    int was_backslashed = FALSE;
-
-		    while ((ptr[0] == '#' || was_backslashed) &&
-			 curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
-		    {
-			if (*ptr && ptr[STRLEN(ptr) - 1] == '\\')
-			    was_backslashed = TRUE;
-			else
-			    was_backslashed = FALSE;
-			ptr = ml_get(++curwin->w_cursor.lnum);
-		    }
-		    if (was_backslashed)
-			newindent = 0;	    /* Got to end of file */
-		    else
-			newindent = get_indent();
-		}
-		p = skipwhite(ptr);
-		if (*p == '}')	    /* if line starts with '}': do indent */
-		    did_si = TRUE;
-		else		    /* can delete indent when '{' typed */
-		    can_si_back = TRUE;
-	    }
-	    curwin->w_cursor = old_cursor;
-	}
-	if (do_si)
-	    can_si = TRUE;
-#endif /* FEAT_SMARTINDENT */
-
-	did_ai = TRUE;
-    }
-
-#ifdef FEAT_COMMENTS
-    /*
-     * Find out if the current line starts with a comment leader.
-     * This may then be inserted in front of the new line.
-     */
-    end_comment_pending = NUL;
-    if (flags & OPENLINE_DO_COM)
-	lead_len = get_leader_len(saved_line, &lead_flags, dir == BACKWARD);
-    else
-	lead_len = 0;
-    if (lead_len > 0)
-    {
-	char_u	*lead_repl = NULL;	    /* replaces comment leader */
-	int	lead_repl_len = 0;	    /* length of *lead_repl */
-	char_u	lead_middle[COM_MAX_LEN];   /* middle-comment string */
-	char_u	lead_end[COM_MAX_LEN];	    /* end-comment string */
-	char_u	*comment_end = NULL;	    /* where lead_end has been found */
-	int	extra_space = FALSE;	    /* append extra space */
-	int	current_flag;
-	int	require_blank = FALSE;	    /* requires blank after middle */
-	char_u	*p2;
-
-	/*
-	 * If the comment leader has the start, middle or end flag, it may not
-	 * be used or may be replaced with the middle leader.
-	 */
-	for (p = lead_flags; *p && *p != ':'; ++p)
-	{
-	    if (*p == COM_BLANK)
-	    {
-		require_blank = TRUE;
-		continue;
-	    }
-	    if (*p == COM_START || *p == COM_MIDDLE)
-	    {
-		current_flag = *p;
-		if (*p == COM_START)
-		{
-		    /*
-		     * Doing "O" on a start of comment does not insert leader.
-		     */
-		    if (dir == BACKWARD)
-		    {
-			lead_len = 0;
-			break;
-		    }
-
-		    /* find start of middle part */
-		    (void)copy_option_part(&p, lead_middle, COM_MAX_LEN, ",");
-		    require_blank = FALSE;
-		}
-
-		/*
-		 * Isolate the strings of the middle and end leader.
-		 */
-		while (*p && p[-1] != ':')	/* find end of middle flags */
-		{
-		    if (*p == COM_BLANK)
-			require_blank = TRUE;
-		    ++p;
-		}
-		(void)copy_option_part(&p, lead_middle, COM_MAX_LEN, ",");
-
-		while (*p && p[-1] != ':')	/* find end of end flags */
-		{
-		    /* Check whether we allow automatic ending of comments */
-		    if (*p == COM_AUTO_END)
-			end_comment_pending = -1; /* means we want to set it */
-		    ++p;
-		}
-		n = copy_option_part(&p, lead_end, COM_MAX_LEN, ",");
-
-		if (end_comment_pending == -1)	/* we can set it now */
-		    end_comment_pending = lead_end[n - 1];
-
-		/*
-		 * If the end of the comment is in the same line, don't use
-		 * the comment leader.
-		 */
-		if (dir == FORWARD)
-		{
-		    for (p = saved_line + lead_len; *p; ++p)
-			if (STRNCMP(p, lead_end, n) == 0)
-			{
-			    comment_end = p;
-			    lead_len = 0;
-			    break;
-			}
-		}
-
-		/*
-		 * Doing "o" on a start of comment inserts the middle leader.
-		 */
-		if (lead_len > 0)
-		{
-		    if (current_flag == COM_START)
-		    {
-			lead_repl = lead_middle;
-			lead_repl_len = (int)STRLEN(lead_middle);
-		    }
-
-		    /*
-		     * If we have hit RETURN immediately after the start
-		     * comment leader, then put a space after the middle
-		     * comment leader on the next line.
-		     */
-		    if (!vim_iswhite(saved_line[lead_len - 1])
-			    && ((p_extra != NULL
-				    && (int)curwin->w_cursor.col == lead_len)
-				|| (p_extra == NULL
-				    && saved_line[lead_len] == NUL)
-				|| require_blank))
-			extra_space = TRUE;
-		}
-		break;
-	    }
-	    if (*p == COM_END)
-	    {
-		/*
-		 * Doing "o" on the end of a comment does not insert leader.
-		 * Remember where the end is, might want to use it to find the
-		 * start (for C-comments).
-		 */
-		if (dir == FORWARD)
-		{
-		    comment_end = skipwhite(saved_line);
-		    lead_len = 0;
-		    break;
-		}
-
-		/*
-		 * Doing "O" on the end of a comment inserts the middle leader.
-		 * Find the string for the middle leader, searching backwards.
-		 */
-		while (p > curbuf->b_p_com && *p != ',')
-		    --p;
-		for (lead_repl = p; lead_repl > curbuf->b_p_com
-					 && lead_repl[-1] != ':'; --lead_repl)
-		    ;
-		lead_repl_len = (int)(p - lead_repl);
-
-		/* We can probably always add an extra space when doing "O" on
-		 * the comment-end */
-		extra_space = TRUE;
-
-		/* Check whether we allow automatic ending of comments */
-		for (p2 = p; *p2 && *p2 != ':'; p2++)
-		{
-		    if (*p2 == COM_AUTO_END)
-			end_comment_pending = -1; /* means we want to set it */
-		}
-		if (end_comment_pending == -1)
-		{
-		    /* Find last character in end-comment string */
-		    while (*p2 && *p2 != ',')
-			p2++;
-		    end_comment_pending = p2[-1];
-		}
-		break;
-	    }
-	    if (*p == COM_FIRST)
-	    {
-		/*
-		 * Comment leader for first line only:	Don't repeat leader
-		 * when using "O", blank out leader when using "o".
-		 */
-		if (dir == BACKWARD)
-		    lead_len = 0;
-		else
-		{
-		    lead_repl = (char_u *)"";
-		    lead_repl_len = 0;
-		}
-		break;
-	    }
-	}
-	if (lead_len)
-	{
-	    /* allocate buffer (may concatenate p_exta later) */
-	    leader = alloc(lead_len + lead_repl_len + extra_space +
-							      extra_len + 1);
-	    allocated = leader;		    /* remember to free it later */
-
-	    if (leader == NULL)
-		lead_len = 0;
-	    else
-	    {
-		STRNCPY(leader, saved_line, lead_len);
-		leader[lead_len] = NUL;
-
-		/*
-		 * Replace leader with lead_repl, right or left adjusted
-		 */
-		if (lead_repl != NULL)
-		{
-		    int		c = 0;
-		    int		off = 0;
-
-		    for (p = lead_flags; *p && *p != ':'; ++p)
-		    {
-			if (*p == COM_RIGHT || *p == COM_LEFT)
-			    c = *p;
-			else if (VIM_ISDIGIT(*p) || *p == '-')
-			    off = getdigits(&p);
-		    }
-		    if (c == COM_RIGHT)    /* right adjusted leader */
-		    {
-			/* find last non-white in the leader to line up with */
-			for (p = leader + lead_len - 1; p > leader
-						      && vim_iswhite(*p); --p)
-			    ;
-
-			++p;
-			if (p < leader + lead_repl_len)
-			    p = leader;
-			else
-			    p -= lead_repl_len;
-			mch_memmove(p, lead_repl, (size_t)lead_repl_len);
-			if (p + lead_repl_len > leader + lead_len)
-			    p[lead_repl_len] = NUL;
-
-			/* blank-out any other chars from the old leader. */
-			while (--p >= leader)
-			    if (!vim_iswhite(*p))
-				*p = ' ';
-		    }
-		    else		    /* left adjusted leader */
-		    {
-			p = skipwhite(leader);
-			mch_memmove(p, lead_repl, (size_t)lead_repl_len);
-
-			/* Replace any remaining non-white chars in the old
-			 * leader by spaces.  Keep Tabs, the indent must
-			 * remain the same. */
-			for (p += lead_repl_len; p < leader + lead_len; ++p)
-			    if (!vim_iswhite(*p))
-			    {
-				/* Don't put a space before a TAB. */
-				if (p + 1 < leader + lead_len && p[1] == TAB)
-				{
-				    --lead_len;
-				    mch_memmove(p, p + 1,
-						     (leader + lead_len) - p);
-				}
-				else
-				    *p = ' ';
-			    }
-			*p = NUL;
-		    }
-
-		    /* Recompute the indent, it may have changed. */
-		    if (curbuf->b_p_ai
-#ifdef FEAT_SMARTINDENT
-					|| do_si
-#endif
-							   )
-			newindent = get_indent_str(leader, (int)curbuf->b_p_ts);
-
-		    /* Add the indent offset */
-		    if (newindent + off < 0)
-		    {
-			off = -newindent;
-			newindent = 0;
-		    }
-		    else
-			newindent += off;
-
-		    /* Correct trailing spaces for the shift, so that
-		     * alignment remains equal. */
-		    while (off > 0 && lead_len > 0
-					       && leader[lead_len - 1] == ' ')
-		    {
-			/* Don't do it when there is a tab before the space */
-			if (vim_strchr(skipwhite(leader), '\t') != NULL)
-			    break;
-			--lead_len;
-			--off;
-		    }
-
-		    /* If the leader ends in white space, don't add an
-		     * extra space */
-		    if (lead_len > 0 && vim_iswhite(leader[lead_len - 1]))
-			extra_space = FALSE;
-		    leader[lead_len] = NUL;
-		}
-
-		if (extra_space)
-		{
-		    leader[lead_len++] = ' ';
-		    leader[lead_len] = NUL;
-		}
-
-		newcol = lead_len;
-
-		/*
-		 * if a new indent will be set below, remove the indent that
-		 * is in the comment leader
-		 */
-		if (newindent
-#ifdef FEAT_SMARTINDENT
-				|| did_si
-#endif
-					   )
-		{
-		    while (lead_len && vim_iswhite(*leader))
-		    {
-			--lead_len;
-			--newcol;
-			++leader;
-		    }
-		}
-
-	    }
-#ifdef FEAT_SMARTINDENT
-	    did_si = can_si = FALSE;
-#endif
-	}
-	else if (comment_end != NULL)
-	{
-	    /*
-	     * We have finished a comment, so we don't use the leader.
-	     * If this was a C-comment and 'ai' or 'si' is set do a normal
-	     * indent to align with the line containing the start of the
-	     * comment.
-	     */
-	    if (comment_end[0] == '*' && comment_end[1] == '/' &&
-			(curbuf->b_p_ai
-#ifdef FEAT_SMARTINDENT
-					|| do_si
-#endif
-							   ))
-	    {
-		old_cursor = curwin->w_cursor;
-		curwin->w_cursor.col = (colnr_T)(comment_end - saved_line);
-		if ((pos = findmatch(NULL, NUL)) != NULL)
-		{
-		    curwin->w_cursor.lnum = pos->lnum;
-		    newindent = get_indent();
-		}
-		curwin->w_cursor = old_cursor;
-	    }
-	}
-    }
-#endif
-
-    /* (State == INSERT || State == REPLACE), only when dir == FORWARD */
-    if (p_extra != NULL)
-    {
-	*p_extra = saved_char;		/* restore char that NUL replaced */
-
-	/*
-	 * When 'ai' set or "flags" has OPENLINE_DELSPACES, skip to the first
-	 * non-blank.
-	 *
-	 * When in REPLACE mode, put the deleted blanks on the replace stack,
-	 * preceded by a NUL, so they can be put back when a BS is entered.
-	 */
-	if (REPLACE_NORMAL(State))
-	    replace_push(NUL);	    /* end of extra blanks */
-	if (curbuf->b_p_ai || (flags & OPENLINE_DELSPACES))
-	{
-	    while ((*p_extra == ' ' || *p_extra == '\t')
-#ifdef FEAT_MBYTE
-		    && (!enc_utf8
-			       || !utf_iscomposing(utf_ptr2char(p_extra + 1)))
-#endif
-		    )
-	    {
-		if (REPLACE_NORMAL(State))
-		    replace_push(*p_extra);
-		++p_extra;
-		++less_cols_off;
-	    }
-	}
-	if (*p_extra != NUL)
-	    did_ai = FALSE;	    /* append some text, don't truncate now */
-
-	/* columns for marks adjusted for removed columns */
-	less_cols = (int)(p_extra - saved_line);
-    }
-
-    if (p_extra == NULL)
-	p_extra = (char_u *)"";		    /* append empty line */
-
-#ifdef FEAT_COMMENTS
-    /* concatenate leader and p_extra, if there is a leader */
-    if (lead_len)
-    {
-	STRCAT(leader, p_extra);
-	p_extra = leader;
-	did_ai = TRUE;	    /* So truncating blanks works with comments */
-	less_cols -= lead_len;
-    }
-    else
-	end_comment_pending = NUL;  /* turns out there was no leader */
-#endif
-
-    old_cursor = curwin->w_cursor;
-    if (dir == BACKWARD)
-	--curwin->w_cursor.lnum;
-#ifdef FEAT_VREPLACE
-    if (!(State & VREPLACE_FLAG) || old_cursor.lnum >= orig_line_count)
-#endif
-    {
-	if (ml_append(curwin->w_cursor.lnum, p_extra, (colnr_T)0, FALSE)
-								      == FAIL)
-	    goto theend;
-	/* Postpone calling changed_lines(), because it would mess up folding
-	 * with markers. */
-	mark_adjust(curwin->w_cursor.lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);
-	did_append = TRUE;
-    }
-#ifdef FEAT_VREPLACE
-    else
-    {
-	/*
-	 * In VREPLACE mode we are starting to replace the next line.
-	 */
-	curwin->w_cursor.lnum++;
-	if (curwin->w_cursor.lnum >= Insstart.lnum + vr_lines_changed)
-	{
-	    /* In case we NL to a new line, BS to the previous one, and NL
-	     * again, we don't want to save the new line for undo twice.
-	     */
-	    (void)u_save_cursor();		    /* errors are ignored! */
-	    vr_lines_changed++;
-	}
-	ml_replace(curwin->w_cursor.lnum, p_extra, TRUE);
-	changed_bytes(curwin->w_cursor.lnum, 0);
-	curwin->w_cursor.lnum--;
-	did_append = FALSE;
-    }
-#endif
-
-    if (newindent
-#ifdef FEAT_SMARTINDENT
-		    || did_si
-#endif
-				)
-    {
-	++curwin->w_cursor.lnum;
-#ifdef FEAT_SMARTINDENT
-	if (did_si)
-	{
-	    if (p_sr)
-		newindent -= newindent % (int)curbuf->b_p_sw;
-	    newindent += (int)curbuf->b_p_sw;
-	}
-#endif
-	/* Copy the indent only if expand tab is disabled */
-	if (curbuf->b_p_ci && !curbuf->b_p_et)
-	{
-	    (void)copy_indent(newindent, saved_line);
-
-	    /*
-	     * Set the 'preserveindent' option so that any further screwing
-	     * with the line doesn't entirely destroy our efforts to preserve
-	     * it.  It gets restored at the function end.
-	     */
-	    curbuf->b_p_pi = TRUE;
-	}
-	else
-	    (void)set_indent(newindent, SIN_INSERT);
-	less_cols -= curwin->w_cursor.col;
-
-	ai_col = curwin->w_cursor.col;
-
-	/*
-	 * In REPLACE mode, for each character in the new indent, there must
-	 * be a NUL on the replace stack, for when it is deleted with BS
-	 */
-	if (REPLACE_NORMAL(State))
-	    for (n = 0; n < (int)curwin->w_cursor.col; ++n)
-		replace_push(NUL);
-	newcol += curwin->w_cursor.col;
-#ifdef FEAT_SMARTINDENT
-	if (no_si)
-	    did_si = FALSE;
-#endif
-    }
-
-#ifdef FEAT_COMMENTS
-    /*
-     * In REPLACE mode, for each character in the extra leader, there must be
-     * a NUL on the replace stack, for when it is deleted with BS.
-     */
-    if (REPLACE_NORMAL(State))
-	while (lead_len-- > 0)
-	    replace_push(NUL);
-#endif
-
-    curwin->w_cursor = old_cursor;
-
-    if (dir == FORWARD)
-    {
-	if (trunc_line || (State & INSERT))
-	{
-	    /* truncate current line at cursor */
-	    saved_line[curwin->w_cursor.col] = NUL;
-	    /* Remove trailing white space, unless OPENLINE_KEEPTRAIL used. */
-	    if (trunc_line && !(flags & OPENLINE_KEEPTRAIL))
-		truncate_spaces(saved_line);
-	    ml_replace(curwin->w_cursor.lnum, saved_line, FALSE);
-	    saved_line = NULL;
-	    if (did_append)
-	    {
-		changed_lines(curwin->w_cursor.lnum, curwin->w_cursor.col,
-					       curwin->w_cursor.lnum + 1, 1L);
-		did_append = FALSE;
-
-		/* Move marks after the line break to the new line. */
-		if (flags & OPENLINE_MARKFIX)
-		    mark_col_adjust(curwin->w_cursor.lnum,
-					 curwin->w_cursor.col + less_cols_off,
-							1L, (long)-less_cols);
-	    }
-	    else
-		changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);
-	}
-
-	/*
-	 * Put the cursor on the new line.  Careful: the scrollup() above may
-	 * have moved w_cursor, we must use old_cursor.
-	 */
-	curwin->w_cursor.lnum = old_cursor.lnum + 1;
-    }
-    if (did_append)
-	changed_lines(curwin->w_cursor.lnum, 0, curwin->w_cursor.lnum, 1L);
-
-    curwin->w_cursor.col = newcol;
-#ifdef FEAT_VIRTUALEDIT
-    curwin->w_cursor.coladd = 0;
-#endif
-
-#if defined(FEAT_VREPLACE) && (defined(FEAT_LISP) || defined(FEAT_CINDENT))
-    /*
-     * In VREPLACE mode, we are handling the replace stack ourselves, so stop
-     * fixthisline() from doing it (via change_indent()) by telling it we're in
-     * normal INSERT mode.
-     */
-    if (State & VREPLACE_FLAG)
-    {
-	vreplace_mode = State;	/* So we know to put things right later */
-	State = INSERT;
-    }
-    else
-	vreplace_mode = 0;
-#endif
-#ifdef FEAT_LISP
-    /*
-     * May do lisp indenting.
-     */
-    if (!p_paste
-# ifdef FEAT_COMMENTS
-	    && leader == NULL
-# endif
-	    && curbuf->b_p_lisp
-	    && curbuf->b_p_ai)
-    {
-	fixthisline(get_lisp_indent);
-	p = ml_get_curline();
-	ai_col = (colnr_T)(skipwhite(p) - p);
-    }
-#endif
-#ifdef FEAT_CINDENT
-    /*
-     * May do indenting after opening a new line.
-     */
-    if (!p_paste
-	    && (curbuf->b_p_cin
-#  ifdef FEAT_EVAL
-		    || *curbuf->b_p_inde != NUL
-#  endif
-		)
-	    && in_cinkeys(dir == FORWARD
-		? KEY_OPEN_FORW
-		: KEY_OPEN_BACK, ' ', linewhite(curwin->w_cursor.lnum)))
-    {
-	do_c_expr_indent();
-	p = ml_get_curline();
-	ai_col = (colnr_T)(skipwhite(p) - p);
-    }
-#endif
-#if defined(FEAT_VREPLACE) && (defined(FEAT_LISP) || defined(FEAT_CINDENT))
-    if (vreplace_mode != 0)
-	State = vreplace_mode;
-#endif
-
-#ifdef FEAT_VREPLACE
-    /*
-     * Finally, VREPLACE gets the stuff on the new line, then puts back the
-     * original line, and inserts the new stuff char by char, pushing old stuff
-     * onto the replace stack (via ins_char()).
-     */
-    if (State & VREPLACE_FLAG)
-    {
-	/* Put new line in p_extra */
-	p_extra = vim_strsave(ml_get_curline());
-	if (p_extra == NULL)
-	    goto theend;
-
-	/* Put back original line */
-	ml_replace(curwin->w_cursor.lnum, next_line, FALSE);
-
-	/* Insert new stuff into line again */
-	curwin->w_cursor.col = 0;
-#ifdef FEAT_VIRTUALEDIT
-	curwin->w_cursor.coladd = 0;
-#endif
-	ins_bytes(p_extra);	/* will call changed_bytes() */
-	vim_free(p_extra);
-	next_line = NULL;
-    }
-#endif
-
-    retval = TRUE;		/* success! */
-theend:
-    curbuf->b_p_pi = saved_pi;
-    vim_free(saved_line);
-    vim_free(next_line);
-    vim_free(allocated);
-    return retval;
-}
-
-#if defined(FEAT_COMMENTS) || defined(PROTO)
-/*
- * get_leader_len() returns the length of the prefix of the given string
- * which introduces a comment.	If this string is not a comment then 0 is
- * returned.
- * When "flags" is not NULL, it is set to point to the flags of the recognized
- * comment leader.
- * "backward" must be true for the "O" command.
- */
-    int
-get_leader_len(line, flags, backward)
-    char_u	*line;
-    char_u	**flags;
-    int		backward;
-{
-    int		i, j;
-    int		got_com = FALSE;
-    int		found_one;
-    char_u	part_buf[COM_MAX_LEN];	/* buffer for one option part */
-    char_u	*string;		/* pointer to comment string */
-    char_u	*list;
-
-    i = 0;
-    while (vim_iswhite(line[i]))    /* leading white space is ignored */
-	++i;
-
-    /*
-     * Repeat to match several nested comment strings.
-     */
-    while (line[i])
-    {
-	/*
-	 * scan through the 'comments' option for a match
-	 */
-	found_one = FALSE;
-	for (list = curbuf->b_p_com; *list; )
-	{
-	    /*
-	     * Get one option part into part_buf[].  Advance list to next one.
-	     * put string at start of string.
-	     */
-	    if (!got_com && flags != NULL)  /* remember where flags started */
-		*flags = list;
-	    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, ",");
-	    string = vim_strchr(part_buf, ':');
-	    if (string == NULL)	    /* missing ':', ignore this part */
-		continue;
-	    *string++ = NUL;	    /* isolate flags from string */
-
-	    /*
-	     * When already found a nested comment, only accept further
-	     * nested comments.
-	     */
-	    if (got_com && vim_strchr(part_buf, COM_NEST) == NULL)
-		continue;
-
-	    /* When 'O' flag used don't use for "O" command */
-	    if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)
-		continue;
-
-	    /*
-	     * Line contents and string must match.
-	     * When string starts with white space, must have some white space
-	     * (but the amount does not need to match, there might be a mix of
-	     * TABs and spaces).
-	     */
-	    if (vim_iswhite(string[0]))
-	    {
-		if (i == 0 || !vim_iswhite(line[i - 1]))
-		    continue;
-		while (vim_iswhite(string[0]))
-		    ++string;
-	    }
-	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
-		;
-	    if (string[j] != NUL)
-		continue;
-
-	    /*
-	     * When 'b' flag used, there must be white space or an
-	     * end-of-line after the string in the line.
-	     */
-	    if (vim_strchr(part_buf, COM_BLANK) != NULL
-			   && !vim_iswhite(line[i + j]) && line[i + j] != NUL)
-		continue;
-
-	    /*
-	     * We have found a match, stop searching.
-	     */
-	    i += j;
-	    got_com = TRUE;
-	    found_one = TRUE;
-	    break;
-	}
-
-	/*
-	 * No match found, stop scanning.
-	 */
-	if (!found_one)
-	    break;
-
-	/*
-	 * Include any trailing white space.
-	 */
-	while (vim_iswhite(line[i]))
-	    ++i;
-
-	/*
-	 * If this comment doesn't nest, stop here.
-	 */
-	if (vim_strchr(part_buf, COM_NEST) == NULL)
-	    break;
-    }
-    return (got_com ? i : 0);
-}
-#endif
-
-/*
- * Return the number of window lines occupied by buffer line "lnum".
- */
-    int
-plines(lnum)
-    linenr_T	lnum;
-{
-    return plines_win(curwin, lnum, TRUE);
-}
-
-    int
-plines_win(wp, lnum, winheight)
-    win_T	*wp;
-    linenr_T	lnum;
-    int		winheight;	/* when TRUE limit to window height */
-{
-#if defined(FEAT_DIFF) || defined(PROTO)
-    /* Check for filler lines above this buffer line.  When folded the result
-     * is one line anyway. */
-    return plines_win_nofill(wp, lnum, winheight) + diff_check_fill(wp, lnum);
-}
-
-    int
-plines_nofill(lnum)
-    linenr_T	lnum;
-{
-    return plines_win_nofill(curwin, lnum, TRUE);
-}
-
-    int
-plines_win_nofill(wp, lnum, winheight)
-    win_T	*wp;
-    linenr_T	lnum;
-    int		winheight;	/* when TRUE limit to window height */
-{
-#endif
-    int		lines;
-
-    if (!wp->w_p_wrap)
-	return 1;
-
-#ifdef FEAT_VERTSPLIT
-    if (wp->w_width == 0)
-	return 1;
-#endif
-
-#ifdef FEAT_FOLDING
-    /* A folded lines is handled just like an empty line. */
-    /* NOTE: Caller must handle lines that are MAYBE folded. */
-    if (lineFolded(wp, lnum) == TRUE)
-	return 1;
-#endif
-
-    lines = plines_win_nofold(wp, lnum);
-    if (winheight > 0 && lines > wp->w_height)
-	return (int)wp->w_height;
-    return lines;
-}
-
-/*
- * Return number of window lines physical line "lnum" will occupy in window
- * "wp".  Does not care about folding, 'wrap' or 'diff'.
- */
-    int
-plines_win_nofold(wp, lnum)
-    win_T	*wp;
-    linenr_T	lnum;
-{
-    char_u	*s;
-    long	col;
-    int		width;
-
-    s = ml_get_buf(wp->w_buffer, lnum, FALSE);
-    if (*s == NUL)		/* empty line */
-	return 1;
-    col = win_linetabsize(wp, s, (colnr_T)MAXCOL);
-
-    /*
-     * If list mode is on, then the '$' at the end of the line may take up one
-     * extra column.
-     */
-    if (wp->w_p_list && lcs_eol != NUL)
-	col += 1;
-
-    /*
-     * Add column offset for 'number' and 'foldcolumn'.
-     */
-    width = W_WIDTH(wp) - win_col_off(wp);
-    if (width <= 0)
-	return 32000;
-    if (col <= width)
-	return 1;
-    col -= width;
-    width += win_col_off2(wp);
-    return (col + (width - 1)) / width + 1;
-}
-
-/*
- * Like plines_win(), but only reports the number of physical screen lines
- * used from the start of the line to the given column number.
- */
-    int
-plines_win_col(wp, lnum, column)
-    win_T	*wp;
-    linenr_T	lnum;
-    long	column;
-{
-    long	col;
-    char_u	*s;
-    int		lines = 0;
-    int		width;
-
-#ifdef FEAT_DIFF
-    /* Check for filler lines above this buffer line.  When folded the result
-     * is one line anyway. */
-    lines = diff_check_fill(wp, lnum);
-#endif
-
-    if (!wp->w_p_wrap)
-	return lines + 1;
-
-#ifdef FEAT_VERTSPLIT
-    if (wp->w_width == 0)
-	return lines + 1;
-#endif
-
-    s = ml_get_buf(wp->w_buffer, lnum, FALSE);
-
-    col = 0;
-    while (*s != NUL && --column >= 0)
-    {
-	col += win_lbr_chartabsize(wp, s, (colnr_T)col, NULL);
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	    s += (*mb_ptr2len_check)(s);
-	else
-#endif
-	    ++s;
-    }
-
-    /*
-     * If *s is a TAB, and the TAB is not displayed as ^I, and we're not in
-     * INSERT mode, then col must be adjusted so that it represents the last
-     * screen position of the TAB.  This only fixes an error when the TAB wraps
-     * from one screen line to the next (when 'columns' is not a multiple of
-     * 'ts') -- webb.
-     */
-    if (*s == TAB && (State & NORMAL) && (!wp->w_p_list || lcs_tab1))
-	col += win_lbr_chartabsize(wp, s, (colnr_T)col, NULL) - 1;
-
-    /*
-     * Add column offset for 'number', 'foldcolumn', etc.
-     */
-    width = W_WIDTH(wp) - win_col_off(wp);
-    if (width > 0)
-    {
-	lines += 1;
-	if (col >= width)
-	    lines += (col - width) / (width + win_col_off2(wp));
-	if (lines <= wp->w_height)
-	    return lines;
-    }
-    return (int)(wp->w_height);	    /* maximum length */
-}
-
-    int
-plines_m_win(wp, first, last)
-    win_T	*wp;
-    linenr_T	first, last;
-{
-    int		count = 0;
-
-    while (first <= last)
-    {
-#ifdef FEAT_FOLDING
-	int	x;
-
-	/* Check if there are any really folded lines, but also included lines
-	 * that are maybe folded. */
-	x = foldedCount(wp, first, NULL);
-	if (x > 0)
-	{
-	    ++count;	    /* count 1 for "+-- folded" line */
-	    first += x;
-	}
-	else
-#endif
-	{
-#ifdef FEAT_DIFF
-	    if (first == wp->w_topline)
-		count += plines_win_nofill(wp, first, TRUE) + wp->w_topfill;
-	    else
-#endif
-		count += plines_win(wp, first, TRUE);
-	    ++first;
-	}
-    }
-    return (count);
-}
-
-#if defined(FEAT_VREPLACE) || defined(FEAT_INS_EXPAND) || defined(PROTO)
-/*
- * Insert string "p" at the cursor position.  Stops at a NUL byte.
- * Handles Replace mode and multi-byte characters.
- */
-    void
-ins_bytes(p)
-    char_u	*p;
-{
-    ins_bytes_len(p, (int)STRLEN(p));
-}
-#endif
-
-#if defined(FEAT_VREPLACE) || defined(FEAT_INS_EXPAND) \
-	|| defined(FEAT_COMMENTS) || defined(FEAT_MBYTE) || defined(PROTO)
-/*
- * Insert string "p" with length "len" at the cursor position.
- * Handles Replace mode and multi-byte characters.
- */
-    void
-ins_bytes_len(p, len)
-    char_u	*p;
-    int		len;
-{
-    int		i;
-# ifdef FEAT_MBYTE
-    int		n;
-
-    for (i = 0; i < len; i += n)
-    {
-	n = (*mb_ptr2len_check)(p + i);
-	ins_char_bytes(p + i, n);
-    }
-# else
-    for (i = 0; i < len; ++i)
-	ins_char(p[i]);
-# endif
-}
-#endif
-
-/*
- * Insert or replace a single character at the cursor position.
- * When in REPLACE or VREPLACE mode, replace any existing character.
- * Caller must have prepared for undo.
- * For multi-byte characters we get the whole character, the caller must
- * convert bytes to a character.
- */
-    void
-ins_char(c)
-    int		c;
-{
-#if defined(FEAT_MBYTE) || defined(PROTO)
-    char_u	buf[MB_MAXBYTES];
-    int		n;
-
-    n = (*mb_char2bytes)(c, buf);
-
-    /* When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
-     * Happens for CTRL-Vu9900. */
-    if (buf[0] == 0)
-	buf[0] = '\n';
-
-    ins_char_bytes(buf, n);
-}
-
-    void
-ins_char_bytes(buf, charlen)
-    char_u	*buf;
-    int		charlen;
-{
-    int		c = buf[0];
-    int		l, j;
-#endif
-    int		newlen;		/* nr of bytes inserted */
-    int		oldlen;		/* nr of bytes deleted (0 when not replacing) */
-    char_u	*p;
-    char_u	*newp;
-    char_u	*oldp;
-    int		linelen;	/* length of old line including NUL */
-    colnr_T	col;
-    linenr_T	lnum = curwin->w_cursor.lnum;
-    int		i;
-
-#ifdef FEAT_VIRTUALEDIT
-    /* Break tabs if needed. */
-    if (virtual_active() && curwin->w_cursor.coladd > 0)
-	coladvance_force(getviscol());
-#endif
-
-    col = curwin->w_cursor.col;
-    oldp = ml_get(lnum);
-    linelen = (int)STRLEN(oldp) + 1;
-
-    /* The lengths default to the values for when not replacing. */
-    oldlen = 0;
-#ifdef FEAT_MBYTE
-    newlen = charlen;
-#else
-    newlen = 1;
-#endif
-
-    if (State & REPLACE_FLAG)
-    {
-#ifdef FEAT_VREPLACE
-	if (State & VREPLACE_FLAG)
-	{
-	    colnr_T	new_vcol = 0;   /* init for GCC */
-	    colnr_T	vcol;
-	    int		old_list;
-#ifndef FEAT_MBYTE
-	    char_u	buf[2];
-#endif
-
-	    /*
-	     * Disable 'list' temporarily, unless 'cpo' contains the 'L' flag.
-	     * Returns the old value of list, so when finished,
-	     * curwin->w_p_list should be set back to this.
-	     */
-	    old_list = curwin->w_p_list;
-	    if (old_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)
-		curwin->w_p_list = FALSE;
-
-	    /*
-	     * In virtual replace mode each character may replace one or more
-	     * characters (zero if it's a TAB).  Count the number of bytes to
-	     * be deleted to make room for the new character, counting screen
-	     * cells.  May result in adding spaces to fill a gap.
-	     */
-	    getvcol(curwin, &curwin->w_cursor, NULL, &vcol, NULL);
-#ifndef FEAT_MBYTE
-	    buf[0] = c;
-	    buf[1] = NUL;
-#endif
-	    new_vcol = vcol + chartabsize(buf, vcol);
-	    while (oldp[col + oldlen] != NUL && vcol < new_vcol)
-	    {
-		vcol += chartabsize(oldp + col + oldlen, vcol);
-		/* Don't need to remove a TAB that takes us to the right
-		 * position. */
-		if (vcol > new_vcol && oldp[col + oldlen] == TAB)
-		    break;
-#ifdef FEAT_MBYTE
-		oldlen += (*mb_ptr2len_check)(oldp + col + oldlen);
-#else
-		++oldlen;
-#endif
-		/* Deleted a bit too much, insert spaces. */
-		if (vcol > new_vcol)
-		    newlen += vcol - new_vcol;
-	    }
-	    curwin->w_p_list = old_list;
-	}
-	else
-#endif
-	    if (oldp[col] != NUL)
-	{
-	    /* normal replace */
-#ifdef FEAT_MBYTE
-	    oldlen = (*mb_ptr2len_check)(oldp + col);
-#else
-	    oldlen = 1;
-#endif
-	}
-
-
-	/* Push the replaced bytes onto the replace stack, so that they can be
-	 * put back when BS is used.  The bytes of a multi-byte character are
-	 * done the other way around, so that the first byte is popped off
-	 * first (it tells the byte length of the character). */
-	replace_push(NUL);
-	for (i = 0; i < oldlen; ++i)
-	{
-#ifdef FEAT_MBYTE
-	    l = (*mb_ptr2len_check)(oldp + col + i) - 1;
-	    for (j = l; j >= 0; --j)
-		replace_push(oldp[col + i + j]);
-	    i += l;
-#else
-	    replace_push(oldp[col + i]);
-#endif
-	}
-    }
-
-    newp = alloc_check((unsigned)(linelen + newlen - oldlen));
-    if (newp == NULL)
-	return;
-
-    /* Copy bytes before the cursor. */
-    if (col > 0)
-	mch_memmove(newp, oldp, (size_t)col);
-
-    /* Copy bytes after the changed character(s). */
-    p = newp + col;
-    mch_memmove(p + newlen, oldp + col + oldlen,
-					    (size_t)(linelen - col - oldlen));
-
-    /* Insert or overwrite the new character. */
-#ifdef FEAT_MBYTE
-    mch_memmove(p, buf, charlen);
-    i = charlen;
-#else
-    *p = c;
-    i = 1;
-#endif
-
-    /* Fill with spaces when necessary. */
-    while (i < newlen)
-	p[i++] = ' ';
-
-    /* Replace the line in the buffer. */
-    ml_replace(lnum, newp, FALSE);
-
-    /* mark the buffer as changed and prepare for displaying */
-    changed_bytes(lnum, col);
-
-    /*
-     * If we're in Insert or Replace mode and 'showmatch' is set, then briefly
-     * show the match for right parens and braces.
-     */
-    if (p_sm && (State & INSERT)
-	    && msg_silent == 0
-#ifdef FEAT_MBYTE
-	    && charlen == 1
-#endif
-       )
-	showmatch(c);
-
-#ifdef FEAT_RIGHTLEFT
-    if (!p_ri || (State & REPLACE_FLAG))
-#endif
-    {
-	/* Normal insert: move cursor right */
-#ifdef FEAT_MBYTE
-	curwin->w_cursor.col += charlen;
-#else
-	++curwin->w_cursor.col;
-#endif
-    }
-    /*
-     * TODO: should try to update w_row here, to avoid recomputing it later.
-     */
-}
-
-/*
- * Insert a string at the cursor position.
- * Note: Does NOT handle Replace mode.
- * Caller must have prepared for undo.
- */
-    void
-ins_str(s)
-    char_u	*s;
-{
-    char_u	*oldp, *newp;
-    int		newlen = (int)STRLEN(s);
-    int		oldlen;
-    colnr_T	col;
-    linenr_T	lnum = curwin->w_cursor.lnum;
-
-#ifdef FEAT_VIRTUALEDIT
-    if (virtual_active() && curwin->w_cursor.coladd > 0)
-	coladvance_force(getviscol());
-#endif
-
-    col = curwin->w_cursor.col;
-    oldp = ml_get(lnum);
-    oldlen = (int)STRLEN(oldp);
-
-    newp = alloc_check((unsigned)(oldlen + newlen + 1));
-    if (newp == NULL)
-	return;
-    if (col > 0)
-	mch_memmove(newp, oldp, (size_t)col);
-    mch_memmove(newp + col, s, (size_t)newlen);
-    mch_memmove(newp + col + newlen, oldp + col, (size_t)(oldlen - col + 1));
-    ml_replace(lnum, newp, FALSE);
-    changed_bytes(lnum, col);
-    curwin->w_cursor.col += newlen;
-}
-
-/*
- * Delete one character under the cursor.
- * If "fixpos" is TRUE, don't leave the cursor on the NUL after the line.
- * Caller must have prepared for undo.
- *
- * return FAIL for failure, OK otherwise
- */
-    int
-del_char(fixpos)
-    int		fixpos;
-{
-#ifdef FEAT_MBYTE
-    if (has_mbyte)
-    {
-	/* Make sure the cursor is at the start of a character. */
-	mb_adjust_cursor();
-	if (*ml_get_cursor() == NUL)
-	    return FAIL;
-	return del_chars(1L, fixpos);
-    }
-#endif
-    return del_bytes(1L, fixpos);
-}
-
-#if defined(FEAT_MBYTE) || defined(PROTO)
-/*
- * Like del_bytes(), but delete characters instead of bytes.
- */
-    int
-del_chars(count, fixpos)
-    long	count;
-    int		fixpos;
-{
-    long	bytes = 0;
-    long	i;
-    char_u	*p;
-    int		l;
-
-    p = ml_get_cursor();
-    for (i = 0; i < count && *p != NUL; ++i)
-    {
-	l = (*mb_ptr2len_check)(p);
-	bytes += l;
-	p += l;
-    }
-    return del_bytes(bytes, fixpos);
-}
-#endif
-
-/*
- * Delete "count" bytes under the cursor.
- * If "fixpos" is TRUE, don't leave the cursor on the NUL after the line.
- * Caller must have prepared for undo.
- *
- * return FAIL for failure, OK otherwise
- */
-    int
-del_bytes(count, fixpos)
-    long	count;
-    int		fixpos;
-{
-    char_u	*oldp, *newp;
-    colnr_T	oldlen;
-    linenr_T	lnum = curwin->w_cursor.lnum;
-    colnr_T	col = curwin->w_cursor.col;
-    int		was_alloced;
-    long	movelen;
-
-    oldp = ml_get(lnum);
-    oldlen = (int)STRLEN(oldp);
-
-    /*
-     * Can't do anything when the cursor is on the NUL after the line.
-     */
-    if (col >= oldlen)
-	return FAIL;
-
-#ifdef FEAT_MBYTE
-    /* If 'delcombine' is set and deleting (less than) one character, only
-     * delete the last combining character. */
-    if (p_deco && enc_utf8 && utfc_ptr2len_check(oldp + col) >= count)
-    {
-	int	c1, c2;
-	int	n;
-
-	(void)utfc_ptr2char(oldp + col, &c1, &c2);
-	if (c1 != NUL)
-	{
-	    /* Find the last composing char, there can be several. */
-	    n = col;
-	    do
-	    {
-		col = n;
-		count = utf_ptr2len_check(oldp + n);
-		n += count;
-	    } while (UTF_COMPOSINGLIKE(oldp + col, oldp + n));
-	    fixpos = 0;
-	}
-    }
-#endif
-
-    /*
-     * When count is too big, reduce it.
-     */
-    movelen = (long)oldlen - (long)col - count + 1; /* includes trailing NUL */
-    if (movelen <= 1)
-    {
-	/*
-	 * If we just took off the last character of a non-blank line, and
-	 * fixpos is TRUE, we don't want to end up positioned at the NUL.
-	 */
-	if (col > 0 && fixpos)
-	{
-	    --curwin->w_cursor.col;
-#ifdef FEAT_VIRTUALEDIT
-	    curwin->w_cursor.coladd = 0;
-#endif
-#ifdef FEAT_MBYTE
-	    if (has_mbyte)
-		curwin->w_cursor.col -=
-			    (*mb_head_off)(oldp, oldp + curwin->w_cursor.col);
-#endif
-	}
-	count = oldlen - col;
-	movelen = 1;
-    }
-
-    /*
-     * If the old line has been allocated the deletion can be done in the
-     * existing line. Otherwise a new line has to be allocated
-     */
-    was_alloced = ml_line_alloced();	    /* check if oldp was allocated */
-#ifdef FEAT_NETBEANS_INTG
-    if (was_alloced && usingNetbeans)
-	netbeans_removed(curbuf, lnum, col, count);
-    /* else is handled by ml_replace() */
-#endif
-    if (was_alloced)
-	newp = oldp;			    /* use same allocated memory */
-    else
-    {					    /* need to allocate a new line */
-	newp = alloc((unsigned)(oldlen + 1 - count));
-	if (newp == NULL)
-	    return FAIL;
-	mch_memmove(newp, oldp, (size_t)col);
-    }
-    mch_memmove(newp + col, oldp + col + count, (size_t)movelen);
-    if (!was_alloced)
-	ml_replace(lnum, newp, FALSE);
-
-    /* mark the buffer as changed and prepare for displaying */
-    changed_bytes(lnum, curwin->w_cursor.col);
-
-    return OK;
-}
-
-/*
- * Delete from cursor to end of line.
- * Caller must have prepared for undo.
- *
- * return FAIL for failure, OK otherwise
- */
-    int
-truncate_line(fixpos)
-    int		fixpos;	    /* if TRUE fix the cursor position when done */
-{
-    char_u	*newp;
-    linenr_T	lnum = curwin->w_cursor.lnum;
-    colnr_T	col = curwin->w_cursor.col;
-
-    if (col == 0)
-	newp = vim_strsave((char_u *)"");
-    else
-	newp = vim_strnsave(ml_get(lnum), col);
-
-    if (newp == NULL)
-	return FAIL;
-
-    ml_replace(lnum, newp, FALSE);
-
-    /* mark the buffer as changed and prepare for displaying */
-    changed_bytes(lnum, curwin->w_cursor.col);
-
-    /*
-     * If "fixpos" is TRUE we don't want to end up positioned at the NUL.
-     */
-    if (fixpos && curwin->w_cursor.col > 0)
-	--curwin->w_cursor.col;
-
-    return OK;
-}
-
-/*
- * Delete "nlines" lines at the cursor.
- * Saves the lines for undo first if "undo" is TRUE.
- */
-    void
-del_lines(nlines, undo)
-    long	nlines;		/* number of lines to delete */
-    int		undo;		/* if TRUE, prepare for undo */
-{
-    long	n;
-
-    if (nlines <= 0)
-	return;
-
-    /* save the deleted lines for undo */
-    if (undo && u_savedel(curwin->w_cursor.lnum, nlines) == FAIL)
-	return;
-
-    for (n = 0; n < nlines; )
-    {
-	if (curbuf->b_ml.ml_flags & ML_EMPTY)	    /* nothing to delete */
-	    break;
-
-	ml_delete(curwin->w_cursor.lnum, TRUE);
-	++n;
-
-	/* If we delete the last line in the file, stop */
-	if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
-	    break;
-    }
-    /* adjust marks, mark the buffer as changed and prepare for displaying */
-    deleted_lines_mark(curwin->w_cursor.lnum, n);
-
-    curwin->w_cursor.col = 0;
-    check_cursor_lnum();
-}
-
-    int
-gchar_pos(pos)
-    pos_T *pos;
-{
-    char_u	*ptr = ml_get_pos(pos);
-
-#ifdef FEAT_MBYTE
-    if (has_mbyte)
-	return (*mb_ptr2char)(ptr);
-#endif
-    return (int)*ptr;
-}
-
-    int
-gchar_cursor()
-{
-#ifdef FEAT_MBYTE
-    if (has_mbyte)
-	return (*mb_ptr2char)(ml_get_cursor());
-#endif
-    return (int)*ml_get_cursor();
-}
-
-/*
- * Write a character at the current cursor position.
- * It is directly written into the block.
- */
-    void
-pchar_cursor(c)
-    int c;
-{
-    *(ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE)
-						  + curwin->w_cursor.col) = c;
-}
-
-#if 0 /* not used */
-/*
- * Put *pos at end of current buffer
- */
-    void
-goto_endofbuf(pos)
-    pos_T    *pos;
-{
-    char_u  *p;
-
-    pos->lnum = curbuf->b_ml.ml_line_count;
-    pos->col = 0;
-    p = ml_get(pos->lnum);
-    while (*p++)
-	++pos->col;
-}
-#endif
-
-/*
- * When extra == 0: Return TRUE if the cursor is before or on the first
- *		    non-blank in the line.
- * When extra == 1: Return TRUE if the cursor is before the first non-blank in
- *		    the line.
- */
-    int
-inindent(extra)
-    int	    extra;
-{
-    char_u	*ptr;
-    colnr_T	col;
-
-    for (col = 0, ptr = ml_get_curline(); vim_iswhite(*ptr); ++col)
-	++ptr;
-    if (col >= curwin->w_cursor.col + extra)
-	return TRUE;
-    else
-	return FALSE;
-}
-
-/*
- * Skip to next part of an option argument: Skip space and comma.
- */
-    char_u *
-skip_to_option_part(p)
-    char_u  *p;
-{
-    if (*p == ',')
-	++p;
-    while (*p == ' ')
-	++p;
-    return p;
-}
-
-/*
- * changed() is called when something in the current buffer is changed.
- *
- * Most often called through changed_bytes() and changed_lines(), which also
- * mark the area of the display to be redrawn.
- */
-    void
-changed()
-{
-#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
-    /* The text of the preediting area is inserted, but this doesn't
-     * mean a change of the buffer yet.  That is delayed until the
-     * text is committed. (this means preedit becomes empty) */
-    if (im_is_preediting() && !xim_changed_while_preediting)
-	return;
-    xim_changed_while_preediting = FALSE;
-#endif
-
-    if (!curbuf->b_changed)
-    {
-	int	save_msg_scroll = msg_scroll;
-
-	change_warning(0);
-	/* Create a swap file if that is wanted.
-	 * Don't do this for "nofile" and "nowrite" buffer types. */
-	if (curbuf->b_may_swap
-#ifdef FEAT_QUICKFIX
-		&& !bt_dontwrite(curbuf)
-#endif
-		)
-	{
-	    ml_open_file(curbuf);
-
-	    /* The ml_open_file() can cause an ATTENTION message.
-	     * Wait two seconds, to make sure the user reads this unexpected
-	     * message.  Since we could be anywhere, call wait_return() now,
-	     * and don't let the emsg() set msg_scroll. */
-	    if (need_wait_return && emsg_silent == 0)
-	    {
-		out_flush();
-		ui_delay(2000L, TRUE);
-		wait_return(TRUE);
-		msg_scroll = save_msg_scroll;
-	    }
-	}
-	curbuf->b_changed = TRUE;
-	ml_setdirty(curbuf, TRUE);
-#ifdef FEAT_WINDOWS
-	check_status(curbuf);
-#endif
-#ifdef FEAT_TITLE
-	need_maketitle = TRUE;	    /* set window title later */
-#endif
-    }
-    ++curbuf->b_changedtick;
-    ++global_changedtick;
-}
-
-static void changedOneline __ARGS((linenr_T lnum));
-static void changed_common __ARGS((linenr_T lnum, colnr_T col, linenr_T lnume, long xtra));
-
-/*
- * Changed bytes within a single line for the current buffer.
- * - marks the windows on this buffer to be redisplayed
- * - marks the buffer changed by calling changed()
- * - invalidates cached values
- */
-    void
-changed_bytes(lnum, col)
-    linenr_T	lnum;
-    colnr_T	col;
-{
-    changedOneline(lnum);
-    changed_common(lnum, col, lnum + 1, 0L);
-}
-
-    static void
-changedOneline(lnum)
-    linenr_T	lnum;
-{
-    if (curbuf->b_mod_set)
-    {
-	/* find the maximum area that must be redisplayed */
-	if (lnum < curbuf->b_mod_top)
-	    curbuf->b_mod_top = lnum;
-	else if (lnum >= curbuf->b_mod_bot)
-	    curbuf->b_mod_bot = lnum + 1;
-    }
-    else
-    {
-	/* set the area that must be redisplayed to one line */
-	curbuf->b_mod_set = TRUE;
-	curbuf->b_mod_top = lnum;
-	curbuf->b_mod_bot = lnum + 1;
-	curbuf->b_mod_xlines = 0;
-    }
-}
-
-/*
- * Appended "count" lines below line "lnum" in the current buffer.
- * Must be called AFTER the change and after mark_adjust().
- * Takes care of marking the buffer to be redrawn and sets the changed flag.
- */
-    void
-appended_lines(lnum, count)
-    linenr_T	lnum;
-    long	count;
-{
-    changed_lines(lnum + 1, 0, lnum + 1, count);
-}
-
-/*
- * Like appended_lines(), but adjust marks first.
- */
-    void
-appended_lines_mark(lnum, count)
-    linenr_T	lnum;
-    long	count;
-{
-    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, count, 0L);
-    changed_lines(lnum + 1, 0, lnum + 1, count);
-}
-
-/*
- * Deleted "count" lines at line "lnum" in the current buffer.
- * Must be called AFTER the change and after mark_adjust().
- * Takes care of marking the buffer to be redrawn and sets the changed flag.
- */
-    void
-deleted_lines(lnum, count)
-    linenr_T	lnum;
-    long	count;
-{
-    changed_lines(lnum, 0, lnum + count, -count);
-}
-
-/*
- * Like deleted_lines(), but adjust marks first.
- */
-    void
-deleted_lines_mark(lnum, count)
-    linenr_T	lnum;
-    long	count;
-{
-    mark_adjust(lnum, (linenr_T)(lnum + count - 1), (long)MAXLNUM, -count);
-    changed_lines(lnum, 0, lnum + count, -count);
-}
-
-/*
- * Changed lines for the current buffer.
- * Must be called AFTER the change and after mark_adjust().
- * - mark the buffer changed by calling changed()
- * - mark the windows on this buffer to be redisplayed
- * - invalidate cached values
- * "lnum" is the first line that needs displaying, "lnume" the first line
- * below the changed lines (BEFORE the change).
- * When only inserting lines, "lnum" and "lnume" are equal.
- * Takes care of calling changed() and updating b_mod_*.
- */
-    void
-changed_lines(lnum, col, lnume, xtra)
-    linenr_T	lnum;	    /* first line with change */
-    colnr_T	col;	    /* column in first line with change */
-    linenr_T	lnume;	    /* line below last changed line */
-    long	xtra;	    /* number of extra lines (negative when deleting) */
-{
-    if (curbuf->b_mod_set)
-    {
-	/* find the maximum area that must be redisplayed */
-	if (lnum < curbuf->b_mod_top)
-	    curbuf->b_mod_top = lnum;
-	if (lnum < curbuf->b_mod_bot)
-	{
-	    /* adjust old bot position for xtra lines */
-	    curbuf->b_mod_bot += xtra;
-	    if (curbuf->b_mod_bot < lnum)
-		curbuf->b_mod_bot = lnum;
-	}
-	if (lnume + xtra > curbuf->b_mod_bot)
-	    curbuf->b_mod_bot = lnume + xtra;
-	curbuf->b_mod_xlines += xtra;
-    }
-    else
-    {
-	/* set the area that must be redisplayed */
-	curbuf->b_mod_set = TRUE;
-	curbuf->b_mod_top = lnum;
-	curbuf->b_mod_bot = lnume + xtra;
-	curbuf->b_mod_xlines = xtra;
-    }
-
-    changed_common(lnum, col, lnume, xtra);
-}
-
-    static void
-changed_common(lnum, col, lnume, xtra)
-    linenr_T	lnum;
-    colnr_T	col;
-    linenr_T	lnume;
-    long	xtra;
-{
-    win_T	*wp;
-    int		i;
-#ifdef FEAT_JUMPLIST
-    int		cols;
-    pos_T	*p;
-    int		add;
-#endif
-
-    /* mark the buffer as modified */
-    changed();
-
-    /* set the '. mark */
-    if (!cmdmod.keepjumps)
-    {
-	curbuf->b_last_change.lnum = lnum;
-	curbuf->b_last_change.col = col;
-
-#ifdef FEAT_JUMPLIST
-	/* Create a new entry if a new undo-able change was started or we
-	 * don't have an entry yet. */
-	if (curbuf->b_new_change || curbuf->b_changelistlen == 0)
-	{
-	    if (curbuf->b_changelistlen == 0)
-		add = TRUE;
-	    else
-	    {
-		/* Don't create a new entry when the line number is the same
-		 * as the last one and the column is not too far away.  Avoids
-		 * creating many entries for typing "xxxxx". */
-		p = &curbuf->b_changelist[curbuf->b_changelistlen - 1];
-		if (p->lnum != lnum)
-		    add = TRUE;
-		else
-		{
-		    cols = comp_textwidth(FALSE);
-		    if (cols == 0)
-			cols = 79;
-		    add = (p->col + cols < col || col + cols < p->col);
-		}
-	    }
-	    if (add)
-	    {
-		/* This is the first of a new sequence of undo-able changes
-		 * and it's at some distance of the last change.  Use a new
-		 * position in the changelist. */
-		curbuf->b_new_change = FALSE;
-
-		if (curbuf->b_changelistlen == JUMPLISTSIZE)
-		{
-		    /* changelist is full: remove oldest entry */
-		    curbuf->b_changelistlen = JUMPLISTSIZE - 1;
-		    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,
-					  sizeof(pos_T) * (JUMPLISTSIZE - 1));
-		    FOR_ALL_WINDOWS(wp)
-		    {
-			/* Correct position in changelist for other windows on
-			 * this buffer. */
-			if (wp->w_buffer == curbuf && wp->w_changelistidx > 0)
-			    --wp->w_changelistidx;
-		    }
-		}
-		FOR_ALL_WINDOWS(wp)
-		{
-		    /* For other windows, if the position in the changelist is
-		     * at the end it stays at the end. */
-		    if (wp->w_buffer == curbuf
-			    && wp->w_changelistidx == curbuf->b_changelistlen)
-			++wp->w_changelistidx;
-		}
-		++curbuf->b_changelistlen;
-	    }
-	}
-	curbuf->b_changelist[curbuf->b_changelistlen - 1] =
-							curbuf->b_last_change;
-	/* The current window is always after the last change, so that "g,"
-	 * takes you back to it. */
-	curwin->w_changelistidx = curbuf->b_changelistlen;
-#endif
-    }
-
-    FOR_ALL_WINDOWS(wp)
-    {
-	if (wp->w_buffer == curbuf)
-	{
-	    /* Mark this window to be redrawn later. */
-	    if (wp->w_redr_type < VALID)
-		wp->w_redr_type = VALID;
-
-	    /* Check if a change in the buffer has invalidated the cached
-	     * values for the cursor. */
-#ifdef FEAT_FOLDING
-	    /*
-	     * Update the folds for this window.  Can't postpone this, because
-	     * a following operator might work on the whole fold: ">>dd".
-	     */
-	    foldUpdate(wp, lnum, lnume + xtra - 1);
-
-	    /* The change may cause lines above or below the change to become
-	     * included in a fold.  Set lnum/lnume to the first/last line that
-	     * might be displayed differently.
-	     * Set w_cline_folded here as an efficient way to update it when
-	     * inserting lines just above a closed fold. */
-	    i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL);
-	    if (wp->w_cursor.lnum == lnum)
-		wp->w_cline_folded = i;
-	    i = hasFoldingWin(wp, lnume, NULL, &lnume, FALSE, NULL);
-	    if (wp->w_cursor.lnum == lnume)
-		wp->w_cline_folded = i;
-
-	    /* If the changed line is in a range of previously folded lines,
-	     * compare with the first line in that range. */
-	    if (wp->w_cursor.lnum <= lnum)
-	    {
-		i = find_wl_entry(wp, lnum);
-		if (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum)
-		    changed_line_abv_curs_win(wp);
-	    }
-#endif
-
-	    if (wp->w_cursor.lnum > lnum)
-		changed_line_abv_curs_win(wp);
-	    else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col)
-		changed_cline_bef_curs_win(wp);
-	    if (wp->w_botline >= lnum)
-	    {
-		/* Assume that botline doesn't change (inserted lines make
-		 * other lines scroll down below botline). */
-		approximate_botline_win(wp);
-	    }
-
-	    /* Check if any w_lines[] entries have become invalid.
-	     * For entries below the change: Correct the lnums for
-	     * inserted/deleted lines.  Makes it possible to stop displaying
-	     * after the change. */
-	    for (i = 0; i < wp->w_lines_valid; ++i)
-		if (wp->w_lines[i].wl_valid)
-		{
-		    if (wp->w_lines[i].wl_lnum >= lnum)
-		    {
-			if (wp->w_lines[i].wl_lnum < lnume)
-			{
-			    /* line included in change */
-			    wp->w_lines[i].wl_valid = FALSE;
-			}
-			else if (xtra != 0)
-			{
-			    /* line below change */
-			    wp->w_lines[i].wl_lnum += xtra;
-#ifdef FEAT_FOLDING
-			    wp->w_lines[i].wl_lastlnum += xtra;
-#endif
-			}
-		    }
-#ifdef FEAT_FOLDING
-		    else if (wp->w_lines[i].wl_lastlnum >= lnum)
-		    {
-			/* change somewhere inside this range of folded lines,
-			 * may need to be redrawn */
-			wp->w_lines[i].wl_valid = FALSE;
-		    }
-#endif
-		}
-	}
-    }
-
-    /* Call update_screen() later, which checks out what needs to be redrawn,
-     * since it notices b_mod_set and then uses b_mod_*. */
-    if (must_redraw < VALID)
-	must_redraw = VALID;
-}
-
-/*
- * unchanged() is called when the changed flag must be reset for buffer 'buf'
- */
-    void
-unchanged(buf, ff)
-    buf_T	*buf;
-    int		ff;	/* also reset 'fileformat' */
-{
-    if (buf->b_changed || (ff && file_ff_differs(buf)))
-    {
-	buf->b_changed = 0;
-	ml_setdirty(buf, FALSE);
-	if (ff)
-	    save_file_ff(buf);
-#ifdef FEAT_WINDOWS
-	check_status(buf);
-#endif
-#ifdef FEAT_TITLE
-	need_maketitle = TRUE;	    /* set window title later */
-#endif
-    }
-    ++buf->b_changedtick;
-    ++global_changedtick;
-#ifdef FEAT_NETBEANS_INTG
-    netbeans_unmodified(buf);
-#endif
-}
-
-#if defined(FEAT_WINDOWS) || defined(PROTO)
-/*
- * check_status: called when the status bars for the buffer 'buf'
- *		 need to be updated
- */
-    void
-check_status(buf)
-    buf_T	*buf;
-{
-    win_T	*wp;
-
-    for (wp = firstwin; wp != NULL; wp = wp->w_next)
-	if (wp->w_buffer == buf && wp->w_status_height)
-	{
-	    wp->w_redr_status = TRUE;
-	    if (must_redraw < VALID)
-		must_redraw = VALID;
-	}
-}
-#endif
-
-/*
- * If the file is readonly, give a warning message with the first change.
- * Don't do this for autocommands.
- * Don't use emsg(), because it flushes the macro buffer.
- * If we have undone all changes b_changed will be FALSE, but b_did_warn
- * will be TRUE.
- */
-    void
-change_warning(col)
-    int	    col;		/* column for message; non-zero when in insert
-				   mode and 'showmode' is on */
-{
-    if (curbuf->b_did_warn == FALSE
-	    && curbufIsChanged() == 0
-#ifdef FEAT_AUTOCMD
-	    && !autocmd_busy
-#endif
-	    && curbuf->b_p_ro)
-    {
-#ifdef FEAT_AUTOCMD
-	apply_autocmds(EVENT_FILECHANGEDRO, NULL, NULL, FALSE, curbuf);
-	if (!curbuf->b_p_ro)
-	    return;
-#endif
-	/*
-	 * Do what msg() does, but with a column offset if the warning should
-	 * be after the mode message.
-	 */
-	msg_start();
-	if (msg_row == Rows - 1)
-	    msg_col = col;
-	MSG_PUTS_ATTR(_("W10: Warning: Changing a readonly file"),
-						   hl_attr(HLF_W) | MSG_HIST);
-	msg_clr_eos();
-	(void)msg_end();
-	if (msg_silent == 0 && !silent_mode)
-	{
-	    out_flush();
-	    ui_delay(1000L, TRUE); /* give the user time to think about it */
-	}
-	curbuf->b_did_warn = TRUE;
-	redraw_cmdline = FALSE;	/* don't redraw and erase the message */
-	if (msg_row < Rows - 1)
-	    showmode();
-    }
-}
-
-/*
- * Ask for a reply from the user, a 'y' or a 'n'.
- * No other characters are accepted, the message is repeated until a valid
- * reply is entered or CTRL-C is hit.
- * If direct is TRUE, don't use vgetc() but ui_inchar(), don't get characters
- * from any buffers but directly from the user.
- *
- * return the 'y' or 'n'
- */
-    int
-ask_yesno(str, direct)
-    char_u  *str;
-    int	    direct;
-{
-    int	    r = ' ';
-    int	    save_State = State;
-
-    if (exiting)		/* put terminal in raw mode for this question */
-	settmode(TMODE_RAW);
-    ++no_wait_return;
-#ifdef USE_ON_FLY_SCROLL
-    dont_scroll = TRUE;		/* disallow scrolling here */
-#endif
-    State = CONFIRM;		/* mouse behaves like with :confirm */
-#ifdef FEAT_MOUSE
-    setmouse();			/* disables mouse for xterm */
-#endif
-    ++no_mapping;
-    ++allow_keys;		/* no mapping here, but recognize keys */
-
-    while (r != 'y' && r != 'n')
-    {
-	/* same highlighting as for wait_return */
-	smsg_attr(hl_attr(HLF_R), (char_u *)"%s (y/n)?", str);
-	if (direct)
-	    r = get_keystroke();
-	else
-	    r = safe_vgetc();
-	if (r == Ctrl_C || r == ESC)
-	    r = 'n';
-	msg_putchar(r);	    /* show what you typed */
-	out_flush();
-    }
-    --no_wait_return;
-    State = save_State;
-#ifdef FEAT_MOUSE
-    setmouse();
-#endif
-    --no_mapping;
-    --allow_keys;
-
-    return r;
-}
-
-/*
- * Get a key stroke directly from the user.
- * Ignores mouse clicks and scrollbar events, except a click for the left
- * button (used at the more prompt).
- * Doesn't use vgetc(), because it syncs undo and eats mapped characters.
- * Disadvantage: typeahead is ignored.
- * Translates the interrupt character for unix to ESC.
- */
-    int
-get_keystroke()
-{
-#define CBUFLEN 151
-    char_u	buf[CBUFLEN];
-    int		len = 0;
-    int		n;
-    int		save_mapped_ctrl_c = mapped_ctrl_c;
-
-    mapped_ctrl_c = FALSE;	/* mappings are not used here */
-    for (;;)
-    {
-	cursor_on();
-	out_flush();
-
-	/* First time: blocking wait.  Second time: wait up to 100ms for a
-	 * terminal code to complete.  Leave some room for check_termcode() to
-	 * insert a key code into (max 5 chars plus NUL).  And
-	 * fix_input_buffer() can triple the number of bytes. */
-	n = ui_inchar(buf + len, (CBUFLEN - 6 - len) / 3,
-						    len == 0 ? -1L : 100L, 0);
-	if (n > 0)
-	{
-	    /* Replace zero and CSI by a special key code. */
-	    n = fix_input_buffer(buf + len, n, FALSE);
-	    len += n;
-	}
-
-	/* incomplete termcode: get more characters */
-	if ((n = check_termcode(1, buf, len)) < 0)
-	    continue;
-	/* found a termcode: adjust length */
-	if (n > 0)
-	    len = n;
-	if (len == 0)	    /* nothing typed yet */
-	    continue;
-
-	/* Handle modifier and/or special key code. */
-	n = buf[0];
-	if (n == K_SPECIAL)
-	{
-	    n = TO_SPECIAL(buf[1], buf[2]);
-	    if (buf[1] == KS_MODIFIER
-		    || n == K_IGNORE
-#ifdef FEAT_MOUSE
-		    || n == K_LEFTMOUSE_NM
-		    || n == K_LEFTDRAG
-		    || n == K_LEFTRELEASE
-		    || n == K_LEFTRELEASE_NM
-		    || n == K_MIDDLEMOUSE
-		    || n == K_MIDDLEDRAG
-		    || n == K_MIDDLERELEASE
-		    || n == K_RIGHTMOUSE
-		    || n == K_RIGHTDRAG
-		    || n == K_RIGHTRELEASE
-		    || n == K_MOUSEDOWN
-		    || n == K_MOUSEUP
-		    || n == K_X1MOUSE
-		    || n == K_X1DRAG
-		    || n == K_X1RELEASE
-		    || n == K_X2MOUSE
-		    || n == K_X2DRAG
-		    || n == K_X2RELEASE
-# ifdef FEAT_GUI
-		    || n == K_VER_SCROLLBAR
-		    || n == K_HOR_SCROLLBAR
-# endif
-#endif
-	       )
-	    {
-		if (buf[1] == KS_MODIFIER)
-		    mod_mask = buf[2];
-		len -= 3;
-		if (len > 0)
-		    mch_memmove(buf, buf + 3, (size_t)len);
-		continue;
-	    }
-	}
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	{
-	    if (MB_BYTE2LEN(n) > len)
-		continue;	/* more bytes to get */
-	    buf[len >= CBUFLEN ? CBUFLEN - 1 : len] = NUL;
-	    n = (*mb_ptr2char)(buf);
-	}
-#endif
-#ifdef UNIX
-	if (n == intr_char)
-	    n = ESC;
-#endif
-	break;
-    }
-
-    mapped_ctrl_c = save_mapped_ctrl_c;
-    return n;
-}
-
-/*
- * get a number from the user
- */
-    int
-get_number(colon)
-    int	colon;			/* allow colon to abort */
-{
-    int	n = 0;
-    int	c;
-
-    /* When not printing messages, the user won't know what to type, return a
-     * zero (as if CR was hit). */
-    if (msg_silent != 0)
-	return 0;
-
-#ifdef USE_ON_FLY_SCROLL
-    dont_scroll = TRUE;		/* disallow scrolling here */
-#endif
-    ++no_mapping;
-    ++allow_keys;		/* no mapping here, but recognize keys */
-    for (;;)
-    {
-	windgoto(msg_row, msg_col);
-	c = safe_vgetc();
-	if (VIM_ISDIGIT(c))
-	{
-	    n = n * 10 + c - '0';
-	    msg_putchar(c);
-	}
-	else if (c == K_DEL || c == K_KDEL || c == K_BS || c == Ctrl_H)
-	{
-	    n /= 10;
-	    MSG_PUTS("\b \b");
-	}
-	else if (n == 0 && c == ':' && colon)
-	{
-	    stuffcharReadbuff(':');
-	    if (!exmode_active)
-		cmdline_row = msg_row;
-	    skip_redraw = TRUE;	    /* skip redraw once */
-	    do_redraw = FALSE;
-	    break;
-	}
-	else if (c == CAR || c == NL || c == Ctrl_C || c == ESC)
-	    break;
-    }
-    --no_mapping;
-    --allow_keys;
-    return n;
-}
-
-    void
-msgmore(n)
-    long n;
-{
-    long pn;
-
-    if (global_busy	    /* no messages now, wait until global is finished */
-	    || keep_msg != NULL /* there is a message already, skip this one */
-	    || !messaging())  /* 'lazyredraw' set, don't do messages now */
-	return;
-
-    if (n > 0)
-	pn = n;
-    else
-	pn = -n;
-
-    if (pn > p_report)
-    {
-	if (pn == 1)
-	{
-	    if (n > 0)
-		STRCPY(msg_buf, _("1 more line"));
-	    else
-		STRCPY(msg_buf, _("1 line less"));
-	}
-	else
-	{
-	    if (n > 0)
-		sprintf((char *)msg_buf, _("%ld more lines"), pn);
-	    else
-		sprintf((char *)msg_buf, _("%ld fewer lines"), pn);
-	}
-	if (got_int)
-	    STRCAT(msg_buf, _(" (Interrupted)"));
-	if (msg(msg_buf))
-	{
-	    set_keep_msg(msg_buf);
-	    keep_msg_attr = 0;
-	}
-    }
-}
-
-/*
- * flush map and typeahead buffers and give a warning for an error
- */
-    void
-beep_flush()
-{
-    if (emsg_silent == 0)
-    {
-	flush_buffers(FALSE);
-	vim_beep();
-    }
-}
-
-/*
- * give a warning for an error
- */
-    void
-vim_beep()
-{
-    if (emsg_silent == 0)
-    {
-	if (p_vb
-#ifdef FEAT_GUI
-		/* While the GUI is starting up the termcap is set for the GUI
-		 * but the output still goes to a terminal. */
-		&& !(gui.in_use && gui.starting)
-#endif
-		)
-	{
-	    out_str(T_VB);
-	}
-	else
-	{
-#ifdef MSDOS
-	    /*
-	     * The number of beeps outputted is reduced to avoid having to wait
-	     * for all the beeps to finish. This is only a problem on systems
-	     * where the beeps don't overlap.
-	     */
-	    if (beep_count == 0 || beep_count == 10)
-	    {
-		out_char(BELL);
-		beep_count = 1;
-	    }
-	    else
-		++beep_count;
-#else
-	    out_char(BELL);
-#endif
-	}
-    }
-}
-
-/*
- * To get the "real" home directory:
- * - get value of $HOME
- * For Unix:
- *  - go to that directory
- *  - do mch_dirname() to get the real name of that directory.
- *  This also works with mounts and links.
- *  Don't do this for MS-DOS, it will change the "current dir" for a drive.
- */
-static char_u	*homedir = NULL;
-
-    void
-init_homedir()
-{
-    char_u  *var;
-
-#ifdef VMS
-    var = mch_getenv((char_u *)"SYS$LOGIN");
-#else
-    var = mch_getenv((char_u *)"HOME");
-#endif
-
-    if (var != NULL && *var == NUL)	/* empty is same as not set */
-	var = NULL;
-
-#ifdef WIN3264
-    /*
-     * Weird but true: $HOME may contain an indirect reference to another
-     * variable, esp. "%USERPROFILE%".  Happens when $USERPROFILE isn't set
-     * when $HOME is being set.
-     */
-    if (var != NULL && *var == '%')
-    {
-	char_u	*p;
-	char_u	*exp;
-
-	p = vim_strchr(var + 1, '%');
-	if (p != NULL)
-	{
-	    STRNCPY(NameBuff, var + 1, p - (var + 1));
-	    NameBuff[p - (var + 1)] = NUL;
-	    exp = mch_getenv(NameBuff);
-	    if (exp != NULL && *exp != NUL
-					&& STRLEN(exp) + STRLEN(p) < MAXPATHL)
-	    {
-		sprintf((char *)NameBuff, "%s%s", exp, p + 1);
-		var = NameBuff;
-		/* Also set $HOME, it's needed for _viminfo. */
-		vim_setenv((char_u *)"HOME", NameBuff);
-	    }
-	}
-    }
-
-    /*
-     * Typically, $HOME is not defined on Windows, unless the user has
-     * specifically defined it for Vim's sake.  However, on Windows NT
-     * platforms, $HOMEDRIVE and $HOMEPATH are automatically defined for
-     * each user.  Try constructing $HOME from these.
-     */
-    if (var == NULL)
-    {
-	char_u *homedrive, *homepath;
-
-	homedrive = mch_getenv((char_u *)"HOMEDRIVE");
-	homepath = mch_getenv((char_u *)"HOMEPATH");
-	if (homedrive != NULL && homepath != NULL
-			   && STRLEN(homedrive) + STRLEN(homepath) < MAXPATHL)
-	{
-	    sprintf((char *)NameBuff, "%s%s", homedrive, homepath);
-	    if (NameBuff[0] != NUL)
-	    {
-		var = NameBuff;
-		/* Also set $HOME, it's needed for _viminfo. */
-		vim_setenv((char_u *)"HOME", NameBuff);
-	    }
-	}
-    }
-#endif
-
-#if defined(OS2) || defined(MSDOS) || defined(MSWIN)
-    /*
-     * Default home dir is C:/
-     * Best assumption we can make in such a situation.
-     */
-    if (var == NULL)
-	var = "C:/";
-#endif
-    if (var != NULL)
-    {
-#ifdef UNIX
-	/*
-	 * Change to the directory and get the actual path.  This resolves
-	 * links.  Don't do it when we can't return.
-	 */
-	if (mch_dirname(NameBuff, MAXPATHL) == OK
-					  && mch_chdir((char *)NameBuff) == 0)
-	{
-	    if (!mch_chdir((char *)var) && mch_dirname(IObuff, IOSIZE) == OK)
-		var = IObuff;
-	    if (mch_chdir((char *)NameBuff) != 0)
-		EMSG(_(e_prev_dir));
-	}
-#endif
-	homedir = vim_strsave(var);
-    }
-}
-
-/*
- * Expand environment variable with path name.
- * "~/" is also expanded, using $HOME.	For Unix "~user/" is expanded.
- * Skips over "\ ", "\~" and "\$".
- * If anything fails no expansion is done and dst equals src.
- */
-    void
-expand_env(src, dst, dstlen)
-    char_u	*src;		/* input string e.g. "$HOME/vim.hlp" */
-    char_u	*dst;		/* where to put the result */
-    int		dstlen;		/* maximum length of the result */
-{
-    expand_env_esc(src, dst, dstlen, FALSE);
-}
-
-    void
-expand_env_esc(src, dst, dstlen, esc)
-    char_u	*src;		/* input string e.g. "$HOME/vim.hlp" */
-    char_u	*dst;		/* where to put the result */
-    int		dstlen;		/* maximum length of the result */
-    int		esc;		/* escape spaces in expanded variables */
-{
-    char_u	*tail;
-    int		c;
-    char_u	*var;
-    int		copy_char;
-    int		mustfree;	/* var was allocated, need to free it later */
-    int		at_start = TRUE; /* at start of a name */
-
-    src = skipwhite(src);
-    --dstlen;		    /* leave one char space for "\," */
-    while (*src && dstlen > 0)
-    {
-	copy_char = TRUE;
-	if ((*src == '$'
-#ifdef VMS
-		    && at_start
-#endif
-	   )
-#if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-		|| *src == '%'
-#endif
-		|| (*src == '~' && at_start))
-	{
-	    mustfree = FALSE;
-
-	    /*
-	     * The variable name is copied into dst temporarily, because it may
-	     * be a string in read-only memory and a NUL needs to be appended.
-	     */
-	    if (*src != '~')				/* environment var */
-	    {
-		tail = src + 1;
-		var = dst;
-		c = dstlen - 1;
-
-#ifdef UNIX
-		/* Unix has ${var-name} type environment vars */
-		if (*tail == '{' && !vim_isIDc('{'))
-		{
-		    tail++;	/* ignore '{' */
-		    while (c-- > 0 && *tail && *tail != '}')
-			*var++ = *tail++;
-		}
-		else
-#endif
-		{
-		    while (c-- > 0 && *tail != NUL && ((vim_isIDc(*tail))
-#if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-			    || (*src == '%' && *tail != '%')
-#endif
-			    ))
-		    {
-#ifdef OS2		/* env vars only in uppercase */
-			*var++ = TOUPPER_LOC(*tail);
-			tail++;	    /* toupper() may be a macro! */
-#else
-			*var++ = *tail++;
-#endif
-		    }
-		}
-
-#if defined(MSDOS) || defined(MSWIN) || defined(OS2) || defined(UNIX)
-# ifdef UNIX
-		if (src[1] == '{' && *tail != '}')
-# else
-		if (*src == '%' && *tail != '%')
-# endif
-		    var = NULL;
-		else
-		{
-# ifdef UNIX
-		    if (src[1] == '{')
-# else
-		    if (*src == '%')
-#endif
-			++tail;
-#endif
-		    *var = NUL;
-		    var = vim_getenv(dst, &mustfree);
-#if defined(MSDOS) || defined(MSWIN) || defined(OS2) || defined(UNIX)
-		}
-#endif
-	    }
-							/* home directory */
-	    else if (  src[1] == NUL
-		    || vim_ispathsep(src[1])
-		    || vim_strchr((char_u *)" ,\t\n", src[1]) != NULL)
-	    {
-		var = homedir;
-		tail = src + 1;
-	    }
-	    else					/* user directory */
-	    {
-#if defined(UNIX) || (defined(VMS) && defined(USER_HOME))
-		/*
-		 * Copy ~user to dst[], so we can put a NUL after it.
-		 */
-		tail = src;
-		var = dst;
-		c = dstlen - 1;
-		while (	   c-- > 0
-			&& *tail
-			&& vim_isfilec(*tail)
-			&& !vim_ispathsep(*tail))
-		    *var++ = *tail++;
-		*var = NUL;
-# ifdef UNIX
-		/*
-		 * If the system supports getpwnam(), use it.
-		 * Otherwise, or if getpwnam() fails, the shell is used to
-		 * expand ~user.  This is slower and may fail if the shell
-		 * does not support ~user (old versions of /bin/sh).
-		 */
-#  if defined(HAVE_GETPWNAM) && defined(HAVE_PWD_H)
-		{
-		    struct passwd *pw;
-
-		    pw = getpwnam((char *)dst + 1);
-		    if (pw != NULL)
-			var = (char_u *)pw->pw_dir;
-		    else
-			var = NULL;
-		}
-		if (var == NULL)
-#  endif
-		{
-		    expand_T	xpc;
-
-		    ExpandInit(&xpc);
-		    xpc.xp_context = EXPAND_FILES;
-		    var = ExpandOne(&xpc, dst, NULL,
-				WILD_ADD_SLASH|WILD_SILENT, WILD_EXPAND_FREE);
-		    ExpandCleanup(&xpc);
-		    mustfree = TRUE;
-		}
-
-# else	/* !UNIX, thus VMS */
-		/*
-		 * USER_HOME is a comma-separated list of
-		 * directories to search for the user account in.
-		 */
-		{
-		    char_u	test[MAXPATHL], paths[MAXPATHL];
-		    char_u	*path, *next_path, *ptr;
-		    struct stat	st;
-
-		    STRCPY(paths, USER_HOME);
-		    next_path = paths;
-		    while (*next_path)
-		    {
-			for (path = next_path; *next_path && *next_path != ',';
-				next_path++);
-			if (*next_path)
-			    *next_path++ = NUL;
-			STRCPY(test, path);
-			STRCAT(test, "/");
-			STRCAT(test, dst + 1);
-			if (mch_stat(test, &st) == 0)
-			{
-			    var = alloc(STRLEN(test) + 1);
-			    STRCPY(var, test);
-			    mustfree = TRUE;
-			    break;
-			}
-		    }
-		}
-# endif /* UNIX */
-#else
-		/* cannot expand user's home directory, so don't try */
-		var = NULL;
-		tail = (char_u *)"";	/* for gcc */
-#endif /* UNIX || VMS */
-	    }
-
-#ifdef BACKSLASH_IN_FILENAME
-	    /* If 'shellslash' is set change backslashes to forward slashes.
-	     * Can't use slash_adjust(), p_ssl may be set temporarily. */
-	    if (p_ssl && var != NULL && vim_strchr(var, '\\') != NULL)
-	    {
-		char_u	*p = vim_strsave(var);
-
-		if (p != NULL)
-		{
-		    if (mustfree)
-			vim_free(var);
-		    var = p;
-		    mustfree = TRUE;
-		    forward_slash(var);
-		}
-	    }
-#endif
-
-	    /* If "var" contains white space, escape it with a backslash.
-	     * Required for ":e ~/tt" when $HOME includes a space. */
-	    if (esc && var != NULL && vim_strpbrk(var, (char_u *)" \t") != NULL)
-	    {
-		char_u	*p = vim_strsave_escaped(var, (char_u *)" \t");
-
-		if (p != NULL)
-		{
-		    if (mustfree)
-			vim_free(var);
-		    var = p;
-		    mustfree = TRUE;
-		}
-	    }
-
-	    if (var != NULL && *var != NUL
-		    && (STRLEN(var) + STRLEN(tail) + 1 < (unsigned)dstlen))
-	    {
-		STRCPY(dst, var);
-		dstlen -= (int)STRLEN(var);
-		dst += STRLEN(var);
-		/* if var[] ends in a path separator and tail[] starts
-		 * with it, skip a character */
-		if (*var != NUL && vim_ispathsep(dst[-1])
-#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA)
-			&& dst[-1] != ':'
-#endif
-			&& vim_ispathsep(*tail))
-		    ++tail;
-		src = tail;
-		copy_char = FALSE;
-	    }
-	    if (mustfree)
-		vim_free(var);
-	}
-
-	if (copy_char)	    /* copy at least one char */
-	{
-	    /*
-	     * Recogize the start of a new name, for '~'.
-	     */
-	    at_start = FALSE;
-	    if (src[0] == '\\' && src[1] != NUL)
-	    {
-		*dst++ = *src++;
-		--dstlen;
-	    }
-	    else if (src[0] == ' ' || src[0] == ',')
-		at_start = TRUE;
-	    *dst++ = *src++;
-	    --dstlen;
-	}
-    }
-    *dst = NUL;
-}
-
-/*
- * Vim's version of getenv().
- * Special handling of $HOME, $VIM and $VIMRUNTIME.
- */
-    char_u *
-vim_getenv(name, mustfree)
-    char_u	*name;
-    int		*mustfree;	/* set to TRUE when returned is allocated */
-{
-    char_u	*p;
-    char_u	*pend;
-    int		vimruntime;
-
-#if defined(OS2) || defined(MSDOS) || defined(MSWIN)
-    /* use "C:/" when $HOME is not set */
-    if (STRCMP(name, "HOME") == 0)
-	return homedir;
-#endif
-
-    p = mch_getenv(name);
-    if (p != NULL && *p == NUL)	    /* empty is the same as not set */
-	p = NULL;
-
-    if (p != NULL)
-	return p;
-
-    vimruntime = (STRCMP(name, "VIMRUNTIME") == 0);
-    if (!vimruntime && STRCMP(name, "VIM") != 0)
-	return NULL;
-
-    /*
-     * When expanding $VIMRUNTIME fails, try using $VIM/vim<version> or $VIM.
-     * Don't do this when default_vimruntime_dir is non-empty.
-     */
-    if (vimruntime
-#ifdef HAVE_PATHDEF
-	    && *default_vimruntime_dir == NUL
-#endif
-       )
-    {
-	p = mch_getenv((char_u *)"VIM");
-	if (p != NULL && *p == NUL)	    /* empty is the same as not set */
-	    p = NULL;
-	if (p != NULL)
-	{
-	    p = vim_version_dir(p);
-	    if (p != NULL)
-		*mustfree = TRUE;
-	    else
-		p = mch_getenv((char_u *)"VIM");
-	}
-    }
-
-    /*
-     * When expanding $VIM or $VIMRUNTIME fails, try using:
-     * - the directory name from 'helpfile' (unless it contains '$')
-     * - the executable name from argv[0]
-     */
-    if (p == NULL)
-    {
-	if (p_hf != NULL && vim_strchr(p_hf, '$') == NULL)
-	    p = p_hf;
-#ifdef USE_EXE_NAME
-	/*
-	 * Use the name of the executable, obtained from argv[0].
-	 */
-	else
-	    p = exe_name;
-#endif
-	if (p != NULL)
-	{
-	    /* remove the file name */
-	    pend = gettail(p);
-
-	    /* remove "doc/" from 'helpfile', if present */
-	    if (p == p_hf)
-		pend = remove_tail(p, pend, (char_u *)"doc");
-
-#ifdef USE_EXE_NAME
-# ifdef MACOS_X
-	    /* remove "build/..." from exe_name, if present */
-	    if (p == exe_name)
-	    {
-		char_u	*pend1;
-		char_u  *pend2;
-
-		pend1 = remove_tail(p, pend, (char_u *)"Contents/MacOS");
-		pend2 = remove_tail_with_ext(p, pend1, (char_u *)".app");
-		pend = remove_tail(p, pend2, (char_u *)"build");
-		/* When runnig from project builder get rid of the
-		 * build/???.app, otherwise keep the ???.app */
-		if (pend2 == pend)
-		    pend = pend1;
-	    }
-# endif
-	    /* remove "src/" from exe_name, if present */
-	    if (p == exe_name)
-		pend = remove_tail(p, pend, (char_u *)"src");
-#endif
-
-	    /* for $VIM, remove "runtime/" or "vim54/", if present */
-	    if (!vimruntime)
-	    {
-		pend = remove_tail(p, pend, (char_u *)RUNTIME_DIRNAME);
-		pend = remove_tail(p, pend, (char_u *)VIM_VERSION_NODOT);
-	    }
-
-	    /* remove trailing path separator */
-#ifndef MACOS_CLASSIC
-	    /* With MacOS path (with  colons) the final colon is required */
-	    /* to avoid confusion between absoulute and relative path */
-	    if (pend > p && vim_ispathsep(*(pend - 1)))
-		--pend;
-#endif
-
-	    /* check that the result is a directory name */
-	    p = vim_strnsave(p, (int)(pend - p));
-
-	    if (p != NULL && !mch_isdir(p))
-	    {
-		vim_free(p);
-		p = NULL;
-	    }
-	    else
-	    {
-#ifdef USE_EXE_NAME
-		/* may add "/vim54" or "/runtime" if it exists */
-		if (vimruntime && (pend = vim_version_dir(p)) != NULL)
-		{
-		    vim_free(p);
-		    p = pend;
-		}
-#endif
-		*mustfree = TRUE;
-	    }
-	}
-    }
-
-#ifdef HAVE_PATHDEF
-    /* When there is a pathdef.c file we can use default_vim_dir and
-     * default_vimruntime_dir */
-    if (p == NULL)
-    {
-	/* Only use default_vimruntime_dir when it is not empty */
-	if (vimruntime && *default_vimruntime_dir != NUL)
-	{
-	    p = default_vimruntime_dir;
-	    *mustfree = FALSE;
-	}
-	else if (*default_vim_dir != NUL)
-	{
-	    if (vimruntime && (p = vim_version_dir(default_vim_dir)) != NULL)
-		*mustfree = TRUE;
-	    else
-	    {
-		p = default_vim_dir;
-		*mustfree = FALSE;
-	    }
-	}
-    }
-#endif
-
-    /*
-     * Set the environment variable, so that the new value can be found fast
-     * next time, and others can also use it (e.g. Perl).
-     */
-    if (p != NULL)
-    {
-	if (vimruntime)
-	{
-	    vim_setenv((char_u *)"VIMRUNTIME", p);
-	    didset_vimruntime = TRUE;
-#ifdef FEAT_GETTEXT
-	    {
-		char_u	*buf = alloc((unsigned int)STRLEN(p) + 6);
-
-		if (buf != NULL)
-		{
-		    STRCPY(buf, p);
-		    STRCAT(buf, "/lang");
-		    bindtextdomain(VIMPACKAGE, (char *)buf);
-		    vim_free(buf);
-		}
-	    }
-#endif
-	}
-	else
-	{
-	    vim_setenv((char_u *)"VIM", p);
-	    didset_vim = TRUE;
-	}
-    }
-    return p;
-}
-
-/*
- * Check if the directory "vimdir/<version>" or "vimdir/runtime" exists.
- * Return NULL if not, return its name in allocated memory otherwise.
- */
-    static char_u *
-vim_version_dir(vimdir)
-    char_u	*vimdir;
-{
-    char_u	*p;
-
-    if (vimdir == NULL || *vimdir == NUL)
-	return NULL;
-    p = concat_fnames(vimdir, (char_u *)VIM_VERSION_NODOT, TRUE);
-    if (p != NULL && mch_isdir(p))
-	return p;
-    vim_free(p);
-    p = concat_fnames(vimdir, (char_u *)RUNTIME_DIRNAME, TRUE);
-    if (p != NULL && mch_isdir(p))
-	return p;
-    vim_free(p);
-    return NULL;
-}
-
-/*
- * If the string between "p" and "pend" ends in "name/", return "pend" minus
- * the length of "name/".  Otherwise return "pend".
- */
-    static char_u *
-remove_tail(p, pend, name)
-    char_u	*p;
-    char_u	*pend;
-    char_u	*name;
-{
-    int		len = (int)STRLEN(name) + 1;
-    char_u	*newend = pend - len;
-
-    if (newend >= p
-	    && fnamencmp(newend, name, len - 1) == 0
-	    && (newend == p || vim_ispathsep(*(newend - 1))))
-	return newend;
-    return pend;
-}
-
-#if defined(USE_EXE_NAME) && defined(MACOS_X)
-/*
- * If the string between "p" and "pend" ends in "???.ext/", return "pend"
- * minus the length of "???.ext/".  Otherwise return "pend".
- */
-    static char_u *
-remove_tail_with_ext(p, pend, ext)
-    char_u	*p;
-    char_u	*pend;
-    char_u	*ext;
-{
-    int		len = (int)STRLEN(ext) + 1;
-    char_u	*newend = pend - len;
-
-    if (newend >= p && fnamencmp(newend, ext, len - 1) == 0)
-	while (newend != p && !vim_ispathsep(*(newend - 1)))
-	    --newend;
-    if (newend == p || vim_ispathsep(*(newend - 1)))
-	return newend;
-    return pend;
-}
-#endif
-
-/*
- * Call expand_env() and store the result in an allocated string.
- * This is not very memory efficient, this expects the result to be freed
- * again soon.
- */
-    char_u *
-expand_env_save(src)
-    char_u	*src;
-{
-    char_u	*p;
-
-    p = alloc(MAXPATHL);
-    if (p != NULL)
-	expand_env(src, p, MAXPATHL);
-    return p;
-}
-
-/*
- * Our portable version of setenv.
- */
-    void
-vim_setenv(name, val)
-    char_u	*name;
-    char_u	*val;
-{
-#ifdef HAVE_SETENV
-    mch_setenv((char *)name, (char *)val, 1);
-#else
-    char_u	*envbuf;
-
-    /*
-     * Putenv does not copy the string, it has to remain
-     * valid.  The allocated memory will never be freed.
-     */
-    envbuf = alloc((unsigned)(STRLEN(name) + STRLEN(val) + 2));
-    if (envbuf != NULL)
-    {
-	sprintf((char *)envbuf, "%s=%s", name, val);
-	putenv((char *)envbuf);
-    }
-#endif
-}
-
-#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
-/*
- * Function given to ExpandGeneric() to obtain an environment variable name.
- */
-/*ARGSUSED*/
-    char_u *
-get_env_name(xp, idx)
-    expand_T	*xp;
-    int		idx;
-{
-# if defined(AMIGA) || defined(__MRC__) || defined(__SC__)
-    /*
-     * No environ[] on the Amiga and on the Mac (using MPW).
-     */
-    return NULL;
-# else
-# ifndef __WIN32__
-    /* Borland C++ 5.2 has this in a header file. */
-    extern char		**environ;
-# endif
-    static char_u	name[100];
-    char_u		*str;
-    int			n;
-
-    str = (char_u *)environ[idx];
-    if (str == NULL)
-	return NULL;
-
-    for (n = 0; n < 99; ++n)
-    {
-	if (str[n] == '=' || str[n] == NUL)
-	    break;
-	name[n] = str[n];
-    }
-    name[n] = NUL;
-    return name;
-# endif
-}
-#endif
-
-/*
- * Replace home directory by "~" in each space or comma separated file name in
- * 'src'.
- * If anything fails (except when out of space) dst equals src.
- */
-    void
-home_replace(buf, src, dst, dstlen, one)
-    buf_T	*buf;	/* when not NULL, check for help files */
-    char_u	*src;	/* input file name */
-    char_u	*dst;	/* where to put the result */
-    int		dstlen;	/* maximum length of the result */
-    int		one;	/* if TRUE, only replace one file name, include
-			   spaces and commas in the file name. */
-{
-    size_t	dirlen = 0, envlen = 0;
-    size_t	len;
-    char_u	*homedir_env;
-    char_u	*p;
-
-    if (src == NULL)
-    {
-	*dst = NUL;
-	return;
-    }
-
-    /*
-     * If the file is a help file, remove the path completely.
-     */
-    if (buf != NULL && buf->b_help)
-    {
-	STRCPY(dst, gettail(src));
-	return;
-    }
-
-    /*
-     * We check both the value of the $HOME environment variable and the
-     * "real" home directory.
-     */
-    if (homedir != NULL)
-	dirlen = STRLEN(homedir);
-
-#ifdef VMS
-    homedir_env = mch_getenv((char_u *)"SYS$LOGIN");
-#else
-    homedir_env = mch_getenv((char_u *)"HOME");
-#endif
-
-    if (homedir_env != NULL && *homedir_env == NUL)
-	homedir_env = NULL;
-    if (homedir_env != NULL)
-	envlen = STRLEN(homedir_env);
-
-    if (!one)
-	src = skipwhite(src);
-    while (*src && dstlen > 0)
-    {
-	/*
-	 * Here we are at the beginning of a file name.
-	 * First, check to see if the beginning of the file name matches
-	 * $HOME or the "real" home directory. Check that there is a '/'
-	 * after the match (so that if e.g. the file is "/home/pieter/bla",
-	 * and the home directory is "/home/piet", the file does not end up
-	 * as "~er/bla" (which would seem to indicate the file "bla" in user
-	 * er's home directory)).
-	 */
-	p = homedir;
-	len = dirlen;
-	for (;;)
-	{
-	    if (   len
-		&& fnamencmp(src, p, len) == 0
-		&& (vim_ispathsep(src[len])
-		    || (!one && (src[len] == ',' || src[len] == ' '))
-		    || src[len] == NUL))
-	    {
-		src += len;
-		if (--dstlen > 0)
-		    *dst++ = '~';
-
-		/*
-		 * If it's just the home directory, add  "/".
-		 */
-		if (!vim_ispathsep(src[0]) && --dstlen > 0)
-		    *dst++ = '/';
-		break;
-	    }
-	    if (p == homedir_env)
-		break;
-	    p = homedir_env;
-	    len = envlen;
-	}
-
-	/* if (!one) skip to separator: space or comma */
-	while (*src && (one || (*src != ',' && *src != ' ')) && --dstlen > 0)
-	    *dst++ = *src++;
-	/* skip separator */
-	while ((*src == ' ' || *src == ',') && --dstlen > 0)
-	    *dst++ = *src++;
-    }
-    /* if (dstlen == 0) out of space, what to do??? */
-
-    *dst = NUL;
-}
-
-/*
- * Like home_replace, store the replaced string in allocated memory.
- * When something fails, NULL is returned.
- */
-    char_u  *
-home_replace_save(buf, src)
-    buf_T	*buf;	/* when not NULL, check for help files */
-    char_u	*src;	/* input file name */
-{
-    char_u	*dst;
-    unsigned	len;
-
-    len = 3;			/* space for "~/" and trailing NUL */
-    if (src != NULL)		/* just in case */
-	len += (unsigned)STRLEN(src);
-    dst = alloc(len);
-    if (dst != NULL)
-	home_replace(buf, src, dst, len, TRUE);
-    return dst;
-}
-
-/*
- * Compare two file names and return:
- * FPC_SAME   if they both exist and are the same file.
- * FPC_SAMEX  if they both don't exist and have the same file name.
- * FPC_DIFF   if they both exist and are different files.
- * FPC_NOTX   if they both don't exist.
- * FPC_DIFFX  if one of them doesn't exist.
- * For the first name environment variables are expanded
- */
-    int
-fullpathcmp(s1, s2, checkname)
-    char_u *s1, *s2;
-    int	    checkname;		/* when both don't exist, check file names */
-{
-#ifdef UNIX
-    char_u	    exp1[MAXPATHL];
-    char_u	    full1[MAXPATHL];
-    char_u	    full2[MAXPATHL];
-    struct stat	    st1, st2;
-    int		    r1, r2;
-
-    expand_env(s1, exp1, MAXPATHL);
-    r1 = mch_stat((char *)exp1, &st1);
-    r2 = mch_stat((char *)s2, &st2);
-    if (r1 != 0 && r2 != 0)
-    {
-	/* if mch_stat() doesn't work, may compare the names */
-	if (checkname)
-	{
-	    if (fnamecmp(exp1, s2) == 0)
-		return FPC_SAMEX;
-	    r1 = vim_FullName(exp1, full1, MAXPATHL, FALSE);
-	    r2 = vim_FullName(s2, full2, MAXPATHL, FALSE);
-	    if (r1 == OK && r2 == OK && fnamecmp(full1, full2) == 0)
-		return FPC_SAMEX;
-	}
-	return FPC_NOTX;
-    }
-    if (r1 != 0 || r2 != 0)
-	return FPC_DIFFX;
-    if (st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino)
-	return FPC_SAME;
-    return FPC_DIFF;
-#else
-    char_u  *exp1;		/* expanded s1 */
-    char_u  *full1;		/* full path of s1 */
-    char_u  *full2;		/* full path of s2 */
-    int	    retval = FPC_DIFF;
-    int	    r1, r2;
-
-    /* allocate one buffer to store three paths (alloc()/free() is slow!) */
-    if ((exp1 = alloc(MAXPATHL * 3)) != NULL)
-    {
-	full1 = exp1 + MAXPATHL;
-	full2 = full1 + MAXPATHL;
-
-	expand_env(s1, exp1, MAXPATHL);
-	r1 = vim_FullName(exp1, full1, MAXPATHL, FALSE);
-	r2 = vim_FullName(s2, full2, MAXPATHL, FALSE);
-
-	/* If vim_FullName() fails, the file probably doesn't exist. */
-	if (r1 != OK && r2 != OK)
-	{
-	    if (checkname && fnamecmp(exp1, s2) == 0)
-		retval = FPC_SAMEX;
-	    else
-		retval = FPC_NOTX;
-	}
-	else if (r1 != OK || r2 != OK)
-	    retval = FPC_DIFFX;
-	else if (fnamecmp(full1, full2))
-	    retval = FPC_DIFF;
-	else
-	    retval = FPC_SAME;
-	vim_free(exp1);
-    }
-    return retval;
-#endif
-}
-
-/*
- * get the tail of a path: the file name.
- */
-    char_u *
-gettail(fname)
-    char_u *fname;
-{
-    char_u  *p1, *p2;
-
-    if (fname == NULL)
-	return (char_u *)"";
-    for (p1 = p2 = fname; *p2; )	/* find last part of path */
-    {
-	if (vim_ispathsep(*p2))
-	    p1 = p2 + 1;
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	    p2 += (*mb_ptr2len_check)(p2);
-	else
-#endif
-	    ++p2;
-    }
-    return p1;
-}
-
-/*
- * get the next path component (just after the next path separator).
- */
-    char_u *
-getnextcomp(fname)
-    char_u *fname;
-{
-    while (*fname && !vim_ispathsep(*fname))
-	++fname;
-    if (*fname)
-	++fname;
-    return fname;
-}
-
-#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
-	|| defined(FEAT_SESSION) || defined(MSWIN) \
-	|| (defined(FEAT_GUI_GTK) \
-			    && (defined(FEAT_WINDOWS) || defined(FEAT_DND))) \
-	|| defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG) \
-	|| defined(PROTO)
-/*
- * Get a pointer to one character past the head of a path name.
- * Unix: after "/"; DOS: after "c:\"; Amiga: after "disk:/"; Mac: no head.
- * If there is no head, path is returned.
- */
-    char_u *
-get_past_head(path)
-    char_u  *path;
-{
-    char_u  *retval;
-
-#if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-    /* may skip "c:" */
-    if (isalpha(path[0]) && path[1] == ':')
-	retval = path + 2;
-    else
-	retval = path;
-#else
-# if defined(AMIGA)
-    /* may skip "label:" */
-    retval = vim_strchr(path, ':');
-    if (retval == NULL)
-	retval = path;
-# else	/* Unix */
-    retval = path;
-# endif
-#endif
-
-    while (vim_ispathsep(*retval))
-	++retval;
-
-    return retval;
-}
-#endif
-
-/*
- * return TRUE if 'c' is a path separator.
- */
-    int
-vim_ispathsep(c)
-    int c;
-{
-#ifdef RISCOS
-    return (c == '.' || c == ':');
-#else
-# ifdef UNIX
-    return (c == '/');	    /* UNIX has ':' inside file names */
-# else
-#  ifdef BACKSLASH_IN_FILENAME
-    return (c == ':' || c == '/' || c == '\\');
-#  else
-#   ifdef VMS
-    /* server"user passwd"::device:[full.path.name]fname.extension;version" */
-    return (c == ':' || c == '[' || c == ']' || c == '/'
-	    || c == '<' || c == '>' || c == '"' );
-#   else
-#    ifdef COLON_AS_PATHSEP
-    return (c == ':');
-#    else		/* Amiga */
-    return (c == ':' || c == '/');
-#    endif
-#   endif /* VMS */
-#  endif
-# endif
-#endif /* RISC OS */
-}
-
-#if defined(FEAT_SEARCHPATH) || defined(PROTO)
-/*
- * return TRUE if 'c' is a path list separator.
- */
-    int
-vim_ispathlistsep(c)
-    int c;
-{
-#ifdef UNIX
-    return (c == ':');
-#else
-    return (c == ';');	/* might not be rigth for every system... */
-#endif
-}
-#endif
-
-#if (defined(CASE_INSENSITIVE_FILENAME) && defined(BACKSLASH_IN_FILENAME)) \
-	|| defined(PROTO)
-/*
- * Versions of fnamecmp() and fnamencmp() that handle '/' and '\' equally.
- */
-    int
-vim_fnamecmp(x, y)
-    char_u	*x, *y;
-{
-    return vim_fnamencmp(x, y, MAXPATHL);
-}
-
-    int
-vim_fnamencmp(x, y, len)
-    char_u	*x, *y;
-    size_t	len;
-{
-    while (len > 0 && *x && *y)
-    {
-	if (TOLOWER_LOC(*x) != TOLOWER_LOC(*y)
-		&& !(*x == '/' && *y == '\\')
-		&& !(*x == '\\' && *y == '/'))
-	    break;
-	++x;
-	++y;
-	--len;
-    }
-    if (len == 0)
-	return 0;
-    return (*x - *y);
-}
-#endif
-
-/*
- * Concatenate file names fname1 and fname2 into allocated memory.
- * Only add a '/' or '\\' when 'sep' is TRUE and it is neccesary.
- */
-    char_u  *
-concat_fnames(fname1, fname2, sep)
-    char_u  *fname1;
-    char_u  *fname2;
-    int	    sep;
-{
-    char_u  *dest;
-
-    dest = alloc((unsigned)(STRLEN(fname1) + STRLEN(fname2) + 3));
-    if (dest != NULL)
-    {
-	STRCPY(dest, fname1);
-	if (sep)
-	    add_pathsep(dest);
-	STRCAT(dest, fname2);
-    }
-    return dest;
-}
-
-/*
- * Add a path separator to a file name, unless it already ends in a path
- * separator.
- */
-    void
-add_pathsep(p)
-    char_u	*p;
-{
-    if (*p != NUL && !vim_ispathsep(*(p + STRLEN(p) - 1)))
-	STRCAT(p, PATHSEPSTR);
-}
-
-/*
- * FullName_save - Make an allocated copy of a full file name.
- * Returns NULL when out of memory.
- */
-    char_u  *
-FullName_save(fname, force)
-    char_u	*fname;
-    int		force;	    /* force expansion, even when it already looks
-			       like a full path name */
-{
-    char_u	*buf;
-    char_u	*new_fname = NULL;
-
-    if (fname == NULL)
-	return NULL;
-
-    buf = alloc((unsigned)MAXPATHL);
-    if (buf != NULL)
-    {
-	if (vim_FullName(fname, buf, MAXPATHL, force) != FAIL)
-	    new_fname = vim_strsave(buf);
-	else
-	    new_fname = vim_strsave(fname);
-	vim_free(buf);
-    }
-    return new_fname;
-}
-
-#if defined(FEAT_CINDENT) || defined(FEAT_SYN_HL)
-
-static char_u	*skip_string __ARGS((char_u *p));
-
-/*
- * Find the start of a comment, not knowing if we are in a comment right now.
- * Search starts at w_cursor.lnum and goes backwards.
- */
-    pos_T *
-find_start_comment(ind_maxcomment)	    /* XXX */
-    int		ind_maxcomment;
-{
-    pos_T	*pos;
-    char_u	*line;
-    char_u	*p;
-
-    if ((pos = findmatchlimit(NULL, '*', FM_BACKWARD, ind_maxcomment)) == NULL)
-	return NULL;
-
-    /*
-     * Check if the comment start we found is inside a string.
-     */
-    line = ml_get(pos->lnum);
-    for (p = line; *p && (unsigned)(p - line) < pos->col; ++p)
-	p = skip_string(p);
-    if ((unsigned)(p - line) > pos->col)
-	return NULL;
-    return pos;
-}
-
-/*
- * Skip to the end of a "string" and a 'c' character.
- * If there is no string or character, return argument unmodified.
- */
-    static char_u *
-skip_string(p)
-    char_u  *p;
-{
-    int	    i;
-
-    /*
-     * We loop, because strings may be concatenated: "date""time".
-     */
-    for ( ; ; ++p)
-    {
-	if (p[0] == '\'')		    /* 'c' or '\n' or '\000' */
-	{
-	    if (!p[1])			    /* ' at end of line */
-		break;
-	    i = 2;
-	    if (p[1] == '\\')		    /* '\n' or '\000' */
-	    {
-		++i;
-		while (vim_isdigit(p[i - 1]))   /* '\000' */
-		    ++i;
-	    }
-	    if (p[i] == '\'')		    /* check for trailing ' */
-	    {
-		p += i;
-		continue;
-	    }
-	}
-	else if (p[0] == '"')		    /* start of string */
-	{
-	    for (++p; p[0]; ++p)
-	    {
-		if (p[0] == '\\' && p[1] != NUL)
-		    ++p;
-		else if (p[0] == '"')	    /* end of string */
-		    break;
-	    }
-	    if (p[0] == '"')
-		continue;
-	}
-	break;				    /* no string found */
-    }
-    if (!*p)
-	--p;				    /* backup from NUL */
-    return p;
-}
-#endif /* FEAT_CINDENT || FEAT_SYN_HL */
-
-#if defined(FEAT_CINDENT) || defined(PROTO)
-
-/*
- * Do C or expression indenting on the current line.
- */
-    void
-do_c_expr_indent()
-{
-# ifdef FEAT_EVAL
-    if (*curbuf->b_p_inde != NUL)
-	fixthisline(get_expr_indent);
-    else
-# endif
-	fixthisline(get_c_indent);
-}
-
-/*
- * Functions for C-indenting.
- * Most of this originally comes from Eric Fischer.
- */
-/*
- * Below "XXX" means that this function may unlock the current line.
- */
-
-static char_u	*cin_skipcomment __ARGS((char_u *));
-static int	cin_nocode __ARGS((char_u *));
-static pos_T	*find_line_comment __ARGS((void));
-static int	cin_islabel_skip __ARGS((char_u **));
-static int	cin_isdefault __ARGS((char_u *));
-static char_u	*after_label __ARGS((char_u *l));
-static int	get_indent_nolabel __ARGS((linenr_T lnum));
-static int	skip_label __ARGS((linenr_T, char_u **pp, int ind_maxcomment));
-static int	cin_first_id_amount __ARGS((void));
-static int	cin_get_equal_amount __ARGS((linenr_T lnum));
-static int	cin_ispreproc __ARGS((char_u *));
-static int	cin_ispreproc_cont __ARGS((char_u **pp, linenr_T *lnump));
-static int	cin_iscomment __ARGS((char_u *));
-static int	cin_islinecomment __ARGS((char_u *));
-static int	cin_isterminated __ARGS((char_u *, int, int));
-static int	cin_isinit __ARGS((void));
-static int	cin_isfuncdecl __ARGS((char_u **, linenr_T));
-static int	cin_isif __ARGS((char_u *));
-static int	cin_iselse __ARGS((char_u *));
-static int	cin_isdo __ARGS((char_u *));
-static int	cin_iswhileofdo __ARGS((char_u *, linenr_T, int));
-static int	cin_isbreak __ARGS((char_u *));
-static int	cin_is_cpp_baseclass __ARGS((char_u *line, colnr_T *col));
-static int	cin_ends_in __ARGS((char_u *, char_u *, char_u *));
-static int	cin_skip2pos __ARGS((pos_T *trypos));
-static pos_T	*find_start_brace __ARGS((int));
-static pos_T	*find_match_paren __ARGS((int, int));
-static int	corr_ind_maxparen __ARGS((int ind_maxparen, pos_T *startpos));
-static int	find_last_paren __ARGS((char_u *l, int start, int end));
-static int	find_match __ARGS((int lookfor, linenr_T ourscope, int ind_maxparen, int ind_maxcomment));
-
-/*
- * Skip over white space and C comments within the line.
- */
-    static char_u *
-cin_skipcomment(s)
-    char_u	*s;
-{
-    while (*s)
-    {
-	s = skipwhite(s);
-	if (*s != '/')
-	    break;
-	++s;
-	if (*s == '/')		/* slash-slash comment continues till eol */
-	{
-	    s += STRLEN(s);
-	    break;
-	}
-	if (*s != '*')
-	    break;
-	for (++s; *s; ++s)	/* skip slash-star comment */
-	    if (s[0] == '*' && s[1] == '/')
-	    {
-		s += 2;
-		break;
-	    }
-    }
-    return s;
-}
-
-/*
- * Return TRUE if there there is no code at *s.  White space and comments are
- * not considered code.
- */
-    static int
-cin_nocode(s)
-    char_u	*s;
-{
-    return *cin_skipcomment(s) == NUL;
-}
-
-/*
- * Check previous lines for a "//" line comment, skipping over blank lines.
- */
-    static pos_T *
-find_line_comment() /* XXX */
-{
-    static pos_T pos;
-    char_u	 *line;
-    char_u	 *p;
-
-    pos = curwin->w_cursor;
-    while (--pos.lnum > 0)
-    {
-	line = ml_get(pos.lnum);
-	p = skipwhite(line);
-	if (cin_islinecomment(p))
-	{
-	    pos.col = (int)(p - line);
-	    return &pos;
-	}
-	if (*p != NUL)
-	    break;
-    }
-    return NULL;
-}
-
-/*
- * Check if string matches "label:"; move to character after ':' if true.
- */
-    static int
-cin_islabel_skip(s)
-    char_u	**s;
-{
-    if (!vim_isIDc(**s))	    /* need at least one ID character */
-	return FALSE;
-
-    while (vim_isIDc(**s))
-	(*s)++;
-
-    *s = cin_skipcomment(*s);
-
-    /* "::" is not a label, it's C++ */
-    return (**s == ':' && *++*s != ':');
-}
-
-/*
- * Recognize a label: "label:".
- * Note: curwin->w_cursor must be where we are looking for the label.
- */
-    int
-cin_islabel(ind_maxcomment)		/* XXX */
-    int		ind_maxcomment;
-{
-    char_u	*s;
-
-    s = cin_skipcomment(ml_get_curline());
-
-    /*
-     * Exclude "default" from labels, since it should be indented
-     * like a switch label.  Same for C++ scope declarations.
-     */
-    if (cin_isdefault(s))
-	return FALSE;
-    if (cin_isscopedecl(s))
-	return FALSE;
-
-    if (cin_islabel_skip(&s))
-    {
-	/*
-	 * Only accept a label if the previous line is terminated or is a case
-	 * label.
-	 */
-	pos_T	cursor_save;
-	pos_T	*trypos;
-	char_u	*line;
-
-	cursor_save = curwin->w_cursor;
-	while (curwin->w_cursor.lnum > 1)
-	{
-	    --curwin->w_cursor.lnum;
-
-	    /*
-	     * If we're in a comment now, skip to the start of the comment.
-	     */
-	    curwin->w_cursor.col = 0;
-	    if ((trypos = find_start_comment(ind_maxcomment)) != NULL) /* XXX */
-		curwin->w_cursor = *trypos;
-
-	    line = ml_get_curline();
-	    if (cin_ispreproc(line))	/* ignore #defines, #if, etc. */
-		continue;
-	    if (*(line = cin_skipcomment(line)) == NUL)
-		continue;
-
-	    curwin->w_cursor = cursor_save;
-	    if (cin_isterminated(line, TRUE, FALSE)
-		    || cin_isscopedecl(line)
-		    || cin_iscase(line)
-		    || (cin_islabel_skip(&line) && cin_nocode(line)))
-		return TRUE;
-	    return FALSE;
-	}
-	curwin->w_cursor = cursor_save;
-	return TRUE;		/* label at start of file??? */
-    }
-    return FALSE;
-}
-
-/*
- * Recognize structure initialization and enumerations.
- * Q&D-Implementation:
- * check for "=" at end or "[typedef] enum" at beginning of line.
- */
-    static int
-cin_isinit(void)
-{
-    char_u	*s;
-
-    s = cin_skipcomment(ml_get_curline());
-
-    if (STRNCMP(s, "typedef", 7) == 0 && !vim_isIDc(s[7]))
-	s = cin_skipcomment(s + 7);
-
-    if (STRNCMP(s, "enum", 4) == 0 && !vim_isIDc(s[4]))
-	return TRUE;
-
-    if (cin_ends_in(s, (char_u *)"=", (char_u *)"{"))
-	return TRUE;
-
-    return FALSE;
-}
-
-/*
- * Recognize a switch label: "case .*:" or "default:".
- */
-     int
-cin_iscase(s)
-    char_u *s;
-{
-    s = cin_skipcomment(s);
-    if (STRNCMP(s, "case", 4) == 0 && !vim_isIDc(s[4]))
-    {
-	for (s += 4; *s; ++s)
-	{
-	    s = cin_skipcomment(s);
-	    if (*s == ':')
-	    {
-		if (s[1] == ':')	/* skip over "::" for C++ */
-		    ++s;
-		else
-		    return TRUE;
-	    }
-	    if (*s == '\'' && s[1] && s[2] == '\'')
-		s += 2;			/* skip over '.' */
-	    else if (*s == '/' && (s[1] == '*' || s[1] == '/'))
-		return FALSE;		/* stop at comment */
-	    else if (*s == '"')
-		return FALSE;		/* stop at string */
-	}
-	return FALSE;
-    }
-
-    if (cin_isdefault(s))
-	return TRUE;
-    return FALSE;
-}
-
-/*
- * Recognize a "default" switch label.
- */
-    static int
-cin_isdefault(s)
-    char_u  *s;
-{
-    return (STRNCMP(s, "default", 7) == 0
-	    && *(s = cin_skipcomment(s + 7)) == ':'
-	    && s[1] != ':');
-}
-
-/*
- * Recognize a "public/private/proctected" scope declaration label.
- */
-    int
-cin_isscopedecl(s)
-    char_u	*s;
-{
-    int		i;
-
-    s = cin_skipcomment(s);
-    if (STRNCMP(s, "public", 6) == 0)
-	i = 6;
-    else if (STRNCMP(s, "protected", 9) == 0)
-	i = 9;
-    else if (STRNCMP(s, "private", 7) == 0)
-	i = 7;
-    else
-	return FALSE;
-    return (*(s = cin_skipcomment(s + i)) == ':' && s[1] != ':');
-}
-
-/*
- * Return a pointer to the first non-empty non-comment character after a ':'.
- * Return NULL if not found.
- *	  case 234:    a = b;
- *		       ^
- */
-    static char_u *
-after_label(l)
-    char_u  *l;
-{
-    for ( ; *l; ++l)
-    {
-	if (*l == ':')
-	{
-	    if (l[1] == ':')	    /* skip over "::" for C++ */
-		++l;
-	    else if (!cin_iscase(l + 1))
-		break;
-	}
-	else if (*l == '\'' && l[1] && l[2] == '\'')
-	    l += 2;		    /* skip over 'x' */
-    }
-    if (*l == NUL)
-	return NULL;
-    l = cin_skipcomment(l + 1);
-    if (*l == NUL)
-	return NULL;
-    return l;
-}
-
-/*
- * Get indent of line "lnum", skipping a label.
- * Return 0 if there is nothing after the label.
- */
-    static int
-get_indent_nolabel(lnum)		/* XXX */
-    linenr_T	lnum;
-{
-    char_u	*l;
-    pos_T	fp;
-    colnr_T	col;
-    char_u	*p;
-
-    l = ml_get(lnum);
-    p = after_label(l);
-    if (p == NULL)
-	return 0;
-
-    fp.col = (colnr_T)(p - l);
-    fp.lnum = lnum;
-    getvcol(curwin, &fp, &col, NULL, NULL);
-    return (int)col;
-}
-
-/*
- * Find indent for line "lnum", ignoring any case or jump label.
- * Also return a pointer to the text (after the label).
- *   label:	if (asdf && asdfasdf)
- *		^
- */
-    static int
-skip_label(lnum, pp, ind_maxcomment)
-    linenr_T	lnum;
-    char_u	**pp;
-    int		ind_maxcomment;
-{
-    char_u	*l;
-    int		amount;
-    pos_T	cursor_save;
-
-    cursor_save = curwin->w_cursor;
-    curwin->w_cursor.lnum = lnum;
-    l = ml_get_curline();
-				    /* XXX */
-    if (cin_iscase(l) || cin_isscopedecl(l) || cin_islabel(ind_maxcomment))
-    {
-	amount = get_indent_nolabel(lnum);
-	l = after_label(ml_get_curline());
-	if (l == NULL)		/* just in case */
-	    l = ml_get_curline();
-    }
-    else
-    {
-	amount = get_indent();
-	l = ml_get_curline();
-    }
-    *pp = l;
-
-    curwin->w_cursor = cursor_save;
-    return amount;
-}
-
-/*
- * Return the indent of the first variable name after a type in a declaration.
- *  int	    a,			indent of "a"
- *  static struct foo    b,	indent of "b"
- *  enum bla    c,		indent of "c"
- * Returns zero when it doesn't look like a declaration.
- */
-    static int
-cin_first_id_amount()
-{
-    char_u	*line, *p, *s;
-    int		len;
-    pos_T	fp;
-    colnr_T	col;
-
-    line = ml_get_curline();
-    p = skipwhite(line);
-    len = skiptowhite(p) - p;
-    if (len == 6 && STRNCMP(p, "static", 6) == 0)
-    {
-	p = skipwhite(p + 6);
-	len = skiptowhite(p) - p;
-    }
-    if (len == 6 && STRNCMP(p, "struct", 6) == 0)
-	p = skipwhite(p + 6);
-    else if (len == 4 && STRNCMP(p, "enum", 4) == 0)
-	p = skipwhite(p + 4);
-    else if ((len == 8 && STRNCMP(p, "unsigned", 8) == 0)
-	    || (len == 6 && STRNCMP(p, "signed", 6) == 0))
-    {
-	s = skipwhite(p + len);
-	if ((STRNCMP(s, "int", 3) == 0 && vim_iswhite(s[3]))
-		|| (STRNCMP(s, "long", 4) == 0 && vim_iswhite(s[4]))
-		|| (STRNCMP(s, "short", 5) == 0 && vim_iswhite(s[5]))
-		|| (STRNCMP(s, "char", 4) == 0 && vim_iswhite(s[4])))
-	    p = s;
-    }
-    for (len = 0; vim_isIDc(p[len]); ++len)
-	;
-    if (len == 0 || !vim_iswhite(p[len]) || cin_nocode(p))
-	return 0;
-
-    p = skipwhite(p + len);
-    fp.lnum = curwin->w_cursor.lnum;
-    fp.col = (colnr_T)(p - line);
-    getvcol(curwin, &fp, &col, NULL, NULL);
-    return (int)col;
-}
-
-/*
- * Return the indent of the first non-blank after an equal sign.
- *       char *foo = "here";
- * Return zero if no (useful) equal sign found.
- * Return -1 if the line above "lnum" ends in a backslash.
- *      foo = "asdf\
- *	       asdf\
- *	       here";
- */
-    static int
-cin_get_equal_amount(lnum)
-    linenr_T	lnum;
-{
-    char_u	*line;
-    char_u	*s;
-    colnr_T	col;
-    pos_T	fp;
-
-    if (lnum > 1)
-    {
-	line = ml_get(lnum - 1);
-	if (*line != NUL && line[STRLEN(line) - 1] == '\\')
-	    return -1;
-    }
-
-    line = s = ml_get(lnum);
-    while (*s != NUL && vim_strchr((char_u *)"=;{}\"'", *s) == NULL)
-    {
-	if (cin_iscomment(s))	/* ignore comments */
-	    s = cin_skipcomment(s);
-	else
-	    ++s;
-    }
-    if (*s != '=')
-	return 0;
-
-    s = skipwhite(s + 1);
-    if (cin_nocode(s))
-	return 0;
-
-    if (*s == '"')	/* nice alignment for continued strings */
-	++s;
-
-    fp.lnum = lnum;
-    fp.col = (colnr_T)(s - line);
-    getvcol(curwin, &fp, &col, NULL, NULL);
-    return (int)col;
-}
-
-/*
- * Recognize a preprocessor statement: Any line that starts with '#'.
- */
-    static int
-cin_ispreproc(s)
-    char_u *s;
-{
-    s = skipwhite(s);
-    if (*s == '#')
-	return TRUE;
-    return FALSE;
-}
-
-/*
- * Return TRUE if line "*pp" at "*lnump" is a preprocessor statement or a
- * continuation line of a preprocessor statement.  Decrease "*lnump" to the
- * start and return the line in "*pp".
- */
-    static int
-cin_ispreproc_cont(pp, lnump)
-    char_u	**pp;
-    linenr_T	*lnump;
-{
-    char_u	*line = *pp;
-    linenr_T	lnum = *lnump;
-    int		retval = FALSE;
-
-    while (1)
-    {
-	if (cin_ispreproc(line))
-	{
-	    retval = TRUE;
-	    *lnump = lnum;
-	    break;
-	}
-	if (lnum == 1)
-	    break;
-	line = ml_get(--lnum);
-	if (*line == NUL || line[STRLEN(line) - 1] != '\\')
-	    break;
-    }
-
-    if (lnum != *lnump)
-	*pp = ml_get(*lnump);
-    return retval;
-}
-
-/*
- * Recognize the start of a C or C++ comment.
- */
-    static int
-cin_iscomment(p)
-    char_u  *p;
-{
-    return (p[0] == '/' && (p[1] == '*' || p[1] == '/'));
-}
-
-/*
- * Recognize the start of a "//" comment.
- */
-    static int
-cin_islinecomment(p)
-    char_u *p;
-{
-    return (p[0] == '/' && p[1] == '/');
-}
-
-/*
- * Recognize a line that starts with '{' or '}', or ends with ';', '{' or '}'.
- * Don't consider "} else" a terminated line.
- * Return the character terminating the line (ending char's have precedence if
- * both apply in order to determine initializations).
- */
-    static int
-cin_isterminated(s, incl_open, incl_comma)
-    char_u	*s;
-    int		incl_open;	/* include '{' at the end as terminator */
-    int		incl_comma;	/* recognize a trailing comma */
-{
-    char_u found_start = 0;
-
-    s = cin_skipcomment(s);
-
-    if (*s == '{' || (*s == '}' && !cin_iselse(s)))
-	found_start = *s;
-
-    while (*s)
-    {
-	/* skip over comments, "" strings and 'c'haracters */
-	s = skip_string(cin_skipcomment(s));
-	if ((*s == ';' || (incl_open && *s == '{') || *s == '}'
-						 || (incl_comma && *s == ','))
-		&& cin_nocode(s + 1))
-	    return *s;
-
-	if (*s)
-	    s++;
-    }
-    return found_start;
-}
-
-/*
- * Recognize the basic picture of a function declaration -- it needs to
- * have an open paren somewhere and a close paren at the end of the line and
- * no semicolons anywhere.
- * When a line ends in a comma we continue looking in the next line.
- * "sp" points to a string with the line.  When looking at other lines it must
- * be restored to the line.  When it's NULL fetch lines here.
- * "lnum" is where we start looking.
- */
-    static int
-cin_isfuncdecl(sp, first_lnum)
-    char_u	**sp;
-    linenr_T	first_lnum;
-{
-    char_u	*s;
-    linenr_T	lnum = first_lnum;
-    int		retval = FALSE;
-
-    if (sp == NULL)
-	s = ml_get(lnum);
-    else
-	s = *sp;
-
-    while (*s && *s != '(' && *s != ';' && *s != '\'' && *s != '"')
-    {
-	if (cin_iscomment(s))	/* ignore comments */
-	    s = cin_skipcomment(s);
-	else
-	    ++s;
-    }
-    if (*s != '(')
-	return FALSE;		/* ';', ' or "  before any () or no '(' */
-
-    while (*s && *s != ';' && *s != '\'' && *s != '"')
-    {
-	if (*s == ')' && cin_nocode(s + 1))
-	{
-	    /* ')' at the end: may have found a match
-	     * Check for he previous line not to end in a backslash:
-	     *       #if defined(x) && \
-	     *		 defined(y)
-	     */
-	    lnum = first_lnum - 1;
-	    s = ml_get(lnum);
-	    if (*s == NUL || s[STRLEN(s) - 1] != '\\')
-		retval = TRUE;
-	    goto done;
-	}
-	if (*s == ',' && cin_nocode(s + 1))
-	{
-	    /* ',' at the end: continue looking in the next line */
-	    if (lnum >= curbuf->b_ml.ml_line_count)
-		break;
-
-	    s = ml_get(++lnum);
-	}
-	else if (cin_iscomment(s))	/* ignore comments */
-	    s = cin_skipcomment(s);
-	else
-	    ++s;
-    }
-
-done:
-    if (lnum != first_lnum && sp != NULL)
-	*sp = ml_get(first_lnum);
-
-    return retval;
-}
-
-    static int
-cin_isif(p)
-    char_u  *p;
-{
-    return (STRNCMP(p, "if", 2) == 0 && !vim_isIDc(p[2]));
-}
-
-    static int
-cin_iselse(p)
-    char_u  *p;
-{
-    if (*p == '}')	    /* accept "} else" */
-	p = cin_skipcomment(p + 1);
-    return (STRNCMP(p, "else", 4) == 0 && !vim_isIDc(p[4]));
-}
-
-    static int
-cin_isdo(p)
-    char_u  *p;
-{
-    return (STRNCMP(p, "do", 2) == 0 && !vim_isIDc(p[2]));
-}
-
-/*
- * Check if this is a "while" that should have a matching "do".
- * We only accept a "while (condition) ;", with only white space between the
- * ')' and ';'. The condition may be spread over several lines.
- */
-    static int
-cin_iswhileofdo(p, lnum, ind_maxparen)	    /* XXX */
-    char_u	*p;
-    linenr_T	lnum;
-    int		ind_maxparen;
-{
-    pos_T	cursor_save;
-    pos_T	*trypos;
-    int		retval = FALSE;
-
-    p = cin_skipcomment(p);
-    if (*p == '}')		/* accept "} while (cond);" */
-	p = cin_skipcomment(p + 1);
-    if (STRNCMP(p, "while", 5) == 0 && !vim_isIDc(p[5]))
-    {
-	cursor_save = curwin->w_cursor;
-	curwin->w_cursor.lnum = lnum;
-	curwin->w_cursor.col = 0;
-	p = ml_get_curline();
-	while (*p && *p != 'w')	/* skip any '}', until the 'w' of the "while" */
-	{
-	    ++p;
-	    ++curwin->w_cursor.col;
-	}
-	if ((trypos = findmatchlimit(NULL, 0, 0, ind_maxparen)) != NULL
-		&& *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')
-	    retval = TRUE;
-	curwin->w_cursor = cursor_save;
-    }
-    return retval;
-}
-
-    static int
-cin_isbreak(p)
-    char_u  *p;
-{
-    return (STRNCMP(p, "break", 5) == 0 && !vim_isIDc(p[5]));
-}
-
-/* Find the position of a C++ base-class declaration or
- * constructor-initialization. eg:
- *
- * class MyClass :
- *	baseClass		<-- here
- * class MyClass : public baseClass,
- *	anotherBaseClass	<-- here (should probably lineup ??)
- * MyClass::MyClass(...) :
- *	baseClass(...)		<-- here (constructor-initialization)
- */
-    static int
-cin_is_cpp_baseclass(line, col)
-    char_u	*line;
-    colnr_T	*col;
-{
-    char_u	*s;
-    int		class_or_struct, lookfor_ctor_init, cpp_base_class;
-
-    *col = 0;
-
-    s = cin_skipcomment(line);
-    if (*s == NUL)
-	return FALSE;
-
-    cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;
-
-    while(*s != NUL)
-    {
-	if (s[0] == ':')
-	{
-	    if (s[1] == ':')
-	    {
-		/* skip double colon. It can't be a constructor
-		 * initialization any more */
-		lookfor_ctor_init = FALSE;
-		s = cin_skipcomment(s + 2);
-	    }
-	    else if (lookfor_ctor_init || class_or_struct)
-	    {
-		/* we have something found, that looks like the start of
-		 * cpp-base-class-declaration or contructor-initialization */
-		cpp_base_class = TRUE;
-		lookfor_ctor_init = class_or_struct = FALSE;
-		*col = 0;
-		s = cin_skipcomment(s + 1);
-	    }
-	    else
-		s = cin_skipcomment(s + 1);
-	}
-	else if ((STRNCMP(s, "class", 5) == 0 && !vim_isIDc(s[5]))
-		|| (STRNCMP(s, "struct", 6) == 0 && !vim_isIDc(s[6])))
-	{
-	    class_or_struct = TRUE;
-	    lookfor_ctor_init = FALSE;
-
-	    if (*s == 'c')
-		s = cin_skipcomment(s + 5);
-	    else
-		s = cin_skipcomment(s + 6);
-	}
-	else
-	{
-	    if (s[0] == '{' || s[0] == '}' || s[0] == ';')
-	    {
-		cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;
-	    }
-	    else if (s[0] == ')')
-	    {
-		/* Constructor-initialization is assumed if we come across
-		 * something like "):" */
-		class_or_struct = FALSE;
-		lookfor_ctor_init = TRUE;
-	    }
-	    else if (!vim_isIDc(s[0]))
-	    {
-		/* if it is not an identifier, we are wrong */
-		class_or_struct = FALSE;
-		lookfor_ctor_init = FALSE;
-	    }
-	    else if (*col == 0)
-	    {
-		/* it can't be a constructor-initialization any more */
-		lookfor_ctor_init = FALSE;
-
-		/* the first statement starts here: lineup with this one... */
-		if (cpp_base_class && *col == 0)
-		    *col = (colnr_T)(s - line);
-	    }
-
-	    s = cin_skipcomment(s + 1);
-	}
-    }
-
-    return cpp_base_class;
-}
-
-/*
- * Return TRUE if string "s" ends with the string "find", possibly followed by
- * white space and comments.  Skip strings and comments.
- * Ignore "ignore" after "find" if it's not NULL.
- */
-    static int
-cin_ends_in(s, find, ignore)
-    char_u	*s;
-    char_u	*find;
-    char_u	*ignore;
-{
-    char_u	*p = s;
-    char_u	*r;
-    int		len = (int)STRLEN(find);
-
-    while (*p != NUL)
-    {
-	p = cin_skipcomment(p);
-	if (STRNCMP(p, find, len) == 0)
-	{
-	    r = skipwhite(p + len);
-	    if (ignore != NULL && STRNCMP(r, ignore, STRLEN(ignore)) == 0)
-		r = skipwhite(r + STRLEN(ignore));
-	    if (cin_nocode(r))
-		return TRUE;
-	}
-	if (*p != NUL)
-	    ++p;
-    }
-    return FALSE;
-}
-
-/*
- * Skip strings, chars and comments until at or past "trypos".
- * Return the column found.
- */
-    static int
-cin_skip2pos(trypos)
-    pos_T	*trypos;
-{
-    char_u	*line;
-    char_u	*p;
-
-    p = line = ml_get(trypos->lnum);
-    while (*p && (colnr_T)(p - line) < trypos->col)
-    {
-	if (cin_iscomment(p))
-	    p = cin_skipcomment(p);
-	else
-	{
-	    p = skip_string(p);
-	    ++p;
-	}
-    }
-    return (int)(p - line);
-}
-
-/*
- * Find the '{' at the start of the block we are in.
- * Return NULL if no match found.
- * Ignore a '{' that is in a comment, makes indenting the next three lines
- * work. */
-/* foo()    */
-/* {	    */
-/* }	    */
-
-    static pos_T *
-find_start_brace(ind_maxcomment)	    /* XXX */
-    int		ind_maxcomment;
-{
-    pos_T	cursor_save;
-    pos_T	*trypos;
-    pos_T	*pos;
-    static pos_T	pos_copy;
-
-    cursor_save = curwin->w_cursor;
-    while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)
-    {
-	pos_copy = *trypos;	/* copy pos_T, next findmatch will change it */
-	trypos = &pos_copy;
-	curwin->w_cursor = *trypos;
-	pos = NULL;
-	/* ignore the { if it's in a // comment */
-	if ((colnr_T)cin_skip2pos(trypos) == trypos->col
-		&& (pos = find_start_comment(ind_maxcomment)) == NULL) /* XXX */
-	    break;
-	if (pos != NULL)
-	    curwin->w_cursor.lnum = pos->lnum;
-    }
-    curwin->w_cursor = cursor_save;
-    return trypos;
-}
-
-/*
- * Find the matching '(', failing if it is in a comment.
- * Return NULL of no match found.
- */
-    static pos_T *
-find_match_paren(ind_maxparen, ind_maxcomment)	    /* XXX */
-    int		ind_maxparen;
-    int		ind_maxcomment;
-{
-    pos_T	cursor_save;
-    pos_T	*trypos;
-    static pos_T	pos_copy;
-
-    cursor_save = curwin->w_cursor;
-    if ((trypos = findmatchlimit(NULL, '(', 0, ind_maxparen)) != NULL)
-    {
-	/* check if the ( is in a // comment */
-	if ((colnr_T)cin_skip2pos(trypos) > trypos->col)
-	    trypos = NULL;
-	else
-	{
-	    pos_copy = *trypos;	    /* copy trypos, findmatch will change it */
-	    trypos = &pos_copy;
-	    curwin->w_cursor = *trypos;
-	    if (find_start_comment(ind_maxcomment) != NULL) /* XXX */
-		trypos = NULL;
-	}
-    }
-    curwin->w_cursor = cursor_save;
-    return trypos;
-}
-
-/*
- * Return ind_maxparen corrected for the difference in line number between the
- * cursor position and "startpos".  This makes sure that searching for a
- * matching paren above the cursor line doesn't find a match because of
- * looking a few lines further.
- */
-    static int
-corr_ind_maxparen(ind_maxparen, startpos)
-    int		ind_maxparen;
-    pos_T	*startpos;
-{
-    long	n = (long)startpos->lnum - (long)curwin->w_cursor.lnum;
-
-    if (n > 0 && n < ind_maxparen / 2)
-	return ind_maxparen - (int)n;
-    return ind_maxparen;
-}
-
-/*
- * Set w_cursor.col to the column number of the last unmatched ')' or '{' in
- * line "l".
- */
-    static int
-find_last_paren(l, start, end)
-    char_u	*l;
-    int		start, end;
-{
-    int		i;
-    int		retval = FALSE;
-    int		open_count = 0;
-
-    curwin->w_cursor.col = 0;		    /* default is start of line */
-
-    for (i = 0; l[i]; i++)
-    {
-	i = (int)(cin_skipcomment(l + i) - l); /* ignore parens in comments */
-	i = (int)(skip_string(l + i) - l);    /* ignore parens in quotes */
-	if (l[i] == start)
-	    ++open_count;
-	else if (l[i] == end)
-	{
-	    if (open_count > 0)
-		--open_count;
-	    else
-	    {
-		curwin->w_cursor.col = i;
-		retval = TRUE;
-	    }
-	}
-    }
-    return retval;
-}
-
-    int
-get_c_indent()
-{
-    /*
-     * spaces from a block's opening brace the prevailing indent for that
-     * block should be
-     */
-    int ind_level = curbuf->b_p_sw;
-
-    /*
-     * spaces from the edge of the line an open brace that's at the end of a
-     * line is imagined to be.
-     */
-    int ind_open_imag = 0;
-
-    /*
-     * spaces from the prevailing indent for a line that is not precededof by
-     * an opening brace.
-     */
-    int ind_no_brace = 0;
-
-    /*
-     * column where the first { of a function should be located }
-     */
-    int ind_first_open = 0;
-
-    /*
-     * spaces from the prevailing indent a leftmost open brace should be
-     * located
-     */
-    int ind_open_extra = 0;
-
-    /*
-     * spaces from the matching open brace (real location for one at the left
-     * edge; imaginary location from one that ends a line) the matching close
-     * brace should be located
-     */
-    int ind_close_extra = 0;
-
-    /*
-     * spaces from the edge of the line an open brace sitting in the leftmost
-     * column is imagined to be
-     */
-    int ind_open_left_imag = 0;
-
-    /*
-     * spaces from the switch() indent a "case xx" label should be located
-     */
-    int ind_case = curbuf->b_p_sw;
-
-    /*
-     * spaces from the "case xx:" code after a switch() should be located
-     */
-    int ind_case_code = curbuf->b_p_sw;
-
-    /*
-     * lineup break at end of case in switch() with case label
-     */
-    int ind_case_break = 0;
-
-    /*
-     * spaces from the class declaration indent a scope declaration label
-     * should be located
-     */
-    int ind_scopedecl = curbuf->b_p_sw;
-
-    /*
-     * spaces from the scope declaration label code should be located
-     */
-    int ind_scopedecl_code = curbuf->b_p_sw;
-
-    /*
-     * amount K&R-style parameters should be indented
-     */
-    int ind_param = curbuf->b_p_sw;
-
-    /*
-     * amount a function type spec should be indented
-     */
-    int ind_func_type = curbuf->b_p_sw;
-
-    /*
-     * amount a cpp base class declaration or constructor initialization
-     * should be indented
-     */
-    int ind_cpp_baseclass = curbuf->b_p_sw;
-
-    /*
-     * additional spaces beyond the prevailing indent a continuation line
-     * should be located
-     */
-    int ind_continuation = curbuf->b_p_sw;
-
-    /*
-     * spaces from the indent of the line with an unclosed parentheses
-     */
-    int ind_unclosed = curbuf->b_p_sw * 2;
-
-    /*
-     * spaces from the indent of the line with an unclosed parentheses, which
-     * itself is also unclosed
-     */
-    int ind_unclosed2 = curbuf->b_p_sw;
-
-    /*
-     * suppress ignoring spaces from the indent of a line starting with an
-     * unclosed parentheses.
-     */
-    int ind_unclosed_noignore = 0;
-
-    /*
-     * If the opening paren is the last nonwhite character on the line, and
-     * ind_unclosed_wrapped is nonzero, use this indent relative to the outer
-     * context (for very long lines).
-     */
-    int ind_unclosed_wrapped = 0;
-
-    /*
-     * suppress ignoring white space when lining up with the character after
-     * an unclosed parentheses.
-     */
-    int ind_unclosed_whiteok = 0;
-
-    /*
-     * indent a closing parentheses under the line start of the matching
-     * opening parentheses.
-     */
-    int ind_matching_paren = 0;
-
-    /*
-     * Extra indent for comments.
-     */
-    int ind_comment = 0;
-
-    /*
-     * spaces from the comment opener when there is nothing after it.
-     */
-    int ind_in_comment = 3;
-
-    /*
-     * boolean: if non-zero, use ind_in_comment even if there is something
-     * after the comment opener.
-     */
-    int ind_in_comment2 = 0;
-
-    /*
-     * max lines to search for an open paren
-     */
-    int ind_maxparen = 20;
-
-    /*
-     * max lines to search for an open comment
-     */
-    int ind_maxcomment = 70;
-
-    /*
-     * handle braces for java code
-     */
-    int	ind_java = 0;
-
-    /*
-     * handle blocked cases correctly
-     */
-    int ind_keep_case_label = 0;
-
-    pos_T	cur_curpos;
-    int		amount;
-    int		scope_amount;
-    int		cur_amount;
-    colnr_T	col;
-    char_u	*theline;
-    char_u	*linecopy;
-    pos_T	*trypos;
-    pos_T	*tryposBrace = NULL;
-    pos_T	our_paren_pos;
-    char_u	*start;
-    int		start_brace;
-#define BRACE_IN_COL0		1	    /* '{' is in comumn 0 */
-#define BRACE_AT_START		2	    /* '{' is at start of line */
-#define BRACE_AT_END		3	    /* '{' is at end of line */
-    linenr_T	ourscope;
-    char_u	*l;
-    char_u	*look;
-    char_u	terminated;
-    int		lookfor;
-#define LOOKFOR_INITIAL		0
-#define LOOKFOR_IF		1
-#define LOOKFOR_DO		2
-#define LOOKFOR_CASE		3
-#define LOOKFOR_ANY		4
-#define LOOKFOR_TERM		5
-#define LOOKFOR_UNTERM		6
-#define LOOKFOR_SCOPEDECL	7
-#define LOOKFOR_NOBREAK		8
-#define LOOKFOR_CPP_BASECLASS	9
-#define LOOKFOR_ENUM_OR_INIT	10
-
-    int		whilelevel;
-    linenr_T	lnum;
-    char_u	*options;
-    int		fraction = 0;	    /* init for GCC */
-    int		divider;
-    int		n;
-    int		iscase;
-    int		lookfor_break;
-    int		cont_amount = 0;    /* amount for continuation line */
-
-    for (options = curbuf->b_p_cino; *options; )
-    {
-	l = options++;
-	if (*options == '-')
-	    ++options;
-	n = getdigits(&options);
-	divider = 0;
-	if (*options == '.')	    /* ".5s" means a fraction */
-	{
-	    fraction = atol((char *)++options);
-	    while (VIM_ISDIGIT(*options))
-	    {
-		++options;
-		if (divider)
-		    divider *= 10;
-		else
-		    divider = 10;
-	    }
-	}
-	if (*options == 's')	    /* "2s" means two times 'shiftwidth' */
-	{
-	    if (n == 0 && fraction == 0)
-		n = curbuf->b_p_sw;	/* just "s" is one 'shiftwidth' */
-	    else
-	    {
-		n *= curbuf->b_p_sw;
-		if (divider)
-		    n += (curbuf->b_p_sw * fraction + divider / 2) / divider;
-	    }
-	    ++options;
-	}
-	if (l[1] == '-')
-	    n = -n;
-	/* When adding an entry here, also update the default 'cinoptions' in
-	 * change.txt, and add explanation for it! */
-	switch (*l)
-	{
-	    case '>': ind_level = n; break;
-	    case 'e': ind_open_imag = n; break;
-	    case 'n': ind_no_brace = n; break;
-	    case 'f': ind_first_open = n; break;
-	    case '{': ind_open_extra = n; break;
-	    case '}': ind_close_extra = n; break;
-	    case '^': ind_open_left_imag = n; break;
-	    case ':': ind_case = n; break;
-	    case '=': ind_case_code = n; break;
-	    case 'b': ind_case_break = n; break;
-	    case 'p': ind_param = n; break;
-	    case 't': ind_func_type = n; break;
-	    case '/': ind_comment = n; break;
-	    case 'c': ind_in_comment = n; break;
-	    case 'C': ind_in_comment2 = n; break;
-	    case 'i': ind_cpp_baseclass = n; break;
-	    case '+': ind_continuation = n; break;
-	    case '(': ind_unclosed = n; break;
-	    case 'u': ind_unclosed2 = n; break;
-	    case 'U': ind_unclosed_noignore = n; break;
-	    case 'W': ind_unclosed_wrapped = n; break;
-	    case 'w': ind_unclosed_whiteok = n; break;
-	    case 'm': ind_matching_paren = n; break;
-	    case ')': ind_maxparen = n; break;
-	    case '*': ind_maxcomment = n; break;
-	    case 'g': ind_scopedecl = n; break;
-	    case 'h': ind_scopedecl_code = n; break;
-	    case 'j': ind_java = n; break;
-	    case 'l': ind_keep_case_label = n; break;
-	}
-    }
-
-    /* remember where the cursor was when we started */
-    cur_curpos = curwin->w_cursor;
-
-    /* Get a copy of the current contents of the line.
-     * This is required, because only the most recent line obtained with
-     * ml_get is valid! */
-    linecopy = vim_strsave(ml_get(cur_curpos.lnum));
-    if (linecopy == NULL)
-	return 0;
-
-    /*
-     * In insert mode and the cursor is on a ')' truncate the line at the
-     * cursor position.  We don't want to line up with the matching '(' when
-     * inserting new stuff.
-     * For unknown reasons the cursor might be past the end of the line, thus
-     * check for that.
-     */
-    if ((State & INSERT)
-	    && curwin->w_cursor.col < STRLEN(linecopy)
-	    && linecopy[curwin->w_cursor.col] == ')')
-	linecopy[curwin->w_cursor.col] = NUL;
-
-    theline = skipwhite(linecopy);
-
-    /* move the cursor to the start of the line */
-
-    curwin->w_cursor.col = 0;
-
-    /*
-     * #defines and so on always go at the left when included in 'cinkeys'.
-     */
-    if (*theline == '#' && (*linecopy == '#' || in_cinkeys('#', ' ', TRUE)))
-    {
-	amount = 0;
-    }
-
-    /*
-     * Is it a non-case label?	Then that goes at the left margin too.
-     */
-    else if (cin_islabel(ind_maxcomment))	    /* XXX */
-    {
-	amount = 0;
-    }
-
-    /*
-     * If we're inside a "//" comment and there is a "//" comment in a
-     * previous line, lineup with that one.
-     */
-    else if (cin_islinecomment(theline)
-	    && (trypos = find_line_comment()) != NULL) /* XXX */
-    {
-	/* find how indented the line beginning the comment is */
-	getvcol(curwin, trypos, &col, NULL, NULL);
-	amount = col;
-    }
-
-    /*
-     * If we're inside a comment and not looking at the start of the
-     * comment, try using the 'comments' option.
-     */
-    else if (!cin_iscomment(theline)
-	    && (trypos = find_start_comment(ind_maxcomment)) != NULL) /* XXX */
-    {
-	int	lead_start_len = 2;
-	int	lead_middle_len = 1;
-	char_u	lead_start[COM_MAX_LEN];	/* start-comment string */
-	char_u	lead_middle[COM_MAX_LEN];	/* middle-comment string */
-	char_u	lead_end[COM_MAX_LEN];		/* end-comment string */
-	char_u	*p;
-	int	start_align = 0;
-	int	start_off = 0;
-	int	done = FALSE;
-
-	/* find how indented the line beginning the comment is */
-	getvcol(curwin, trypos, &col, NULL, NULL);
-	amount = col;
-
-	p = curbuf->b_p_com;
-	while (*p != NUL)
-	{
-	    int	align = 0;
-	    int	off = 0;
-	    int what = 0;
-
-	    while (*p != NUL && *p != ':')
-	    {
-		if (*p == COM_START || *p == COM_END || *p == COM_MIDDLE)
-		    what = *p++;
-		else if (*p == COM_LEFT || *p == COM_RIGHT)
-		    align = *p++;
-		else if (VIM_ISDIGIT(*p) || *p == '-')
-		    off = getdigits(&p);
-		else
-		    ++p;
-	    }
-
-	    if (*p == ':')
-		++p;
-	    (void)copy_option_part(&p, lead_end, COM_MAX_LEN, ",");
-	    if (what == COM_START)
-	    {
-		STRCPY(lead_start, lead_end);
-		lead_start_len = (int)STRLEN(lead_start);
-		start_off = off;
-		start_align = align;
-	    }
-	    else if (what == COM_MIDDLE)
-	    {
-		STRCPY(lead_middle, lead_end);
-		lead_middle_len = (int)STRLEN(lead_middle);
-	    }
-	    else if (what == COM_END)
-	    {
-		/* If our line starts with the middle comment string, line it
-		 * up with the comment opener per the 'comments' option. */
-		if (STRNCMP(theline, lead_middle, lead_middle_len) == 0
-			&& STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0)
-		{
-		    done = TRUE;
-		    if (curwin->w_cursor.lnum > 1)
-		    {
-			/* If the start comment string matches in the previous
-			 * line, use the indent of that line pluss offset.  If
-			 * the middle comment string matches in the previous
-			 * line, use the indent of that line.  XXX */
-			look = skipwhite(ml_get(curwin->w_cursor.lnum - 1));
-			if (STRNCMP(look, lead_start, lead_start_len) == 0)
-			    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
-			else if (STRNCMP(look, lead_middle,
-							lead_middle_len) == 0)
-			{
-			    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
-			    break;
-			}
-			/* If the start comment string doesn't match with the
-			 * start of the comment, skip this entry. XXX */
-			else if (STRNCMP(ml_get(trypos->lnum) + trypos->col,
-					     lead_start, lead_start_len) != 0)
-			    continue;
-		    }
-		    if (start_off != 0)
-			amount += start_off;
-		    else if (start_align == COM_RIGHT)
-			amount += lead_start_len - lead_middle_len;
-		    break;
-		}
-
-		/* If our line starts with the end comment string, line it up
-		 * with the middle comment */
-		if (STRNCMP(theline, lead_middle, lead_middle_len) != 0
-			&& STRNCMP(theline, lead_end, STRLEN(lead_end)) == 0)
-		{
-		    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
-								     /* XXX */
-		    if (off != 0)
-			amount += off;
-		    else if (align == COM_RIGHT)
-			amount += lead_start_len - lead_middle_len;
-		    done = TRUE;
-		    break;
-		}
-	    }
-	}
-
-	/* If our line starts with an asterisk, line up with the
-	 * asterisk in the comment opener; otherwise, line up
-	 * with the first character of the comment text.
-	 */
-	if (done)
-	    ;
-	else if (theline[0] == '*')
-	    amount += 1;
-	else
-	{
-	    /*
-	     * If we are more than one line away from the comment opener, take
-	     * the indent of the previous non-empty line.  If 'cino' has "CO"
-	     * and we are just below the comment opener and there are any
-	     * white characters after it line up with the text after it;
-	     * otherwise, add the amount specified by "c" in 'cino'
-	     */
-	    amount = -1;
-	    for (lnum = cur_curpos.lnum - 1; lnum > trypos->lnum; --lnum)
-	    {
-		if (linewhite(lnum))		    /* skip blank lines */
-		    continue;
-		amount = get_indent_lnum(lnum);	    /* XXX */
-		break;
-	    }
-	    if (amount == -1)			    /* use the comment opener */
-	    {
-		if (!ind_in_comment2)
-		{
-		    start = ml_get(trypos->lnum);
-		    look = start + trypos->col + 2; /* skip / and * */
-		    if (*look != NUL)		    /* if something after it */
-			trypos->col = (colnr_T)(skipwhite(look) - start);
-		}
-		getvcol(curwin, trypos, &col, NULL, NULL);
-		amount = col;
-		if (ind_in_comment2 || *look == NUL)
-		    amount += ind_in_comment;
-	    }
-	}
-    }
-
-    /*
-     * Are we inside parentheses or braces?
-     */						    /* XXX */
-    else if (((trypos = find_match_paren(ind_maxparen, ind_maxcomment)) != NULL
-		&& ind_java == 0)
-	    || (tryposBrace = find_start_brace(ind_maxcomment)) != NULL
-	    || trypos != NULL)
-    {
-      if (trypos != NULL && tryposBrace != NULL)
-      {
-	  /* Both an unmatched '(' and '{' is found.  Use the one which is
-	   * closer to the current cursor position, set the other to NULL. */
-	  if (trypos->lnum != tryposBrace->lnum
-		  ? trypos->lnum < tryposBrace->lnum
-		  : trypos->col < tryposBrace->col)
-	      trypos = NULL;
-	  else
-	      tryposBrace = NULL;
-      }
-
-      if (trypos != NULL)
-      {
-	/*
-	 * If the matching paren is more than one line away, use the indent of
-	 * a previous non-empty line that matches the same paren.
-	 */
-	amount = -1;
-	cur_amount = MAXCOL;
-	our_paren_pos = *trypos;
-	for (lnum = cur_curpos.lnum - 1; lnum > our_paren_pos.lnum; --lnum)
-	{
-	    l = skipwhite(ml_get(lnum));
-	    if (cin_nocode(l))		/* skip comment lines */
-		continue;
-	    if (cin_ispreproc_cont(&l, &lnum))	/* ignore #defines, #if, etc. */
-		continue;
-	    curwin->w_cursor.lnum = lnum;
-
-	    /* Skip a comment. XXX */
-	    if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
-	    {
-		lnum = trypos->lnum + 1;
-		continue;
-	    }
-
-	    /* XXX */
-	    if ((trypos = find_match_paren(
-			    corr_ind_maxparen(ind_maxparen, &cur_curpos),
-						      ind_maxcomment)) != NULL
-		    && trypos->lnum == our_paren_pos.lnum
-		    && trypos->col == our_paren_pos.col)
-	    {
-		    amount = get_indent_lnum(lnum);	/* XXX */
-
-		    if (theline[0] == ')')
-		    {
-			if (our_paren_pos.lnum != lnum && cur_amount > amount)
-			    cur_amount = amount;
-			amount = -1;
-		    }
-		break;
-	    }
-	}
-
-	/*
-	 * Line up with line where the matching paren is. XXX
-	 * If the line starts with a '(' or the indent for unclosed
-	 * parentheses is zero, line up with the unclosed parentheses.
-	 */
-	if (amount == -1)
-	{
-	    amount = skip_label(our_paren_pos.lnum, &look, ind_maxcomment);
-	    if (theline[0] == ')' || ind_unclosed == 0
-		       || (!ind_unclosed_noignore && *skipwhite(look) == '('))
-	    {
-		/*
-		 * If we're looking at a close paren, line up right there;
-		 * otherwise, line up with the next (non-white) character.
-		 * When ind_unclosed_wrapped is set and the matching paren is
-		 * the last nonwhite character of the line, use either the
-		 * indent of the current line or the indentation of the next
-		 * outer paren and add ind_unclosed_wrapped (for very long
-		 * lines).
-		 */
-		if (theline[0] != ')')
-		{
-		    cur_amount = MAXCOL;
-		    l = ml_get(our_paren_pos.lnum);
-		    if (ind_unclosed_wrapped
-				       && cin_ends_in(l, (char_u *)"(", NULL))
-		    {
-			/* look for opening unmatched paren, indent one level
-			 * for each additional level */
-			n = 1;
-			for (col = 0; col < our_paren_pos.col; ++col)
-			{
-			    switch (l[col])
-			    {
-				case '(':
-				case '{': ++n;
-					  break;
-
-				case ')':
-				case '}': if (n > 1)
-					      --n;
-					  break;
-			    }
-			}
-
-			our_paren_pos.col = 0;
-			amount += n * ind_unclosed_wrapped;
-		    }
-		    else if (ind_unclosed_whiteok)
-			our_paren_pos.col++;
-		    else
-		    {
-			col = our_paren_pos.col + 1;
-			while (vim_iswhite(l[col]))
-			    col++;
-			if (l[col] != NUL)	/* In case of trailing space */
-			    our_paren_pos.col = col;
-			else
-			    our_paren_pos.col++;
-		    }
-		}
-
-		/*
-		 * Find how indented the paren is, or the character after it
-		 * if we did the above "if".
-		 */
-		if (our_paren_pos.col > 0)
-		{
-		    getvcol(curwin, &our_paren_pos, &col, NULL, NULL);
-		    if (cur_amount > (int)col)
-			cur_amount = col;
-		}
-	    }
-
-	    if (theline[0] == ')' && ind_matching_paren)
-	    {
-		/* Line up with the start of the matching paren line. */
-	    }
-	    else if (ind_unclosed == 0 || (!ind_unclosed_noignore
-						  && *skipwhite(look) == '('))
-	    {
-		if (cur_amount != MAXCOL)
-		    amount = cur_amount;
-	    }
-	    else
-	    {
-		/* add ind_unclosed2 for each '(' before our matching one */
-		col = our_paren_pos.col;
-		while (our_paren_pos.col > 0)
-		{
-		    --our_paren_pos.col;
-		    switch (*ml_get_pos(&our_paren_pos))
-		    {
-			case '(': amount += ind_unclosed2;
-				  col = our_paren_pos.col;
-				  break;
-			case ')': amount -= ind_unclosed2;
-				  col = MAXCOL;
-				  break;
-		    }
-		}
-
-		/* Use ind_unclosed once, when the first '(' is not inside
-		 * braces */
-		if (col == MAXCOL)
-		    amount += ind_unclosed;
-		else
-		{
-		    curwin->w_cursor.lnum = our_paren_pos.lnum;
-		    curwin->w_cursor.col = col;
-		    if ((trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
-			amount += ind_unclosed2;
-		    else
-			amount += ind_unclosed;
-		}
-		/*
-		 * For a line starting with ')' use the minimum of the two
-		 * positions, to avoid giving it more indent than the previous
-		 * lines:
-		 *  func_long_name(		    if (x
-		 *	arg				    && yy
-		 *	)	  ^ not here	       )    ^ not here
-		 */
-		if (cur_amount < amount)
-		    amount = cur_amount;
-	    }
-	}
-
-	/* add extra indent for a comment */
-	if (cin_iscomment(theline))
-	    amount += ind_comment;
-      }
-
-      /*
-       * Are we at least inside braces, then?
-       */
-      else
-      {
-	trypos = tryposBrace;
-
-	ourscope = trypos->lnum;
-	start = ml_get(ourscope);
-
-	/*
-	 * Now figure out how indented the line is in general.
-	 * If the brace was at the start of the line, we use that;
-	 * otherwise, check out the indentation of the line as
-	 * a whole and then add the "imaginary indent" to that.
-	 */
-	look = skipwhite(start);
-	if (*look == '{')
-	{
-	    getvcol(curwin, trypos, &col, NULL, NULL);
-	    amount = col;
-	    if (*start == '{')
-		start_brace = BRACE_IN_COL0;
-	    else
-		start_brace = BRACE_AT_START;
-	}
-	else
-	{
-	    /*
-	     * that opening brace might have been on a continuation
-	     * line.  if so, find the start of the line.
-	     */
-	    curwin->w_cursor.lnum = ourscope;
-
-	    /*
-	     * position the cursor over the rightmost paren, so that
-	     * matching it will take us back to the start of the line.
-	     */
-	    lnum = ourscope;
-	    if (find_last_paren(start, '(', ')')
-		    && (trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
-		lnum = trypos->lnum;
-
-	    /*
-	     * It could have been something like
-	     *	   case 1: if (asdf &&
-	     *			ldfd) {
-	     *		    }
-	     */
-	    if (ind_keep_case_label && cin_iscase(skipwhite(ml_get_curline())))
-		amount = get_indent();
-	    else
-		amount = skip_label(lnum, &l, ind_maxcomment);
-
-	    start_brace = BRACE_AT_END;
-	}
-
-	/*
-	 * if we're looking at a closing brace, that's where
-	 * we want to be.  otherwise, add the amount of room
-	 * that an indent is supposed to be.
-	 */
-	if (theline[0] == '}')
-	{
-	    /*
-	     * they may want closing braces to line up with something
-	     * other than the open brace.  indulge them, if so.
-	     */
-	    amount += ind_close_extra;
-	}
-	else
-	{
-	    /*
-	     * If we're looking at an "else", try to find an "if"
-	     * to match it with.
-	     * If we're looking at a "while", try to find a "do"
-	     * to match it with.
-	     */
-	    lookfor = LOOKFOR_INITIAL;
-	    if (cin_iselse(theline))
-		lookfor = LOOKFOR_IF;
-	    else if (cin_iswhileofdo(theline, cur_curpos.lnum, ind_maxparen))
-								    /* XXX */
-		lookfor = LOOKFOR_DO;
-	    if (lookfor != LOOKFOR_INITIAL)
-	    {
-		curwin->w_cursor.lnum = cur_curpos.lnum;
-		if (find_match(lookfor, ourscope, ind_maxparen,
-							ind_maxcomment) == OK)
-		{
-		    amount = get_indent();	/* XXX */
-		    goto theend;
-		}
-	    }
-
-	    /*
-	     * We get here if we are not on an "while-of-do" or "else" (or
-	     * failed to find a matching "if").
-	     * Search backwards for something to line up with.
-	     * First set amount for when we don't find anything.
-	     */
-
-	    /*
-	     * if the '{' is  _really_ at the left margin, use the imaginary
-	     * location of a left-margin brace.  Otherwise, correct the
-	     * location for ind_open_extra.
-	     */
-
-	    if (start_brace == BRACE_IN_COL0)	    /* '{' is in column 0 */
-	    {
-		amount = ind_open_left_imag;
-	    }
-	    else
-	    {
-		if (start_brace == BRACE_AT_END)    /* '{' is at end of line */
-		    amount += ind_open_imag;
-		else
-		{
-		    /* Compensate for adding ind_open_extra later. */
-		    amount -= ind_open_extra;
-		    if (amount < 0)
-			amount = 0;
-		}
-	    }
-
-	    lookfor_break = FALSE;
-
-	    if (cin_iscase(theline))	/* it's a switch() label */
-	    {
-		lookfor = LOOKFOR_CASE;	/* find a previous switch() label */
-		amount += ind_case;
-	    }
-	    else if (cin_isscopedecl(theline))	/* private:, ... */
-	    {
-		lookfor = LOOKFOR_SCOPEDECL;	/* class decl is this block */
-		amount += ind_scopedecl;
-	    }
-	    else
-	    {
-		if (ind_case_break && cin_isbreak(theline))	/* break; ... */
-		    lookfor_break = TRUE;
-
-		lookfor = LOOKFOR_INITIAL;
-		amount += ind_level;	/* ind_level from start of block */
-	    }
-	    scope_amount = amount;
-	    whilelevel = 0;
-
-	    /*
-	     * Search backwards.  If we find something we recognize, line up
-	     * with that.
-	     *
-	     * if we're looking at an open brace, indent
-	     * the usual amount relative to the conditional
-	     * that opens the block.
-	     */
-	    curwin->w_cursor = cur_curpos;
-	    for (;;)
-	    {
-		curwin->w_cursor.lnum--;
-		curwin->w_cursor.col = 0;
-
-		/*
-		 * If we went all the way back to the start of our scope, line
-		 * up with it.
-		 */
-		if (curwin->w_cursor.lnum <= ourscope)
-		{
-		    /* we reached end of scope:
-		     * if looking for a enum or structure initialization
-		     * go further back:
-		     * if it is an initializer (enum xxx or xxx =), then
-		     * don't add ind_continuation, otherwise it is a variable
-		     * declaration:
-		     * int x,
-		     *     here; <-- add ind_continuation
-		     */
-		    if (lookfor == LOOKFOR_ENUM_OR_INIT)
-		    {
-			if (curwin->w_cursor.lnum == 0
-				|| curwin->w_cursor.lnum
-						    < ourscope - ind_maxparen)
-			{
-			    /* nothing found (abuse ind_maxparen as limit)
-			     * assume terminated line (i.e. a variable
-			     * initialization) */
-			    if (cont_amount > 0)
-				amount = cont_amount;
-			    else
-				amount += ind_continuation;
-			    break;
-			}
-
-			l = ml_get_curline();
-
-			/*
-			 * If we're in a comment now, skip to the start of the
-			 * comment.
-			 */
-			trypos = find_start_comment(ind_maxcomment);
-			if (trypos != NULL)
-			{
-			    curwin->w_cursor.lnum = trypos->lnum + 1;
-			    continue;
-			}
-
-			/*
-			 * Skip preprocessor directives and blank lines.
-			 */
-			if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum))
-			    continue;
-
-			if (cin_nocode(l))
-			    continue;
-
-			terminated = cin_isterminated(l, FALSE, TRUE);
-
-			/*
-			 * If we are at top level and the line looks like a
-			 * function declaration, we are done
-			 * (it's a variable declaration).
-			 */
-			if (start_brace != BRACE_IN_COL0
-				|| !cin_isfuncdecl(&l, curwin->w_cursor.lnum))
-			{
-			    /* if the line is terminated with another ','
-			     * it is a continued variable initialization.
-			     * don't add extra indent.
-			     * TODO: does not work, if  a function
-			     * declaration is split over multiple lines:
-			     * cin_isfuncdecl returns FALSE then.
-			     */
-			    if (terminated == ',')
-				break;
-
-			    /* if it es a enum declaration or an assignment,
-			     * we are done.
-			     */
-			    if (terminated != ';' && cin_isinit())
-				break;
-
-			    /* nothing useful found */
-			    if (terminated == 0 || terminated == '{')
-				continue;
-			}
-
-			if (terminated != ';')
-			{
-			    /* Skip parens and braces. Position the cursor
-			     * over the rightmost paren, so that matching it
-			     * will take us back to the start of the line.
-			     */					/* XXX */
-			    trypos = NULL;
-			    if (find_last_paren(l, '(', ')'))
-				trypos = find_match_paren(ind_maxparen,
-					ind_maxcomment);
-
-			    if (trypos == NULL && find_last_paren(l, '{', '}'))
-				trypos = find_start_brace(ind_maxcomment);
-
-			    if (trypos != NULL)
-			    {
-				curwin->w_cursor.lnum = trypos->lnum + 1;
-				continue;
-			    }
-			}
-
-			/* it's a variable declaration, add indentation
-			 * like in
-			 * int a,
-			 *    b;
-			 */
-			if (cont_amount > 0)
-			    amount = cont_amount;
-			else
-			    amount += ind_continuation;
-		    }
-		    else if (lookfor == LOOKFOR_UNTERM)
-		    {
-			if (cont_amount > 0)
-			    amount = cont_amount;
-			else
-			    amount += ind_continuation;
-		    }
-		    else if (lookfor != LOOKFOR_TERM
-					  && lookfor != LOOKFOR_CPP_BASECLASS)
-		    {
-			amount = scope_amount;
-			if (theline[0] == '{')
-			    amount += ind_open_extra;
-		    }
-		    break;
-		}
-
-		/*
-		 * If we're in a comment now, skip to the start of the comment.
-		 */					    /* XXX */
-		if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
-		{
-		    curwin->w_cursor.lnum = trypos->lnum + 1;
-		    continue;
-		}
-
-		l = ml_get_curline();
-
-		/*
-		 * If this is a switch() label, may line up relative to that.
-		 * if this is a C++ scope declaration, do the same.
-		 */
-		iscase = cin_iscase(l);
-		if (iscase || cin_isscopedecl(l))
-		{
-		    /* we are only looking for cpp base class
-		     * declaration/initialization any longer */
-		    if (lookfor == LOOKFOR_CPP_BASECLASS)
-			break;
-
-		    /* When looking for a "do" we are not interested in
-		     * labels. */
-		    if (whilelevel > 0)
-			continue;
-
-		    /*
-		     *	case xx:
-		     *	    c = 99 +	    <- this indent plus continuation
-		     *->	   here;
-		     */
-		    if (lookfor == LOOKFOR_UNTERM
-					   || lookfor == LOOKFOR_ENUM_OR_INIT)
-		    {
-			if (cont_amount > 0)
-			    amount = cont_amount;
-			else
-			    amount += ind_continuation;
-			break;
-		    }
-
-		    /*
-		     *	case xx:	<- line up with this case
-		     *	    x = 333;
-		     *	case yy:
-		     */
-		    if (       (iscase && lookfor == LOOKFOR_CASE)
-			    || (iscase && lookfor_break)
-			    || (!iscase && lookfor == LOOKFOR_SCOPEDECL))
-		    {
-			/*
-			 * Check that this case label is not for another
-			 * switch()
-			 */				    /* XXX */
-			if ((trypos = find_start_brace(ind_maxcomment)) ==
-					     NULL || trypos->lnum == ourscope)
-			{
-			    amount = get_indent();	/* XXX */
-			    break;
-			}
-			continue;
-		    }
-
-		    n = get_indent_nolabel(curwin->w_cursor.lnum);  /* XXX */
-
-		    /*
-		     *	 case xx: if (cond)	    <- line up with this if
-		     *		      y = y + 1;
-		     * ->	  s = 99;
-		     *
-		     *	 case xx:
-		     *	     if (cond)		<- line up with this line
-		     *		 y = y + 1;
-		     * ->    s = 99;
-		     */
-		    if (lookfor == LOOKFOR_TERM)
-		    {
-			if (n)
-			    amount = n;
-
-			if (!lookfor_break)
-			    break;
-		    }
-
-		    /*
-		     *	 case xx: x = x + 1;	    <- line up with this x
-		     * ->	  y = y + 1;
-		     *
-		     *	 case xx: if (cond)	    <- line up with this if
-		     * ->	       y = y + 1;
-		     */
-		    if (n)
-		    {
-			amount = n;
-			l = after_label(ml_get_curline());
-			if (l != NULL && cin_is_cinword(l))
-			    amount += ind_level + ind_no_brace;
-			break;
-		    }
-
-		    /*
-		     * Try to get the indent of a statement before the switch
-		     * label.  If nothing is found, line up relative to the
-		     * switch label.
-		     *	    break;		<- may line up with this line
-		     *	 case xx:
-		     * ->   y = 1;
-		     */
-		    scope_amount = get_indent() + (iscase    /* XXX */
-					? ind_case_code : ind_scopedecl_code);
-		    lookfor = ind_case_break ? LOOKFOR_NOBREAK : LOOKFOR_ANY;
-		    continue;
-		}
-
-		/*
-		 * Looking for a switch() label or C++ scope declaration,
-		 * ignore other lines, skip {}-blocks.
-		 */
-		if (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL)
-		{
-		    if (find_last_paren(l, '{', '}') && (trypos =
-				    find_start_brace(ind_maxcomment)) != NULL)
-			curwin->w_cursor.lnum = trypos->lnum + 1;
-		    continue;
-		}
-
-		/*
-		 * Ignore jump labels with nothing after them.
-		 */
-		if (cin_islabel(ind_maxcomment))
-		{
-		    l = after_label(ml_get_curline());
-		    if (l == NULL || cin_nocode(l))
-			continue;
-		}
-
-		/*
-		 * Ignore #defines, #if, etc.
-		 * Ignore comment and empty lines.
-		 * (need to get the line again, cin_islabel() may have
-		 * unlocked it)
-		 */
-		l = ml_get_curline();
-		if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum)
-							     || cin_nocode(l))
-		    continue;
-
-		/*
-		 * Are we at the start of a cpp base class declaration or
-		 * constructor initialization?
-		 */						    /* XXX */
-		if (lookfor != LOOKFOR_TERM && ind_cpp_baseclass
-					     && cin_is_cpp_baseclass(l, &col))
-		{
-		    if (lookfor == LOOKFOR_UNTERM)
-		    {
-			if (cont_amount > 0)
-			    amount = cont_amount;
-			else
-			    amount += ind_continuation;
-		    }
-		    else if (col == 0 || theline[0] == '{')
-		    {
-			amount = get_indent();
-			if (find_last_paren(l, '(', ')')
-				&& (trypos = find_match_paren(ind_maxparen,
-					ind_maxcomment)) != NULL)
-			    amount = get_indent_lnum(trypos->lnum); /* XXX */
-			if (theline[0] != '{')
-			    amount += ind_cpp_baseclass;
-		    }
-		    else
-		    {
-			curwin->w_cursor.col = col;
-			getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);
-			amount = (int)col;
-		    }
-		    break;
-		}
-		else if (lookfor == LOOKFOR_CPP_BASECLASS)
-		{
-		    /* only look, whether there is a cpp base class
-		     * declaration or initialization before the opening brace. */
-		    if (cin_isterminated(l, TRUE, FALSE))
-			break;
-		    else
-			continue;
-		}
-
-		/*
-		 * What happens next depends on the line being terminated.
-		 * If terminated with a ',' only consider it terminating if
-		 * there is anoter unterminated statement behind, eg:
-		 *   123,
-		 *   sizeof
-		 *	  here
-		 * Otherwise check whether it is a enumeration or structure
-		 * initialisation (not indented) or a variable declaration
-		 * (indented).
-		 */
-		terminated = cin_isterminated(l, FALSE, TRUE);
-
-		if (terminated == 0 || (lookfor != LOOKFOR_UNTERM
-							&& terminated == ','))
-		{
-		    /*
-		     * if we're in the middle of a paren thing,
-		     * go back to the line that starts it so
-		     * we can get the right prevailing indent
-		     *	   if ( foo &&
-		     *		    bar )
-		     */
-		    /*
-		     * position the cursor over the rightmost paren, so that
-		     * matching it will take us back to the start of the line.
-		     */
-		    (void)find_last_paren(l, '(', ')');
-		    trypos = find_match_paren(
-				 corr_ind_maxparen(ind_maxparen, &cur_curpos),
-							      ind_maxcomment);
-
-		    /*
-		     * If we are looking for ',', we also look for matching
-		     * braces.
-		     */
-		    if (trypos == NULL && find_last_paren(l, '{', '}'))
-			trypos = find_start_brace(ind_maxcomment);
-
-		    if (trypos != NULL)
-		    {
-			/*
-			 * Check if we are on a case label now.  This is
-			 * handled above.
-			 *     case xx:  if ( asdf &&
-			 *			asdf)
-			 */
-			curwin->w_cursor.lnum = trypos->lnum;
-			l = ml_get_curline();
-			if (cin_iscase(l) || cin_isscopedecl(l))
-			{
-			    ++curwin->w_cursor.lnum;
-			    continue;
-			}
-		    }
-
-		    /*
-		     * Skip over continuation lines to find the one to get the
-		     * indent from
-		     * char *usethis = "bla\
-		     *		 bla",
-		     *      here;
-		     */
-		    if (terminated == ',')
-		    {
-			while (curwin->w_cursor.lnum > 1)
-			{
-			    l = ml_get(curwin->w_cursor.lnum - 1);
-			    if (*l == NUL || l[STRLEN(l) - 1] != '\\')
-				break;
-			    --curwin->w_cursor.lnum;
-			}
-		    }
-
-		    /*
-		     * Get indent and pointer to text for current line,
-		     * ignoring any jump label.	    XXX
-		     */
-		    cur_amount = skip_label(curwin->w_cursor.lnum,
-							  &l, ind_maxcomment);
-
-		    /*
-		     * If this is just above the line we are indenting, and it
-		     * starts with a '{', line it up with this line.
-		     *		while (not)
-		     * ->	{
-		     *		}
-		     */
-		    if (terminated != ',' && lookfor != LOOKFOR_TERM
-							 && theline[0] == '{')
-		    {
-			amount = cur_amount;
-			/*
-			 * Only add ind_open_extra when the current line
-			 * doesn't start with a '{', which must have a match
-			 * in the same line (scope is the same).  Probably:
-			 *	{ 1, 2 },
-			 * ->	{ 3, 4 }
-			 */
-			if (*skipwhite(l) != '{')
-			    amount += ind_open_extra;
-
-			if (ind_cpp_baseclass)
-			{
-			    /* have to look back, whether it is a cpp base
-			     * class declaration or initialization */
-			    lookfor = LOOKFOR_CPP_BASECLASS;
-			    continue;
-			}
-			break;
-		    }
-
-		    /*
-		     * Check if we are after an "if", "while", etc.
-		     * Also allow "   } else".
-		     */
-		    if (cin_is_cinword(l) || cin_iselse(skipwhite(l)))
-		    {
-			/*
-			 * Found an unterminated line after an if (), line up
-			 * with the last one.
-			 *   if (cond)
-			 *	    100 +
-			 * ->		here;
-			 */
-			if (lookfor == LOOKFOR_UNTERM
-					   || lookfor == LOOKFOR_ENUM_OR_INIT)
-			{
-			    if (cont_amount > 0)
-				amount = cont_amount;
-			    else
-				amount += ind_continuation;
-			    break;
-			}
-
-			/*
-			 * If this is just above the line we are indenting, we
-			 * are finished.
-			 *	    while (not)
-			 * ->		here;
-			 * Otherwise this indent can be used when the line
-			 * before this is terminated.
-			 *	yyy;
-			 *	if (stat)
-			 *	    while (not)
-			 *		xxx;
-			 * ->	here;
-			 */
-			amount = cur_amount;
-			if (theline[0] == '{')
-			    amount += ind_open_extra;
-			if (lookfor != LOOKFOR_TERM)
-			{
-			    amount += ind_level + ind_no_brace;
-			    break;
-			}
-
-			/*
-			 * Special trick: when expecting the while () after a
-			 * do, line up with the while()
-			 *     do
-			 *	    x = 1;
-			 * ->  here
-			 */
-			l = skipwhite(ml_get_curline());
-			if (cin_isdo(l))
-			{
-			    if (whilelevel == 0)
-				break;
-			    --whilelevel;
-			}
-
-			/*
-			 * When searching for a terminated line, don't use the
-			 * one between the "if" and the "else".
-			 * Need to use the scope of this "else".  XXX
-			 * If whilelevel != 0 continue looking for a "do {".
-			 */
-			if (cin_iselse(l)
-				&& whilelevel == 0
-				&& ((trypos = find_start_brace(ind_maxcomment))
-								    == NULL
-				    || find_match(LOOKFOR_IF, trypos->lnum,
-					ind_maxparen, ind_maxcomment) == FAIL))
-			    break;
-		    }
-
-		    /*
-		     * If we're below an unterminated line that is not an
-		     * "if" or something, we may line up with this line or
-		     * add someting for a continuation line, depending on
-		     * the line before this one.
-		     */
-		    else
-		    {
-			/*
-			 * Found two unterminated lines on a row, line up with
-			 * the last one.
-			 *   c = 99 +
-			 *	    100 +
-			 * ->	    here;
-			 */
-			if (lookfor == LOOKFOR_UNTERM)
-			{
-			    /* When line ends in a comma add extra indent */
-			    if (terminated == ',')
-				amount += ind_continuation;
-			    break;
-			}
-
-			if (lookfor == LOOKFOR_ENUM_OR_INIT)
-			{
-			    /* Found two lines ending in ',', lineup with the
-			     * lowest one, but check for cpp base class
-			     * declaration/initialization, if it is an
-			     * opening brace or we are looking just for
-			     * enumerations/initializations. */
-			    if (terminated == ',')
-			    {
-				if (ind_cpp_baseclass == 0)
-				    break;
-
-				lookfor = LOOKFOR_CPP_BASECLASS;
-				continue;
-			    }
-
-			    /* Ignore unterminated lines in between, but
-			     * reduce indent. */
-			    if (amount > cur_amount)
-				amount = cur_amount;
-			}
-			else
-			{
-			    /*
-			     * Found first unterminated line on a row, may
-			     * line up with this line, remember its indent
-			     *	    100 +
-			     * ->	    here;
-			     */
-			    amount = cur_amount;
-
-			    /*
-			     * If previous line ends in ',', check whether we
-			     * are in an initialization or enum
-			     * struct xxx =
-			     * {
-			     *      sizeof a,
-			     *      124 };
-			     * or a normal possible continuation line.
-			     * but only, of no other statement has been found
-			     * yet.
-			     */
-			    if (lookfor == LOOKFOR_INITIAL && terminated == ',')
-			    {
-				lookfor = LOOKFOR_ENUM_OR_INIT;
-				cont_amount = cin_first_id_amount();
-			    }
-			    else
-			    {
-				if (lookfor == LOOKFOR_INITIAL
-					&& *l != NUL
-					&& l[STRLEN(l) - 1] == '\\')
-								/* XXX */
-				    cont_amount = cin_get_equal_amount(
-						       curwin->w_cursor.lnum);
-				if (lookfor != LOOKFOR_TERM)
-				    lookfor = LOOKFOR_UNTERM;
-			    }
-			}
-		    }
-		}
-
-		/*
-		 * Check if we are after a while (cond);
-		 * If so: Ignore until the matching "do".
-		 */
-							/* XXX */
-		else if (cin_iswhileofdo(l,
-					 curwin->w_cursor.lnum, ind_maxparen))
-		{
-		    /*
-		     * Found an unterminated line after a while ();, line up
-		     * with the last one.
-		     *	    while (cond);
-		     *	    100 +		<- line up with this one
-		     * ->	    here;
-		     */
-		    if (lookfor == LOOKFOR_UNTERM
-					   || lookfor == LOOKFOR_ENUM_OR_INIT)
-		    {
-			if (cont_amount > 0)
-			    amount = cont_amount;
-			else
-			    amount += ind_continuation;
-			break;
-		    }
-
-		    if (whilelevel == 0)
-		    {
-			lookfor = LOOKFOR_TERM;
-			amount = get_indent();	    /* XXX */
-			if (theline[0] == '{')
-			    amount += ind_open_extra;
-		    }
-		    ++whilelevel;
-		}
-
-		/*
-		 * We are after a "normal" statement.
-		 * If we had another statement we can stop now and use the
-		 * indent of that other statement.
-		 * Otherwise the indent of the current statement may be used,
-		 * search backwards for the next "normal" statement.
-		 */
-		else
-		{
-		    /*
-		     * Skip single break line, if before a switch label. It
-		     * may be lined up with the case label.
-		     */
-		    if (lookfor == LOOKFOR_NOBREAK
-				  && cin_isbreak(skipwhite(ml_get_curline())))
-		    {
-			lookfor = LOOKFOR_ANY;
-			continue;
-		    }
-
-		    /*
-		     * Handle "do {" line.
-		     */
-		    if (whilelevel > 0)
-		    {
-			l = cin_skipcomment(ml_get_curline());
-			if (cin_isdo(l))
-			{
-			    amount = get_indent();	/* XXX */
-			    --whilelevel;
-			    continue;
-			}
-		    }
-
-		    /*
-		     * Found a terminated line above an unterminated line. Add
-		     * the amount for a continuation line.
-		     *	 x = 1;
-		     *	 y = foo +
-		     * ->	here;
-		     * or
-		     *	 int x = 1;
-		     *	 int foo,
-		     * ->	here;
-		     */
-		    if (lookfor == LOOKFOR_UNTERM
-					   || lookfor == LOOKFOR_ENUM_OR_INIT)
-		    {
-			if (cont_amount > 0)
-			    amount = cont_amount;
-			else
-			    amount += ind_continuation;
-			break;
-		    }
-
-		    /*
-		     * Found a terminated line above a terminated line or "if"
-		     * etc. line. Use the amount of the line below us.
-		     *	 x = 1;				x = 1;
-		     *	 if (asdf)		    y = 2;
-		     *	     while (asdf)	  ->here;
-		     *		here;
-		     * ->foo;
-		     */
-		    if (lookfor == LOOKFOR_TERM)
-		    {
-			if (!lookfor_break && whilelevel == 0)
-			    break;
-		    }
-
-		    /*
-		     * First line above the one we're indenting is terminated.
-		     * To know what needs to be done look further backward for
-		     * a terminated line.
-		     */
-		    else
-		    {
-			/*
-			 * position the cursor over the rightmost paren, so
-			 * that matching it will take us back to the start of
-			 * the line.  Helps for:
-			 *     func(asdr,
-			 *	      asdfasdf);
-			 *     here;
-			 */
-term_again:
-			l = ml_get_curline();
-			if (find_last_paren(l, '(', ')')
-				&& (trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
-			{
-			    /*
-			     * Check if we are on a case label now.  This is
-			     * handled above.
-			     *	   case xx:  if ( asdf &&
-			     *			    asdf)
-			     */
-			    curwin->w_cursor.lnum = trypos->lnum;
-			    l = ml_get_curline();
-			    if (cin_iscase(l) || cin_isscopedecl(l))
-			    {
-				++curwin->w_cursor.lnum;
-				continue;
-			    }
-			}
-
-			/* When aligning with the case statement, don't align
-			 * with a statement after it.
-			 *  case 1: {   <-- don't use this { position
-			 *	stat;
-			 *  }
-			 *  case 2:
-			 *	stat;
-			 * }
-			 */
-			iscase = (ind_keep_case_label && cin_iscase(l));
-
-			/*
-			 * Get indent and pointer to text for current line,
-			 * ignoring any jump label.
-			 */
-			amount = skip_label(curwin->w_cursor.lnum,
-							  &l, ind_maxcomment);
-
-			if (theline[0] == '{')
-			    amount += ind_open_extra;
-			/* See remark above: "Only add ind_open_extra.." */
-			if (*skipwhite(l) == '{')
-			    amount -= ind_open_extra;
-			lookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;
-
-			/*
-			 * If we're at the end of a block, skip to the start of
-			 * that block.
-			 */
-			curwin->w_cursor.col = 0;
-			if (*cin_skipcomment(l) == '}'
-				&& (trypos = find_start_brace(ind_maxcomment))
-							    != NULL) /* XXX */
-			{
-			    curwin->w_cursor.lnum = trypos->lnum;
-			    /* if not "else {" check for terminated again */
-			    /* but skip block for "} else {" */
-			    l = cin_skipcomment(ml_get_curline());
-			    if (*l == '}' || !cin_iselse(l))
-				goto term_again;
-			    ++curwin->w_cursor.lnum;
-			}
-		    }
-		}
-	    }
-	}
-      }
-
-      /* add extra indent for a comment */
-      if (cin_iscomment(theline))
-	  amount += ind_comment;
-    }
-
-    /*
-     * ok -- we're not inside any sort of structure at all!
-     *
-     * this means we're at the top level, and everything should
-     * basically just match where the previous line is, except
-     * for the lines immediately following a function declaration,
-     * which are K&R-style parameters and need to be indented.
-     */
-    else
-    {
-	/*
-	 * if our line starts with an open brace, forget about any
-	 * prevailing indent and make sure it looks like the start
-	 * of a function
-	 */
-
-	if (theline[0] == '{')
-	{
-	    amount = ind_first_open;
-	}
-
-	/*
-	 * If the NEXT line is a function declaration, the current
-	 * line needs to be indented as a function type spec.
-	 * Don't do this if the current line looks like a comment
-	 * or if the current line is terminated, ie. ends in ';'.
-	 */
-	else if (cur_curpos.lnum < curbuf->b_ml.ml_line_count
-		&& !cin_nocode(theline)
-		&& !cin_ends_in(theline, (char_u *)":", NULL)
-		&& !cin_ends_in(theline, (char_u *)",", NULL)
-		&& cin_isfuncdecl(NULL, cur_curpos.lnum + 1)
-		&& !cin_isterminated(theline, FALSE, TRUE))
-	{
-	    amount = ind_func_type;
-	}
-	else
-	{
-	    amount = 0;
-	    curwin->w_cursor = cur_curpos;
-
-	    /* search backwards until we find something we recognize */
-
-	    while (curwin->w_cursor.lnum > 1)
-	    {
-		curwin->w_cursor.lnum--;
-		curwin->w_cursor.col = 0;
-
-		l = ml_get_curline();
-
-		/*
-		 * If we're in a comment now, skip to the start of the comment.
-		 */						/* XXX */
-		if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
-		{
-		    curwin->w_cursor.lnum = trypos->lnum + 1;
-		    continue;
-		}
-
-		/*
-		 * Are we at the start of a cpp base class declaration or constructor
-		 * initialization?
-		 */						    /* XXX */
-		if (ind_cpp_baseclass != 0 && theline[0] != '{'
-					     && cin_is_cpp_baseclass(l, &col))
-		{
-		    if (col == 0)
-		    {
-			amount = get_indent() + ind_cpp_baseclass;  /* XXX */
-			if (find_last_paren(l, '(', ')')
-				&& (trypos = find_match_paren(ind_maxparen,
-					ind_maxcomment)) != NULL)
-			    amount = get_indent_lnum(trypos->lnum)
-					   + ind_cpp_baseclass;	    /* XXX */
-		    }
-		    else
-		    {
-			curwin->w_cursor.col = col;
-			getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);
-			amount = (int)col;
-		    }
-		    break;
-		}
-
-		/*
-		 * Skip preprocessor directives and blank lines.
-		 */
-		if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum))
-		    continue;
-
-		if (cin_nocode(l))
-		    continue;
-
-		/*
-		 * If the previous line ends in ',', use one level of
-		 * indentation:
-		 * int foo,
-		 *     bar;
-		 * do this before checking for '}' in case of eg.
-		 * enum foobar
-		 * {
-		 *   ...
-		 * } foo,
-		 *   bar;
-		 */
-		n = 0;
-		if (cin_ends_in(l, (char_u *)",", NULL)
-			     || (*l != NUL && (n = l[STRLEN(l) - 1]) == '\\'))
-		{
-		    /* take us back to opening paren */
-		    if (find_last_paren(l, '(', ')')
-			    && (trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
-			curwin->w_cursor.lnum = trypos->lnum;
-
-		    /* For a line ending in ',' that is a continuation line go
-		     * back to the first line with a backslash:
-		     * char *foo = "bla\
-		     *		 bla",
-		     *      here;
-		     */
-		    while (n == 0 && curwin->w_cursor.lnum > 1)
-		    {
-			l = ml_get(curwin->w_cursor.lnum - 1);
-			if (*l == NUL || l[STRLEN(l) - 1] != '\\')
-			    break;
-			--curwin->w_cursor.lnum;
-		    }
-
-		    amount = get_indent();	    /* XXX */
-
-		    if (amount == 0)
-			amount = cin_first_id_amount();
-		    if (amount == 0)
-			amount = ind_continuation;
-		    break;
-		}
-
-		/*
-		 * If the line looks like a function declaration, and we're
-		 * not in a comment, put it the left margin.
-		 */
-		if (cin_isfuncdecl(NULL, cur_curpos.lnum))  /* XXX */
-		    break;
-		l = ml_get_curline();
-
-		/*
-		 * Finding the closing '}' of a previous function.  Put
-		 * current line at the left margin.  For when 'cino' has "fs".
-		 */
-		if (*skipwhite(l) == '}')
-		    break;
-
-		/*			    (matching {)
-		 * If the previous line ends on '};' (maybe followed by
-		 * comments) align at column 0.  For example:
-		 * char *string_array[] = { "foo",
-		 *     / * x * / "b};ar" }; / * foobar * /
-		 */
-		if (cin_ends_in(l, (char_u *)"};", NULL))
-		    break;
-
-		/*
-		 * If the PREVIOUS line is a function declaration, the current
-		 * line (and the ones that follow) needs to be indented as
-		 * parameters.
-		 */
-		if (cin_isfuncdecl(&l, curwin->w_cursor.lnum))
-		{
-		    amount = ind_param;
-		    break;
-		}
-
-		/*
-		 * If the previous line ends in ';' and the line before the
-		 * previous line ends in ',' or '\', ident to column zero:
-		 * int foo,
-		 *     bar;
-		 * indent_to_0 here;
-		 */
-		if (cin_ends_in(l, (char_u*)";", NULL))
-		{
-		    l = ml_get(curwin->w_cursor.lnum - 1);
-		    if (cin_ends_in(l, (char_u *)",", NULL)
-			    || (*l != NUL && l[STRLEN(l) - 1] == '\\'))
-			break;
-		    l = ml_get_curline();
-		}
-
-		/*
-		 * Doesn't look like anything interesting -- so just
-		 * use the indent of this line.
-		 *
-		 * Position the cursor over the rightmost paren, so that
-		 * matching it will take us back to the start of the line.
-		 */
-		find_last_paren(l, '(', ')');
-
-		if ((trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
-		    curwin->w_cursor.lnum = trypos->lnum;
-		amount = get_indent();	    /* XXX */
-		break;
-	    }
-
-	    /* add extra indent for a comment */
-	    if (cin_iscomment(theline))
-		amount += ind_comment;
-
-	    /* add extra indent if the previous line ended in a backslash:
-	     *	      "asdfasdf\
-	     *		  here";
-	     *	    char *foo = "asdf\
-	     *			 here";
-	     */
-	    if (cur_curpos.lnum > 1)
-	    {
-		l = ml_get(cur_curpos.lnum - 1);
-		if (*l != NUL && l[STRLEN(l) - 1] == '\\')
-		{
-		    cur_amount = cin_get_equal_amount(cur_curpos.lnum - 1);
-		    if (cur_amount > 0)
-			amount = cur_amount;
-		    else if (cur_amount == 0)
-			amount += ind_continuation;
-		}
-	    }
-	}
-    }
-
-theend:
-    /* put the cursor back where it belongs */
-    curwin->w_cursor = cur_curpos;
-
-    vim_free(linecopy);
-
-    if (amount < 0)
-	return 0;
-    return amount;
-}
-
-    static int
-find_match(lookfor, ourscope, ind_maxparen, ind_maxcomment)
-    int		lookfor;
-    linenr_T	ourscope;
-    int		ind_maxparen;
-    int		ind_maxcomment;
-{
-    char_u	*look;
-    pos_T	*theirscope;
-    char_u	*mightbeif;
-    int		elselevel;
-    int		whilelevel;
-
-    if (lookfor == LOOKFOR_IF)
-    {
-	elselevel = 1;
-	whilelevel = 0;
-    }
-    else
-    {
-	elselevel = 0;
-	whilelevel = 1;
-    }
-
-    curwin->w_cursor.col = 0;
-
-    while (curwin->w_cursor.lnum > ourscope + 1)
-    {
-	curwin->w_cursor.lnum--;
-	curwin->w_cursor.col = 0;
-
-	look = cin_skipcomment(ml_get_curline());
-	if (cin_iselse(look)
-		|| cin_isif(look)
-		|| cin_isdo(look)			    /* XXX */
-		|| cin_iswhileofdo(look, curwin->w_cursor.lnum, ind_maxparen))
-	{
-	    /*
-	     * if we've gone outside the braces entirely,
-	     * we must be out of scope...
-	     */
-	    theirscope = find_start_brace(ind_maxcomment);  /* XXX */
-	    if (theirscope == NULL)
-		break;
-
-	    /*
-	     * and if the brace enclosing this is further
-	     * back than the one enclosing the else, we're
-	     * out of luck too.
-	     */
-	    if (theirscope->lnum < ourscope)
-		break;
-
-	    /*
-	     * and if they're enclosed in a *deeper* brace,
-	     * then we can ignore it because it's in a
-	     * different scope...
-	     */
-	    if (theirscope->lnum > ourscope)
-		continue;
-
-	    /*
-	     * if it was an "else" (that's not an "else if")
-	     * then we need to go back to another if, so
-	     * increment elselevel
-	     */
-	    look = cin_skipcomment(ml_get_curline());
-	    if (cin_iselse(look))
-	    {
-		mightbeif = cin_skipcomment(look + 4);
-		if (!cin_isif(mightbeif))
-		    ++elselevel;
-		continue;
-	    }
-
-	    /*
-	     * if it was a "while" then we need to go back to
-	     * another "do", so increment whilelevel.  XXX
-	     */
-	    if (cin_iswhileofdo(look, curwin->w_cursor.lnum, ind_maxparen))
-	    {
-		++whilelevel;
-		continue;
-	    }
-
-	    /* If it's an "if" decrement elselevel */
-	    look = cin_skipcomment(ml_get_curline());
-	    if (cin_isif(look))
-	    {
-		elselevel--;
-		/*
-		 * When looking for an "if" ignore "while"s that
-		 * get in the way.
-		 */
-		if (elselevel == 0 && lookfor == LOOKFOR_IF)
-		    whilelevel = 0;
-	    }
-
-	    /* If it's a "do" decrement whilelevel */
-	    if (cin_isdo(look))
-		whilelevel--;
-
-	    /*
-	     * if we've used up all the elses, then
-	     * this must be the if that we want!
-	     * match the indent level of that if.
-	     */
-	    if (elselevel <= 0 && whilelevel <= 0)
-	    {
-		return OK;
-	    }
-	}
-    }
-    return FAIL;
-}
-
-# if defined(FEAT_EVAL) || defined(PROTO)
-/*
- * Get indent level from 'indentexpr'.
- */
-    int
-get_expr_indent()
-{
-    int		indent;
-    pos_T	pos;
-    int		save_State;
-
-    pos = curwin->w_cursor;
-    set_vim_var_nr(VV_LNUM, curwin->w_cursor.lnum);
-    ++sandbox;
-    indent = eval_to_number(curbuf->b_p_inde);
-    --sandbox;
-
-    /* Restore the cursor position so that 'indentexpr' doesn't need to.
-     * Pretend to be in Insert mode, allow cursor past end of line for "o"
-     * command. */
-    save_State = State;
-    State = INSERT;
-    curwin->w_cursor = pos;
-    check_cursor();
-    State = save_State;
-
-    /* If there is an error, just keep the current indent. */
-    if (indent < 0)
-	indent = get_indent();
-
-    return indent;
-}
-# endif
-
-#endif /* FEAT_CINDENT */
-
-#if defined(FEAT_LISP) || defined(PROTO)
-
-static int lisp_match __ARGS((char_u *p));
-
-    static int
-lisp_match(p)
-    char_u	*p;
-{
-    char_u	buf[LSIZE];
-    int		len;
-    char_u	*word = p_lispwords;
-
-    while (*word != NUL)
-    {
-	(void)copy_option_part(&word, buf, LSIZE, ",");
-	len = (int)STRLEN(buf);
-	if (STRNCMP(buf, p, len) == 0 && p[len] == ' ')
-	    return TRUE;
-    }
-    return FALSE;
-}
-
-/*
- * When 'p' is present in 'cpoptions, a Vi compatible method is used.
- * The incompatible newer method is quite a bit better at indenting
- * code in lisp-like languages than the traditional one; it's still
- * mostly heuristics however -- Dirk van Deun, dirk@rave.org
- *
- * TODO:
- * Findmatch() should be adapted for lisp, also to make showmatch
- * work correctly: now (v5.3) it seems all C/C++ oriented:
- * - it does not recognize the #\( and #\) notations as character literals
- * - it doesn't know about comments starting with a semicolon
- * - it incorrectly interprets '(' as a character literal
- * All this messes up get_lisp_indent in some rare cases.
- */
-    int
-get_lisp_indent()
-{
-    pos_T	*pos, realpos;
-    int		amount;
-    char_u	*that;
-    colnr_T	col;
-    colnr_T	firsttry;
-    int		parencount, quotecount;
-    int		vi_lisp;
-
-    /* Set vi_lisp to use the vi-compatible method */
-    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);
-
-    realpos = curwin->w_cursor;
-    curwin->w_cursor.col = 0;
-
-    if ((pos = findmatch(NULL, '(')) != NULL)
-    {
-	/* Extra trick: Take the indent of the first previous non-white
-	 * line that is at the same () level. */
-	amount = -1;
-	parencount = 0;
-
-	while (--curwin->w_cursor.lnum >= pos->lnum)
-	{
-	    if (linewhite(curwin->w_cursor.lnum))
-		continue;
-	    for (that = ml_get_curline(); *that != NUL; ++that)
-	    {
-		if (*that == ';')
-		{
-		    while (*(that + 1) != NUL)
-			++that;
-		    continue;
-		}
-		if (*that == '\\')
-		{
-		    if (*(that + 1) != NUL)
-			++that;
-		    continue;
-		}
-		if (*that == '"' && *(that + 1) != NUL)
-		{
-		    that++;
-		    while (*that && (*that != '"' || *(that - 1) == '\\'))
-			++that;
-		}
-		if (*that == '(')
-		    ++parencount;
-		else if (*that == ')')
-		    --parencount;
-	    }
-	    if (parencount == 0)
-	    {
-		amount = get_indent();
-		break;
-	    }
-	}
-
-	if (amount == -1)
-	{
-	    curwin->w_cursor.lnum = pos->lnum;
-	    curwin->w_cursor.col = pos->col;
-	    col = pos->col;
-
-	    that = ml_get_curline();
-
-	    if (vi_lisp && get_indent() == 0)
-		amount = 2;
-	    else
-	    {
-		amount = 0;
-		while (*that && col)
-		{
-		    amount += lbr_chartabsize_adv(&that, (colnr_T)amount);
-		    col--;
-		}
-
-		/*
-		 * Some keywords require "body" indenting rules (the
-		 * non-standard-lisp ones are Scheme special forms):
-		 *
-		 * (let ((a 1))    instead    (let ((a 1))
-		 *   (...))	      of	   (...))
-		 */
-
-		if (!vi_lisp && *that == '(' && lisp_match(that + 1))
-		    amount += 2;
-		else
-		{
-		    that++;
-		    amount++;
-		    firsttry = amount;
-
-		    while (vim_iswhite(*that))
-		    {
-			amount += lbr_chartabsize(that, (colnr_T)amount);
-			++that;
-		    }
-
-		    if (*that && *that != ';') /* not a comment line */
-		    {
-			/* test *that != '(' to accomodate first let/do
-			 * argument if it is more than one line */
-			if (!vi_lisp && *that != '(')
-			    firsttry++;
-
-			parencount = 0;
-			quotecount = 0;
-
-			if (vi_lisp
-				|| (*that != '"'
-				    && *that != '\''
-				    && *that != '#'
-				    && (*that < '0' || *that > '9')))
-			{
-			    while (*that
-				    && (!vim_iswhite(*that)
-					|| quotecount
-					|| parencount)
-				    && (!(*that == '('
-					    && !quotecount
-					    && !parencount
-					    && vi_lisp)))
-			    {
-				if (*that == '"')
-				    quotecount = !quotecount;
-				if (*that == '(' && !quotecount)
-				    ++parencount;
-				if (*that == ')' && !quotecount)
-				    --parencount;
-				if (*that == '\\' && *(that+1) != NUL)
-				    amount += lbr_chartabsize_adv(&that,
-							     (colnr_T)amount);
-				amount += lbr_chartabsize_adv(&that,
-							     (colnr_T)amount);
-			    }
-			}
-			while (vim_iswhite(*that))
-			{
-			    amount += lbr_chartabsize(that, (colnr_T)amount);
-			    that++;
-			}
-			if (!*that || *that == ';')
-			    amount = firsttry;
-		    }
-		}
-	    }
-	}
-    }
-    else
-	amount = 0;	/* no matching '(' found, use zero indent */
-
-    curwin->w_cursor = realpos;
-
-    return amount;
-}
-#endif /* FEAT_LISP */
-
-    void
-prepare_to_exit()
-{
-#if defined(SIGHUP) && defined(SIG_IGN)
-    /* Ignore SIGHUP, because a dropped connection causes a read error, which
-     * makes Vim exit and then handling SIGHUP causes various reentrance
-     * problems. */
-    signal(SIGHUP, SIG_IGN);
-#endif
-
-#ifdef FEAT_GUI
-    if (gui.in_use)
-    {
-	gui.dying = TRUE;
-	out_trash();	/* trash any pending output */
-    }
-    else
-#endif
-    {
-	windgoto((int)Rows - 1, 0);
-
-	/*
-	 * Switch terminal mode back now, so messages end up on the "normal"
-	 * screen (if there are two screens).
-	 */
-	settmode(TMODE_COOK);
-#ifdef WIN3264
-	if (can_end_termcap_mode(FALSE) == TRUE)
-#endif
-	    stoptermcap();
-	out_flush();
-    }
-}
-
-/*
- * Preserve files and exit.
- * When called IObuff must contain a message.
- */
-    void
-preserve_exit()
-{
-    buf_T	*buf;
-
-    prepare_to_exit();
-
-    out_str(IObuff);
-    screen_start();		    /* don't know where cursor is now */
-    out_flush();
-
-    ml_close_notmod();		    /* close all not-modified buffers */
-
-    for (buf = firstbuf; buf != NULL; buf = buf->b_next)
-    {
-	if (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)
-	{
-	    OUT_STR(_("Vim: preserving files...\n"));
-	    screen_start();	    /* don't know where cursor is now */
-	    out_flush();
-	    ml_sync_all(FALSE, FALSE);	/* preserve all swap files */
-	    break;
-	}
-    }
-
-    ml_close_all(FALSE);	    /* close all memfiles, without deleting */
-
-    OUT_STR(_("Vim: Finished.\n"));
-
-    getout(1);
-}
-
-/*
- * return TRUE if "fname" exists.
- */
-    int
-vim_fexists(fname)
-    char_u  *fname;
-{
-    struct stat st;
-
-    if (mch_stat((char *)fname, &st))
-	return FALSE;
-    return TRUE;
-}
-
-/*
- * Check for CTRL-C pressed, but only once in a while.
- * Should be used instead of ui_breakcheck() for functions that check for
- * each line in the file.  Calling ui_breakcheck() each time takes too much
- * time, because it can be a system call.
- */
-
-#ifndef BREAKCHECK_SKIP
-# ifdef FEAT_GUI		    /* assume the GUI only runs on fast computers */
-#  define BREAKCHECK_SKIP 200
-# else
-#  define BREAKCHECK_SKIP 32
-# endif
-#endif
-
-static int	breakcheck_count = 0;
-
-    void
-line_breakcheck()
-{
-    if (++breakcheck_count >= BREAKCHECK_SKIP)
-    {
-	breakcheck_count = 0;
-	ui_breakcheck();
-    }
-}
-
-/*
- * Like line_breakcheck() but check 10 times less often.
- */
-    void
-fast_breakcheck()
-{
-    if (++breakcheck_count >= BREAKCHECK_SKIP * 10)
-    {
-	breakcheck_count = 0;
-	ui_breakcheck();
-    }
-}
-
-/*
- * Expand wildcards.  Calls gen_expand_wildcards() and removes files matching
- * 'wildignore'.
- */
-    int
-expand_wildcards(num_pat, pat, num_file, file, flags)
-    int		   num_pat;	/* number of input patterns */
-    char_u	 **pat;		/* array of input patterns */
-    int		  *num_file;	/* resulting number of files */
-    char_u	***file;	/* array of resulting files */
-    int		   flags;	/* EW_DIR, etc. */
-{
-    int		retval;
-    int		i, j;
-    char_u	*p;
-    int		non_suf_match;	/* number without matching suffix */
-
-    retval = gen_expand_wildcards(num_pat, pat, num_file, file, flags);
-
-    /* When keeping all matches, return here */
-    if (flags & EW_KEEPALL)
-	return retval;
-
-#ifdef FEAT_WILDIGN
-    /*
-     * Remove names that match 'wildignore'.
-     */
-    if (*p_wig)
-    {
-	char_u	*ffname;
-
-	/* check all files in (*file)[] */
-	for (i = 0; i < *num_file; ++i)
-	{
-	    ffname = FullName_save((*file)[i], FALSE);
-	    if (ffname == NULL)		/* out of memory */
-		break;
-# ifdef VMS
-	    vms_remove_version(ffname);
-# endif
-	    if (match_file_list(p_wig, (*file)[i], ffname))
-	    {
-		/* remove this matching file from the list */
-		vim_free((*file)[i]);
-		for (j = i; j + 1 < *num_file; ++j)
-		    (*file)[j] = (*file)[j + 1];
-		--*num_file;
-		--i;
-	    }
-	    vim_free(ffname);
-	}
-    }
-#endif
-
-    /*
-     * Move the names where 'suffixes' match to the end.
-     */
-    if (*num_file > 1)
-    {
-	non_suf_match = 0;
-	for (i = 0; i < *num_file; ++i)
-	{
-	    if (!match_suffix((*file)[i]))
-	    {
-		/*
-		 * Move the name without matching suffix to the front
-		 * of the list.
-		 */
-		p = (*file)[i];
-		for (j = i; j > non_suf_match; --j)
-		    (*file)[j] = (*file)[j - 1];
-		(*file)[non_suf_match++] = p;
-	    }
-	}
-    }
-
-    return retval;
-}
-
-/*
- * Return TRUE if "fname" matches with an entry in 'suffixes'.
- */
-    int
-match_suffix(fname)
-    char_u	*fname;
-{
-    int		fnamelen, setsuflen;
-    char_u	*setsuf;
-#define MAXSUFLEN 30	    /* maximum length of a file suffix */
-    char_u	suf_buf[MAXSUFLEN];
-
-    fnamelen = (int)STRLEN(fname);
-    setsuflen = 0;
-    for (setsuf = p_su; *setsuf; )
-    {
-	setsuflen = copy_option_part(&setsuf, suf_buf, MAXSUFLEN, ".,");
-	if (fnamelen >= setsuflen
-		&& fnamencmp(suf_buf, fname + fnamelen - setsuflen,
-					      (size_t)setsuflen) == 0)
-	    break;
-	setsuflen = 0;
-    }
-    return (setsuflen != 0);
-}
-
-#if !defined(NO_EXPANDPATH) || defined(PROTO)
-
-# ifdef VIM_BACKTICK
-static int vim_backtick __ARGS((char_u *p));
-static int expand_backtick __ARGS((garray_T *gap, char_u *pat, int flags));
-# endif
-
-# if defined(MSDOS) || defined(FEAT_GUI_W16) || defined(WIN3264)
-/*
- * File name expansion code for MS-DOS, Win16 and Win32.  It's here because
- * it's shared between these systems.
- */
-# if defined(DJGPP) || defined(PROTO)
-#  define _cdecl	    /* DJGPP doesn't have this */
-# else
-#  ifdef __BORLANDC__
-#   define _cdecl _RTLENTRYF
-#  endif
-# endif
-
-/*
- * comparison function for qsort in dos_expandpath()
- */
-    static int _cdecl
-pstrcmp(const void *a, const void *b)
-{
-    return (pathcmp(*(char **)a, *(char **)b));
-}
-
-# ifndef WIN3264
-    static void
-namelowcpy(
-    char_u *d,
-    char_u *s)
-{
-#  ifdef DJGPP
-    if (USE_LONG_FNAME)	    /* don't lower case on Windows 95/NT systems */
-	while (*s)
-	    *d++ = *s++;
-    else
-#  endif
-	while (*s)
-	    *d++ = TOLOWER_LOC(*s++);
-    *d = NUL;
-}
-# endif
-
-/*
- * Recursively build up a list of files in "gap" matching the first wildcard
- * in `path'.  Called by expand_wildcards().
- * Return the number of matches found.
- * "path" has backslashes before chars that are not to be expanded, starting
- * at "path[wildoff]".
- */
-    static int
-dos_expandpath(
-    garray_T	*gap,
-    char_u	*path,
-    int		wildoff,
-    int		flags)		/* EW_* flags */
-{
-    char_u		*buf;
-    char_u		*path_end;
-    char_u		*p, *s, *e;
-    int			start_len = gap->ga_len;
-    int			ok;
-#ifdef WIN3264
-    WIN32_FIND_DATA	fb;
-    HANDLE		hFind = (HANDLE)0;
-# ifdef FEAT_MBYTE
-    WIN32_FIND_DATAW    wfb;
-    WCHAR		*wn = NULL;	/* UCS-2 name, NULL when not used. */
-# endif
-#else
-    struct ffblk	fb;
-#endif
-    int			matches;
-    int			starts_with_dot;
-    int			len;
-    char_u		*pat;
-    regmatch_T		regmatch;
-    char_u		*matchname;
-
-    /* make room for file name */
-    buf = alloc((unsigned int)STRLEN(path) + BASENAMELEN + 5);
-    if (buf == NULL)
-	return 0;
-
-    /*
-     * Find the first part in the path name that contains a wildcard or a ~1.
-     * Copy it into buf, including the preceding characters.
-     */
-    p = buf;
-    s = buf;
-    e = NULL;
-    path_end = path;
-    while (*path_end != NUL)
-    {
-	/* May ignore a wildcard that has a backslash before it; it will
-	 * be removed by rem_backslash() or file_pat_to_reg_pat() below. */
-	if (path_end >= path + wildoff && rem_backslash(path_end))
-	    *p++ = *path_end++;
-	else if (*path_end == '\\' || *path_end == ':' || *path_end == '/')
-	{
-	    if (e != NULL)
-		break;
-	    s = p + 1;
-	}
-	else if (path_end >= path + wildoff
-			 && vim_strchr((char_u *)"*?[~", *path_end) != NULL)
-	    e = p;
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	{
-	    len = (*mb_ptr2len_check)(path_end);
-	    STRNCPY(p, path_end, len);
-	    p += len;
-	    path_end += len;
-	}
-	else
-#endif
-	    *p++ = *path_end++;
-    }
-    e = p;
-    *e = NUL;
-
-    /* now we have one wildcard component between s and e */
-    /* Remove backslashes between "wildoff" and the start of the wildcard
-     * component. */
-    for (p = buf + wildoff; p < s; ++p)
-	if (rem_backslash(p))
-	{
-	    STRCPY(p, p + 1);
-	    --e;
-	    --s;
-	}
-
-    starts_with_dot = (*s == '.');
-    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);
-    if (pat == NULL)
-    {
-	vim_free(buf);
-	return 0;
-    }
-
-    /* compile the regexp into a program */
-    regmatch.rm_ic = TRUE;		/* Always ignore case */
-    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);
-    vim_free(pat);
-
-    if (regmatch.regprog == NULL)
-    {
-	vim_free(buf);
-	return 0;
-    }
-
-    /* remember the pattern or file name being looked for */
-    matchname = vim_strsave(s);
-
-    /* Scan all files in the directory with "dir/ *.*" */
-    STRCPY(s, "*.*");
-#ifdef WIN3264
-# ifdef FEAT_MBYTE
-    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
-    {
-	/* The active codepage differs from 'encoding'.  Attempt using the
-	 * wide function.  If it fails because it is not implemented fall back
-	 * to the non-wide version (for Windows 98) */
-	wn = enc_to_ucs2(buf, NULL);
-	if (wn != NULL)
-	{
-	    hFind = FindFirstFileW(wn, &wfb);
-	    if (hFind == INVALID_HANDLE_VALUE
-			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
-	    {
-		vim_free(wn);
-		wn = NULL;
-	    }
-	}
-    }
-
-    if (wn == NULL)
-# endif
-	hFind = FindFirstFile(buf, &fb);
-    ok = (hFind != INVALID_HANDLE_VALUE);
-#else
-    /* If we are expanding wildcards we try both files and directories */
-    ok = (findfirst((char *)buf, &fb,
-		(*path_end != NUL || (flags & EW_DIR)) ? FA_DIREC : 0) == 0);
-#endif
-
-    while (ok)
-    {
-#ifdef WIN3264
-# ifdef FEAT_MBYTE
-	if (wn != NULL)
-	    p = ucs2_to_enc(wfb.cFileName, NULL);   /* p is allocated here */
-	else
-# endif
-	    p = (char_u *)fb.cFileName;
-#else
-	p = (char_u *)fb.ff_name;
-#endif
-	/* Ignore entries starting with a dot, unless when asked for.  Accept
-	 * all entries found with "matchname". */
-	if ((p[0] != '.' || starts_with_dot)
-		&& (matchname == NULL
-		    || vim_regexec(&regmatch, p, (colnr_T)0)))
-	{
-#ifdef WIN3264
-	    STRCPY(s, p);
-#else
-	    namelowcpy(s, p);
-#endif
-	    len = (int)STRLEN(buf);
-	    STRCPY(buf + len, path_end);
-	    if (mch_has_exp_wildcard(path_end))
-	    {
-		/* need to expand another component of the path */
-		/* remove backslashes for the remaining components only */
-		(void)dos_expandpath(gap, buf, len + 1, flags);
-	    }
-	    else
-	    {
-		/* no more wildcards, check if there is a match */
-		/* remove backslashes for the remaining components only */
-		if (*path_end != 0)
-		    backslash_halve(buf + len + 1);
-		if (mch_getperm(buf) >= 0)	/* add existing file */
-		    addfile(gap, buf, flags);
-	    }
-	}
-
-#ifdef WIN3264
-# ifdef FEAT_MBYTE
-	if (wn != NULL)
-	{
-	    vim_free(p);
-	    ok = FindNextFileW(hFind, &wfb);
-	}
-	else
-# endif
-	    ok = FindNextFile(hFind, &fb);
-#else
-	ok = (findnext(&fb) == 0);
-#endif
-
-	/* If no more matches and no match was used, try expanding the name
-	 * itself.  Finds the long name of a short filename. */
-	if (!ok && matchname != NULL && gap->ga_len == start_len)
-	{
-	    STRCPY(s, matchname);
-#ifdef WIN3264
-	    FindClose(hFind);
-# ifdef FEAT_MBYTE
-	    if (wn != NULL)
-	    {
-		vim_free(wn);
-		wn = enc_to_ucs2(buf, NULL);
-		if (wn != NULL)
-		    hFind = FindFirstFileW(wn, &wfb);
-	    }
-	    if (wn == NULL)
-# endif
-		hFind = FindFirstFile(buf, &fb);
-	    ok = (hFind != INVALID_HANDLE_VALUE);
-#else
-	    ok = (findfirst((char *)buf, &fb,
-		 (*path_end != NUL || (flags & EW_DIR)) ? FA_DIREC : 0) == 0);
-#endif
-	    vim_free(matchname);
-	    matchname = NULL;
-	}
-    }
-
-#ifdef WIN3264
-    FindClose(hFind);
-# ifdef FEAT_MBYTE
-    vim_free(wn);
-# endif
-#endif
-    vim_free(buf);
-    vim_free(regmatch.regprog);
-    vim_free(matchname);
-
-    matches = gap->ga_len - start_len;
-    if (matches > 0)
-	qsort(((char_u **)gap->ga_data) + start_len, (size_t)matches,
-						   sizeof(char_u *), pstrcmp);
-    return matches;
-}
-
-    int
-mch_expandpath(
-    garray_T	*gap,
-    char_u	*path,
-    int		flags)		/* EW_* flags */
-{
-    return dos_expandpath(gap, path, 0, flags);
-}
-# endif /* MSDOS || FEAT_GUI_W16 || WIN3264 */
-
-/*
- * Generic wildcard expansion code.
- *
- * Characters in "pat" that should not be expanded must be preceded with a
- * backslash. E.g., "/path\ with\ spaces/my\*star*"
- *
- * Return FAIL when no single file was found.  In this case "num_file" is not
- * set, and "file" may contain an error message.
- * Return OK when some files found.  "num_file" is set to the number of
- * matches, "file" to the array of matches.  Call FreeWild() later.
- */
-    int
-gen_expand_wildcards(num_pat, pat, num_file, file, flags)
-    int		num_pat;	/* number of input patterns */
-    char_u	**pat;		/* array of input patterns */
-    int		*num_file;	/* resulting number of files */
-    char_u	***file;	/* array of resulting files */
-    int		flags;		/* EW_* flags */
-{
-    int			i;
-    garray_T		ga;
-    char_u		*p;
-    static int		recursive = FALSE;
-    int			add_pat;
-
-    /*
-     * expand_env() is called to expand things like "~user".  If this fails,
-     * it calls ExpandOne(), which brings us back here.  In this case, always
-     * call the machine specific expansion function, if possible.  Otherwise,
-     * return FAIL.
-     */
-    if (recursive)
-#ifdef SPECIAL_WILDCHAR
-	return mch_expand_wildcards(num_pat, pat, num_file, file, flags);
-#else
-	return FAIL;
-#endif
-
-#ifdef SPECIAL_WILDCHAR
-    /*
-     * If there are any special wildcard characters which we cannot handle
-     * here, call machine specific function for all the expansion.  This
-     * avoids starting the shell for each argument separately.
-     * For `=expr` do use the internal function.
-     */
-    for (i = 0; i < num_pat; i++)
-    {
-	if (vim_strpbrk(pat[i], (char_u *)SPECIAL_WILDCHAR) != NULL
-# ifdef VIM_BACKTICK
-		&& !(vim_backtick(pat[i]) && pat[i][1] == '=')
-# endif
-	   )
-	    return mch_expand_wildcards(num_pat, pat, num_file, file, flags);
-    }
-#endif
-
-    recursive = TRUE;
-
-    /*
-     * The matching file names are stored in a growarray.  Init it empty.
-     */
-    ga_init2(&ga, (int)sizeof(char_u *), 30);
-
-    for (i = 0; i < num_pat; ++i)
-    {
-	add_pat = -1;
-	p = pat[i];
-
-#ifdef VIM_BACKTICK
-	if (vim_backtick(p))
-	    add_pat = expand_backtick(&ga, p, flags);
-	else
-#endif
-	{
-	    /*
-	     * First expand environment variables, "~/" and "~user/".
-	     */
-	    if (vim_strpbrk(p, (char_u *)"$~") != NULL)
-	    {
-		p = expand_env_save(p);
-		if (p == NULL)
-		    p = pat[i];
-#ifdef UNIX
-		/*
-		 * On Unix, if expand_env() can't expand an environment
-		 * variable, use the shell to do that.  Discard previously
-		 * found file names and start all over again.
-		 */
-		else if (vim_strpbrk(p, (char_u *)"$~") != NULL)
-		{
-		    vim_free(p);
-		    ga_clear(&ga);
-		    i = mch_expand_wildcards(num_pat, pat, num_file, file,
-								       flags);
-		    recursive = FALSE;
-		    return i;
-		}
-#endif
-	    }
-
-	    /*
-	     * If there are wildcards: Expand file names and add each match to
-	     * the list.  If there is no match, and EW_NOTFOUND is given, add
-	     * the pattern.
-	     * If there are no wildcards: Add the file name if it exists or
-	     * when EW_NOTFOUND is given.
-	     */
-	    if (mch_has_exp_wildcard(p))
-		add_pat = mch_expandpath(&ga, p, flags);
-	}
-
-	if (add_pat == -1 || (add_pat == 0 && (flags & EW_NOTFOUND)))
-	{
-	    char_u	*t = backslash_halve_save(p);
-
-#if defined(MACOS_CLASSIC)
-	    slash_to_colon(t);
-#endif
-	    /* When EW_NOTFOUND is used, always add files and dirs.  Makes
-	     * "vim c:/" work. */
-	    if (flags & EW_NOTFOUND)
-		addfile(&ga, t, flags | EW_DIR | EW_FILE);
-	    else if (mch_getperm(t) >= 0)
-		addfile(&ga, t, flags);
-	    vim_free(t);
-	}
-
-	if (p != pat[i])
-	    vim_free(p);
-    }
-
-    *num_file = ga.ga_len;
-    *file = (ga.ga_data != NULL) ? (char_u **)ga.ga_data : (char_u **)"";
-
-    recursive = FALSE;
-
-    return (ga.ga_data != NULL) ? OK : FAIL;
-}
-
-# ifdef VIM_BACKTICK
-
-/*
- * Return TRUE if we can expand this backtick thing here.
- */
-    static int
-vim_backtick(p)
-    char_u	*p;
-{
-    return (*p == '`' && *(p + 1) != NUL && *(p + STRLEN(p) - 1) == '`');
-}
-
-/*
- * Expand an item in `backticks` by executing it as a command.
- * Currently only works when pat[] starts and ends with a `.
- * Returns number of file names found.
- */
-    static int
-expand_backtick(gap, pat, flags)
-    garray_T	*gap;
-    char_u	*pat;
-    int		flags;	/* EW_* flags */
-{
-    char_u	*p;
-    char_u	*cmd;
-    char_u	*buffer;
-    int		cnt = 0;
-    int		i;
-
-    /* Create the command: lop off the backticks. */
-    cmd = vim_strnsave(pat + 1, (int)STRLEN(pat) - 2);
-    if (cmd == NULL)
-	return 0;
-
-#ifdef FEAT_EVAL
-    if (*cmd == '=')	    /* `={expr}`: Expand expression */
-	buffer = eval_to_string(cmd + 1, &p);
-    else
-#endif
-	buffer = get_cmd_output(cmd, (flags & EW_SILENT) ? SHELL_SILENT : 0);
-    vim_free(cmd);
-    if (buffer == NULL)
-	return 0;
-
-    cmd = buffer;
-    while (*cmd != NUL)
-    {
-	cmd = skipwhite(cmd);		/* skip over white space */
-	p = cmd;
-	while (*p != NUL && *p != '\r' && *p != '\n') /* skip over entry */
-	    ++p;
-	/* add an entry if it is not empty */
-	if (p > cmd)
-	{
-	    i = *p;
-	    *p = NUL;
-	    addfile(gap, cmd, flags);
-	    *p = i;
-	    ++cnt;
-	}
-	cmd = p;
-	while (*cmd != NUL && (*cmd == '\r' || *cmd == '\n'))
-	    ++cmd;
-    }
-
-    vim_free(buffer);
-    return cnt;
-}
-# endif /* VIM_BACKTICK */
-
-/*
- * Add a file to a file list.  Accepted flags:
- * EW_DIR	add directories
- * EW_FILE	add files
- * EW_NOTFOUND	add even when it doesn't exist
- * EW_ADDSLASH	add slash after directory name
- */
-    void
-addfile(gap, f, flags)
-    garray_T	*gap;
-    char_u	*f;	/* filename */
-    int		flags;
-{
-    char_u	*p;
-    int		isdir;
-
-    /* if the file/dir doesn't exist, may not add it */
-    if (!(flags & EW_NOTFOUND) && mch_getperm(f) < 0)
-	return;
-
-#ifdef FNAME_ILLEGAL
-    /* if the file/dir contains illegal characters, don't add it */
-    if (vim_strpbrk(f, (char_u *)FNAME_ILLEGAL) != NULL)
-	return;
-#endif
-
-    isdir = mch_isdir(f);
-    if ((isdir && !(flags & EW_DIR)) || (!isdir && !(flags & EW_FILE)))
-	return;
-
-    /* Make room for another item in the file list. */
-    if (ga_grow(gap, 1) == FAIL)
-	return;
-
-    p = alloc((unsigned)(STRLEN(f) + 1 + isdir));
-    if (p == NULL)
-	return;
-
-    STRCPY(p, f);
-#ifdef BACKSLASH_IN_FILENAME
-    slash_adjust(p);
-#endif
-    /*
-     * Append a slash or backslash after directory names if none is present.
-     */
-#ifndef DONT_ADD_PATHSEP_TO_DIR
-    if (isdir && (flags & EW_ADDSLASH))
-	add_pathsep(p);
-#endif
-    ((char_u **)gap->ga_data)[gap->ga_len++] = p;
-    --gap->ga_room;
-}
-#endif /* !NO_EXPANDPATH */
-
-#if defined(VIM_BACKTICK) || defined(FEAT_EVAL) || defined(PROTO)
-
-#ifndef SEEK_SET
-# define SEEK_SET 0
-#endif
-#ifndef SEEK_END
-# define SEEK_END 2
-#endif
-
-/*
- * Get the stdout of an external command.
- * Returns an allocated string, or NULL for error.
- */
-    char_u *
-get_cmd_output(cmd, flags)
-    char_u	*cmd;
-    int		flags;		/* can be SHELL_SILENT */
-{
-    char_u	*tempname;
-    char_u	*command;
-    char_u	*buffer = NULL;
-    int		len;
-    int		i = 0;
-    FILE	*fd;
-
-    if (check_restricted() || check_secure())
-	return NULL;
-
-    /* get a name for the temp file */
-    if ((tempname = vim_tempname('o')) == NULL)
-    {
-	EMSG(_(e_notmp));
-	return NULL;
-    }
-
-    /* Add the redirection stuff */
-    command = make_filter_cmd(cmd, NULL, tempname);
-    if (command == NULL)
-	goto done;
-
-    /*
-     * Call the shell to execute the command (errors are ignored).
-     * Don't check timestamps here.
-     */
-    ++no_check_timestamps;
-    call_shell(command, SHELL_DOOUT | SHELL_EXPAND | flags);
-    --no_check_timestamps;
-
-    vim_free(command);
-
-    /*
-     * read the names from the file into memory
-     */
-# ifdef VMS
-    /* created temporary file is not allways readable as binary */
-    fd = mch_fopen((char *)tempname, "r");
-# else
-    fd = mch_fopen((char *)tempname, READBIN);
-# endif
-
-    if (fd == NULL)
-    {
-	EMSG2(_(e_notopen), tempname);
-	goto done;
-    }
-
-    fseek(fd, 0L, SEEK_END);
-    len = ftell(fd);		    /* get size of temp file */
-    fseek(fd, 0L, SEEK_SET);
-
-    buffer = alloc(len + 1);
-    if (buffer != NULL)
-	i = (int)fread((char *)buffer, (size_t)1, (size_t)len, fd);
-    fclose(fd);
-    mch_remove(tempname);
-    if (buffer == NULL)
-	goto done;
-#ifdef VMS
-    len = i;	/* VMS doesn't give us what we asked for... */
-#endif
-    if (i != len)
-    {
-	EMSG2(_(e_notread), tempname);
-	vim_free(buffer);
-	buffer = NULL;
-    }
-    else
-	buffer[len] = '\0';	/* make sure the buffer is terminated */
-
-done:
-    vim_free(tempname);
-    return buffer;
-}
-#endif
-
-/*
- * Free the list of files returned by expand_wildcards() or other expansion
- * functions.
- */
-    void
-FreeWild(count, files)
-    int	    count;
-    char_u  **files;
-{
-    if (files == NULL || count <= 0)
-	return;
-#if defined(__EMX__) && defined(__ALWAYS_HAS_TRAILING_NULL_POINTER) /* XXX */
-    /*
-     * Is this still OK for when other functions than expand_wildcards() have
-     * been used???
-     */
-    _fnexplodefree((char **)files);
-#else
-    while (count--)
-	vim_free(files[count]);
-    vim_free(files);
-#endif
-}
-
-/*
- * return TRUE when need to go to Insert mode because of 'insertmode'.
- * Don't do this when still processing a command or a mapping.
- * Don't do this when inside a ":normal" command.
- */
-    int
-goto_im()
-{
-    return (p_im && stuff_empty() && typebuf_typed());
-}
diff -Nur vim63/src/normal.c.orig vim63-bonobo/src/normal.c.orig
--- vim63/src/normal.c.orig	2005-09-09 20:11:10.205812000 +0200
+++ vim63-bonobo/src/normal.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,8519 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-/*
- * normal.c:	Contains the main routine for processing characters in command
- *		mode.  Communicates closely with the code in ops.c to handle
- *		the operators.
- */
-
-#include "vim.h"
-
-#ifdef FEAT_VISUAL
-/*
- * The Visual area is remembered for reselection.
- */
-static int	resel_VIsual_mode = NUL;	/* 'v', 'V', or Ctrl-V */
-static linenr_T	resel_VIsual_line_count;	/* number of lines */
-static colnr_T	resel_VIsual_col;		/* nr of cols or end col */
-
-static int	restart_VIsual_select = 0;
-#endif
-
-static int
-# ifdef __BORLANDC__
-_RTLENTRYF
-# endif
-		nv_compare __ARGS((const void *s1, const void *s2));
-static int	find_command __ARGS((int cmdchar));
-static void	op_colon __ARGS((oparg_T *oap));
-#if defined(FEAT_MOUSE) && defined(FEAT_VISUAL)
-static void	find_start_of_word __ARGS((pos_T *));
-static void	find_end_of_word __ARGS((pos_T *));
-static int	get_mouse_class __ARGS((char_u *p));
-#endif
-static void	prep_redo_cmd __ARGS((cmdarg_T *cap));
-static void	prep_redo __ARGS((int regname, long, int, int, int, int, int));
-static int	checkclearop __ARGS((oparg_T *oap));
-static int	checkclearopq __ARGS((oparg_T *oap));
-static void	clearop __ARGS((oparg_T *oap));
-static void	clearopbeep __ARGS((oparg_T *oap));
-#ifdef FEAT_VISUAL
-static void	unshift_special __ARGS((cmdarg_T *cap));
-#endif
-#ifdef FEAT_CMDL_INFO
-static void	del_from_showcmd __ARGS((int));
-#endif
-
-/*
- * nv_*(): functions called to handle Normal and Visual mode commands.
- * n_*(): functions called to handle Normal mode commands.
- * v_*(): functions called to handle Visual mode commands.
- */
-static void	nv_ignore __ARGS((cmdarg_T *cap));
-static void	nv_error __ARGS((cmdarg_T *cap));
-static void	nv_help __ARGS((cmdarg_T *cap));
-static void	nv_addsub __ARGS((cmdarg_T *cap));
-static void	nv_page __ARGS((cmdarg_T *cap));
-static void	nv_gd __ARGS((oparg_T *oap, int nchar));
-static int	nv_screengo __ARGS((oparg_T *oap, int dir, long dist));
-#ifdef FEAT_MOUSE
-static void	nv_mousescroll __ARGS((cmdarg_T *cap));
-static void	nv_mouse __ARGS((cmdarg_T *cap));
-#endif
-static void	nv_scroll_line __ARGS((cmdarg_T *cap));
-static void	nv_zet __ARGS((cmdarg_T *cap));
-#ifdef FEAT_GUI
-static void	nv_ver_scrollbar __ARGS((cmdarg_T *cap));
-static void	nv_hor_scrollbar __ARGS((cmdarg_T *cap));
-#endif
-static void	nv_exmode __ARGS((cmdarg_T *cap));
-static void	nv_colon __ARGS((cmdarg_T *cap));
-static void	nv_ctrlg __ARGS((cmdarg_T *cap));
-static void	nv_ctrlh __ARGS((cmdarg_T *cap));
-static void	nv_clear __ARGS((cmdarg_T *cap));
-static void	nv_ctrlo __ARGS((cmdarg_T *cap));
-static void	nv_hat __ARGS((cmdarg_T *cap));
-static void	nv_Zet __ARGS((cmdarg_T *cap));
-static void	nv_ident __ARGS((cmdarg_T *cap));
-#ifdef FEAT_VISUAL
-static int	get_visual_text __ARGS((cmdarg_T *cap, char_u **pp, int *lenp));
-#endif
-static void	nv_tagpop __ARGS((cmdarg_T *cap));
-static void	nv_scroll __ARGS((cmdarg_T *cap));
-static void	nv_right __ARGS((cmdarg_T *cap));
-static void	nv_left __ARGS((cmdarg_T *cap));
-static void	nv_up __ARGS((cmdarg_T *cap));
-static void	nv_down __ARGS((cmdarg_T *cap));
-#ifdef FEAT_SEARCHPATH
-static void	nv_gotofile __ARGS((cmdarg_T *cap));
-#endif
-static void	nv_end __ARGS((cmdarg_T *cap));
-static void	nv_dollar __ARGS((cmdarg_T *cap));
-static void	nv_search __ARGS((cmdarg_T *cap));
-static void	nv_next __ARGS((cmdarg_T *cap));
-static void	normal_search __ARGS((cmdarg_T *cap, int dir, char_u *pat, int opt));
-static void	nv_csearch __ARGS((cmdarg_T *cap));
-static void	nv_brackets __ARGS((cmdarg_T *cap));
-static void	nv_percent __ARGS((cmdarg_T *cap));
-static void	nv_brace __ARGS((cmdarg_T *cap));
-static void	nv_mark __ARGS((cmdarg_T *cap));
-static void	nv_findpar __ARGS((cmdarg_T *cap));
-static void	nv_undo __ARGS((cmdarg_T *cap));
-static void	nv_kundo __ARGS((cmdarg_T *cap));
-static void	nv_Replace __ARGS((cmdarg_T *cap));
-#ifdef FEAT_VREPLACE
-static void	nv_vreplace __ARGS((cmdarg_T *cap));
-#endif
-#ifdef FEAT_VISUAL
-static void	v_swap_corners __ARGS((int cmdchar));
-#endif
-static void	nv_replace __ARGS((cmdarg_T *cap));
-static void	n_swapchar __ARGS((cmdarg_T *cap));
-static void	nv_cursormark __ARGS((cmdarg_T *cap, int flag, pos_T *pos));
-#ifdef FEAT_VISUAL
-static void	v_visop __ARGS((cmdarg_T *cap));
-#endif
-static void	nv_subst __ARGS((cmdarg_T *cap));
-static void	nv_abbrev __ARGS((cmdarg_T *cap));
-static void	nv_optrans __ARGS((cmdarg_T *cap));
-static void	nv_gomark __ARGS((cmdarg_T *cap));
-static void	nv_pcmark __ARGS((cmdarg_T *cap));
-static void	nv_regname __ARGS((cmdarg_T *cap));
-#ifdef FEAT_VISUAL
-static void	nv_visual __ARGS((cmdarg_T *cap));
-static void	n_start_visual_mode __ARGS((int c));
-#endif
-static void	nv_window __ARGS((cmdarg_T *cap));
-static void	nv_suspend __ARGS((cmdarg_T *cap));
-static void	nv_g_cmd __ARGS((cmdarg_T *cap));
-static void	n_opencmd __ARGS((cmdarg_T *cap));
-static void	nv_dot __ARGS((cmdarg_T *cap));
-static void	nv_redo __ARGS((cmdarg_T *cap));
-static void	nv_Undo __ARGS((cmdarg_T *cap));
-static void	nv_tilde __ARGS((cmdarg_T *cap));
-static void	nv_operator __ARGS((cmdarg_T *cap));
-static void	nv_lineop __ARGS((cmdarg_T *cap));
-static void	nv_home __ARGS((cmdarg_T *cap));
-static void	nv_pipe __ARGS((cmdarg_T *cap));
-static void	nv_bck_word __ARGS((cmdarg_T *cap));
-static void	nv_wordcmd __ARGS((cmdarg_T *cap));
-static void	nv_beginline __ARGS((cmdarg_T *cap));
-#ifdef FEAT_VISUAL
-static void	adjust_for_sel __ARGS((cmdarg_T *cap));
-static int	unadjust_for_sel __ARGS((void));
-static void	nv_select __ARGS((cmdarg_T *cap));
-#endif
-static void	nv_goto __ARGS((cmdarg_T *cap));
-static void	nv_normal __ARGS((cmdarg_T *cap));
-static void	nv_esc __ARGS((cmdarg_T *oap));
-static void	nv_edit __ARGS((cmdarg_T *cap));
-static void	invoke_edit __ARGS((cmdarg_T *cap, int repl, int cmd, int startln));
-#ifdef FEAT_TEXTOBJ
-static void	nv_object __ARGS((cmdarg_T *cap));
-#endif
-static void	nv_record __ARGS((cmdarg_T *cap));
-static void	nv_at __ARGS((cmdarg_T *cap));
-static void	nv_halfpage __ARGS((cmdarg_T *cap));
-static void	nv_join __ARGS((cmdarg_T *cap));
-static void	nv_put __ARGS((cmdarg_T *cap));
-static void	nv_open __ARGS((cmdarg_T *cap));
-#ifdef FEAT_SNIFF
-static void	nv_sniff __ARGS((cmdarg_T *cap));
-#endif
-#ifdef FEAT_NETBEANS_INTG
-static void	nv_nbcmd __ARGS((cmdarg_T *cap));
-#endif
-#ifdef FEAT_DND
-static void	nv_drop __ARGS((cmdarg_T *cap));
-#endif
-
-/*
- * Function to be called for a Normal or Visual mode command.
- * The argument is a cmdarg_T.
- */
-typedef void (*nv_func_T) __ARGS((cmdarg_T *cap));
-
-/* Values for cmd_flags. */
-#define NV_NCH	    0x01	  /* may need to get a second char */
-#define NV_NCH_NOP  (0x02|NV_NCH) /* get second char when no operator pending */
-#define NV_NCH_ALW  (0x04|NV_NCH) /* always get a second char */
-#define NV_LANG	    0x08	/* second char needs language adjustment */
-
-#define NV_SS	    0x10	/* may start selection */
-#define NV_SSS	    0x20	/* may start selection with shift modifier */
-#define NV_STS	    0x40	/* may stop selection without shift modif. */
-#define NV_RL	    0x80	/* 'rightleft' modifies command */
-#define NV_KEEPREG  0x100	/* don't clear regname */
-#define NV_NCW	    0x200	/* not allowed in command-line window */
-
-/*
- * Generally speaking, every Normal mode command should either clear any
- * pending operator (with *clearop*()), or set the motion type variable
- * oap->motion_type.
- *
- * When a cursor motion command is made, it is marked as being a character or
- * line oriented motion.  Then, if an operator is in effect, the operation
- * becomes character or line oriented accordingly.
- */
-
-/*
- * This table contains one entry for every Normal or Visual mode command.
- * The order doesn't matter, init_normal_cmds() will create a sorted index.
- * It is faster when all keys from zero to '~' are present.
- */
-static const struct nv_cmd
-{
-    int		cmd_char;	/* (first) command character */
-    nv_func_T   cmd_func;	/* function for this command */
-    short_u	cmd_flags;	/* NV_ flags */
-    short	cmd_arg;	/* value for ca.arg */
-} nv_cmds[] =
-{
-    {NUL,	nv_error,	0,			0},
-    {Ctrl_A,	nv_addsub,	0,			0},
-    {Ctrl_B,	nv_page,	NV_STS,			BACKWARD},
-    {Ctrl_C,	nv_esc,		0,			TRUE},
-    {Ctrl_D,	nv_halfpage,	0,			0},
-    {Ctrl_E,	nv_scroll_line,	0,			TRUE},
-    {Ctrl_F,	nv_page,	NV_STS,			FORWARD},
-    {Ctrl_G,	nv_ctrlg,	0,			0},
-    {Ctrl_H,	nv_ctrlh,	0,			0},
-    {Ctrl_I,	nv_pcmark,	0,			0},
-    {NL,	nv_down,	0,			FALSE},
-    {Ctrl_K,	nv_error,	0,			0},
-    {Ctrl_L,	nv_clear,	0,			0},
-    {CAR,	nv_down,	0,			TRUE},
-    {Ctrl_N,	nv_down,	NV_STS,			FALSE},
-    {Ctrl_O,	nv_ctrlo,	0,			0},
-    {Ctrl_P,	nv_up,		NV_STS,			FALSE},
-    {Ctrl_Q,	nv_ignore,	0,			0},
-    {Ctrl_R,	nv_redo,	0,			0},
-    {Ctrl_S,	nv_ignore,	0,			0},
-    {Ctrl_T,	nv_tagpop,	NV_NCW,			0},
-    {Ctrl_U,	nv_halfpage,	0,			0},
-#ifdef FEAT_VISUAL
-    {Ctrl_V,	nv_visual,	0,			FALSE},
-    {'V',	nv_visual,	0,			FALSE},
-    {'v',	nv_visual,	0,			FALSE},
-#else
-    {Ctrl_V,	nv_error,	0,			0},
-    {'V',	nv_error,	0,			0},
-    {'v',	nv_error,	0,			0},
-#endif
-    {Ctrl_W,	nv_window,	0,			0},
-    {Ctrl_X,	nv_addsub,	0,			0},
-    {Ctrl_Y,	nv_scroll_line,	0,			FALSE},
-    {Ctrl_Z,	nv_suspend,	0,			0},
-    {ESC,	nv_esc,		0,			FALSE},
-    {Ctrl_BSL,	nv_normal,	NV_NCH_ALW,		0},
-    {Ctrl_RSB,	nv_ident,	NV_NCW,			0},
-    {Ctrl_HAT,	nv_hat,		NV_NCW,			0},
-    {Ctrl__,	nv_error,	0,			0},
-    {' ',	nv_right,	0,			0},
-    {'!',	nv_operator,	0,			0},
-    {'"',	nv_regname,	NV_NCH_NOP|NV_KEEPREG,	0},
-    {'#',	nv_ident,	0,			0},
-    {'$',	nv_dollar,	0,			0},
-    {'%',	nv_percent,	0,			0},
-    {'&',	nv_optrans,	0,			0},
-    {'\'',	nv_gomark,	NV_NCH_ALW,		TRUE},
-    {'(',	nv_brace,	0,			BACKWARD},
-    {')',	nv_brace,	0,			FORWARD},
-    {'*',	nv_ident,	0,			0},
-    {'+',	nv_down,	0,			TRUE},
-    {',',	nv_csearch,	0,			TRUE},
-    {'-',	nv_up,		0,			TRUE},
-    {'.',	nv_dot,		NV_KEEPREG,		0},
-    {'/',	nv_search,	0,			FALSE},
-    {'0',	nv_beginline,	0,			0},
-    {'1',	nv_ignore,	0,			0},
-    {'2',	nv_ignore,	0,			0},
-    {'3',	nv_ignore,	0,			0},
-    {'4',	nv_ignore,	0,			0},
-    {'5',	nv_ignore,	0,			0},
-    {'6',	nv_ignore,	0,			0},
-    {'7',	nv_ignore,	0,			0},
-    {'8',	nv_ignore,	0,			0},
-    {'9',	nv_ignore,	0,			0},
-    {':',	nv_colon,	0,			0},
-    {';',	nv_csearch,	0,			FALSE},
-    {'<',	nv_operator,	NV_RL,			0},
-    {'=',	nv_operator,	0,			0},
-    {'>',	nv_operator,	NV_RL,			0},
-    {'?',	nv_search,	0,			FALSE},
-    {'@',	nv_at,		NV_NCH_NOP,		FALSE},
-    {'A',	nv_edit,	0,			0},
-    {'B',	nv_bck_word,	0,			1},
-    {'C',	nv_abbrev,	NV_KEEPREG,		0},
-    {'D',	nv_abbrev,	NV_KEEPREG,		0},
-    {'E',	nv_wordcmd,	0,			TRUE},
-    {'F',	nv_csearch,	NV_NCH_ALW|NV_LANG,	BACKWARD},
-    {'G',	nv_goto,	0,			TRUE},
-    {'H',	nv_scroll,	0,			0},
-    {'I',	nv_edit,	0,			0},
-    {'J',	nv_join,	0,			0},
-    {'K',	nv_ident,	0,			0},
-    {'L',	nv_scroll,	0,			0},
-    {'M',	nv_scroll,	0,			0},
-    {'N',	nv_next,	0,			SEARCH_REV},
-    {'O',	nv_open,	0,			0},
-    {'P',	nv_put,		0,			0},
-    {'Q',	nv_exmode,	NV_NCW,			0},
-    {'R',	nv_Replace,	0,			FALSE},
-    {'S',	nv_subst,	NV_KEEPREG,		0},
-    {'T',	nv_csearch,	NV_NCH_ALW|NV_LANG,	BACKWARD},
-    {'U',	nv_Undo,	0,			0},
-    {'W',	nv_wordcmd,	0,			TRUE},
-    {'X',	nv_abbrev,	NV_KEEPREG,		0},
-    {'Y',	nv_abbrev,	NV_KEEPREG,		0},
-    {'Z',	nv_Zet,		NV_NCH_NOP|NV_NCW,	0},
-    {'[',	nv_brackets,	NV_NCH_ALW,		BACKWARD},
-    {'\\',	nv_error,	0,			0},
-    {']',	nv_brackets,	NV_NCH_ALW,		FORWARD},
-    {'^',	nv_beginline,	0,			BL_WHITE | BL_FIX},
-    {'_',	nv_lineop,	0,			0},
-    {'`',	nv_gomark,	NV_NCH_ALW,		FALSE},
-    {'a',	nv_edit,	NV_NCH,			0},
-    {'b',	nv_bck_word,	0,			0},
-    {'c',	nv_operator,	0,			0},
-    {'d',	nv_operator,	0,			0},
-    {'e',	nv_wordcmd,	0,			FALSE},
-    {'f',	nv_csearch,	NV_NCH_ALW|NV_LANG,	FORWARD},
-    {'g',	nv_g_cmd,	NV_NCH_ALW,		FALSE},
-    {'h',	nv_left,	NV_RL,			0},
-    {'i',	nv_edit,	NV_NCH,			0},
-    {'j',	nv_down,	0,			FALSE},
-    {'k',	nv_up,		0,			FALSE},
-    {'l',	nv_right,	NV_RL,			0},
-    {'m',	nv_mark,	NV_NCH_NOP,		0},
-    {'n',	nv_next,	0,			0},
-    {'o',	nv_open,	0,			0},
-    {'p',	nv_put,		0,			0},
-    {'q',	nv_record,	NV_NCH,			0},
-    {'r',	nv_replace,	NV_NCH_NOP|NV_LANG,	0},
-    {'s',	nv_subst,	NV_KEEPREG,		0},
-    {'t',	nv_csearch,	NV_NCH_ALW|NV_LANG,	FORWARD},
-    {'u',	nv_undo,	0,			0},
-    {'w',	nv_wordcmd,	0,			FALSE},
-    {'x',	nv_abbrev,	NV_KEEPREG,		0},
-    {'y',	nv_operator,	0,			0},
-    {'z',	nv_zet,		NV_NCH_ALW,		0},
-    {'{',	nv_findpar,	0,			BACKWARD},
-    {'|',	nv_pipe,	0,			0},
-    {'}',	nv_findpar,	0,			FORWARD},
-    {'~',	nv_tilde,	0,			0},
-
-    /* pound sign */
-    {POUND,	nv_ident,	0,			0},
-#ifdef FEAT_MOUSE
-    {K_MOUSEUP, nv_mousescroll,	0,			TRUE},
-    {K_MOUSEDOWN, nv_mousescroll, 0,			FALSE},
-    {K_LEFTMOUSE, nv_mouse,	0,			0},
-    {K_LEFTMOUSE_NM, nv_mouse,	0,			0},
-    {K_LEFTDRAG, nv_mouse,	0,			0},
-    {K_LEFTRELEASE, nv_mouse,	0,			0},
-    {K_LEFTRELEASE_NM, nv_mouse, 0,			0},
-    {K_MIDDLEMOUSE, nv_mouse,	0,			0},
-    {K_MIDDLEDRAG, nv_mouse,	0,			0},
-    {K_MIDDLERELEASE, nv_mouse,	0,			0},
-    {K_RIGHTMOUSE, nv_mouse,	0,			0},
-    {K_RIGHTDRAG, nv_mouse,	0,			0},
-    {K_RIGHTRELEASE, nv_mouse,	0,			0},
-    {K_X1MOUSE, nv_mouse,	0,			0},
-    {K_X1DRAG, nv_mouse,	0,			0},
-    {K_X1RELEASE, nv_mouse,	0,			0},
-    {K_X2MOUSE, nv_mouse,	0,			0},
-    {K_X2DRAG, nv_mouse,	0,			0},
-    {K_X2RELEASE, nv_mouse,	0,			0},
-#endif
-    {K_IGNORE,	nv_ignore,	0,			0},
-    {K_INS,	nv_edit,	0,			0},
-    {K_KINS,	nv_edit,	0,			0},
-    {K_BS,	nv_ctrlh,	0,			0},
-    {K_UP,	nv_up,		NV_SSS|NV_STS,		FALSE},
-    {K_S_UP,	nv_page,	NV_SS,			BACKWARD},
-    {K_DOWN,	nv_down,	NV_SSS|NV_STS,		FALSE},
-    {K_S_DOWN,	nv_page,	NV_SS,			FORWARD},
-    {K_LEFT,	nv_left,	NV_SSS|NV_STS|NV_RL,	0},
-    {K_S_LEFT,	nv_bck_word,	NV_SS|NV_RL,		0},
-    {K_C_LEFT,	nv_bck_word,	NV_SSS|NV_RL|NV_STS,	1},
-    {K_RIGHT,	nv_right,	NV_SSS|NV_STS|NV_RL,	0},
-    {K_S_RIGHT,	nv_wordcmd,	NV_SS|NV_RL,		FALSE},
-    {K_C_RIGHT,	nv_wordcmd,	NV_SSS|NV_RL|NV_STS,	TRUE},
-    {K_PAGEUP,	nv_page,	NV_SSS|NV_STS,		BACKWARD},
-    {K_KPAGEUP,	nv_page,	NV_SSS|NV_STS,		BACKWARD},
-    {K_PAGEDOWN, nv_page,	NV_SSS|NV_STS,		FORWARD},
-    {K_KPAGEDOWN, nv_page,	NV_SSS|NV_STS,		FORWARD},
-    {K_END,	nv_end,		NV_SSS|NV_STS,		FALSE},
-    {K_KEND,	nv_end,		NV_SSS|NV_STS,		FALSE},
-    {K_XEND,	nv_end,		NV_SSS|NV_STS,		FALSE},
-    {K_S_END,	nv_end,		NV_SS,			FALSE},
-    {K_C_END,	nv_end,		NV_SSS|NV_STS,		TRUE},
-    {K_HOME,	nv_home,	NV_SSS|NV_STS,		0},
-    {K_KHOME,	nv_home,	NV_SSS|NV_STS,		0},
-    {K_XHOME,	nv_home,	NV_SSS|NV_STS,		0},
-    {K_S_HOME,	nv_home,	NV_SS,			0},
-    {K_C_HOME,	nv_goto,	NV_SSS|NV_STS,		FALSE},
-    {K_DEL,	nv_abbrev,	0,			0},
-    {K_KDEL,	nv_abbrev,	0,			0},
-    {K_UNDO,	nv_kundo,	0,			0},
-    {K_HELP,	nv_help,	NV_NCW,			0},
-    {K_F1,	nv_help,	NV_NCW,			0},
-    {K_XF1,	nv_help,	NV_NCW,			0},
-#ifdef FEAT_VISUAL
-    {K_SELECT,	nv_select,	0,			0},
-#endif
-#ifdef FEAT_GUI
-    {K_VER_SCROLLBAR, nv_ver_scrollbar, 0,		0},
-    {K_HOR_SCROLLBAR, nv_hor_scrollbar, 0,		0},
-#endif
-#ifdef FEAT_FKMAP
-    {K_F8,	farsi_fkey,	0,			0},
-    {K_F9,	farsi_fkey,	0,			0},
-#endif
-#ifdef FEAT_SNIFF
-    {K_SNIFF,	nv_sniff,	0,			0},
-#endif
-#ifdef FEAT_NETBEANS_INTG
-    {K_F21,	nv_nbcmd,	NV_NCH_ALW,		0},
-#endif
-#ifdef FEAT_DND
-    {K_DROP,	nv_drop,	NV_STS,			0},
-#endif
-};
-
-/* Number of commands in nv_cmds[]. */
-#define NV_CMDS_SIZE (sizeof(nv_cmds) / sizeof(struct nv_cmd))
-
-/* Sorted index of commands in nv_cmds[]. */
-static short nv_cmd_idx[NV_CMDS_SIZE];
-
-/* The highest index for which
- * nv_cmds[idx].cmd_char == nv_cmd_idx[nv_cmds[idx].cmd_char] */
-static int nv_max_linear;
-
-/*
- * Compare functions for qsort() below, that checks the command character
- * through the index in nv_cmd_idx[].
- */
-    static int
-#ifdef __BORLANDC__
-_RTLENTRYF
-#endif
-nv_compare(s1, s2)
-    const void	*s1;
-    const void	*s2;
-{
-    int		c1, c2;
-
-    /* The commands are sorted on absolute value. */
-    c1 = nv_cmds[*(const short *)s1].cmd_char;
-    c2 = nv_cmds[*(const short *)s2].cmd_char;
-    if (c1 < 0)
-	c1 = -c1;
-    if (c2 < 0)
-	c2 = -c2;
-    return c1 - c2;
-}
-
-/*
- * Initialize the nv_cmd_idx[] table.
- */
-    void
-init_normal_cmds()
-{
-    int		i;
-
-    /* Fill the index table with a one to one relation. */
-    for (i = 0; i < NV_CMDS_SIZE; ++i)
-	nv_cmd_idx[i] = i;
-
-    /* Sort the commands by the command character.  */
-    qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);
-
-    /* Find the first entry that can't be indexed by the command character. */
-    for (i = 0; i < NV_CMDS_SIZE; ++i)
-	if (i != nv_cmds[nv_cmd_idx[i]].cmd_char)
-	    break;
-    nv_max_linear = i - 1;
-}
-
-/*
- * Search for a command in the commands table.
- * Returns -1 for invalid command.
- */
-    static int
-find_command(cmdchar)
-    int		cmdchar;
-{
-    int		i;
-    int		idx;
-    int		top, bot;
-    int		c;
-
-#ifdef FEAT_MBYTE
-    /* A multi-byte character is never a command. */
-    if (cmdchar >= 0x100)
-	return -1;
-#endif
-
-    /* We use the absolute value of the character.  Special keys have a
-     * negative value, but are sorted on their absolute value. */
-    if (cmdchar < 0)
-	cmdchar = -cmdchar;
-
-    /* If the character is in the first part: The character is the index into
-     * nv_cmd_idx[]. */
-    if (cmdchar <= nv_max_linear)
-	return nv_cmd_idx[cmdchar];
-
-    /* Perform a binary search. */
-    bot = nv_max_linear + 1;
-    top = NV_CMDS_SIZE - 1;
-    idx = -1;
-    while (bot <= top)
-    {
-	i = (top + bot) / 2;
-	c = nv_cmds[nv_cmd_idx[i]].cmd_char;
-	if (c < 0)
-	    c = -c;
-	if (cmdchar == c)
-	{
-	    idx = nv_cmd_idx[i];
-	    break;
-	}
-	if (cmdchar > c)
-	    bot = i + 1;
-	else
-	    top = i - 1;
-    }
-    return idx;
-}
-
-/*
- * Execute a command in Normal mode.
- */
-/*ARGSUSED*/
-    void
-normal_cmd(oap, toplevel)
-    oparg_T	*oap;
-    int		toplevel;		/* TRUE when called from main() */
-{
-    static long	opcount = 0;		/* ca.opcount saved here */
-    cmdarg_T	ca;			/* command arguments */
-    int		c;
-    int		ctrl_w = FALSE;		/* got CTRL-W command */
-    int		old_col = curwin->w_curswant;
-#ifdef FEAT_CMDL_INFO
-    int		need_flushbuf;		/* need to call out_flush() */
-#endif
-#ifdef FEAT_VISUAL
-    pos_T	old_pos;		/* cursor position before command */
-    int		mapped_len;
-#endif
-    static int	old_mapped_len = 0;
-    int		idx;
-
-    vim_memset(&ca, 0, sizeof(ca));	/* also resets ca.retval */
-    ca.oap = oap;
-    ca.opcount = opcount;
-
-#ifdef FEAT_SNIFF
-    want_sniff_request = sniff_connected;
-#endif
-
-    /*
-     * If there is an operator pending, then the command we take this time
-     * will terminate it. Finish_op tells us to finish the operation before
-     * returning this time (unless the operation was cancelled).
-     */
-#ifdef CURSOR_SHAPE
-    c = finish_op;
-#endif
-    finish_op = (oap->op_type != OP_NOP);
-#ifdef CURSOR_SHAPE
-    if (finish_op != c)
-    {
-	ui_cursor_shape();		/* may show different cursor shape */
-# ifdef FEAT_MOUSESHAPE
-	update_mouseshape(-1);
-# endif
-    }
-#endif
-
-    if (!finish_op && !oap->regname)
-	ca.opcount = 0;
-
-#ifdef FEAT_VISUAL
-    mapped_len = typebuf_maplen();
-#endif
-
-    State = NORMAL_BUSY;
-#ifdef USE_ON_FLY_SCROLL
-    dont_scroll = FALSE;	/* allow scrolling here */
-#endif
-
-    /*
-     * Get the command character from the user.
-     */
-    c = safe_vgetc();
-
-#ifdef FEAT_LANGMAP
-    LANGMAP_ADJUST(c, TRUE);
-#endif
-
-    /*
-     * If a mapping was started in Visual or Select mode, remember the length
-     * of the mapping.  This is used below to not return to Insert mode for as
-     * long as the mapping is being executed.
-     */
-    if (restart_edit == 0)
-	old_mapped_len = 0;
-    else if (old_mapped_len
-#ifdef FEAT_VISUAL
-	    || (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0)
-#endif
-	    )
-	old_mapped_len = typebuf_maplen();
-
-    if (c == NUL)
-	c = K_ZERO;
-
-#ifdef FEAT_VISUAL
-    /*
-     * In Select mode, typed text replaces the selection.
-     */
-    if (VIsual_active
-	    && VIsual_select
-	    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))
-    {
-# ifdef FEAT_MBYTE
-	char_u	    buf[MB_MAXBYTES + 1];
-
-	buf[(*mb_char2bytes)(c, buf)] = NUL;
-# else
-	char_u	    buf[2];
-
-	buf[0] = c;
-	buf[1] = NUL;
-# endif
-	/* Fake a "c"hange command.  When "restart_edit" is set (e.g., because
-	 * 'insertmode' is set) fake a "d"elete command, Insert mode will
-	 * restart automatically.
-	 * Insert the typed character in the typeahead buffer, so that it will
-	 * be mapped in Insert mode.  Required for ":lmap" to work.  May cause
-	 * mapping a character from ":vnoremap"... */
-	(void)ins_typebuf(buf, REMAP_YES, 0, !KeyTyped, FALSE);
-	if (restart_edit != 0)
-	    c = 'd';
-	else
-	    c = 'c';
-    }
-#endif
-
-#ifdef FEAT_CMDL_INFO
-    need_flushbuf = add_to_showcmd(c);
-#endif
-
-getcount:
-#ifdef FEAT_VISUAL
-    if (!(VIsual_active && VIsual_select))
-#endif
-    {
-	/*
-	 * Handle a count before a command and compute ca.count0.
-	 * Note that '0' is a command and not the start of a count, but it's
-	 * part of a count after other digits.
-	 */
-	while (    (c >= '1' && c <= '9')
-		|| (ca.count0 != 0 && (c == K_DEL || c == K_KDEL || c == '0')))
-	{
-	    if (c == K_DEL || c == K_KDEL)
-	    {
-		ca.count0 /= 10;
-#ifdef FEAT_CMDL_INFO
-		del_from_showcmd(4);	/* delete the digit and ~@% */
-#endif
-	    }
-	    else
-		ca.count0 = ca.count0 * 10 + (c - '0');
-	    if (ca.count0 < 0)	    /* got too large! */
-		ca.count0 = 999999999L;
-	    if (ctrl_w)
-	    {
-		++no_mapping;
-		++allow_keys;		/* no mapping for nchar, but keys */
-	    }
-	    ++no_zero_mapping;		/* don't map zero here */
-	    c = safe_vgetc();
-#ifdef FEAT_LANGMAP
-	    LANGMAP_ADJUST(c, TRUE);
-#endif
-	    --no_zero_mapping;
-	    if (ctrl_w)
-	    {
-		--no_mapping;
-		--allow_keys;
-	    }
-#ifdef FEAT_CMDL_INFO
-	    need_flushbuf |= add_to_showcmd(c);
-#endif
-	}
-
-	/*
-	 * If we got CTRL-W there may be a/another count
-	 */
-	if (c == Ctrl_W && !ctrl_w && oap->op_type == OP_NOP)
-	{
-	    ctrl_w = TRUE;
-	    ca.opcount = ca.count0;	/* remember first count */
-	    ca.count0 = 0;
-	    ++no_mapping;
-	    ++allow_keys;		/* no mapping for nchar, but keys */
-	    c = safe_vgetc();		/* get next character */
-#ifdef FEAT_LANGMAP
-	    LANGMAP_ADJUST(c, TRUE);
-#endif
-	    --no_mapping;
-	    --allow_keys;
-#ifdef FEAT_CMDL_INFO
-	    need_flushbuf |= add_to_showcmd(c);
-#endif
-	    goto getcount;		/* jump back */
-	}
-    }
-
-    /*
-     * If we're in the middle of an operator (including after entering a yank
-     * buffer with '"') AND we had a count before the operator, then that
-     * count overrides the current value of ca.count0.
-     * What this means effectively, is that commands like "3dw" get turned
-     * into "d3w" which makes things fall into place pretty neatly.
-     * If you give a count before AND after the operator, they are multiplied.
-     */
-    if (ca.opcount != 0)
-    {
-	if (ca.count0)
-	    ca.count0 *= ca.opcount;
-	else
-	    ca.count0 = ca.opcount;
-    }
-
-    /*
-     * Always remember the count.  It will be set to zero (on the next call,
-     * above) when there is no pending operator.
-     * When called from main(), save the count for use by the "count" built-in
-     * variable.
-     */
-    ca.opcount = ca.count0;
-    ca.count1 = (ca.count0 == 0 ? 1 : ca.count0);
-
-#ifdef FEAT_EVAL
-    /*
-     * Only set v:count when called from main() and not a stuffed command.
-     */
-    if (toplevel && stuff_empty())
-	set_vcount(ca.count0, ca.count1);
-#endif
-
-    /*
-     * Find the command character in the table of commands.
-     * For CTRL-W we already got nchar when looking for a count.
-     */
-    if (ctrl_w)
-    {
-	ca.nchar = c;
-	ca.cmdchar = Ctrl_W;
-    }
-    else
-	ca.cmdchar = c;
-    idx = find_command(ca.cmdchar);
-    if (idx < 0)
-    {
-	/* Not a known command: beep. */
-	clearopbeep(oap);
-	goto normal_end;
-    }
-#ifdef FEAT_CMDWIN
-    if (cmdwin_type != 0 && (nv_cmds[idx].cmd_flags & NV_NCW))
-    {
-	/* This command is not allowed in the cmdline window: beep. */
-	clearopbeep(oap);
-	EMSG(_(e_cmdwin));
-	goto normal_end;
-    }
-#endif
-
-#ifdef FEAT_VISUAL
-    /*
-     * In Visual/Select mode, a few keys are handled in a special way.
-     */
-    if (VIsual_active)
-    {
-	/* when 'keymodel' contains "stopsel" may stop Select/Visual mode */
-	if (km_stopsel
-		&& (nv_cmds[idx].cmd_flags & NV_STS)
-		&& !(mod_mask & MOD_MASK_SHIFT))
-	{
-	    end_visual_mode();
-	    redraw_curbuf_later(INVERTED);
-	}
-
-	/* Keys that work different when 'keymodel' contains "startsel" */
-	if (km_startsel)
-	{
-	    if (nv_cmds[idx].cmd_flags & NV_SS)
-	    {
-		unshift_special(&ca);
-		idx = find_command(ca.cmdchar);
-	    }
-	    else if ((nv_cmds[idx].cmd_flags & NV_SSS)
-					       && (mod_mask & MOD_MASK_SHIFT))
-	    {
-		mod_mask &= ~MOD_MASK_SHIFT;
-	    }
-	}
-    }
-#endif
-
-#ifdef FEAT_RIGHTLEFT
-    if (curwin->w_p_rl && KeyTyped && !KeyStuffed
-					  && (nv_cmds[idx].cmd_flags & NV_RL))
-    {
-	/* Invert horizontal movements and operations.  Only when typed by the
-	 * user directly, not when the result of a mapping or "x" translated
-	 * to "dl". */
-	switch (ca.cmdchar)
-	{
-	    case 'l':	    ca.cmdchar = 'h'; break;
-	    case K_RIGHT:   ca.cmdchar = K_LEFT; break;
-	    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;
-	    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;
-	    case 'h':	    ca.cmdchar = 'l'; break;
-	    case K_LEFT:    ca.cmdchar = K_RIGHT; break;
-	    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;
-	    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;
-	    case '>':	    ca.cmdchar = '<'; break;
-	    case '<':	    ca.cmdchar = '>'; break;
-	}
-	idx = find_command(ca.cmdchar);
-    }
-#endif
-
-    /*
-     * Get an additional character if we need one.
-     */
-    if ((nv_cmds[idx].cmd_flags & NV_NCH)
-	    && (((nv_cmds[idx].cmd_flags & NV_NCH_NOP) == NV_NCH_NOP
-		    && oap->op_type == OP_NOP)
-		|| (nv_cmds[idx].cmd_flags & NV_NCH_ALW) == NV_NCH_ALW
-		|| (ca.cmdchar == 'q'
-		    && oap->op_type == OP_NOP
-		    && !Recording
-		    && !Exec_reg)
-		|| ((ca.cmdchar == 'a' || ca.cmdchar == 'i')
-		    && (oap->op_type != OP_NOP
-#ifdef FEAT_VISUAL
-			|| VIsual_active
-#endif
-		       ))))
-    {
-	int	*cp;
-	int	repl = FALSE;	/* get character for replace mode */
-	int	lit = FALSE;	/* get extra character literally */
-	int	langmap_active = FALSE;    /* using :lmap mappings */
-	int	lang;		/* getting a text character */
-#ifdef USE_IM_CONTROL
-	int	save_smd;	/* saved value of p_smd */
-#endif
-
-	++no_mapping;
-	++allow_keys;		/* no mapping for nchar, but allow key codes */
-	if (ca.cmdchar == 'g')
-	{
-	    /*
-	     * For 'g' get the next character now, so that we can check for
-	     * "gr", "g'" and "g`".
-	     */
-	    ca.nchar = safe_vgetc();
-#ifdef FEAT_LANGMAP
-	    LANGMAP_ADJUST(ca.nchar, TRUE);
-#endif
-#ifdef FEAT_CMDL_INFO
-	    need_flushbuf |= add_to_showcmd(ca.nchar);
-#endif
-	    if (ca.nchar == 'r' || ca.nchar == '\'' || ca.nchar == '`'
-						      || ca.nchar == Ctrl_BSL)
-	    {
-		cp = &ca.extra_char;	/* need to get a third character */
-		if (ca.nchar != 'r')
-		    lit = TRUE;			/* get it literally */
-		else
-		    repl = TRUE;		/* get it in replace mode */
-	    }
-	    else
-		cp = NULL;		/* no third character needed */
-	}
-	else
-	{
-	    if (ca.cmdchar == 'r')		/* get it in replace mode */
-		repl = TRUE;
-	    cp = &ca.nchar;
-	}
-	lang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));
-
-	/*
-	 * Get a second or third character.
-	 */
-	if (cp != NULL)
-	{
-#ifdef CURSOR_SHAPE
-	    if (repl)
-	    {
-		State = REPLACE;	/* pretend Replace mode */
-		ui_cursor_shape();	/* show different cursor shape */
-	    }
-#endif
-	    if (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)
-	    {
-		/* Allow mappings defined with ":lmap". */
-		--no_mapping;
-		--allow_keys;
-		if (repl)
-		    State = LREPLACE;
-		else
-		    State = LANGMAP;
-		langmap_active = TRUE;
-	    }
-#ifdef USE_IM_CONTROL
-	    save_smd = p_smd;
-	    p_smd = FALSE;	/* Don't let the IM code show the mode here */
-	    if (lang && curbuf->b_p_iminsert == B_IMODE_IM)
-		im_set_active(TRUE);
-#endif
-
-	    *cp = safe_vgetc();
-
-	    if (langmap_active)
-	    {
-		/* Undo the decrement done above */
-		++no_mapping;
-		++allow_keys;
-		State = NORMAL_BUSY;
-	    }
-#ifdef USE_IM_CONTROL
-	    if (lang)
-	    {
-		if (curbuf->b_p_iminsert != B_IMODE_LMAP)
-		    im_save_status(&curbuf->b_p_iminsert);
-		im_set_active(FALSE);
-	    }
-	    p_smd = save_smd;
-#endif
-#ifdef CURSOR_SHAPE
-	    State = NORMAL_BUSY;
-#endif
-#ifdef FEAT_CMDL_INFO
-	    need_flushbuf |= add_to_showcmd(*cp);
-#endif
-
-	    if (!lit)
-	    {
-#ifdef FEAT_DIGRAPHS
-		/* Typing CTRL-K gets a digraph. */
-		if (*cp == Ctrl_K
-			&& ((nv_cmds[idx].cmd_flags & NV_LANG)
-			    || cp == &ca.extra_char)
-			&& vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)
-		{
-		    c = get_digraph(FALSE);
-		    if (c > 0)
-		    {
-			*cp = c;
-# ifdef FEAT_CMDL_INFO
-			/* Guessing how to update showcmd here... */
-			del_from_showcmd(3);
-			need_flushbuf |= add_to_showcmd(*cp);
-# endif
-		    }
-		}
-#endif
-
-#ifdef FEAT_LANGMAP
-		/* adjust chars > 127, except after "tTfFr" commands */
-		LANGMAP_ADJUST(*cp, !lang);
-#endif
-#ifdef FEAT_RIGHTLEFT
-		/* adjust Hebrew mapped char */
-		if (p_hkmap && lang && KeyTyped)
-		    *cp = hkmap(*cp);
-# ifdef FEAT_FKMAP
-		/* adjust Farsi mapped char */
-		if (p_fkmap && lang && KeyTyped)
-		    *cp = fkmap(*cp);
-# endif
-#endif
-	    }
-
-	    /*
-	     * When the next character is CTRL-\ a following CTRL-N means the
-	     * command is aborted and we go to Normal mode.
-	     */
-	    if (cp == &ca.extra_char
-		    && ca.nchar == Ctrl_BSL
-		    && (ca.extra_char == Ctrl_N || ca.extra_char == Ctrl_G))
-	    {
-		ca.cmdchar = Ctrl_BSL;
-		ca.nchar = ca.extra_char;
-		idx = find_command(ca.cmdchar);
-	    }
-	    else if (*cp == Ctrl_BSL)
-	    {
-		long towait = (p_ttm >= 0 ? p_ttm : p_tm);
-
-		/* There is a busy wait here when typing "f<C-\>" and then
-		 * something different from CTRL-N.  Can't be avoided. */
-		while ((c = vpeekc()) <= 0 && towait > 0L)
-		{
-		    do_sleep(towait > 50L ? 50L : towait);
-		    towait -= 50L;
-		}
-		if (c > 0)
-		{
-		    c = safe_vgetc();
-		    if (c != Ctrl_N && c != Ctrl_G)
-			vungetc(c);
-		    else
-		    {
-			ca.cmdchar = Ctrl_BSL;
-			ca.nchar = c;
-			idx = find_command(ca.cmdchar);
-		    }
-		}
-	    }
-
-#ifdef FEAT_MBYTE
-	    /* When getting a text character and the next character is a
-	     * multi-byte character, it could be a composing character.
-	     * However, don't wait for it to arrive. */
-	    while (enc_utf8 && lang && (c = vpeekc()) > 0
-				 && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))
-	    {
-		c = safe_vgetc();
-		if (!utf_iscomposing(c))
-		{
-		    vungetc(c);		/* it wasn't, put it back */
-		    break;
-		}
-		else if (ca.ncharC1 == 0)
-		    ca.ncharC1 = c;
-		else
-		    ca.ncharC2 = c;
-	    }
-#endif
-	}
-	--no_mapping;
-	--allow_keys;
-    }
-
-#ifdef FEAT_CMDL_INFO
-    /*
-     * Flush the showcmd characters onto the screen so we can see them while
-     * the command is being executed.  Only do this when the shown command was
-     * actually displayed, otherwise this will slow down a lot when executing
-     * mappings.
-     */
-    if (need_flushbuf)
-	out_flush();
-#endif
-
-    State = NORMAL;
-
-    if (ca.nchar == ESC)
-    {
-	clearop(oap);
-	if (restart_edit == 0 && goto_im())
-	    restart_edit = 'a';
-	goto normal_end;
-    }
-
-    msg_didout = FALSE;	    /* don't scroll screen up for normal command */
-    msg_col = 0;
-
-#ifdef FEAT_VISUAL
-    old_pos = curwin->w_cursor;		/* remember where cursor was */
-
-    /* When 'keymodel' contains "startsel" some keys start Select/Visual
-     * mode. */
-    if (!VIsual_active && km_startsel)
-    {
-	if (nv_cmds[idx].cmd_flags & NV_SS)
-	{
-	    start_selection();
-	    unshift_special(&ca);
-	    idx = find_command(ca.cmdchar);
-	}
-	else if ((nv_cmds[idx].cmd_flags & NV_SSS)
-					   && (mod_mask & MOD_MASK_SHIFT))
-	{
-	    start_selection();
-	    mod_mask &= ~MOD_MASK_SHIFT;
-	}
-    }
-#endif
-
-    /*
-     * Execute the command!
-     * Call the command function found in the commands table.
-     */
-    ca.arg = nv_cmds[idx].cmd_arg;
-    (nv_cmds[idx].cmd_func)(&ca);
-
-    /*
-     * If we didn't start or finish an operator, reset oap->regname, unless we
-     * need it later.
-     */
-    if (!finish_op
-	    && !oap->op_type
-	    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))
-    {
-	clearop(oap);
-#ifdef FEAT_EVAL
-	set_reg_var('"');
-#endif
-    }
-
-    /* get the length of mapped chars again after typing a count, second
-     * character or "z333<cr>". */
-    if (old_mapped_len > 0)
-	old_mapped_len = typebuf_maplen();
-
-    /*
-     * If an operation is pending, handle it...
-     */
-    do_pending_operator(&ca, old_col, FALSE);
-
-    /*
-     * Wait for a moment when a message is displayed that will be overwritten
-     * by the mode message.
-     * In Visual mode and with "^O" in Insert mode, a short message will be
-     * overwritten by the mode message.  Wait a bit, until a key is hit.
-     * In Visual mode, it's more important to keep the Visual area updated
-     * than keeping a message (e.g. from a /pat search).
-     * Only do this if the command was typed, not from a mapping.
-     * Don't wait when emsg_silent is non-zero.
-     * Also wait a bit after an error message, e.g. for "^O:".
-     * Don't redraw the screen, it would remove the message.
-     */
-    if (       ((p_smd
-		    && (restart_edit != 0
-#ifdef FEAT_VISUAL
-			|| (VIsual_active
-			    && old_pos.lnum == curwin->w_cursor.lnum
-			    && old_pos.col == curwin->w_cursor.col)
-#endif
-		       )
-		    && (clear_cmdline
-			|| redraw_cmdline)
-		    && (msg_didout || (msg_didany && msg_scroll))
-		    && !msg_nowait
-		    && KeyTyped)
-		|| (restart_edit != 0
-#ifdef FEAT_VISUAL
-		    && !VIsual_active
-#endif
-		    && (msg_scroll
-			|| emsg_on_display)))
-	    && oap->regname == 0
-	    && !(ca.retval & CA_COMMAND_BUSY)
-	    && stuff_empty()
-	    && typebuf_typed()
-	    && emsg_silent == 0
-	    && !did_wait_return
-	    && oap->op_type == OP_NOP)
-    {
-	int	save_State = State;
-
-	/* Draw the cursor with the right shape here */
-	if (restart_edit != 0)
-	    State = INSERT;
-
-	/* If need to redraw, and there is a "keep_msg", redraw before the
-	 * delay */
-	if (must_redraw && keep_msg != NULL && !emsg_on_display)
-	{
-	    char_u	*kmsg;
-
-	    kmsg = keep_msg;
-	    keep_msg = NULL;
-	    /* showmode() will clear keep_msg, but we want to use it anyway */
-	    update_screen(0);
-	    /* now reset it, otherwise it's put in the history again */
-	    keep_msg = kmsg;
-	    msg_attr(kmsg, keep_msg_attr);
-	    vim_free(kmsg);
-	}
-	setcursor();
-	cursor_on();
-	out_flush();
-	if (msg_scroll || emsg_on_display)
-	    ui_delay(1000L, TRUE);	/* wait at least one second */
-	ui_delay(3000L, FALSE);		/* wait up to three seconds */
-	State = save_State;
-
-	msg_scroll = FALSE;
-	emsg_on_display = FALSE;
-    }
-
-    /*
-     * Finish up after executing a Normal mode command.
-     */
-normal_end:
-
-    msg_nowait = FALSE;
-
-    /* Reset finish_op, in case it was set */
-#ifdef CURSOR_SHAPE
-    c = finish_op;
-#endif
-    finish_op = FALSE;
-#ifdef CURSOR_SHAPE
-    /* Redraw the cursor with another shape, if we were in Operator-pending
-     * mode or did a replace command. */
-    if (c || ca.cmdchar == 'r')
-    {
-	ui_cursor_shape();		/* may show different cursor shape */
-# ifdef FEAT_MOUSESHAPE
-	update_mouseshape(-1);
-# endif
-    }
-#endif
-
-#ifdef FEAT_CMDL_INFO
-    if (oap->op_type == OP_NOP && oap->regname == 0)
-	clear_showcmd();
-#endif
-
-    checkpcmark();		/* check if we moved since setting pcmark */
-    vim_free(ca.searchbuf);
-
-#ifdef FEAT_MBYTE
-    if (has_mbyte)
-	mb_adjust_cursor();
-#endif
-
-#ifdef FEAT_SCROLLBIND
-    if (curwin->w_p_scb && toplevel)
-    {
-	validate_cursor();	/* may need to update w_leftcol */
-	do_check_scrollbind(TRUE);
-    }
-#endif
-
-    /*
-     * May restart edit(), if we got here with CTRL-O in Insert mode (but not
-     * if still inside a mapping that started in Visual mode).
-     * May switch from Visual to Select mode after CTRL-O command.
-     */
-    if (       oap->op_type == OP_NOP
-#ifdef FEAT_VISUAL
-	    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)
-		|| restart_VIsual_select == 1)
-#endif
-	    && !(ca.retval & CA_COMMAND_BUSY)
-	    && stuff_empty()
-	    && oap->regname == 0)
-    {
-#ifdef FEAT_VISUAL
-	if (restart_VIsual_select == 1)
-	{
-	    VIsual_select = TRUE;
-	    showmode();
-	    restart_VIsual_select = 0;
-	}
-#endif
-	if (restart_edit != 0
-#ifdef FEAT_VISUAL
-		&& !VIsual_active
-#endif
-		&& old_mapped_len == 0)
-	    (void)edit(restart_edit, FALSE, 1L);
-    }
-
-#ifdef FEAT_VISUAL
-    if (restart_VIsual_select == 2)
-	restart_VIsual_select = 1;
-#endif
-
-    /* Save count before an operator for next time. */
-    opcount = ca.opcount;
-}
-
-/*
- * Handle an operator after visual mode or when the movement is finished
- */
-    void
-do_pending_operator(cap, old_col, gui_yank)
-    cmdarg_T	*cap;
-    int		old_col;
-    int		gui_yank;
-{
-    oparg_T	*oap = cap->oap;
-    pos_T	old_cursor;
-    int		empty_region_error;
-    int		restart_edit_save;
-
-#ifdef FEAT_VISUAL
-    /* The visual area is remembered for redo */
-    static int	    redo_VIsual_mode = NUL; /* 'v', 'V', or Ctrl-V */
-    static linenr_T redo_VIsual_line_count; /* number of lines */
-    static colnr_T  redo_VIsual_col;	    /* number of cols or end column */
-    static long	    redo_VIsual_count;	    /* count for Visual operator */
-# ifdef FEAT_VIRTUALEDIT
-    int		    include_line_break = FALSE;
-# endif
-#endif
-
-#if defined(FEAT_CLIPBOARD)
-    /*
-     * Yank the visual area into the GUI selection register before we operate
-     * on it and lose it forever.
-     * Don't do it if a specific register was specified, so that ""x"*P works.
-     * This could call do_pending_operator() recursively, but that's OK
-     * because gui_yank will be TRUE for the nested call.
-     */
-    if (clip_star.available
-	    && oap->op_type != OP_NOP
-	    && !gui_yank
-# ifdef FEAT_VISUAL
-	    && VIsual_active
-	    && !redo_VIsual_busy
-# endif
-	    && oap->regname == 0)
-	clip_auto_select();
-#endif
-    old_cursor = curwin->w_cursor;
-
-    /*
-     * If an operation is pending, handle it...
-     */
-    if ((finish_op
-#ifdef FEAT_VISUAL
-		|| VIsual_active
-#endif
-		) && oap->op_type != OP_NOP)
-    {
-#ifdef FEAT_VISUAL
-	oap->is_VIsual = VIsual_active;
-	if (oap->motion_force == 'V')
-	    oap->motion_type = MLINE;
-	else if (oap->motion_force == 'v')
-	{
-	    /* If the motion was linewise, "inclusive" will not have been set.
-	     * Use "exclusive" to be consistent.  Makes "dvj" work nice. */
-	    if (oap->motion_type == MLINE)
-		oap->inclusive = FALSE;
-	    /* If the motion already was characterwise, toggle "inclusive" */
-	    else if (oap->motion_type == MCHAR)
-		oap->inclusive = !oap->inclusive;
-	    oap->motion_type = MCHAR;
-	}
-	else if (oap->motion_force == Ctrl_V)
-	{
-	    /* Change line- or characterwise motion into Visual block mode. */
-	    VIsual_active = TRUE;
-	    VIsual = oap->start;
-	    VIsual_mode = Ctrl_V;
-	    VIsual_select = FALSE;
-	    VIsual_reselect = FALSE;
-	}
-#endif
-
-	/* only redo yank when 'y' flag is in 'cpoptions' */
-	/* never redo "zf" (define fold) */
-	if ((vim_strchr(p_cpo, CPO_YANK) != NULL || oap->op_type != OP_YANK)
-#ifdef FEAT_VISUAL
-		&& (!VIsual_active || oap->motion_force)
-#endif
-#ifdef FEAT_FOLDING
-		&& oap->op_type != OP_FOLD
-		&& oap->op_type != OP_FOLDOPEN
-		&& oap->op_type != OP_FOLDOPENREC
-		&& oap->op_type != OP_FOLDCLOSE
-		&& oap->op_type != OP_FOLDCLOSEREC
-		&& oap->op_type != OP_FOLDDEL
-		&& oap->op_type != OP_FOLDDELREC
-#endif
-		)
-	{
-	    prep_redo(oap->regname, cap->count0,
-		    get_op_char(oap->op_type), get_extra_op_char(oap->op_type),
-		    oap->motion_force, cap->cmdchar, cap->nchar);
-	    if (cap->cmdchar == '/' || cap->cmdchar == '?') /* was a search */
-	    {
-		/*
-		 * If 'cpoptions' does not contain 'r', insert the search
-		 * pattern to really repeat the same command.
-		 */
-		if (vim_strchr(p_cpo, CPO_REDO) == NULL)
-		    AppendToRedobuffLit(cap->searchbuf);
-		AppendToRedobuff(NL_STR);
-	    }
-	    else if (cap->cmdchar == ':')
-	    {
-		/* do_cmdline() has stored the first typed line in
-		 * "repeat_cmdline".  When several lines are typed repeating
-		 * won't be possible. */
-		if (repeat_cmdline == NULL)
-		    ResetRedobuff();
-		else
-		{
-		    AppendToRedobuffLit(repeat_cmdline);
-		    AppendToRedobuff(NL_STR);
-		    vim_free(repeat_cmdline);
-		    repeat_cmdline = NULL;
-		}
-	    }
-	}
-
-#ifdef FEAT_VISUAL
-	if (redo_VIsual_busy)
-	{
-	    oap->start = curwin->w_cursor;
-	    curwin->w_cursor.lnum += redo_VIsual_line_count - 1;
-	    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
-		curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
-	    VIsual_mode = redo_VIsual_mode;
-	    if (VIsual_mode == 'v')
-	    {
-		if (redo_VIsual_line_count <= 1)
-		    curwin->w_cursor.col += redo_VIsual_col - 1;
-		else
-		    curwin->w_cursor.col = redo_VIsual_col;
-	    }
-	    if (redo_VIsual_col == MAXCOL)
-	    {
-		curwin->w_curswant = MAXCOL;
-		coladvance((colnr_T)MAXCOL);
-	    }
-	    cap->count0 = redo_VIsual_count;
-	    if (redo_VIsual_count != 0)
-		cap->count1 = redo_VIsual_count;
-	    else
-		cap->count1 = 1;
-	}
-	else if (VIsual_active)
-	{
-	    /* Save the current VIsual area for '< and '> marks, and "gv" */
-	    curbuf->b_visual_start = VIsual;
-	    curbuf->b_visual_end = curwin->w_cursor;
-	    curbuf->b_visual_mode = VIsual_mode;
-# ifdef FEAT_EVAL
-	    curbuf->b_visual_mode_eval = VIsual_mode;
-# endif
-	    curbuf->b_visual_curswant = curwin->w_curswant;
-
-	    /* In Select mode, a linewise selection is operated upon like a
-	     * characterwise selection. */
-	    if (VIsual_select && VIsual_mode == 'V')
-	    {
-		if (lt(VIsual, curwin->w_cursor))
-		{
-		    VIsual.col = 0;
-		    curwin->w_cursor.col =
-			       (colnr_T)STRLEN(ml_get(curwin->w_cursor.lnum));
-		}
-		else
-		{
-		    curwin->w_cursor.col = 0;
-		    VIsual.col = (colnr_T)STRLEN(ml_get(VIsual.lnum));
-		}
-		VIsual_mode = 'v';
-	    }
-	    /* If 'selection' is "exclusive", backup one character for
-	     * charwise selections. */
-	    else if (VIsual_mode == 'v')
-	    {
-# ifdef FEAT_VIRTUALEDIT
-		include_line_break =
-# endif
-		    unadjust_for_sel();
-	    }
-
-	    oap->start = VIsual;
-	    if (VIsual_mode == 'V')
-		oap->start.col = 0;
-	}
-#endif /* FEAT_VISUAL */
-
-	/*
-	 * Set oap->start to the first position of the operated text, oap->end
-	 * to the end of the operated text.  w_cursor is equal to oap->start.
-	 */
-	if (lt(oap->start, curwin->w_cursor))
-	{
-#ifdef FEAT_FOLDING
-	    /* Include folded lines completely. */
-	    if (!VIsual_active)
-	    {
-		if (hasFolding(oap->start.lnum, &oap->start.lnum, NULL))
-		    oap->start.col = 0;
-		if (hasFolding(curwin->w_cursor.lnum, NULL,
-						      &curwin->w_cursor.lnum))
-		    curwin->w_cursor.col = (colnr_T)STRLEN(ml_get_curline());
-	    }
-#endif
-	    oap->end = curwin->w_cursor;
-	    curwin->w_cursor = oap->start;
-
-	    /* w_virtcol may have been updated; if the cursor goes back to its
-	     * previous position w_virtcol becomes invalid and isn't updated
-	     * automatically. */
-	    curwin->w_valid &= ~VALID_VIRTCOL;
-	}
-	else
-	{
-#ifdef FEAT_FOLDING
-	    /* Include folded lines completely. */
-	    if (!VIsual_active && oap->motion_type == MLINE)
-	    {
-		if (hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum,
-									NULL))
-		    curwin->w_cursor.col = 0;
-		if (hasFolding(oap->start.lnum, NULL, &oap->start.lnum))
-		    oap->start.col = (colnr_T)STRLEN(ml_get(oap->start.lnum));
-	    }
-#endif
-	    oap->end = oap->start;
-	    oap->start = curwin->w_cursor;
-	}
-
-	oap->line_count = oap->end.lnum - oap->start.lnum + 1;
-
-#ifdef FEAT_VIRTUALEDIT
-	/* Set "virtual_op" before resetting VIsual_active. */
-	virtual_op = virtual_active();
-#endif
-
-#ifdef FEAT_VISUAL
-	if (VIsual_active || redo_VIsual_busy)
-	{
-	    if (VIsual_mode == Ctrl_V)	/* block mode */
-	    {
-		colnr_T	    start, end;
-
-		oap->block_mode = TRUE;
-
-		getvvcol(curwin, &(oap->start),
-				      &oap->start_vcol, NULL, &oap->end_vcol);
-		if (!redo_VIsual_busy)
-		{
-		    getvvcol(curwin, &(oap->end), &start, NULL, &end);
-
-		    if (start < oap->start_vcol)
-			oap->start_vcol = start;
-		    if (end > oap->end_vcol)
-		    {
-			if (*p_sel == 'e' && start >= 1
-						&& start - 1 >= oap->end_vcol)
-			    oap->end_vcol = start - 1;
-			else
-			    oap->end_vcol = end;
-		    }
-		}
-
-		/* if '$' was used, get oap->end_vcol from longest line */
-		if (curwin->w_curswant == MAXCOL)
-		{
-		    curwin->w_cursor.col = MAXCOL;
-		    oap->end_vcol = 0;
-		    for (curwin->w_cursor.lnum = oap->start.lnum;
-			    curwin->w_cursor.lnum <= oap->end.lnum;
-						      ++curwin->w_cursor.lnum)
-		    {
-			getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &end);
-			if (end > oap->end_vcol)
-			    oap->end_vcol = end;
-		    }
-		}
-		else if (redo_VIsual_busy)
-		    oap->end_vcol = oap->start_vcol + redo_VIsual_col - 1;
-		/*
-		 * Correct oap->end.col and oap->start.col to be the
-		 * upper-left and lower-right corner of the block area.
-		 *
-		 * (Actually, this does convert column positions into character
-		 * positions)
-		 */
-		curwin->w_cursor.lnum = oap->end.lnum;
-		coladvance(oap->end_vcol);
-		oap->end = curwin->w_cursor;
-
-		curwin->w_cursor = oap->start;
-		coladvance(oap->start_vcol);
-		oap->start = curwin->w_cursor;
-	    }
-
-	    if (!redo_VIsual_busy && !gui_yank)
-	    {
-		/*
-		 * Prepare to reselect and redo Visual: this is based on the
-		 * size of the Visual text
-		 */
-		resel_VIsual_mode = VIsual_mode;
-		if (curwin->w_curswant == MAXCOL)
-		    resel_VIsual_col = MAXCOL;
-		else if (VIsual_mode == Ctrl_V)
-		    resel_VIsual_col = oap->end_vcol - oap->start_vcol + 1;
-		else if (oap->line_count > 1)
-		    resel_VIsual_col = oap->end.col;
-		else
-		    resel_VIsual_col = oap->end.col - oap->start.col + 1;
-		resel_VIsual_line_count = oap->line_count;
-	    }
-
-	    /* can't redo yank (unless 'y' is in 'cpoptions') and ":" */
-	    if ((vim_strchr(p_cpo, CPO_YANK) != NULL || oap->op_type != OP_YANK)
-		    && oap->op_type != OP_COLON
-#ifdef FEAT_FOLDING
-		    && oap->op_type != OP_FOLD
-		    && oap->op_type != OP_FOLDOPEN
-		    && oap->op_type != OP_FOLDOPENREC
-		    && oap->op_type != OP_FOLDCLOSE
-		    && oap->op_type != OP_FOLDCLOSEREC
-		    && oap->op_type != OP_FOLDDEL
-		    && oap->op_type != OP_FOLDDELREC
-#endif
-		    && oap->motion_force == NUL
-		    )
-	    {
-		/* Prepare for redoing.  Only use the nchar field for "r",
-		 * otherwise it might be the second char of the operator. */
-		prep_redo(oap->regname, 0L, NUL, 'v',
-				get_op_char(oap->op_type),
-				get_extra_op_char(oap->op_type),
-				oap->op_type == OP_REPLACE ? cap->nchar : NUL);
-		if (!redo_VIsual_busy)
-		{
-		    redo_VIsual_mode = resel_VIsual_mode;
-		    redo_VIsual_col = resel_VIsual_col;
-		    redo_VIsual_line_count = resel_VIsual_line_count;
-		    redo_VIsual_count = cap->count0;
-		}
-	    }
-
-	    /*
-	     * oap->inclusive defaults to TRUE.
-	     * If oap->end is on a NUL (empty line) oap->inclusive becomes
-	     * FALSE.  This makes "d}P" and "v}dP" work the same.
-	     */
-	    if (oap->motion_force == NUL || oap->motion_type == MLINE)
-		oap->inclusive = TRUE;
-	    if (VIsual_mode == 'V')
-		oap->motion_type = MLINE;
-	    else
-	    {
-		oap->motion_type = MCHAR;
-		if (VIsual_mode != Ctrl_V && *ml_get_pos(&(oap->end)) == NUL
-# ifdef FEAT_VIRTUALEDIT
-			&& (include_line_break || !virtual_op)
-# endif
-			)
-		{
-		    oap->inclusive = FALSE;
-		    /* Try to include the newline, unless it's an operator
-		     * that works on lines only */
-		    if (*p_sel != 'o'
-			    && !op_on_lines(oap->op_type)
-			    && oap->end.lnum < curbuf->b_ml.ml_line_count)
-		    {
-			++oap->end.lnum;
-			oap->end.col = 0;
-# ifdef FEAT_VIRTUALEDIT
-			oap->end.coladd = 0;
-# endif
-			++oap->line_count;
-		    }
-		}
-	    }
-
-	    redo_VIsual_busy = FALSE;
-	    /*
-	     * Switch Visual off now, so screen updating does
-	     * not show inverted text when the screen is redrawn.
-	     * With OP_YANK and sometimes with OP_COLON and OP_FILTER there is
-	     * no screen redraw, so it is done here to remove the inverted
-	     * part.
-	     */
-	    if (!gui_yank)
-	    {
-		VIsual_active = FALSE;
-# ifdef FEAT_MOUSE
-		setmouse();
-		mouse_dragging = 0;
-# endif
-		if (p_smd)
-		    clear_cmdline = TRUE;   /* unshow visual mode later */
-#ifdef FEAT_CMDL_INFO
-		else
-		    clear_showcmd();
-#endif
-		if ((oap->op_type == OP_YANK
-			    || oap->op_type == OP_COLON
-			    || oap->op_type == OP_FILTER)
-			&& oap->motion_force == NUL)
-		    redraw_curbuf_later(INVERTED);
-	    }
-	}
-#endif
-
-#ifdef FEAT_MBYTE
-	/* Include the trailing byte of a multi-byte char. */
-	if (has_mbyte && oap->inclusive)
-	{
-	    int		l;
-
-	    l = (*mb_ptr2len_check)(ml_get_pos(&oap->end));
-	    if (l > 1)
-		oap->end.col += l - 1;
-	}
-#endif
-	curwin->w_set_curswant = TRUE;
-
-	/*
-	 * oap->empty is set when start and end are the same.  The inclusive
-	 * flag affects this too, unless yanking and the end is on a NUL.
-	 */
-	oap->empty = (oap->motion_type == MCHAR
-		    && (!oap->inclusive
-			|| (oap->op_type == OP_YANK
-			    && gchar_pos(&oap->end) == NUL))
-		    && equalpos(oap->start, oap->end)
-#ifdef FEAT_VIRTUALEDIT
-		    && !(virtual_op && oap->start.coladd != oap->end.coladd)
-#endif
-		    );
-	/*
-	 * For delete, change and yank, it's an error to operate on an
-	 * empty region, when 'E' included in 'cpoptions' (Vi compatible).
-	 */
-	empty_region_error = (oap->empty
-				&& vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);
-
-#ifdef FEAT_VISUAL
-	/* Force a redraw when operating on an empty Visual region, when
-	 * 'modifiable is off or creating a fold. */
-	if (oap->is_VIsual && (oap->empty || !curbuf->b_p_ma
-# ifdef FEAT_FOLDING
-		    || oap->op_type == OP_FOLD
-# endif
-		    ))
-	    redraw_curbuf_later(INVERTED);
-#endif
-
-	/*
-	 * If the end of an operator is in column one while oap->motion_type
-	 * is MCHAR and oap->inclusive is FALSE, we put op_end after the last
-	 * character in the previous line. If op_start is on or before the
-	 * first non-blank in the line, the operator becomes linewise
-	 * (strange, but that's the way vi does it).
-	 */
-	if (	   oap->motion_type == MCHAR
-		&& oap->inclusive == FALSE
-		&& !(cap->retval & CA_NO_ADJ_OP_END)
-		&& oap->end.col == 0
-#ifdef FEAT_VISUAL
-		&& (!oap->is_VIsual || *p_sel == 'o')
-#endif
-		&& oap->line_count > 1)
-	{
-	    oap->end_adjusted = TRUE;	    /* remember that we did this */
-	    --oap->line_count;
-	    --oap->end.lnum;
-	    if (inindent(0))
-		oap->motion_type = MLINE;
-	    else
-	    {
-		oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));
-		if (oap->end.col)
-		{
-		    --oap->end.col;
-		    oap->inclusive = TRUE;
-		}
-	    }
-	}
-	else
-	    oap->end_adjusted = FALSE;
-
-	switch (oap->op_type)
-	{
-	case OP_LSHIFT:
-	case OP_RSHIFT:
-	    op_shift(oap, TRUE,
-#ifdef FEAT_VISUAL
-		    oap->is_VIsual ? (int)cap->count1 :
-#endif
-		    1);
-	    auto_format(FALSE, TRUE);
-	    break;
-
-	case OP_JOIN_NS:
-	case OP_JOIN:
-	    if (oap->line_count < 2)
-		oap->line_count = 2;
-	    if (curwin->w_cursor.lnum + oap->line_count - 1 >
-						   curbuf->b_ml.ml_line_count)
-		beep_flush();
-	    else
-	    {
-		do_do_join(oap->line_count, oap->op_type == OP_JOIN);
-		auto_format(FALSE, TRUE);
-	    }
-	    break;
-
-	case OP_DELETE:
-#ifdef FEAT_VISUAL
-	    VIsual_reselect = FALSE;	    /* don't reselect now */
-#endif
-	    if (empty_region_error)
-		vim_beep();
-	    else
-	    {
-		(void)op_delete(oap);
-		if (oap->motion_type == MLINE && has_format_option(FO_AUTO))
-		    u_save_cursor();	    /* cursor line wasn't saved yet */
-		auto_format(FALSE, TRUE);
-	    }
-	    break;
-
-	case OP_YANK:
-	    if (empty_region_error)
-	    {
-		if (!gui_yank)
-		    vim_beep();
-	    }
-	    else
-		(void)op_yank(oap, FALSE, !gui_yank);
-	    check_cursor_col();
-	    break;
-
-	case OP_CHANGE:
-#ifdef FEAT_VISUAL
-	    VIsual_reselect = FALSE;	    /* don't reselect now */
-#endif
-	    if (empty_region_error)
-		vim_beep();
-	    else
-	    {
-		/* This is a new edit command, not a restart.  Need to
-		 * remember it to make 'insertmode' work with mappings for
-		 * Visual mode.  But do this only once and not when typed and
-		 * 'insertmode' isn't set. */
-		if (p_im || !KeyTyped)
-		    restart_edit_save = restart_edit;
-		else
-		    restart_edit_save = 0;
-		restart_edit = 0;
-		/* Reset finish_op now, don't want it set inside edit(). */
-		finish_op = FALSE;
-		if (op_change(oap))	/* will call edit() */
-		    cap->retval |= CA_COMMAND_BUSY;
-		if (restart_edit == 0)
-		    restart_edit = restart_edit_save;
-	    }
-	    break;
-
-	case OP_FILTER:
-	    if (vim_strchr(p_cpo, CPO_FILTER) != NULL)
-		AppendToRedobuff((char_u *)"!\r");  /* use any last used !cmd */
-	    else
-		bangredo = TRUE;    /* do_bang() will put cmd in redo buffer */
-
-	case OP_INDENT:
-	case OP_COLON:
-
-#if defined(FEAT_LISP) || defined(FEAT_CINDENT)
-	    /*
-	     * If 'equalprg' is empty, do the indenting internally.
-	     */
-	    if (oap->op_type == OP_INDENT && *get_equalprg() == NUL)
-	    {
-# ifdef FEAT_LISP
-		if (curbuf->b_p_lisp)
-		{
-		    op_reindent(oap, get_lisp_indent);
-		    break;
-		}
-# endif
-# ifdef FEAT_CINDENT
-		op_reindent(oap,
-#  ifdef FEAT_EVAL
-			*curbuf->b_p_inde != NUL ? get_expr_indent :
-#  endif
-			    get_c_indent);
-		break;
-# endif
-	    }
-#endif
-
-	    op_colon(oap);
-	    break;
-
-	case OP_TILDE:
-	case OP_UPPER:
-	case OP_LOWER:
-	case OP_ROT13:
-	    if (empty_region_error)
-		vim_beep();
-	    else
-		op_tilde(oap);
-	    check_cursor_col();
-	    break;
-
-	case OP_FORMAT:
-	    if (*p_fp != NUL)
-		op_colon(oap);		/* use external command */
-	    else
-		op_format(oap, FALSE);	/* use internal function */
-	    break;
-
-	case OP_FORMAT2:
-	    op_format(oap, TRUE);	/* use internal function */
-	    break;
-
-	case OP_INSERT:
-	case OP_APPEND:
-#ifdef FEAT_VISUAL
-	    VIsual_reselect = FALSE;	/* don't reselect now */
-#endif
-#ifdef FEAT_VISUALEXTRA
-	    if (empty_region_error)
-		vim_beep();
-	    else
-	    {
-		/* This is a new edit command, not a restart.  Need to
-		 * remember it to make 'insertmode' work with mappings for
-		 * Visual mode.  But do this only once. */
-		restart_edit_save = restart_edit;
-		restart_edit = 0;
-
-		op_insert(oap, cap->count1);
-
-		/* TODO: when inserting in several lines, should format all
-		 * the lines. */
-		auto_format(FALSE, TRUE);
-
-		if (restart_edit == 0)
-		    restart_edit = restart_edit_save;
-	    }
-#else
-	    vim_beep();
-#endif
-	    break;
-
-	case OP_REPLACE:
-#ifdef FEAT_VISUAL
-	    VIsual_reselect = FALSE;	/* don't reselect now */
-#endif
-#ifdef FEAT_VISUALEXTRA
-	    if (empty_region_error)
-#endif
-		vim_beep();
-#ifdef FEAT_VISUALEXTRA
-	    else
-		op_replace(oap, cap->nchar);
-#endif
-	    break;
-
-#ifdef FEAT_FOLDING
-	case OP_FOLD:
-	    VIsual_reselect = FALSE;	/* don't reselect now */
-	    foldCreate(oap->start.lnum, oap->end.lnum);
-	    break;
-
-	case OP_FOLDOPEN:
-	case OP_FOLDOPENREC:
-	case OP_FOLDCLOSE:
-	case OP_FOLDCLOSEREC:
-	    VIsual_reselect = FALSE;	/* don't reselect now */
-	    opFoldRange(oap->start.lnum, oap->end.lnum,
-		    oap->op_type == OP_FOLDOPEN
-					    || oap->op_type == OP_FOLDOPENREC,
-		    oap->op_type == OP_FOLDOPENREC
-					  || oap->op_type == OP_FOLDCLOSEREC,
-					  oap->is_VIsual);
-	    break;
-
-	case OP_FOLDDEL:
-	case OP_FOLDDELREC:
-	    VIsual_reselect = FALSE;	/* don't reselect now */
-	    deleteFold(oap->start.lnum, oap->end.lnum,
-			       oap->op_type == OP_FOLDDELREC, oap->is_VIsual);
-	    break;
-#endif
-	default:
-	    clearopbeep(oap);
-	}
-#ifdef FEAT_VIRTUALEDIT
-	virtual_op = MAYBE;
-#endif
-	if (!gui_yank)
-	{
-	    /*
-	     * if 'sol' not set, go back to old column for some commands
-	     */
-	    if (!p_sol && oap->motion_type == MLINE && !oap->end_adjusted
-		    && (oap->op_type == OP_LSHIFT || oap->op_type == OP_RSHIFT
-						|| oap->op_type == OP_DELETE))
-		coladvance(curwin->w_curswant = old_col);
-	}
-	else
-	{
-	    curwin->w_cursor = old_cursor;
-	}
-#ifdef FEAT_VISUAL
-	oap->block_mode = FALSE;
-#endif
-	clearop(oap);
-    }
-}
-
-/*
- * Handle indent and format operators and visual mode ":".
- */
-    static void
-op_colon(oap)
-    oparg_T	*oap;
-{
-    stuffcharReadbuff(':');
-#ifdef FEAT_VISUAL
-    if (oap->is_VIsual)
-	stuffReadbuff((char_u *)"'<,'>");
-    else
-#endif
-    {
-	/*
-	 * Make the range look nice, so it can be repeated.
-	 */
-	if (oap->start.lnum == curwin->w_cursor.lnum)
-	    stuffcharReadbuff('.');
-	else
-	    stuffnumReadbuff((long)oap->start.lnum);
-	if (oap->end.lnum != oap->start.lnum)
-	{
-	    stuffcharReadbuff(',');
-	    if (oap->end.lnum == curwin->w_cursor.lnum)
-		stuffcharReadbuff('.');
-	    else if (oap->end.lnum == curbuf->b_ml.ml_line_count)
-		stuffcharReadbuff('$');
-	    else if (oap->start.lnum == curwin->w_cursor.lnum)
-	    {
-		stuffReadbuff((char_u *)".+");
-		stuffnumReadbuff((long)oap->line_count - 1);
-	    }
-	    else
-		stuffnumReadbuff((long)oap->end.lnum);
-	}
-    }
-    if (oap->op_type != OP_COLON)
-	stuffReadbuff((char_u *)"!");
-    if (oap->op_type == OP_INDENT)
-    {
-#ifndef FEAT_CINDENT
-	if (*get_equalprg() == NUL)
-	    stuffReadbuff((char_u *)"indent");
-	else
-#endif
-	    stuffReadbuff(get_equalprg());
-	stuffReadbuff((char_u *)"\n");
-    }
-    else if (oap->op_type == OP_FORMAT)
-    {
-	if (*p_fp == NUL)
-	    stuffReadbuff((char_u *)"fmt");
-	else
-	    stuffReadbuff(p_fp);
-	stuffReadbuff((char_u *)"\n");
-    }
-
-    /*
-     * do_cmdline() does the rest
-     */
-}
-
-#if defined(FEAT_MOUSE) || defined(PROTO)
-/*
- * Do the appropriate action for the current mouse click in the current mode.
- * Not used for Command-line mode.
- *
- * Normal Mode:
- * event	 modi-	position      visual	   change   action
- *		 fier	cursor			   window
- * left press	  -	yes	    end		    yes
- * left press	  C	yes	    end		    yes	    "^]" (2)
- * left press	  S	yes	    end		    yes	    "*" (2)
- * left drag	  -	yes	start if moved	    no
- * left relse	  -	yes	start if moved	    no
- * middle press	  -	yes	 if not active	    no	    put register
- * middle press	  -	yes	 if active	    no	    yank and put
- * right press	  -	yes	start or extend	    yes
- * right press	  S	yes	no change	    yes	    "#" (2)
- * right drag	  -	yes	extend		    no
- * right relse	  -	yes	extend		    no
- *
- * Insert or Replace Mode:
- * event	 modi-	position      visual	   change   action
- *		 fier	cursor			   window
- * left press	  -	yes	(cannot be active)  yes
- * left press	  C	yes	(cannot be active)  yes	    "CTRL-O^]" (2)
- * left press	  S	yes	(cannot be active)  yes	    "CTRL-O*" (2)
- * left drag	  -	yes	start or extend (1) no	    CTRL-O (1)
- * left relse	  -	yes	start or extend (1) no	    CTRL-O (1)
- * middle press	  -	no	(cannot be active)  no	    put register
- * right press	  -	yes	start or extend	    yes	    CTRL-O
- * right press	  S	yes	(cannot be active)  yes	    "CTRL-O#" (2)
- *
- * (1) only if mouse pointer moved since press
- * (2) only if click is in same buffer
- *
- * Return TRUE if start_arrow() should be called for edit mode.
- */
-    int
-do_mouse(oap, c, dir, count, fixindent)
-    oparg_T	*oap;		/* operator argument, can be NULL */
-    int		c;		/* K_LEFTMOUSE, etc */
-    int		dir;		/* Direction to 'put' if necessary */
-    long	count;
-    int		fixindent;	/* PUT_FIXINDENT if fixing indent necessary */
-{
-    static int	do_always = FALSE;	/* ignore 'mouse' setting next time */
-    static int	got_click = FALSE;	/* got a click some time back */
-
-    int		which_button;	/* MOUSE_LEFT, _MIDDLE or _RIGHT */
-    int		is_click;	/* If FALSE it's a drag or release event */
-    int		is_drag;	/* If TRUE it's a drag event */
-    int		jump_flags = 0;	/* flags for jump_to_mouse() */
-    pos_T	start_visual;
-    int		moved;		/* Has cursor moved? */
-    int		in_status_line;	/* mouse in status line */
-#ifdef FEAT_VERTSPLIT
-    int		in_sep_line;	/* mouse in vertical separator line */
-#endif
-    int		c1, c2;
-#if defined(FEAT_FOLDING)
-    pos_T	save_cursor;
-#endif
-    win_T	*old_curwin = curwin;
-#ifdef FEAT_VISUAL
-    static pos_T orig_cursor;
-    colnr_T	leftcol, rightcol;
-    pos_T	end_visual;
-    int		diff;
-    int		old_active = VIsual_active;
-    int		old_mode = VIsual_mode;
-#endif
-    int		regname;
-
-#if defined(FEAT_FOLDING)
-    save_cursor = curwin->w_cursor;
-#endif
-
-    /*
-     * When GUI is active, always recognize mouse events, otherwise:
-     * - Ignore mouse event in normal mode if 'mouse' doesn't include 'n'.
-     * - Ignore mouse event in visual mode if 'mouse' doesn't include 'v'.
-     * - For command line and insert mode 'mouse' is checked before calling
-     *	 do_mouse().
-     */
-    if (do_always)
-	do_always = FALSE;
-    else
-#ifdef FEAT_GUI
-	if (!gui.in_use)
-#endif
-	{
-#ifdef FEAT_VISUAL
-	    if (VIsual_active)
-	    {
-		if (!mouse_has(MOUSE_VISUAL))
-		    return FALSE;
-	    }
-	    else
-#endif
-		if (State == NORMAL && !mouse_has(MOUSE_NORMAL))
-		return FALSE;
-	}
-
-    which_button = get_mouse_button(KEY2TERMCAP1(c), &is_click, &is_drag);
-
-#ifdef FEAT_MOUSESHAPE
-    /* May have stopped dragging the status or separator line.  The pointer is
-     * most likely still on the status or separator line. */
-    if (!is_drag && drag_status_line)
-    {
-	drag_status_line = FALSE;
-	update_mouseshape(SHAPE_IDX_STATUS);
-    }
-# ifdef FEAT_VERTSPLIT
-    if (!is_drag && drag_sep_line)
-    {
-	drag_sep_line = FALSE;
-	update_mouseshape(SHAPE_IDX_VSEP);
-    }
-# endif
-#endif
-
-    /*
-     * Ignore drag and release events if we didn't get a click.
-     */
-    if (is_click)
-	got_click = TRUE;
-    else
-    {
-	if (!got_click)			/* didn't get click, ignore */
-	    return FALSE;
-	if (!is_drag)			/* release, reset got_click */
-	    got_click = FALSE;
-    }
-
-    /*
-     * ALT is currently ignored
-     */
-    if ((mod_mask & MOD_MASK_ALT))
-	return FALSE;
-
-    /*
-     * CTRL right mouse button does CTRL-T
-     */
-    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)
-    {
-	if (State & INSERT)
-	    stuffcharReadbuff(Ctrl_O);
-	if (count > 1)
-	    stuffnumReadbuff(count);
-	stuffcharReadbuff(Ctrl_T);
-	got_click = FALSE;		/* ignore drag&release now */
-	return FALSE;
-    }
-
-    /*
-     * CTRL only works with left mouse button
-     */
-    if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)
-	return FALSE;
-
-    /*
-     * When a modifier is down, ignore drag and release events, as well as
-     * multiple clicks and the middle mouse button.
-     * Accept shift-leftmouse drags when 'mousemodel' is "popup.*".
-     */
-    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT))
-	    && (!is_click
-		|| (mod_mask & MOD_MASK_MULTI_CLICK)
-		|| which_button == MOUSE_MIDDLE)
-	    && !((mod_mask & MOD_MASK_SHIFT)
-		&& mouse_model_popup()
-		&& which_button == MOUSE_LEFT)
-	    )
-	return FALSE;
-
-    /*
-     * If the button press was used as the movement command for an operator
-     * (eg "d<MOUSE>"), or it is the middle button that is held down, ignore
-     * drag/release events.
-     */
-    if (!is_click && which_button == MOUSE_MIDDLE)
-	return FALSE;
-
-    if (oap != NULL)
-	regname = oap->regname;
-    else
-	regname = 0;
-
-    /*
-     * Middle mouse button does a 'put' of the selected text
-     */
-    if (which_button == MOUSE_MIDDLE)
-    {
-	if (State == NORMAL)
-	{
-	    /*
-	     * If an operator was pending, we don't know what the user wanted
-	     * to do. Go back to normal mode: Clear the operator and beep().
-	     */
-	    if (oap != NULL && oap->op_type != OP_NOP)
-	    {
-		clearopbeep(oap);
-		return FALSE;
-	    }
-
-#ifdef FEAT_VISUAL
-	    /*
-	     * If visual was active, yank the highlighted text and put it
-	     * before the mouse pointer position.
-	     */
-	    if (VIsual_active)
-	    {
-		stuffcharReadbuff('y');
-		stuffcharReadbuff(K_MIDDLEMOUSE);
-		do_always = TRUE;	/* ignore 'mouse' setting next time */
-		return FALSE;
-	    }
-#endif
-	    /*
-	     * The rest is below jump_to_mouse()
-	     */
-	}
-
-	else if ((State & INSERT) == 0)
-	    return FALSE;
-
-	/*
-	 * Middle click in insert mode doesn't move the mouse, just insert the
-	 * contents of a register.  '.' register is special, can't insert that
-	 * with do_put().
-	 * Also paste at the cursor if the current mode isn't in 'mouse' (only
-	 * happens for the GUI).
-	 */
-	if ((State & INSERT) || !mouse_has(MOUSE_NORMAL))
-	{
-	    if (regname == '.')
-		insert_reg(regname, TRUE);
-	    else
-	    {
-#ifdef FEAT_CLIPBOARD
-		if (clip_star.available && regname == 0)
-		    regname = '*';
-#endif
-		if ((State & REPLACE_FLAG) && !yank_register_mline(regname))
-		    insert_reg(regname, TRUE);
-		else
-		{
-		    do_put(regname, BACKWARD, 1L, fixindent | PUT_CURSEND);
-
-		    /* Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r */
-		    AppendCharToRedobuff(Ctrl_R);
-		    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);
-		    AppendCharToRedobuff(regname == 0 ? '"' : regname);
-		}
-	    }
-	    return FALSE;
-	}
-    }
-
-    /* When dragging or button-up stay in the same window. */
-    if (!is_click)
-	jump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;
-
-    start_visual.lnum = 0;
-
-    /*
-     * When 'mousemodel' is "popup" or "popup_setpos", translate mouse events:
-     * right button up   -> pop-up menu
-     * shift-left button -> right button
-     */
-    if (mouse_model_popup())
-    {
-	if (which_button == MOUSE_RIGHT
-			    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))
-	{
-	    /*
-	     * NOTE: Ignore right button down and drag mouse events.
-	     * Windows only shows the popup menu on the button up event.
-	     */
-#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON)
-	    if (!is_click)
-		return FALSE;
-#endif
-#if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MSWIN)
-	    if (is_click || is_drag)
-		return FALSE;
-#endif
-#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \
-	    || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MSWIN) \
-	    || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_PHOTON)
-	    if (gui.in_use)
-	    {
-		jump_flags = 0;
-		if (STRCMP(p_mousem, "popup_setpos") == 0)
-		{
-		    /* First set the cursor position before showing the popup
-		     * menu. */
-#ifdef FEAT_VISUAL
-		    if (VIsual_active)
-		    {
-			pos_T    m_pos;
-
-			/*
-			 * set MOUSE_MAY_STOP_VIS if we are outside the
-			 * selection or the current window (might have false
-			 * negative here)
-			 */
-			if (mouse_row < W_WINROW(curwin)
-			     || mouse_row
-				      > (W_WINROW(curwin) + curwin->w_height))
-			    jump_flags = MOUSE_MAY_STOP_VIS;
-			else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)
-			    jump_flags = MOUSE_MAY_STOP_VIS;
-			else
-			{
-			    if ((lt(curwin->w_cursor, VIsual)
-					&& (lt(m_pos, curwin->w_cursor)
-					    || lt(VIsual, m_pos)))
-				    || (lt(VIsual, curwin->w_cursor)
-					&& (lt(m_pos, VIsual)
-					    || lt(curwin->w_cursor, m_pos))))
-			    {
-				jump_flags = MOUSE_MAY_STOP_VIS;
-			    }
-			    else if (VIsual_mode == Ctrl_V)
-			    {
-				getvcols(curwin, &curwin->w_cursor, &VIsual,
-							 &leftcol, &rightcol);
-				getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);
-				if (m_pos.col < leftcol || m_pos.col > rightcol)
-				    jump_flags = MOUSE_MAY_STOP_VIS;
-			    }
-			}
-		    }
-		    else
-			jump_flags = MOUSE_MAY_STOP_VIS;
-#endif
-		}
-		if (jump_flags)
-		{
-		    jump_flags = jump_to_mouse(jump_flags, NULL, which_button);
-		    update_curbuf(
-#ifdef FEAT_VISUAL
-			    VIsual_active ? INVERTED :
-#endif
-			    VALID);
-		    setcursor();
-		    out_flush();    /* Update before showing popup menu */
-		}
-# ifdef FEAT_MENU
-		gui_show_popupmenu();
-# endif
-		return (jump_flags & CURSOR_MOVED) != 0;
-	    }
-	    else
-		return FALSE;
-#else
-	    return FALSE;
-#endif
-	}
-	if (which_button == MOUSE_LEFT && (mod_mask & MOD_MASK_SHIFT))
-	{
-	    which_button = MOUSE_RIGHT;
-	    mod_mask &= ~MOD_MASK_SHIFT;
-	}
-    }
-
-#ifdef FEAT_VISUAL
-    if ((State & (NORMAL | INSERT))
-			    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))
-    {
-	if (which_button == MOUSE_LEFT)
-	{
-	    if (is_click)
-	    {
-		/* stop Visual mode for a left click in a window, but not when
-		 * on a status line */
-		if (VIsual_active)
-		    jump_flags |= MOUSE_MAY_STOP_VIS;
-	    }
-	    else if (mouse_has(MOUSE_VISUAL))
-		jump_flags |= MOUSE_MAY_VIS;
-	}
-	else if (which_button == MOUSE_RIGHT)
-	{
-	    if (is_click && VIsual_active)
-	    {
-		/*
-		 * Remember the start and end of visual before moving the
-		 * cursor.
-		 */
-		if (lt(curwin->w_cursor, VIsual))
-		{
-		    start_visual = curwin->w_cursor;
-		    end_visual = VIsual;
-		}
-		else
-		{
-		    start_visual = VIsual;
-		    end_visual = curwin->w_cursor;
-		}
-	    }
-	    jump_flags |= MOUSE_FOCUS;
-	    if (mouse_has(MOUSE_VISUAL))
-		jump_flags |= MOUSE_MAY_VIS;
-	}
-    }
-#endif
-
-    /*
-     * If an operator is pending, ignore all drags and releases until the
-     * next mouse click.
-     */
-    if (!is_drag && oap != NULL && oap->op_type != OP_NOP)
-    {
-	got_click = FALSE;
-	oap->motion_type = MCHAR;
-    }
-
-    /* When releasing the button let jump_to_mouse() know. */
-    if (!is_click && !is_drag)
-	jump_flags |= MOUSE_RELEASED;
-
-    /*
-     * JUMP!
-     */
-    jump_flags = jump_to_mouse(jump_flags,
-			oap == NULL ? NULL : &(oap->inclusive), which_button);
-    moved = (jump_flags & CURSOR_MOVED);
-    in_status_line = (jump_flags & IN_STATUS_LINE);
-#ifdef FEAT_VERTSPLIT
-    in_sep_line = (jump_flags & IN_SEP_LINE);
-#endif
-
-#ifdef FEAT_NETBEANS_INTG
-    if (usingNetbeans && isNetbeansBuffer(curbuf)
-			    && !(jump_flags & (IN_STATUS_LINE | IN_SEP_LINE)))
-    {
-	int key = KEY2TERMCAP1(c);
-
-	if (key == (int)KE_LEFTRELEASE || key == (int)KE_MIDDLERELEASE
-					       || key == (int)KE_RIGHTRELEASE)
-	    netbeans_button_release(which_button);
-    }
-#endif
-
-    /* When jumping to another window, clear a pending operator.  That's a bit
-     * friendlier than beeping and not jumping to that window. */
-    if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)
-	clearop(oap);
-
-#ifdef FEAT_FOLDING
-    if (mod_mask == 0
-	    && !is_drag
-	    && (jump_flags & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))
-	    && which_button == MOUSE_LEFT)
-    {
-	/* open or close a fold at this line */
-	if (jump_flags & MOUSE_FOLD_OPEN)
-	    openFold(curwin->w_cursor.lnum, 1L);
-	else
-	    closeFold(curwin->w_cursor.lnum, 1L);
-	/* don't move the cursor if still in the same window */
-	if (curwin == old_curwin)
-	    curwin->w_cursor = save_cursor;
-    }
-#endif
-
-#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)
-    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)
-    {
-	clip_modeless(which_button, is_click, is_drag);
-	return FALSE;
-    }
-#endif
-
-#ifdef FEAT_VISUAL
-    /* Set global flag that we are extending the Visual area with mouse
-     * dragging; temporarily mimimize 'scrolloff'. */
-    if (VIsual_active && is_drag && p_so)
-    {
-	/* In the very first line, allow scrolling one line */
-	if (mouse_row == 0)
-	    mouse_dragging = 2;
-	else
-	    mouse_dragging = 1;
-    }
-
-    /* When dragging the mouse above the window, scroll down. */
-    if (is_drag && mouse_row < 0 && !in_status_line)
-    {
-	scroll_redraw(FALSE, 1L);
-	mouse_row = 0;
-    }
-
-    if (start_visual.lnum)		/* right click in visual mode */
-    {
-	/*
-	 * In Visual-block mode, divide the area in four, pick up the corner
-	 * that is in the quarter that the cursor is in.
-	 */
-	if (VIsual_mode == Ctrl_V)
-	{
-	    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);
-	    if (curwin->w_curswant > (leftcol + rightcol) / 2)
-		end_visual.col = leftcol;
-	    else
-		end_visual.col = rightcol;
-	    if (curwin->w_cursor.lnum <
-				    (start_visual.lnum + end_visual.lnum) / 2)
-		end_visual.lnum = end_visual.lnum;
-	    else
-		end_visual.lnum = start_visual.lnum;
-
-	    /* move VIsual to the right column */
-	    start_visual = curwin->w_cursor;	    /* save the cursor pos */
-	    curwin->w_cursor = end_visual;
-	    coladvance(end_visual.col);
-	    VIsual = curwin->w_cursor;
-	    curwin->w_cursor = start_visual;	    /* restore the cursor */
-	}
-	else
-	{
-	    /*
-	     * If the click is before the start of visual, change the start.
-	     * If the click is after the end of visual, change the end.  If
-	     * the click is inside the visual, change the closest side.
-	     */
-	    if (lt(curwin->w_cursor, start_visual))
-		VIsual = end_visual;
-	    else if (lt(end_visual, curwin->w_cursor))
-		VIsual = start_visual;
-	    else
-	    {
-		/* In the same line, compare column number */
-		if (end_visual.lnum == start_visual.lnum)
-		{
-		    if (curwin->w_cursor.col - start_visual.col >
-				    end_visual.col - curwin->w_cursor.col)
-			VIsual = start_visual;
-		    else
-			VIsual = end_visual;
-		}
-
-		/* In different lines, compare line number */
-		else
-		{
-		    diff = (curwin->w_cursor.lnum - start_visual.lnum) -
-				(end_visual.lnum - curwin->w_cursor.lnum);
-
-		    if (diff > 0)		/* closest to end */
-			VIsual = start_visual;
-		    else if (diff < 0)	/* closest to start */
-			VIsual = end_visual;
-		    else			/* in the middle line */
-		    {
-			if (curwin->w_cursor.col <
-					(start_visual.col + end_visual.col) / 2)
-			    VIsual = end_visual;
-			else
-			    VIsual = start_visual;
-		    }
-		}
-	    }
-	}
-    }
-    /*
-     * If Visual mode started in insert mode, execute "CTRL-O"
-     */
-    else if ((State & INSERT) && VIsual_active)
-	stuffcharReadbuff(Ctrl_O);
-#endif
-
-    /*
-     * Middle mouse click: Put text before cursor.
-     */
-    if (which_button == MOUSE_MIDDLE)
-    {
-#ifdef FEAT_CLIPBOARD
-	if (clip_star.available && regname == 0)
-	    regname = '*';
-#endif
-	if (yank_register_mline(regname))
-	{
-	    if (mouse_past_bottom)
-		dir = FORWARD;
-	}
-	else if (mouse_past_eol)
-	    dir = FORWARD;
-
-	if (fixindent)
-	{
-	    c1 = (dir == BACKWARD) ? '[' : ']';
-	    c2 = 'p';
-	}
-	else
-	{
-	    c1 = (dir == FORWARD) ? 'p' : 'P';
-	    c2 = NUL;
-	}
-	prep_redo(regname, count, NUL, c1, NUL, c2, NUL);
-
-	/*
-	 * Remember where the paste started, so in edit() Insstart can be set
-	 * to this position
-	 */
-	if (restart_edit != 0)
-	    where_paste_started = curwin->w_cursor;
-	do_put(regname, dir, count, fixindent | PUT_CURSEND);
-    }
-
-#if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-    /*
-     * Ctrl-Mouse click or double click in a quickfix window jumps to the
-     * error under the mouse pointer.
-     */
-    else if (((mod_mask & MOD_MASK_CTRL)
-		|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)
-	    && bt_quickfix(curbuf))
-    {
-	if (State & INSERT)
-	    stuffcharReadbuff(Ctrl_O);
-	stuffReadbuff((char_u *)":.cc\n");
-	got_click = FALSE;		/* ignore drag&release now */
-    }
-#endif
-
-    /*
-     * Ctrl-Mouse click (or double click in a help window) jumps to the tag
-     * under the mouse pointer.
-     */
-    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help
-		     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))
-    {
-	if (State & INSERT)
-	    stuffcharReadbuff(Ctrl_O);
-	stuffcharReadbuff(Ctrl_RSB);
-	got_click = FALSE;		/* ignore drag&release now */
-    }
-
-    /*
-     * Shift-Mouse click searches for the next occurrence of the word under
-     * the mouse pointer
-     */
-    else if ((mod_mask & MOD_MASK_SHIFT))
-    {
-	if (State & INSERT
-#ifdef FEAT_VISUAL
-		|| (VIsual_active && VIsual_select)
-#endif
-		)
-	    stuffcharReadbuff(Ctrl_O);
-	if (which_button == MOUSE_LEFT)
-	    stuffcharReadbuff('*');
-	else	/* MOUSE_RIGHT */
-	    stuffcharReadbuff('#');
-    }
-
-    /* Handle double clicks, unless on status line */
-    else if (in_status_line)
-    {
-#ifdef FEAT_MOUSESHAPE
-	if ((is_drag || is_click) && !drag_status_line)
-	{
-	    drag_status_line = TRUE;
-	    update_mouseshape(-1);
-	}
-#endif
-    }
-#ifdef FEAT_VERTSPLIT
-    else if (in_sep_line)
-    {
-# ifdef FEAT_MOUSESHAPE
-	if ((is_drag || is_click) && !drag_sep_line)
-	{
-	    drag_sep_line = TRUE;
-	    update_mouseshape(-1);
-	}
-# endif
-    }
-#endif
-#ifdef FEAT_VISUAL
-    else if ((mod_mask & MOD_MASK_MULTI_CLICK) && (State & (NORMAL | INSERT))
-	     && mouse_has(MOUSE_VISUAL))
-    {
-	if (is_click || !VIsual_active)
-	{
-	    if (VIsual_active)
-		orig_cursor = VIsual;
-	    else
-	    {
-		check_visual_highlight();
-		VIsual = curwin->w_cursor;
-		orig_cursor = VIsual;
-		VIsual_active = TRUE;
-		VIsual_reselect = TRUE;
-		/* start Select mode if 'selectmode' contains "mouse" */
-		may_start_select('o');
-		setmouse();
-	    }
-	    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)
-		VIsual_mode = 'v';
-	    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)
-		VIsual_mode = 'V';
-	    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)
-		VIsual_mode = Ctrl_V;
-#ifdef FEAT_CLIPBOARD
-	    /* Make sure the clipboard gets updated.  Needed because start and
-	     * end may still be the same, and the selection needs to be owned */
-	    clip_star.vmode = NUL;
-#endif
-	}
-	/*
-	 * A double click selects a word or a block.
-	 */
-	if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)
-	{
-	    pos_T	*pos = NULL;
-
-	    if (is_click)
-	    {
-		/* If the character under the cursor (skipping white space) is
-		 * not a word character, try finding a match and select a (),
-		 * {}, [], #if/#endif, etc. block. */
-		end_visual = curwin->w_cursor;
-		while (vim_iswhite(gchar_pos(&end_visual)))
-		    inc(&end_visual);
-		if (oap != NULL)
-		    oap->motion_type = MCHAR;
-		if (oap != NULL
-			&& VIsual_mode == 'v'
-			&& !vim_iswordc(gchar_pos(&end_visual))
-			&& equalpos(curwin->w_cursor, VIsual)
-			&& (pos = findmatch(oap, NUL)) != NULL)
-		{
-		    curwin->w_cursor = *pos;
-		    if (oap->motion_type == MLINE)
-			VIsual_mode = 'V';
-		    else if (*p_sel == 'e')
-		    {
-			if (lt(curwin->w_cursor, VIsual))
-			    ++VIsual.col;
-			else
-			    ++curwin->w_cursor.col;
-		    }
-		}
-	    }
-
-	    if (pos == NULL && (is_click || is_drag))
-	    {
-		/* When not found a match or when dragging: extend to include
-		 * a word. */
-		if (lt(curwin->w_cursor, orig_cursor))
-		{
-		    find_start_of_word(&curwin->w_cursor);
-		    find_end_of_word(&VIsual);
-		}
-		else
-		{
-		    find_start_of_word(&VIsual);
-		    if (*p_sel == 'e' && *ml_get_cursor() != NUL)
-#ifdef FEAT_MBYTE
-			curwin->w_cursor.col +=
-					 (*mb_ptr2len_check)(ml_get_cursor());
-#else
-			++curwin->w_cursor.col;
-#endif
-		    find_end_of_word(&curwin->w_cursor);
-		}
-	    }
-	    curwin->w_set_curswant = TRUE;
-	}
-	if (is_click)
-	    redraw_curbuf_later(INVERTED);	/* update the inversion */
-    }
-    else if (VIsual_active && !old_active)
-	VIsual_mode = 'v';
-
-    /* If Visual mode changed show it later. */
-    if (p_smd && (VIsual_active != old_active || VIsual_mode != old_mode))
-	redraw_cmdline = TRUE;
-#endif
-
-    return moved;
-}
-
-#ifdef FEAT_VISUAL
-/*
- * Move "pos" back to the start of the word it's in.
- */
-    static void
-find_start_of_word(pos)
-    pos_T	*pos;
-{
-    char_u	*line;
-    int		cclass;
-    int		col;
-
-    line = ml_get(pos->lnum);
-    cclass = get_mouse_class(line + pos->col);
-
-    while (pos->col > 0)
-    {
-	col = pos->col - 1;
-#ifdef FEAT_MBYTE
-	col -= (*mb_head_off)(line, line + col);
-#endif
-	if (get_mouse_class(line + col) != cclass)
-	    break;
-	pos->col = col;
-    }
-}
-
-/*
- * Move "pos" forward to the end of the word it's in.
- * When 'selection' is "exclusive", the position is just after the word.
- */
-    static void
-find_end_of_word(pos)
-    pos_T	*pos;
-{
-    char_u	*line;
-    int		cclass;
-    int		col;
-
-    line = ml_get(pos->lnum);
-    if (*p_sel == 'e' && pos->col > 0)
-    {
-	--pos->col;
-#ifdef FEAT_MBYTE
-	pos->col -= (*mb_head_off)(line, line + pos->col);
-#endif
-    }
-    cclass = get_mouse_class(line + pos->col);
-    while (line[pos->col] != NUL)
-    {
-#ifdef FEAT_MBYTE
-	col = pos->col + (*mb_ptr2len_check)(line + pos->col);
-#else
-	col = pos->col + 1;
-#endif
-	if (get_mouse_class(line + col) != cclass)
-	{
-	    if (*p_sel == 'e')
-		pos->col = col;
-	    break;
-	}
-	pos->col = col;
-    }
-}
-
-/*
- * Get class of a character for selection: same class means same word.
- * 0: blank
- * 1: punctuation groups
- * 2: normal word character
- * >2: multi-byte word character.
- */
-    static int
-get_mouse_class(p)
-    char_u	*p;
-{
-    int		c;
-
-#ifdef FEAT_MBYTE
-    if (has_mbyte && MB_BYTE2LEN(p[0]) > 1)
-	return mb_get_class(p);
-#endif
-
-    c = *p;
-    if (c == ' ' || c == '\t')
-	return 0;
-
-    if (vim_iswordc(c))
-	return 2;
-
-    /*
-     * There are a few special cases where we want certain combinations of
-     * characters to be considered as a single word.  These are things like
-     * "->", "/ *", "*=", "+=", "&=", "<=", ">=", "!=" etc.  Otherwise, each
-     * character is in it's own class.
-     */
-    if (c != NUL && vim_strchr((char_u *)"-+*/%<>&|^!=", c) != NULL)
-	return 1;
-    return c;
-}
-#endif /* FEAT_VISUAL */
-#endif /* FEAT_MOUSE */
-
-#if defined(FEAT_VISUAL) || defined(PROTO)
-/*
- * Check if  highlighting for visual mode is possible, give a warning message
- * if not.
- */
-    void
-check_visual_highlight()
-{
-    static int	    did_check = FALSE;
-
-    if (full_screen)
-    {
-	if (!did_check && hl_attr(HLF_V) == 0)
-	    MSG(_("Warning: terminal cannot highlight"));
-	did_check = TRUE;
-    }
-}
-
-/*
- * End visual mode.
- * This function should ALWAYS be called to end Visual mode, except from
- * do_pending_operator().
- */
-    void
-end_visual_mode()
-{
-#ifdef FEAT_CLIPBOARD
-    /*
-     * If we are using the clipboard, then remember what was selected in case
-     * we need to paste it somewhere while we still own the selection.
-     * Only do this when the clipboard is already owned.  Don't want to grab
-     * the selection when hitting ESC.
-     */
-    if (clip_star.available && clip_star.owned)
-	clip_auto_select();
-#endif
-
-    VIsual_active = FALSE;
-#ifdef FEAT_MOUSE
-    setmouse();
-    mouse_dragging = 0;
-#endif
-
-    /* Save the current VIsual area for '< and '> marks, and "gv" */
-    curbuf->b_visual_mode = VIsual_mode;
-#ifdef FEAT_EVAL
-    curbuf->b_visual_mode_eval = VIsual_mode;
-#endif
-    curbuf->b_visual_start = VIsual;
-    curbuf->b_visual_end = curwin->w_cursor;
-    curbuf->b_visual_curswant = curwin->w_curswant;
-#ifdef FEAT_VIRTUALEDIT
-    if (!virtual_active())
-	curwin->w_cursor.coladd = 0;
-#endif
-
-    if (p_smd)
-	clear_cmdline = TRUE;		/* unshow visual mode later */
-#ifdef FEAT_CMDL_INFO
-    else
-	clear_showcmd();
-#endif
-
-    /* Don't leave the cursor past the end of the line */
-    if (curwin->w_cursor.col > 0 && *ml_get_cursor() == NUL)
-	--curwin->w_cursor.col;
-}
-
-/*
- * Reset VIsual_active and VIsual_reselect.
- */
-    void
-reset_VIsual_and_resel()
-{
-    if (VIsual_active)
-    {
-	end_visual_mode();
-	redraw_curbuf_later(INVERTED);	/* delete the inversion later */
-    }
-    VIsual_reselect = FALSE;
-}
-
-/*
- * Reset VIsual_active and VIsual_reselect if it's set.
- */
-    void
-reset_VIsual()
-{
-    if (VIsual_active)
-    {
-	end_visual_mode();
-	redraw_curbuf_later(INVERTED);	/* delete the inversion later */
-	VIsual_reselect = FALSE;
-    }
-}
-#endif /* FEAT_VISUAL */
-
-#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-static int find_is_eval_item __ARGS((char_u *ptr, int *colp, int *nbp, int dir));
-
-/*
- * Check for a balloon-eval special item to include when searching for an
- * identifier.  When "dir" is BACKWARD "ptr[-1]" must be valid!
- * Returns TRUE if the character at "*ptr" should be included.
- * "dir" is FORWARD or BACKWARD, the direction of searching.
- * "*colp" is in/decremented if "ptr[-dir]" should also be included.
- * "bnp" points to a counter for square brackets.
- */
-    static int
-find_is_eval_item(ptr, colp, bnp, dir)
-    char_u	*ptr;
-    int		*colp;
-    int		*bnp;
-    int		dir;
-{
-    /* Accept everything inside []. */
-    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))
-	++*bnp;
-    if (*bnp > 0)
-    {
-	if ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))
-	    --*bnp;
-	return TRUE;
-    }
-
-    /* skip over "s.var" */
-    if (*ptr == '.')
-	return TRUE;
-
-    /* two-character item: s->var */
-    if (ptr[dir == BACKWARD ? 0 : 1] == '>'
-	    && ptr[dir == BACKWARD ? -1 : 0] == '-')
-    {
-	*colp += dir;
-	return TRUE;
-    }
-    return FALSE;
-}
-#endif
-
-/*
- * Find the identifier under or to the right of the cursor.
- * "find_type" can have one of three values:
- * FIND_IDENT:   find an identifier (keyword)
- * FIND_STRING:  find any non-white string
- * FIND_IDENT + FIND_STRING: find any non-white string, identifier preferred.
- *
- * There are three steps:
- * 1. Search forward for the start of an identifier/string.  Doesn't move if
- *    already on one.
- * 2. Search backward for the start of this identifier/string.
- *    This doesn't match the real Vi but I like it a little better and it
- *    shouldn't bother anyone.
- * 3. Search forward to the end of this identifier/string.
- *    When FIND_IDENT isn't defined, we backup until a blank.
- *
- * Returns the length of the string, or zero if no string is found.
- * If a string is found, a pointer to the string is put in "*string".  This
- * string is not always NUL terminated.
- */
-    int
-find_ident_under_cursor(string, find_type)
-    char_u	**string;
-    int		find_type;
-{
-    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,
-				     curwin->w_cursor.col, string, find_type);
-}
-
-/*
- * Like find_ident_under_cursor(), but for any window and any position.
- * However: Uses 'iskeyword' from the current window!.
- */
-    int
-find_ident_at_pos(wp, lnum, startcol, string, find_type)
-    win_T	*wp;
-    linenr_T	lnum;
-    colnr_T	startcol;
-    char_u	**string;
-    int		find_type;
-{
-    char_u	*ptr;
-    int		col = 0;	    /* init to shut up GCC */
-    int		i;
-#ifdef FEAT_MBYTE
-    int		this_class = 0;
-    int		prev_class;
-    int		prevcol;
-#endif
-#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-    int		bn = 0;	    /* bracket nesting */
-#endif
-
-    /*
-     * if i == 0: try to find an identifier
-     * if i == 1: try to find any non-white string
-     */
-    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);
-    for (i = (find_type & FIND_IDENT) ? 0 : 1;	i < 2; ++i)
-    {
-	/*
-	 * 1. skip to start of identifier/string
-	 */
-	col = startcol;
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	{
-	    while (ptr[col] != NUL)
-	    {
-# if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-		/* Stop at a ']' to evaluate "a[x]". */
-		if ((find_type & FIND_EVAL) && ptr[col] == ']')
-		    break;
-# endif
-		this_class = mb_get_class(ptr + col);
-		if (this_class != 0 && (i == 1 || this_class != 1))
-		    break;
-		col += (*mb_ptr2len_check)(ptr + col);
-	    }
-	}
-	else
-#endif
-	    while (ptr[col] != NUL
-		    && (i == 0 ? !vim_iswordc(ptr[col]) : vim_iswhite(ptr[col]))
-# if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-		    && (!(find_type & FIND_EVAL) || ptr[col] != ']')
-# endif
-		    )
-		++col;
-
-#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-	/* When starting on a ']' count it, so that we include the '['. */
-	bn = ptr[col] == ']';
-#endif
-
-	/*
-	 * 2. Back up to start of identifier/string.
-	 */
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	{
-	    /* Remember class of character under cursor. */
-# if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-	    if ((find_type & FIND_EVAL) && ptr[col] == ']')
-		this_class = mb_get_class((char_u *)"a");
-	    else
-# endif
-		this_class = mb_get_class(ptr + col);
-	    while (col > 0)
-	    {
-		prevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);
-		prev_class = mb_get_class(ptr + prevcol);
-		if (this_class != prev_class
-			&& (i == 0
-			    || prev_class == 0
-			    || (find_type & FIND_IDENT))
-# if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-			&& (!(find_type & FIND_EVAL)
-			    || prevcol == 0
-			    || !find_is_eval_item(ptr + prevcol, &prevcol,
-							       &bn, BACKWARD))
-# endif
-			)
-		    break;
-		col = prevcol;
-	    }
-
-	    /* If we don't want just any old string, or we've found an
-	     * identifier, stop searching. */
-	    if (this_class > 2)
-		this_class = 2;
-	    if (!(find_type & FIND_STRING) || this_class == 2)
-		break;
-	}
-	else
-#endif
-	{
-	    while (col > 0
-		    && ((i == 0
-			    ? vim_iswordc(ptr[col - 1])
-			    : (!vim_iswhite(ptr[col - 1])
-				&& (!(find_type & FIND_IDENT)
-				    || !vim_iswordc(ptr[col - 1]))))
-#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-			|| ((find_type & FIND_EVAL)
-			    && col > 1
-			    && find_is_eval_item(ptr + col - 1, &col,
-							       &bn, BACKWARD))
-#endif
-			))
-		--col;
-
-	    /* If we don't want just any old string, or we've found an
-	     * identifier, stop searching. */
-	    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))
-		break;
-	}
-    }
-
-    if (ptr[col] == NUL || (i == 0 && (
-#ifdef FEAT_MBYTE
-		has_mbyte ? this_class != 2 :
-#endif
-		!vim_iswordc(ptr[col]))))
-    {
-	/*
-	 * didn't find an identifier or string
-	 */
-	if (find_type & FIND_STRING)
-	    EMSG(_("E348: No string under cursor"));
-	else
-	    EMSG(_("E349: No identifier under cursor"));
-	return 0;
-    }
-    ptr += col;
-    *string = ptr;
-
-    /*
-     * 3. Find the end if the identifier/string.
-     */
-#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-    bn = 0;
-    startcol -= col;
-#endif
-    col = 0;
-#ifdef FEAT_MBYTE
-    if (has_mbyte)
-    {
-	/* Search for point of changing multibyte character class. */
-	this_class = mb_get_class(ptr);
-	while (ptr[col] != NUL
-		&& ((i == 0 ? mb_get_class(ptr + col) == this_class
-			    : mb_get_class(ptr + col) != 0)
-# if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-		    || ((find_type & FIND_EVAL)
-			&& col <= (int)startcol
-			&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))
-# endif
-		))
-	    col += (*mb_ptr2len_check)(ptr + col);
-    }
-    else
-#endif
-	while ((i == 0 ? vim_iswordc(ptr[col])
-		       : (ptr[col] != NUL && !vim_iswhite(ptr[col])))
-# if defined(FEAT_NETBEANS_INTG) && defined(FEAT_BEVAL)
-		    || ((find_type & FIND_EVAL)
-			&& col <= (int)startcol
-			&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))
-# endif
-		)
-	{
-	    ++col;
-	}
-
-    return col;
-}
-
-/*
- * Prepare for redo of a normal command.
- */
-    static void
-prep_redo_cmd(cap)
-    cmdarg_T  *cap;
-{
-    prep_redo(cap->oap->regname, cap->count0,
-				     NUL, cap->cmdchar, NUL, NUL, cap->nchar);
-}
-
-/*
- * Prepare for redo of any command.
- * Note that only the last argument can be a multi-byte char.
- */
-    static void
-prep_redo(regname, num, cmd1, cmd2, cmd3, cmd4, cmd5)
-    int	    regname;
-    long    num;
-    int	    cmd1;
-    int	    cmd2;
-    int	    cmd3;
-    int	    cmd4;
-    int	    cmd5;
-{
-    ResetRedobuff();
-    if (regname != 0)	/* yank from specified buffer */
-    {
-	AppendCharToRedobuff('"');
-	AppendCharToRedobuff(regname);
-    }
-    if (num)
-	AppendNumberToRedobuff(num);
-
-    if (cmd1 != NUL)
-	AppendCharToRedobuff(cmd1);
-    if (cmd2 != NUL)
-	AppendCharToRedobuff(cmd2);
-    if (cmd3 != NUL)
-	AppendCharToRedobuff(cmd3);
-    if (cmd4 != NUL)
-	AppendCharToRedobuff(cmd4);
-    if (cmd5 != NUL)
-	AppendCharToRedobuff(cmd5);
-}
-
-/*
- * check for operator active and clear it
- *
- * return TRUE if operator was active
- */
-    static int
-checkclearop(oap)
-    oparg_T	*oap;
-{
-    if (oap->op_type == OP_NOP)
-	return FALSE;
-    clearopbeep(oap);
-    return TRUE;
-}
-
-/*
- * check for operator or Visual active and clear it
- *
- * return TRUE if operator was active
- */
-    static int
-checkclearopq(oap)
-    oparg_T	*oap;
-{
-    if (oap->op_type == OP_NOP
-#ifdef FEAT_VISUAL
-	    && !VIsual_active
-#endif
-	    )
-	return FALSE;
-    clearopbeep(oap);
-    return TRUE;
-}
-
-    static void
-clearop(oap)
-    oparg_T	*oap;
-{
-    oap->op_type = OP_NOP;
-    oap->regname = 0;
-    oap->motion_force = NUL;
-    oap->use_reg_one = FALSE;
-}
-
-    static void
-clearopbeep(oap)
-    oparg_T	*oap;
-{
-    clearop(oap);
-    beep_flush();
-}
-
-#ifdef FEAT_VISUAL
-/*
- * Remove the shift modifier from a special key.
- */
-    static void
-unshift_special(cap)
-    cmdarg_T	*cap;
-{
-    switch (cap->cmdchar)
-    {
-	case K_S_RIGHT:	cap->cmdchar = K_RIGHT; break;
-	case K_S_LEFT:	cap->cmdchar = K_LEFT; break;
-	case K_S_UP:	cap->cmdchar = K_UP; break;
-	case K_S_DOWN:	cap->cmdchar = K_DOWN; break;
-	case K_S_HOME:	cap->cmdchar = K_HOME; break;
-	case K_S_END:	cap->cmdchar = K_END; break;
-    }
-    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);
-}
-#endif
-
-#if defined(FEAT_CMDL_INFO) || defined(PROTO)
-/*
- * Routines for displaying a partly typed command
- */
-
-#ifdef FEAT_VISUAL	/* need room for size of Visual area */
-# define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30
-#else
-# define SHOWCMD_BUFLEN SHOWCMD_COLS + 1
-#endif
-static char_u	showcmd_buf[SHOWCMD_BUFLEN];
-static char_u	old_showcmd_buf[SHOWCMD_BUFLEN];  /* For push_showcmd() */
-static int	showcmd_is_clear = TRUE;
-static int	showcmd_visual = FALSE;
-
-static void display_showcmd __ARGS((void));
-
-    void
-clear_showcmd()
-{
-    if (!p_sc)
-	return;
-
-#ifdef FEAT_VISUAL
-    if (VIsual_active && !char_avail())
-    {
-	int		i = lt(VIsual, curwin->w_cursor);
-	long		lines;
-	colnr_T		leftcol, rightcol;
-	linenr_T	top, bot;
-
-	/* Show the size of the Visual area. */
-	if (i)
-	{
-	    top = VIsual.lnum;
-	    bot = curwin->w_cursor.lnum;
-	}
-	else
-	{
-	    top = curwin->w_cursor.lnum;
-	    bot = VIsual.lnum;
-	}
-# ifdef FEAT_FOLDING
-	/* Include closed folds as a whole. */
-	hasFolding(top, &top, NULL);
-	hasFolding(bot, NULL, &bot);
-# endif
-	lines = bot - top + 1;
-
-	if (VIsual_mode == Ctrl_V)
-	{
-	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
-	    sprintf((char *)showcmd_buf, "%ldx%ld", lines,
-					      (long)(rightcol - leftcol + 1));
-	}
-	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
-	    sprintf((char *)showcmd_buf, "%ld", lines);
-	else
-	    sprintf((char *)showcmd_buf, "%ld", (long)(i
-		    ? curwin->w_cursor.col - VIsual.col
-		    : VIsual.col - curwin->w_cursor.col) + (*p_sel != 'e'));
-	showcmd_buf[SHOWCMD_COLS] = NUL;	/* truncate */
-	showcmd_visual = TRUE;
-    }
-    else
-#endif
-    {
-	showcmd_buf[0] = NUL;
-	showcmd_visual = FALSE;
-
-	/* Don't actually display something if there is nothing to clear. */
-	if (showcmd_is_clear)
-	    return;
-    }
-
-    display_showcmd();
-}
-
-/*
- * Add 'c' to string of shown command chars.
- * Return TRUE if output has been written (and setcursor() has been called).
- */
-    int
-add_to_showcmd(c)
-    int		c;
-{
-    char_u	*p;
-    int		old_len;
-    int		extra_len;
-    int		overflow;
-#if defined(FEAT_MOUSE)
-    int		i;
-    static int	ignore[] =
-    {
-#ifdef FEAT_GUI
-	K_VER_SCROLLBAR, K_HOR_SCROLLBAR,
-	K_LEFTMOUSE_NM, K_LEFTRELEASE_NM,
-#endif
-	K_IGNORE,
-	K_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE,
-	K_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,
-	K_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,
-	K_MOUSEDOWN, K_MOUSEUP,
-	K_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,
-	0
-    };
-#endif
-
-    if (!p_sc)
-	return FALSE;
-
-    if (showcmd_visual)
-    {
-	showcmd_buf[0] = NUL;
-	showcmd_visual = FALSE;
-    }
-
-#if defined(FEAT_MOUSE)
-    /* Ignore keys that are scrollbar updates and mouse clicks */
-    if (IS_SPECIAL(c))
-	for (i = 0; ignore[i] != 0; ++i)
-	    if (ignore[i] == c)
-		return FALSE;
-#endif
-
-    p = transchar(c);
-    old_len = (int)STRLEN(showcmd_buf);
-    extra_len = (int)STRLEN(p);
-    overflow = old_len + extra_len - SHOWCMD_COLS;
-    if (overflow > 0)
-	STRCPY(showcmd_buf, showcmd_buf + overflow);
-    STRCAT(showcmd_buf, p);
-
-    if (char_avail())
-	return FALSE;
-
-    display_showcmd();
-
-    return TRUE;
-}
-
-    void
-add_to_showcmd_c(c)
-    int		c;
-{
-    if (!add_to_showcmd(c))
-	setcursor();
-}
-
-/*
- * Delete 'len' characters from the end of the shown command.
- */
-    static void
-del_from_showcmd(len)
-    int	    len;
-{
-    int	    old_len;
-
-    if (!p_sc)
-	return;
-
-    old_len = (int)STRLEN(showcmd_buf);
-    if (len > old_len)
-	len = old_len;
-    showcmd_buf[old_len - len] = NUL;
-
-    if (!char_avail())
-	display_showcmd();
-}
-
-/*
- * push_showcmd() and pop_showcmd() are used when waiting for the user to type
- * something and there is a partial mapping.
- */
-    void
-push_showcmd()
-{
-    if (p_sc)
-	STRCPY(old_showcmd_buf, showcmd_buf);
-}
-
-    void
-pop_showcmd()
-{
-    if (!p_sc)
-	return;
-
-    STRCPY(showcmd_buf, old_showcmd_buf);
-
-    display_showcmd();
-}
-
-    static void
-display_showcmd()
-{
-    int	    len;
-
-    cursor_off();
-
-    len = (int)STRLEN(showcmd_buf);
-    if (len == 0)
-	showcmd_is_clear = TRUE;
-    else
-    {
-	screen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);
-	showcmd_is_clear = FALSE;
-    }
-
-    /*
-     * clear the rest of an old message by outputing up to SHOWCMD_COLS spaces
-     */
-    screen_puts((char_u *)"          " + len, (int)Rows - 1, sc_col + len, 0);
-
-    setcursor();	    /* put cursor back where it belongs */
-}
-#endif
-
-#ifdef FEAT_SCROLLBIND
-/*
- * When "check" is FALSE, prepare for commands that scroll the window.
- * When "check" is TRUE, take care of scroll-binding after the window has
- * scrolled.  Called from normal_cmd() and edit().
- */
-    void
-do_check_scrollbind(check)
-    int		check;
-{
-    static win_T	*old_curwin = NULL;
-    static linenr_T	old_topline = 0;
-#ifdef FEAT_DIFF
-    static int		old_topfill = 0;
-#endif
-    static buf_T	*old_buf = NULL;
-    static colnr_T	old_leftcol = 0;
-
-    if (check && curwin->w_p_scb)
-    {
-	/* If a ":syncbind" command was just used, don't scroll, only reset
-	 * the values. */
-	if (did_syncbind)
-	    did_syncbind = FALSE;
-	else if (curwin == old_curwin)
-	{
-	    /*
-	     * Synchronize other windows, as necessary according to
-	     * 'scrollbind'.  Don't do this after an ":edit" command, except
-	     * when 'diff' is set.
-	     */
-	    if ((curwin->w_buffer == old_buf
-#ifdef FEAT_DIFF
-			|| curwin->w_p_diff
-#endif
-		)
-		&& (curwin->w_topline != old_topline
-#ifdef FEAT_DIFF
-			|| curwin->w_topfill != old_topfill
-#endif
-			|| curwin->w_leftcol != old_leftcol))
-	    {
-		check_scrollbind(curwin->w_topline - old_topline,
-			(long)(curwin->w_leftcol - old_leftcol));
-	    }
-	}
-	else if (vim_strchr(p_sbo, 'j')) /* jump flag set in 'scrollopt' */
-	{
-	    /*
-	     * When switching between windows, make sure that the relative
-	     * vertical offset is valid for the new window.  The relative
-	     * offset is invalid whenever another 'scrollbind' window has
-	     * scrolled to a point that would force the current window to
-	     * scroll past the beginning or end of its buffer.  When the
-	     * resync is performed, some of the other 'scrollbind' windows may
-	     * need to jump so that the current window's relative position is
-	     * visible on-screen.
-	     */
-	    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);
-	}
-	curwin->w_scbind_pos = curwin->w_topline;
-    }
-
-    old_curwin = curwin;
-    old_topline = curwin->w_topline;
-#ifdef FEAT_DIFF
-    old_topfill = curwin->w_topfill;
-#endif
-    old_buf = curwin->w_buffer;
-    old_leftcol = curwin->w_leftcol;
-}
-
-/*
- * Synchronize any windows that have "scrollbind" set, based on the
- * number of rows by which the current window has changed
- * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
- */
-    void
-check_scrollbind(topline_diff, leftcol_diff)
-    linenr_T	topline_diff;
-    long	leftcol_diff;
-{
-    int		want_ver;
-    int		want_hor;
-    win_T	*old_curwin = curwin;
-    buf_T	*old_curbuf = curbuf;
-#ifdef FEAT_VISUAL
-    int		old_VIsual_select = VIsual_select;
-    int		old_VIsual_active = VIsual_active;
-#endif
-    colnr_T	tgt_leftcol = curwin->w_leftcol;
-    long	topline;
-    long	y;
-
-    /*
-     * check 'scrollopt' string for vertical and horizontal scroll options
-     */
-    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);
-#ifdef FEAT_DIFF
-    want_ver |= old_curwin->w_p_diff;
-#endif
-    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));
-
-    /*
-     * loop through the scrollbound windows and scroll accordingly
-     */
-#ifdef FEAT_VISUAL
-    VIsual_select = VIsual_active = 0;
-#endif
-    for (curwin = firstwin; curwin; curwin = curwin->w_next)
-    {
-	curbuf = curwin->w_buffer;
-	/* skip original window  and windows with 'noscrollbind' */
-	if (curwin != old_curwin && curwin->w_p_scb)
-	{
-	    /*
-	     * do the vertical scroll
-	     */
-	    if (want_ver)
-	    {
-#ifdef FEAT_DIFF
-		if (old_curwin->w_p_diff && curwin->w_p_diff)
-		{
-		    diff_set_topline(old_curwin, curwin);
-		}
-		else
-#endif
-		{
-		    curwin->w_scbind_pos += topline_diff;
-		    topline = curwin->w_scbind_pos;
-		    if (topline > curbuf->b_ml.ml_line_count)
-			topline = curbuf->b_ml.ml_line_count;
-		    if (topline < 1)
-			topline = 1;
-
-		    y = topline - curwin->w_topline;
-		    if (y > 0)
-			scrollup(y, FALSE);
-		    else
-			scrolldown(-y, FALSE);
-		}
-
-		redraw_later(VALID);
-		cursor_correct();
-#ifdef FEAT_WINDOWS
-		curwin->w_redr_status = TRUE;
-#endif
-	    }
-
-	    /*
-	     * do the horizontal scroll
-	     */
-	    if (want_hor && curwin->w_leftcol != tgt_leftcol)
-	    {
-		curwin->w_leftcol = tgt_leftcol;
-		leftcol_changed();
-	    }
-	}
-    }
-
-    /*
-     * reset current-window
-     */
-#ifdef FEAT_VISUAL
-    VIsual_select = old_VIsual_select;
-    VIsual_active = old_VIsual_active;
-#endif
-    curwin = old_curwin;
-    curbuf = old_curbuf;
-}
-#endif /* #ifdef FEAT_SCROLLBIND */
-
-/*
- * Command character that's ignored.
- * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use
- * xon/xoff
- */
-/*ARGSUSED */
-    static void
-nv_ignore(cap)
-    cmdarg_T	*cap;
-{
-}
-
-/*
- * Command character doesn't exist.
- */
-    static void
-nv_error(cap)
-    cmdarg_T	*cap;
-{
-    clearopbeep(cap->oap);
-}
-
-/*
- * <Help> and <F1> commands.
- */
-    static void
-nv_help(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearopq(cap->oap))
-	ex_help(NULL);
-}
-
-/*
- * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.
- */
-    static void
-nv_addsub(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearopq(cap->oap)
-	    && do_addsub((int)cap->cmdchar, cap->count1) == OK)
-	prep_redo_cmd(cap);
-}
-
-/*
- * CTRL-F, CTRL-B, etc: Scroll page up or down.
- */
-    static void
-nv_page(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearop(cap->oap))
-	(void)onepage(cap->arg, cap->count1);
-}
-
-/*
- * Implementation of "gd" and "gD" command.
- */
-    static void
-nv_gd(oap, nchar)
-    oparg_T   *oap;
-    int	    nchar;
-{
-    int		len;
-    char_u	*pat;
-    pos_T	old_pos;
-    int		t;
-    int		save_p_ws;
-    int		save_p_scs;
-    char_u	*ptr;
-
-    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0 ||
-					       (pat = alloc(len + 5)) == NULL)
-    {
-	clearopbeep(oap);
-	return;
-    }
-    sprintf((char *)pat, vim_iswordp(ptr) ? "\\<%.*s\\>" : "%.*s", len, ptr);
-    old_pos = curwin->w_cursor;
-    save_p_ws = p_ws;
-    save_p_scs = p_scs;
-    p_ws = FALSE;	/* don't wrap around end of file now */
-    p_scs = FALSE;	/* don't switch ignorecase off now */
-
-    /*
-     * With "gD" go to line 1.
-     * With "gd" Search back for the start of the current function, then go
-     * back until a blank line.  If this fails go to line 1.
-     */
-    if (nchar == 'D' || !findpar(oap, BACKWARD, 1L, '{', FALSE))
-    {
-	setpcmark();			/* Set in findpar() otherwise */
-	curwin->w_cursor.lnum = 1;
-    }
-    else
-    {
-	while (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)
-	    --curwin->w_cursor.lnum;
-    }
-    curwin->w_cursor.col = 0;
-
-    /* Search forward for the identifier, ignore comment lines. */
-    while ((t = searchit(curwin, curbuf, &curwin->w_cursor, FORWARD, pat, 1L, 0,
-							     RE_LAST)) != FAIL
-#ifdef FEAT_COMMENTS
-	    && get_leader_len(ml_get_curline(), NULL, FALSE) > 0
-#endif
-	    && old_pos.lnum > curwin->w_cursor.lnum)
-    {
-	/* Ignore this line, continue at start of next line. */
-	++curwin->w_cursor.lnum;
-	curwin->w_cursor.col = 0;
-    }
-    if (t == FAIL || old_pos.lnum <= curwin->w_cursor.lnum)
-    {
-	clearopbeep(oap);
-	curwin->w_cursor = old_pos;
-    }
-    else
-    {
-	curwin->w_set_curswant = TRUE;
-#ifdef FEAT_FOLDING
-	if ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)
-	    foldOpenCursor();
-#endif
-	/* "n" searches forward now */
-	reset_search_dir();
-    }
-
-    vim_free(pat);
-    p_ws = save_p_ws;
-    p_scs = save_p_scs;
-}
-
-/*
- * Move 'dist' lines in direction 'dir', counting lines by *screen*
- * lines rather than lines in the file.
- * 'dist' must be positive.
- *
- * Return OK if able to move cursor, FAIL otherwise.
- */
-    static int
-nv_screengo(oap, dir, dist)
-    oparg_T	*oap;
-    int		dir;
-    long	dist;
-{
-    int		linelen = linetabsize(ml_get_curline());
-    int		retval = OK;
-    int		atend = FALSE;
-    int		n;
-    int		col_off1;	/* margin offset for first screen line */
-    int		col_off2;	/* margin offset for wrapped screen line */
-    int		width1;		/* text width for first screen line */
-    int		width2;		/* test width for wrapped screen line */
-
-    oap->motion_type = MCHAR;
-    oap->inclusive = FALSE;
-
-    col_off1 = curwin_col_off();
-    col_off2 = col_off1 - curwin_col_off2();
-    width1 = W_WIDTH(curwin) - col_off1;
-    width2 = W_WIDTH(curwin) - col_off2;
-
-#ifdef FEAT_VERTSPLIT
-    if (curwin->w_width != 0)
-    {
-#endif
-      /*
-       * Instead of sticking at the last character of the buffer line we
-       * try to stick in the last column of the screen.
-       */
-      if (curwin->w_curswant == MAXCOL)
-      {
-	atend = TRUE;
-	validate_virtcol();
-	if (width1 <= 0)
-	    curwin->w_curswant = 0;
-	else
-	{
-	    curwin->w_curswant = width1 - 1;
-	    if (curwin->w_virtcol > curwin->w_curswant)
-		curwin->w_curswant += ((curwin->w_virtcol
-			     - curwin->w_curswant - 1) / width2 + 1) * width2;
-	}
-      }
-      else
-      {
-	if (linelen > width1)
-	    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;
-	else
-	    n = width1;
-	if (curwin->w_curswant > (colnr_T)n + 1)
-	    curwin->w_curswant -= ((curwin->w_curswant - n) / width2 + 1)
-								     * width2;
-      }
-
-      while (dist--)
-      {
-	if (dir == BACKWARD)
-	{
-	    if ((long)curwin->w_curswant >= width2)
-		/* move back within line */
-		curwin->w_curswant -= width2;
-	    else
-	    {
-		/* to previous line */
-		if (curwin->w_cursor.lnum == 1)
-		{
-		    retval = FAIL;
-		    break;
-		}
-		--curwin->w_cursor.lnum;
-#ifdef FEAT_FOLDING
-		/* Move to the start of a closed fold.  Don't do that when
-		 * 'foldopen' contains "all": it will open in a moment. */
-		if (!(fdo_flags & FDO_ALL))
-		    (void)hasFolding(curwin->w_cursor.lnum,
-						&curwin->w_cursor.lnum, NULL);
-#endif
-		linelen = linetabsize(ml_get_curline());
-		if (linelen > width1)
-		    curwin->w_curswant += (((linelen - width1 - 1) / width2)
-								+ 1) * width2;
-	    }
-	}
-	else /* dir == FORWARD */
-	{
-	    if (linelen > width1)
-		n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;
-	    else
-		n = width1;
-	    if (curwin->w_curswant + width2 < (colnr_T)n)
-		/* move forward within line */
-		curwin->w_curswant += width2;
-	    else
-	    {
-		/* to next line */
-#ifdef FEAT_FOLDING
-		/* Move to the end of a closed fold. */
-		(void)hasFolding(curwin->w_cursor.lnum, NULL,
-						      &curwin->w_cursor.lnum);
-#endif
-		if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)
-		{
-		    retval = FAIL;
-		    break;
-		}
-		curwin->w_cursor.lnum++;
-		curwin->w_curswant %= width2;
-	    }
-	}
-      }
-#ifdef FEAT_VERTSPLIT
-    }
-#endif
-
-    coladvance(curwin->w_curswant);
-
-#if defined(FEAT_LINEBREAK) || defined(FEAT_MBYTE)
-    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)
-    {
-	/*
-	 * Check for landing on a character that got split at the end of the
-	 * last line.  We want to advance a screenline, not end up in the same
-	 * screenline or move two screenlines.
-	 */
-	validate_virtcol();
-	if (curwin->w_virtcol > curwin->w_curswant
-		&& (curwin->w_curswant < (colnr_T)width1
-		    ? (curwin->w_curswant > (colnr_T)width1 / 2)
-		    : ((curwin->w_curswant - width1) % width2
-						      > (colnr_T)width2 / 2)))
-	    --curwin->w_cursor.col;
-    }
-#endif
-
-    if (atend)
-	curwin->w_curswant = MAXCOL;	    /* stick in the last column */
-
-    return retval;
-}
-
-#ifdef FEAT_MOUSE
-/*
- * Mouse scroll wheel: Default action is to scroll three lines, or one page
- * when Shift or Ctrl is used.
- * K_MOUSEUP (cap->arg == TRUE) or K_MOUSEDOWN (cap->arg == FALSE)
- */
-    static void
-nv_mousescroll(cap)
-    cmdarg_T	*cap;
-{
-# if defined(FEAT_GUI) && defined(FEAT_WINDOWS)
-    win_T *old_curwin;
-
-    old_curwin = curwin;
-
-    /* Currently we only get the mouse coordinates in the GUI. */
-    if (gui.in_use && mouse_row >= 0 && mouse_col >= 0)
-    {
-	int row, col;
-
-	row = mouse_row;
-	col = mouse_col;
-
-	/* find the window at the pointer coordinates */
-	curwin = mouse_find_win(&row, &col);
-	curbuf = curwin->w_buffer;
-    }
-# endif
-
-    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))
-    {
-	(void)onepage(cap->arg ? FORWARD : BACKWARD, 1L);
-    }
-    else
-    {
-	cap->count1 = 3;
-	cap->count0 = 3;
-	nv_scroll_line(cap);
-    }
-
-# if defined(FEAT_GUI) && defined(FEAT_WINDOWS)
-    curwin->w_redr_status = TRUE;
-
-    curwin = old_curwin;
-    curbuf = curwin->w_buffer;
-# endif
-}
-
-/*
- * Mouse clicks and drags.
- */
-    static void
-nv_mouse(cap)
-    cmdarg_T	*cap;
-{
-    (void)do_mouse(cap->oap, cap->cmdchar, BACKWARD, cap->count1, 0);
-}
-#endif
-
-/*
- * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.
- * cap->arg must be TRUE for CTRL-E.
- */
-    static void
-nv_scroll_line(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearop(cap->oap))
-	scroll_redraw(cap->arg, cap->count1);
-}
-
-/*
- * Scroll "count" lines up or down, and redraw.
- */
-    void
-scroll_redraw(up, count)
-    int		up;
-    long	count;
-{
-    linenr_T	prev_topline = curwin->w_topline;
-#ifdef FEAT_DIFF
-    int		prev_topfill = curwin->w_topfill;
-#endif
-    linenr_T	prev_lnum = curwin->w_cursor.lnum;
-
-    if (up)
-	scrollup(count, TRUE);
-    else
-	scrolldown(count, TRUE);
-    if (p_so)
-    {
-	/* Adjust the cursor position for 'scrolloff'.  Mark w_topline as
-	 * valid, otherwise the screen jumps back at the end of the file. */
-	cursor_correct();
-	check_cursor_moved(curwin);
-	curwin->w_valid |= VALID_TOPLINE;
-
-	/* If moved back to where we were, at least move the cursor, otherwise
-	 * we get stuck at one position.  Don't move the cursor up if the
-	 * first line of the buffer is already on the screen */
-	while (curwin->w_topline == prev_topline
-#ifdef FEAT_DIFF
-		&& curwin->w_topfill == prev_topfill
-#endif
-		)
-	{
-	    if (up)
-	    {
-		if (curwin->w_cursor.lnum > prev_lnum
-			|| cursor_down(1L, FALSE) == FAIL)
-		    break;
-	    }
-	    else
-	    {
-		if (curwin->w_cursor.lnum < prev_lnum
-			|| prev_topline == 1L
-			|| cursor_up(1L, FALSE) == FAIL)
-		    break;
-	    }
-	    /* Mark w_topline as valid, otherwise the screen jumps back at the
-	     * end of the file. */
-	    check_cursor_moved(curwin);
-	    curwin->w_valid |= VALID_TOPLINE;
-	}
-    }
-    if (curwin->w_cursor.lnum != prev_lnum)
-	coladvance(curwin->w_curswant);
-    redraw_later(VALID);
-}
-
-/*
- * Commands that start with "z".
- */
-    static void
-nv_zet(cap)
-    cmdarg_T  *cap;
-{
-    long	n;
-    colnr_T	col;
-    int		nchar = cap->nchar;
-#ifdef FEAT_FOLDING
-    long	old_fdl = curwin->w_p_fdl;
-    int		old_fen = curwin->w_p_fen;
-#endif
-
-    if (VIM_ISDIGIT(nchar))
-    {
-	/*
-	 * "z123{nchar}": edit the count before obtaining {nchar}
-	 */
-	if (checkclearop(cap->oap))
-	    return;
-	n = nchar - '0';
-	for (;;)
-	{
-#ifdef USE_ON_FLY_SCROLL
-	    dont_scroll = TRUE;		/* disallow scrolling here */
-#endif
-	    ++no_mapping;
-	    ++allow_keys;   /* no mapping for nchar, but allow key codes */
-	    nchar = safe_vgetc();
-#ifdef FEAT_LANGMAP
-	    LANGMAP_ADJUST(nchar, TRUE);
-#endif
-	    --no_mapping;
-	    --allow_keys;
-#ifdef FEAT_CMDL_INFO
-	    (void)add_to_showcmd(nchar);
-#endif
-	    if (nchar == K_DEL || nchar == K_KDEL)
-		n /= 10;
-	    else if (VIM_ISDIGIT(nchar))
-		n = n * 10 + (nchar - '0');
-	    else if (nchar == CAR)
-	    {
-#ifdef FEAT_GUI
-		need_mouse_correct = TRUE;
-#endif
-		win_setheight((int)n);
-		break;
-	    }
-	    else if (nchar == 'l'
-		    || nchar == 'h'
-		    || nchar == K_LEFT
-		    || nchar == K_RIGHT)
-	    {
-		cap->count1 = n ? n * cap->count1 : cap->count1;
-		goto dozet;
-	    }
-	    else
-	    {
-		clearopbeep(cap->oap);
-		break;
-	    }
-	}
-	cap->oap->op_type = OP_NOP;
-	return;
-    }
-
-dozet:
-    if (
-#ifdef FEAT_FOLDING
-	    /* "zf" and "zF" are always an operator, "zd", "zo", "zO", "zc"
-	     * and "zC" only in Visual mode.  "zj" and "zk" are motion
-	     * commands. */
-	    cap->nchar != 'f' && cap->nchar != 'F'
-	    && !(VIsual_active && vim_strchr((char_u *)"dcCoO", cap->nchar))
-	    && cap->nchar != 'j' && cap->nchar != 'k'
-	    &&
-#endif
-	    checkclearop(cap->oap))
-	return;
-
-    /*
-     * For "z+", "z<CR>", "zt", "z.", "zz", "z^", "z-", "zb":
-     * If line number given, set cursor.
-     */
-    if ((vim_strchr((char_u *)"+\r\nt.z^-b", nchar) != NULL)
-	    && cap->count0
-	    && cap->count0 != curwin->w_cursor.lnum)
-    {
-	setpcmark();
-	if (cap->count0 > curbuf->b_ml.ml_line_count)
-	    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
-	else
-	    curwin->w_cursor.lnum = cap->count0;
-	check_cursor_col();
-    }
-
-    switch (nchar)
-    {
-		/* "z+", "z<CR>" and "zt": put cursor at top of screen */
-    case '+':
-		if (cap->count0 == 0)
-		{
-		    /* No count given: put cursor at the line below screen */
-		    validate_botline();	/* make sure w_botline is valid */
-		    if (curwin->w_botline > curbuf->b_ml.ml_line_count)
-			curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
-		    else
-			curwin->w_cursor.lnum = curwin->w_botline;
-		}
-		/* FALLTHROUGH */
-    case NL:
-    case CAR:
-    case K_KENTER:
-		beginline(BL_WHITE | BL_FIX);
-		/* FALLTHROUGH */
-
-    case 't':	scroll_cursor_top(0, TRUE);
-		redraw_later(VALID);
-		break;
-
-		/* "z." and "zz": put cursor in middle of screen */
-    case '.':	beginline(BL_WHITE | BL_FIX);
-		/* FALLTHROUGH */
-
-    case 'z':	scroll_cursor_halfway(TRUE);
-		redraw_later(VALID);
-		break;
-
-		/* "z^", "z-" and "zb": put cursor at bottom of screen */
-    case '^':	/* Strange Vi behavior: <count>z^ finds line at top of window
-		 * when <count> is at bottom of window, and puts that one at
-		 * bottom of window. */
-		if (cap->count0 != 0)
-		{
-		    scroll_cursor_bot(0, TRUE);
-		    curwin->w_cursor.lnum = curwin->w_topline;
-		}
-		else if (curwin->w_topline == 1)
-		    curwin->w_cursor.lnum = 1;
-		else
-		    curwin->w_cursor.lnum = curwin->w_topline - 1;
-		/* FALLTHROUGH */
-    case '-':
-		beginline(BL_WHITE | BL_FIX);
-		/* FALLTHROUGH */
-
-    case 'b':	scroll_cursor_bot(0, TRUE);
-		redraw_later(VALID);
-		break;
-
-		/* "zH" - scroll screen right half-page */
-    case 'H':
-		cap->count1 *= W_WIDTH(curwin) / 2;
-		/* FALLTHROUGH */
-
-		/* "zh" - scroll screen to the right */
-    case 'h':
-    case K_LEFT:
-		if (!curwin->w_p_wrap)
-		{
-		    if ((colnr_T)cap->count1 > curwin->w_leftcol)
-			curwin->w_leftcol = 0;
-		    else
-			curwin->w_leftcol -= (colnr_T)cap->count1;
-		    leftcol_changed();
-		}
-		break;
-
-		/* "zL" - scroll screen left half-page */
-    case 'L':	cap->count1 *= W_WIDTH(curwin) / 2;
-		/* FALLTHROUGH */
-
-		/* "zl" - scroll screen to the left */
-    case 'l':
-    case K_RIGHT:
-		if (!curwin->w_p_wrap)
-		{
-		    /* scroll the window left */
-		    curwin->w_leftcol += (colnr_T)cap->count1;
-		    leftcol_changed();
-		}
-		break;
-
-		/* "zs" - scroll screen, cursor at the start */
-    case 's':	if (!curwin->w_p_wrap)
-		{
-#ifdef FEAT_FOLDING
-		    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))
-			col = 0;	/* like the cursor is in col 0 */
-		    else
-#endif
-		    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);
-		    if ((long)col > p_siso)
-			col -= p_siso;
-		    else
-			col = 0;
-		    if (curwin->w_leftcol != col)
-		    {
-			curwin->w_leftcol = col;
-			redraw_later(NOT_VALID);
-		    }
-		}
-		break;
-
-		/* "ze" - scroll screen, cursor at the end */
-    case 'e':	if (!curwin->w_p_wrap)
-		{
-#ifdef FEAT_FOLDING
-		    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))
-			col = 0;	/* like the cursor is in col 0 */
-		    else
-#endif
-		    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);
-		    n = W_WIDTH(curwin) - curwin_col_off();
-		    if ((long)col + p_siso < n)
-			col = 0;
-		    else
-			col = col + p_siso - n + 1;
-		    if (curwin->w_leftcol != col)
-		    {
-			curwin->w_leftcol = col;
-			redraw_later(NOT_VALID);
-		    }
-		}
-		break;
-
-#ifdef FEAT_FOLDING
-		/* "zF": create fold command */
-		/* "zf": create fold operator */
-    case 'F':
-    case 'f':   if (foldManualAllowed(TRUE))
-		{
-		    cap->nchar = 'f';
-		    nv_operator(cap);
-		    curwin->w_p_fen = TRUE;
-
-		    /* "zF" is like "zfzf" */
-		    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)
-		    {
-			nv_operator(cap);
-			finish_op = TRUE;
-		    }
-		}
-		else
-		    clearopbeep(cap->oap);
-		break;
-
-		/* "zd": delete fold at cursor */
-		/* "zD": delete fold at cursor recursively */
-    case 'd':
-    case 'D':	if (foldManualAllowed(FALSE))
-		{
-		    if (VIsual_active)
-			nv_operator(cap);
-		    else
-			deleteFold(curwin->w_cursor.lnum,
-				  curwin->w_cursor.lnum, nchar == 'D', FALSE);
-		}
-		break;
-
-		/* "zE": erease all folds */
-    case 'E':	if (foldmethodIsManual(curwin))
-		{
-		    clearFolding(curwin);
-		    changed_window_setting();
-		}
-		else if (foldmethodIsMarker(curwin))
-		    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,
-								 TRUE, FALSE);
-		else
-		    EMSG(_("E352: Cannot erase folds with current 'foldmethod'"));
-		break;
-
-		/* "zn": fold none: reset 'foldenable' */
-    case 'n':	curwin->w_p_fen = FALSE;
-		break;
-
-		/* "zN": fold Normal: set 'foldenable' */
-    case 'N':	curwin->w_p_fen = TRUE;
-		break;
-
-		/* "zi": invert folding: toggle 'foldenable' */
-    case 'i':	curwin->w_p_fen = !curwin->w_p_fen;
-		break;
-
-		/* "za": open closed fold or close open fold at cursor */
-    case 'a':	if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))
-		    openFold(curwin->w_cursor.lnum, cap->count1);
-		else
-		{
-		    closeFold(curwin->w_cursor.lnum, cap->count1);
-		    curwin->w_p_fen = TRUE;
-		}
-		break;
-
-		/* "zA": open fold at cursor recursively */
-    case 'A':	if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))
-		    openFoldRecurse(curwin->w_cursor.lnum);
-		else
-		{
-		    closeFoldRecurse(curwin->w_cursor.lnum);
-		    curwin->w_p_fen = TRUE;
-		}
-		break;
-
-		/* "zo": open fold at cursor or Visual area */
-    case 'o':	if (VIsual_active)
-		    nv_operator(cap);
-		else
-		    openFold(curwin->w_cursor.lnum, cap->count1);
-		break;
-
-		/* "zO": open fold recursively */
-    case 'O':	if (VIsual_active)
-		    nv_operator(cap);
-		else
-		    openFoldRecurse(curwin->w_cursor.lnum);
-		break;
-
-		/* "zc": close fold at cursor or Visual area */
-    case 'c':	if (VIsual_active)
-		    nv_operator(cap);
-		else
-		    closeFold(curwin->w_cursor.lnum, cap->count1);
-		curwin->w_p_fen = TRUE;
-		break;
-
-		/* "zC": close fold recursively */
-    case 'C':	if (VIsual_active)
-		    nv_operator(cap);
-		else
-		    closeFoldRecurse(curwin->w_cursor.lnum);
-		curwin->w_p_fen = TRUE;
-		break;
-
-		/* "zv": open folds at the cursor */
-    case 'v':	foldOpenCursor();
-		break;
-
-		/* "zx": re-apply 'foldlevel' and open folds at the cursor */
-    case 'x':	curwin->w_p_fen = TRUE;
-		newFoldLevel();		/* update right now */
-		foldOpenCursor();
-		break;
-
-		/* "zX": undo manual opens/closes, re-apply 'foldlevel' */
-    case 'X':	curwin->w_p_fen = TRUE;
-		old_fdl = -1;		/* force an update */
-		break;
-
-		/* "zm": fold more */
-    case 'm':	if (curwin->w_p_fdl > 0)
-		    --curwin->w_p_fdl;
-		old_fdl = -1;		/* force an update */
-		curwin->w_p_fen = TRUE;
-		break;
-
-		/* "zM": close all folds */
-    case 'M':	curwin->w_p_fdl = 0;
-		old_fdl = -1;		/* force an update */
-		curwin->w_p_fen = TRUE;
-		break;
-
-		/* "zr": reduce folding */
-    case 'r':	++curwin->w_p_fdl;
-		break;
-
-		/* "zR": open all folds */
-    case 'R':	curwin->w_p_fdl = getDeepestNesting();
-		old_fdl = -1;		/* force an update */
-		break;
-
-    case 'j':	/* "zj" move to next fold downwards */
-    case 'k':	/* "zk" move to next fold upwards */
-		if (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,
-							  cap->count1) == FAIL)
-		    clearopbeep(cap->oap);
-		break;
-
-#endif /* FEAT_FOLDING */
-
-    default:	clearopbeep(cap->oap);
-    }
-
-#ifdef FEAT_FOLDING
-    /* Redraw when 'foldenable' changed */
-    if (old_fen != curwin->w_p_fen)
-    {
-# ifdef FEAT_DIFF
-	win_T	    *wp;
-
-	if (foldmethodIsDiff(curwin) && curwin->w_p_scb)
-	{
-	    /* Adjust 'foldenable' in diff-synced windows. */
-	    FOR_ALL_WINDOWS(wp)
-	    {
-		if (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)
-		{
-		    wp->w_p_fen = curwin->w_p_fen;
-		    changed_window_setting_win(wp);
-		}
-	    }
-	}
-# endif
-	changed_window_setting();
-    }
-
-    /* Redraw when 'foldlevel' changed. */
-    if (old_fdl != curwin->w_p_fdl)
-	newFoldLevel();
-#endif
-}
-
-#ifdef FEAT_GUI
-/*
- * Vertical scrollbar movement.
- */
-    static void
-nv_ver_scrollbar(cap)
-    cmdarg_T	*cap;
-{
-    if (cap->oap->op_type != OP_NOP)
-	clearopbeep(cap->oap);
-
-    /* Even if an operator was pending, we still want to scroll */
-    gui_do_scroll();
-}
-
-/*
- * Horizontal scrollbar movement.
- */
-    static void
-nv_hor_scrollbar(cap)
-    cmdarg_T	*cap;
-{
-    if (cap->oap->op_type != OP_NOP)
-	clearopbeep(cap->oap);
-
-    /* Even if an operator was pending, we still want to scroll */
-    gui_do_horiz_scroll();
-}
-#endif
-
-/*
- * "Q" command.
- */
-    static void
-nv_exmode(cap)
-    cmdarg_T	*cap;
-{
-    /*
-     * Ignore 'Q' in Visual mode, just give a beep.
-     */
-#ifdef FEAT_VISUAL
-    if (VIsual_active)
-	vim_beep();
-    else
-#endif
-	if (!checkclearop(cap->oap))
-	do_exmode(FALSE);
-}
-
-/*
- * Handle a ":" command.
- */
-    static void
-nv_colon(cap)
-    cmdarg_T  *cap;
-{
-    int	    old_p_im;
-
-#ifdef FEAT_VISUAL
-    if (VIsual_active)
-	nv_operator(cap);
-    else
-#endif
-    {
-	if (cap->oap->op_type != OP_NOP)
-	{
-	    /* Using ":" as a movement is characterwise exclusive. */
-	    cap->oap->motion_type = MCHAR;
-	    cap->oap->inclusive = FALSE;
-	}
-	else if (cap->count0)
-	{
-	    /* translate "count:" into ":.,.+(count - 1)" */
-	    stuffcharReadbuff('.');
-	    if (cap->count0 > 1)
-	    {
-		stuffReadbuff((char_u *)",.+");
-		stuffnumReadbuff((long)cap->count0 - 1L);
-	    }
-	}
-
-	/* When typing, don't type below an old message */
-	if (KeyTyped)
-	    compute_cmdrow();
-
-	old_p_im = p_im;
-
-	/* get a command line and execute it */
-	do_cmdline(NULL, getexline, NULL,
-			    cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0);
-
-	/* If 'insertmode' changed, enter or exit Insert mode */
-	if (p_im != old_p_im)
-	{
-	    if (p_im)
-		restart_edit = 'i';
-	    else
-		restart_edit = 0;
-	}
-
-	/* The start of the operator may have become invalid by the Ex
-	 * command. */
-	if (cap->oap->op_type != OP_NOP
-		&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count
-		    || cap->oap->start.col >
-					 STRLEN(ml_get(cap->oap->start.lnum))))
-	    clearopbeep(cap->oap);
-    }
-}
-
-/*
- * Handle CTRL-G command.
- */
-    static void
-nv_ctrlg(cap)
-    cmdarg_T *cap;
-{
-#ifdef FEAT_VISUAL
-    if (VIsual_active)	/* toggle Selection/Visual mode */
-    {
-	VIsual_select = !VIsual_select;
-	showmode();
-    }
-    else
-#endif
-	if (!checkclearop(cap->oap))
-	/* print full name if count given or :cd used */
-	fileinfo((int)cap->count0, FALSE, TRUE);
-}
-
-/*
- * Handle CTRL-H <Backspace> command.
- */
-    static void
-nv_ctrlh(cap)
-    cmdarg_T *cap;
-{
-#ifdef FEAT_VISUAL
-    if (VIsual_active && VIsual_select)
-    {
-	cap->cmdchar = 'x';	/* BS key behaves like 'x' in Select mode */
-	v_visop(cap);
-    }
-    else
-#endif
-	nv_left(cap);
-}
-
-/*
- * CTRL-L: clear screen and redraw.
- */
-    static void
-nv_clear(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearop(cap->oap))
-    {
-#if defined(__BEOS__) && !USE_THREAD_FOR_INPUT_WITH_TIMEOUT
-	/*
-	 * Right now, the BeBox doesn't seem to have an easy way to detect
-	 * window resizing, so we cheat and make the user detect it
-	 * manually with CTRL-L instead
-	 */
-	ui_get_shellsize();
-#endif
-#ifdef FEAT_SYN_HL
-	/* Clear all syntax states to force resyncing. */
-	syn_stack_free_all(curbuf);
-#endif
-	redraw_later(CLEAR);
-    }
-}
-
-/*
- * CTRL-O: In Select mode: switch to Visual mode for one command.
- * Otherwise: Go to older pcmark.
- */
-    static void
-nv_ctrlo(cap)
-    cmdarg_T	*cap;
-{
-#ifdef FEAT_VISUAL
-    if (VIsual_active && VIsual_select)
-    {
-	VIsual_select = FALSE;
-	showmode();
-	restart_VIsual_select = 2;	/* restart Select mode later */
-    }
-    else
-#endif
-    {
-	cap->count1 = -cap->count1;
-	nv_pcmark(cap);
-    }
-}
-
-/*
- * CTRL-^ command, short for ":e #"
- */
-    static void
-nv_hat(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearopq(cap->oap))
-	(void)buflist_getfile((int)cap->count0, (linenr_T)0,
-						GETF_SETMARK|GETF_ALT, FALSE);
-}
-
-/*
- * "Z" commands.
- */
-    static void
-nv_Zet(cap)
-    cmdarg_T *cap;
-{
-    if (!checkclearopq(cap->oap))
-    {
-	switch (cap->nchar)
-	{
-			/* "ZZ": equivalent to ":x". */
-	    case 'Z':	do_cmdline_cmd((char_u *)"x");
-			break;
-
-			/* "ZQ": equivalent to ":q!" (Elvis compatible). */
-	    case 'Q':	do_cmdline_cmd((char_u *)"q!");
-			break;
-
-	    default:	clearopbeep(cap->oap);
-	}
-    }
-}
-
-#if defined(FEAT_WINDOWS) || defined(PROTO)
-/*
- * Call nv_ident() as if "c1" was used, with "c2" as next character.
- */
-    void
-do_nv_ident(c1, c2)
-    int		c1;
-    int		c2;
-{
-    oparg_T	oa;
-    cmdarg_T	ca;
-
-    clear_oparg(&oa);
-    vim_memset(&ca, 0, sizeof(ca));
-    ca.oap = &oa;
-    ca.cmdchar = c1;
-    ca.nchar = c2;
-    nv_ident(&ca);
-}
-#endif
-
-/*
- * Handle the commands that use the word under the cursor.
- * [g] CTRL-]	:ta to current identifier
- * [g] 'K'	run program for current identifier
- * [g] '*'	/ to current identifier or string
- * [g] '#'	? to current identifier or string
- *  g  ']'	:tselect for current identifier
- */
-    static void
-nv_ident(cap)
-    cmdarg_T	*cap;
-{
-    char_u	*ptr = NULL;
-    char_u	*buf;
-    char_u	*p;
-    char_u	*kp;		/* value of 'keywordprg' */
-    int		kp_help;	/* 'keywordprg' is ":help" */
-    int		n = 0;		/* init for GCC */
-    int		cmdchar;
-    int		g_cmd;		/* "g" command */
-    char_u	*aux_ptr;
-    int		isman;
-    int		isman_s;
-
-    if (cap->cmdchar == 'g')	/* "g*", "g#", "g]" and "gCTRL-]" */
-    {
-	cmdchar = cap->nchar;
-	g_cmd = TRUE;
-    }
-    else
-    {
-	cmdchar = cap->cmdchar;
-	g_cmd = FALSE;
-    }
-
-    if (cmdchar == POUND)	/* the pound sign, '#' for English keyboards */
-	cmdchar = '#';
-
-    /*
-     * The "]", "CTRL-]" and "K" commands accept an argument in Visual mode.
-     */
-    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')
-    {
-#ifdef FEAT_VISUAL
-	if (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)
-	    return;
-#endif
-	if (checkclearopq(cap->oap))
-	    return;
-    }
-
-    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,
-		    (cmdchar == '*' || cmdchar == '#')
-				 ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)
-    {
-	clearop(cap->oap);
-	return;
-    }
-
-    /* Allocate buffer to put the command in.  Inserting backslashes can
-     * double the length of the word.  p_kp / curbuf->b_p_kp could be added
-     * and some numbers. */
-    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);
-    kp_help = (*kp == NUL || STRCMP(kp, ":he") == 0
-						 || STRCMP(kp, ":help") == 0);
-    buf = alloc((unsigned)(n * 2 + 30 + STRLEN(kp)));
-    if (buf == NULL)
-	return;
-    buf[0] = NUL;
-
-    switch (cmdchar)
-    {
-	case '*':
-	case '#':
-	    /*
-	     * Put cursor at start of word, makes search skip the word
-	     * under the cursor.
-	     * Call setpcmark() first, so "*``" puts the cursor back where
-	     * it was.
-	     */
-	    setpcmark();
-	    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());
-
-	    if (!g_cmd && vim_iswordp(ptr))
-		STRCPY(buf, "\\<");
-	    no_smartcase = TRUE;	/* don't use 'smartcase' now */
-	    break;
-
-	case 'K':
-	    if (kp_help)
-		STRCPY(buf, "he! ");
-	    else
-	    {
-		/* When a count is given, turn it into a range.  Is this
-		 * really what we want? */
-		isman = (STRCMP(kp, "man") == 0);
-		isman_s = (STRCMP(kp, "man -s") == 0);
-		if (cap->count0 != 0 && !(isman || isman_s))
-		    sprintf((char *)buf, ".,.+%ld", cap->count0 - 1);
-
-		STRCAT(buf, "! ");
-		if (cap->count0 == 0 && isman_s)
-		    STRCAT(buf, "man");
-		else
-		    STRCAT(buf, kp);
-		STRCAT(buf, " ");
-		if (cap->count0 != 0 && (isman || isman_s))
-		{
-		    sprintf((char *)buf + STRLEN(buf), "%ld", cap->count0);
-		    STRCAT(buf, " ");
-		}
-	    }
-	    break;
-
-	case ']':
-#ifdef FEAT_CSCOPE
-	    if (p_cst)
-		STRCPY(buf, "cstag ");
-	    else
-#endif
-		STRCPY(buf, "ts ");
-	    break;
-
-	default:
-	    if (curbuf->b_help)
-		STRCPY(buf, "he! ");
-	    else if (g_cmd)
-		STRCPY(buf, "tj ");
-	    else
-		STRCPY(buf, "ta ");
-    }
-
-    /*
-     * Now grab the chars in the identifier
-     */
-    if (cmdchar == '*')
-	aux_ptr = (char_u *)(p_magic ? "/.*~[^$\\" : "/^$\\");
-    else if (cmdchar == '#')
-	aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
-    else if (cmdchar == 'K' && !kp_help)
-	aux_ptr = (char_u *)" \t\\\"|!";
-    else
-	/* Don't escape spaces and Tabs in a tag with a backslash */
-	aux_ptr = (char_u *)"\\|\"";
-
-    p = buf + STRLEN(buf);
-    while (n-- > 0)
-    {
-	/* put a backslash before \ and some others */
-	if (vim_strchr(aux_ptr, *ptr) != NULL)
-	    *p++ = '\\';
-#ifdef FEAT_MBYTE
-	/* When current byte is a part of multibyte character, copy all bytes
-	 * of that character. */
-	if (has_mbyte)
-	{
-	    int i;
-	    int len = (*mb_ptr2len_check)(ptr) - 1;
-
-	    for (i = 0; i < len && n >= 1; ++i, --n)
-		*p++ = *ptr++;
-	}
-#endif
-	*p++ = *ptr++;
-    }
-    *p = NUL;
-
-    /*
-     * Execute the command.
-     */
-    if (cmdchar == '*' || cmdchar == '#')
-    {
-	if (!g_cmd && (
-#ifdef FEAT_MBYTE
-		has_mbyte ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr)) :
-#endif
-		vim_iswordc(ptr[-1])))
-	    STRCAT(buf, "\\>");
-#ifdef FEAT_CMDHIST
-	/* put pattern in search history */
-	add_to_history(HIST_SEARCH, buf, TRUE, NUL);
-#endif
-	normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0);
-    }
-    else
-	do_cmdline_cmd(buf);
-
-    vim_free(buf);
-}
-
-#ifdef FEAT_VISUAL
-/*
- * Get visually selected text, within one line only.
- * Returns FAIL if more than one line selected.
- */
-    static int
-get_visual_text(cap, pp, lenp)
-    cmdarg_T	*cap;
-    char_u	**pp;	    /* return: start of selected text */
-    int		*lenp;	    /* return: length of selected text */
-{
-    if (VIsual_mode != 'V')
-	unadjust_for_sel();
-    if (VIsual.lnum != curwin->w_cursor.lnum)
-    {
-	clearopbeep(cap->oap);
-	return FAIL;
-    }
-    if (VIsual_mode == 'V')
-    {
-	*pp = ml_get_curline();
-	*lenp = (int)STRLEN(*pp);
-    }
-    else
-    {
-	if (lt(curwin->w_cursor, VIsual))
-	{
-	    *pp = ml_get_pos(&curwin->w_cursor);
-	    *lenp = VIsual.col - curwin->w_cursor.col + 1;
-	}
-	else
-	{
-	    *pp = ml_get_pos(&VIsual);
-	    *lenp = curwin->w_cursor.col - VIsual.col + 1;
-	}
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	    /* Correct the length to include the whole last character. */
-	    *lenp += (*mb_ptr2len_check)(*pp + (*lenp - 1)) - 1;
-#endif
-    }
-    reset_VIsual_and_resel();
-    return OK;
-}
-#endif
-
-/*
- * CTRL-T: backwards in tag stack
- */
-    static void
-nv_tagpop(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearopq(cap->oap))
-	do_tag((char_u *)"", DT_POP, (int)cap->count1, FALSE, TRUE);
-}
-
-/*
- * Handle scrolling command 'H', 'L' and 'M'.
- */
-    static void
-nv_scroll(cap)
-    cmdarg_T  *cap;
-{
-    int		used = 0;
-    long	n;
-#ifdef FEAT_FOLDING
-    linenr_T	lnum;
-#endif
-    int		half;
-
-    cap->oap->motion_type = MLINE;
-    setpcmark();
-
-    if (cap->cmdchar == 'L')
-    {
-	validate_botline();	    /* make sure curwin->w_botline is valid */
-	curwin->w_cursor.lnum = curwin->w_botline - 1;
-	if (cap->count1 - 1 >= curwin->w_cursor.lnum)
-	    curwin->w_cursor.lnum = 1;
-	else
-	    curwin->w_cursor.lnum -= cap->count1 - 1;
-    }
-    else
-    {
-	if (cap->cmdchar == 'M')
-	{
-#ifdef FEAT_DIFF
-	    /* Don't count filler lines above the window. */
-	    used -= diff_check_fill(curwin, curwin->w_topline)
-							  - curwin->w_topfill;
-#endif
-	    validate_botline();	    /* make sure w_empty_rows is valid */
-	    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;
-	    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)
-	    {
-#ifdef FEAT_DIFF
-		/* Count half he number of filler lines to be "below this
-		 * line" and half to be "above the next line". */
-		if (n > 0 && used + diff_check_fill(curwin, curwin->w_topline
-							     + n) / 2 >= half)
-		{
-		    --n;
-		    break;
-		}
-#endif
-		used += plines(curwin->w_topline + n);
-		if (used >= half)
-		    break;
-#ifdef FEAT_FOLDING
-		if (hasFolding(curwin->w_topline + n, NULL, &lnum))
-		    n = lnum - curwin->w_topline;
-#endif
-	    }
-	    if (n > 0 && used > curwin->w_height)
-		--n;
-	}
-	else
-	    n = cap->count1 - 1;
-	curwin->w_cursor.lnum = curwin->w_topline + n;
-	if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
-	    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
-    }
-
-    cursor_correct();	/* correct for 'so' */
-    beginline(BL_SOL | BL_FIX);
-}
-
-/*
- * Cursor right commands.
- */
-    static void
-nv_right(cap)
-    cmdarg_T	*cap;
-{
-    long	n;
-#ifdef FEAT_VISUAL
-    int		PAST_LINE;
-#else
-# define PAST_LINE 0
-#endif
-
-    cap->oap->motion_type = MCHAR;
-    cap->oap->inclusive = FALSE;
-#ifdef FEAT_VISUAL
-    PAST_LINE = (VIsual_active && *p_sel != 'o');
-
-# ifdef FEAT_VIRTUALEDIT
-    /*
-     * In virtual mode, there's no such thing as "PAST_LINE", as lines are
-     * (theoretically) infinitly long.
-     */
-    if (virtual_active())
-	PAST_LINE = 0;
-# endif
-#endif
-
-    for (n = cap->count1; n > 0; --n)
-    {
-	if ((!PAST_LINE && oneright() == FAIL)
-		|| (PAST_LINE && *ml_get_cursor() == NUL))
-	{
-	    /*
-	     *	  <Space> wraps to next line if 'whichwrap' bit 1 set.
-	     *	      'l' wraps to next line if 'whichwrap' bit 2 set.
-	     * CURS_RIGHT wraps to next line if 'whichwrap' bit 3 set
-	     */
-	    if (       ((cap->cmdchar == ' '
-			    && vim_strchr(p_ww, 's') != NULL)
-			|| (cap->cmdchar == 'l'
-			    && vim_strchr(p_ww, 'l') != NULL)
-			|| (cap->cmdchar == K_RIGHT
-			    && vim_strchr(p_ww, '>') != NULL))
-		    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
-	    {
-		/* When deleting we also count the NL as a character.
-		 * Set cap->oap->inclusive when last char in the line is
-		 * included, move to next line after that */
-		if (	   (cap->oap->op_type == OP_DELETE
-			    || cap->oap->op_type == OP_CHANGE)
-			&& !cap->oap->inclusive
-			&& !lineempty(curwin->w_cursor.lnum))
-		    cap->oap->inclusive = TRUE;
-		else
-		{
-		    ++curwin->w_cursor.lnum;
-		    curwin->w_cursor.col = 0;
-#ifdef FEAT_VIRTUALEDIT
-		    curwin->w_cursor.coladd = 0;
-#endif
-		    curwin->w_set_curswant = TRUE;
-		    cap->oap->inclusive = FALSE;
-		}
-		continue;
-	    }
-	    if (cap->oap->op_type == OP_NOP)
-	    {
-		/* Only beep and flush if not moved at all */
-		if (n == cap->count1)
-		    beep_flush();
-	    }
-	    else
-	    {
-		if (!lineempty(curwin->w_cursor.lnum))
-		    cap->oap->inclusive = TRUE;
-	    }
-	    break;
-	}
-#ifdef FEAT_VISUAL
-	else if (PAST_LINE)
-	{
-	    curwin->w_set_curswant = TRUE;
-# ifdef FEAT_VIRTUALEDIT
-	    if (virtual_active())
-		oneright();
-	    else
-# endif
-	    {
-# ifdef FEAT_MBYTE
-		if (has_mbyte)
-		    curwin->w_cursor.col +=
-					 (*mb_ptr2len_check)(ml_get_cursor());
-		else
-# endif
-		    ++curwin->w_cursor.col;
-	    }
-	}
-#endif
-    }
-#ifdef FEAT_FOLDING
-    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped
-					       && cap->oap->op_type == OP_NOP)
-	foldOpenCursor();
-#endif
-}
-
-/*
- * Cursor left commands.
- *
- * Returns TRUE when operator end should not be adjusted.
- */
-    static void
-nv_left(cap)
-    cmdarg_T	*cap;
-{
-    long	n;
-
-    cap->oap->motion_type = MCHAR;
-    cap->oap->inclusive = FALSE;
-    for (n = cap->count1; n > 0; --n)
-    {
-	if (oneleft() == FAIL)
-	{
-	    /* <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.
-	     *		 'h' wraps to previous line if 'whichwrap' has 'h'.
-	     *	   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.
-	     */
-	    if (       (((cap->cmdchar == K_BS
-				|| cap->cmdchar == Ctrl_H)
-			    && vim_strchr(p_ww, 'b') != NULL)
-			|| (cap->cmdchar == 'h'
-			    && vim_strchr(p_ww, 'h') != NULL)
-			|| (cap->cmdchar == K_LEFT
-			    && vim_strchr(p_ww, '<') != NULL))
-		    && curwin->w_cursor.lnum > 1)
-	    {
-		--(curwin->w_cursor.lnum);
-		coladvance((colnr_T)MAXCOL);
-		curwin->w_set_curswant = TRUE;
-
-		/* When the NL before the first char has to be deleted we
-		 * put the cursor on the NUL after the previous line.
-		 * This is a very special case, be careful!
-		 * don't adjust op_end now, otherwise it won't work */
-		if (	   (cap->oap->op_type == OP_DELETE
-			    || cap->oap->op_type == OP_CHANGE)
-			&& !lineempty(curwin->w_cursor.lnum))
-		{
-		    ++curwin->w_cursor.col;
-		    cap->retval |= CA_NO_ADJ_OP_END;
-		}
-		continue;
-	    }
-	    /* Only beep and flush if not moved at all */
-	    else if (cap->oap->op_type == OP_NOP && n == cap->count1)
-		beep_flush();
-	    break;
-	}
-    }
-#ifdef FEAT_FOLDING
-    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped
-					       && cap->oap->op_type == OP_NOP)
-	foldOpenCursor();
-#endif
-}
-
-/*
- * Cursor up commands.
- * cap->arg is TRUE for "-": Move cursor to first non-blank.
- */
-    static void
-nv_up(cap)
-    cmdarg_T	*cap;
-{
-    cap->oap->motion_type = MLINE;
-    if (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)
-	clearopbeep(cap->oap);
-    else if (cap->arg)
-	beginline(BL_WHITE | BL_FIX);
-}
-
-/*
- * Cursor down commands.
- * cap->arg is TRUE for CR and "+": Move cursor to first non-blank.
- */
-    static void
-nv_down(cap)
-    cmdarg_T	*cap;
-{
-#if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-    /* In a quickfix window a <CR> jumps to the error under the cursor. */
-    if (bt_quickfix(curbuf) && cap->cmdchar == '\r')
-	do_cmdline_cmd((char_u *)".cc");
-    else
-#endif
-    {
-#ifdef FEAT_CMDWIN
-	/* In the cmdline window a <CR> executes the command. */
-	if (cmdwin_type != 0 && cap->cmdchar == '\r')
-	    cmdwin_result = CAR;
-	else
-#endif
-	{
-	    cap->oap->motion_type = MLINE;
-	    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)
-		clearopbeep(cap->oap);
-	    else if (cap->arg)
-		beginline(BL_WHITE | BL_FIX);
-	}
-    }
-}
-
-#ifdef FEAT_SEARCHPATH
-/*
- * Grab the file name under the cursor and edit it.
- */
-    static void
-nv_gotofile(cap)
-    cmdarg_T	*cap;
-{
-    char_u	*ptr;
-
-#ifdef FEAT_CMDWIN
-    if (cmdwin_type != 0)
-    {
-	clearopbeep(cap->oap);
-	return;
-    }
-#endif
-
-# ifdef FEAT_VISUAL
-    /*
-     * In Visual mode, use the selected text as a file name.
-     * Don't allow selection across multiple lines.
-     */
-    if (VIsual_active)
-    {
-	int	len;
-
-	if (get_visual_text(cap, &ptr, &len) == FAIL)
-	    return;
-	ptr = find_file_name_in_path(ptr, len,
-	       FNAME_MESS|FNAME_EXP|FNAME_REL, cap->count1, curbuf->b_ffname);
-    }
-    else
-# endif
-	ptr = file_name_at_cursor(FNAME_MESS|FNAME_HYP|FNAME_EXP|FNAME_REL,
-								 cap->count1);
-
-    if (ptr != NULL)
-    {
-	/* do autowrite if necessary */
-	if (curbufIsChanged() && curbuf->b_nwindows <= 1 && !P_HID(curbuf))
-	    autowrite(curbuf, FALSE);
-	setpcmark();
-	(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,
-					       P_HID(curbuf) ? ECMD_HIDE : 0);
-	vim_free(ptr);
-    }
-    else
-	clearop(cap->oap);
-}
-#endif
-
-/*
- * <End> command: to end of current line or last line.
- */
-    static void
-nv_end(cap)
-    cmdarg_T	*cap;
-{
-    if (cap->arg)	/* CTRL-END = goto last line */
-    {
-	nv_goto(cap);
-	cap->count1 = 1;		/* to end of current line */
-    }
-    nv_dollar(cap);
-}
-
-/*
- * Handle the "$" command.
- */
-    static void
-nv_dollar(cap)
-    cmdarg_T	*cap;
-{
-    cap->oap->motion_type = MCHAR;
-    cap->oap->inclusive = TRUE;
-#ifdef FEAT_VIRTUALEDIT
-    /* In virtual mode when off the edge of a line and an operator
-     * is pending (whew!) keep the cursor where it is.
-     * Otherwise, send it to the end of the line. */
-    if (!virtual_active() || gchar_cursor() != NUL
-					       || cap->oap->op_type == OP_NOP)
-#endif
-	curwin->w_curswant = MAXCOL;	/* so we stay at the end */
-    if (cursor_down((long)(cap->count1 - 1),
-					 cap->oap->op_type == OP_NOP) == FAIL)
-	clearopbeep(cap->oap);
-#ifdef FEAT_FOLDING
-    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)
-	foldOpenCursor();
-#endif
-}
-
-/*
- * Implementation of '?' and '/' commands.
- * If cap->arg is TRUE don't set PC mark.
- */
-    static void
-nv_search(cap)
-    cmdarg_T	    *cap;
-{
-    oparg_T	*oap = cap->oap;
-
-    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)
-    {
-	/* Translate "g??" to "g?g?" */
-	cap->cmdchar = 'g';
-	cap->nchar = '?';
-	nv_operator(cap);
-	return;
-    }
-
-    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0);
-
-    if (cap->searchbuf == NULL)
-    {
-	clearop(oap);
-	return;
-    }
-
-    normal_search(cap, cap->cmdchar, cap->searchbuf,
-						(cap->arg ? 0 : SEARCH_MARK));
-}
-
-/*
- * Handle "N" and "n" commands.
- * cap->arg is SEARCH_REV for "N", 0 for "n".
- */
-    static void
-nv_next(cap)
-    cmdarg_T	*cap;
-{
-    normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg);
-}
-
-/*
- * Search for "pat" in direction "dir" ('/' or '?', 0 for repeat).
- * Uses only cap->count1 and cap->oap from "cap".
- */
-    static void
-normal_search(cap, dir, pat, opt)
-    cmdarg_T	*cap;
-    int		dir;
-    char_u	*pat;
-    int		opt;		/* extra flags for do_search() */
-{
-    int		i;
-
-    cap->oap->motion_type = MCHAR;
-    cap->oap->inclusive = FALSE;
-    cap->oap->use_reg_one = TRUE;
-    curwin->w_set_curswant = TRUE;
-
-    i = do_search(cap->oap, dir, pat, cap->count1,
-				 opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG);
-    if (i == 0)
-	clearop(cap->oap);
-    else
-    {
-	if (i == 2)
-	    cap->oap->motion_type = MLINE;
-#ifdef FEAT_VIRTUALEDIT
-	curwin->w_cursor.coladd = 0;
-#endif
-#ifdef FEAT_FOLDING
-	if (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)
-	    foldOpenCursor();
-#endif
-    }
-
-    /* "/$" will put the cursor after the end of the line, may need to
-     * correct that here */
-    check_cursor();
-}
-
-/*
- * Character search commands.
- * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for
- * ',' and FALSE for ';'.
- * cap->nchar is NUL for ',' and ';' (repeat the search)
- */
-    static void
-nv_csearch(cap)
-    cmdarg_T	*cap;
-{
-    int		t_cmd;
-
-    if (cap->cmdchar == 't' || cap->cmdchar == 'T')
-	t_cmd = TRUE;
-    else
-	t_cmd = FALSE;
-
-    cap->oap->motion_type = MCHAR;
-    if (cap->arg == BACKWARD)
-	cap->oap->inclusive = FALSE;
-    else
-	cap->oap->inclusive = TRUE;
-    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)
-	clearopbeep(cap->oap);
-    else
-    {
-	curwin->w_set_curswant = TRUE;
-#ifdef FEAT_VIRTUALEDIT
-	/* Include a Tab for "tx" and for "dfx". */
-	if (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD
-		&& (t_cmd || cap->oap->op_type != OP_NOP))
-	{
-	    colnr_T	scol, ecol;
-
-	    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);
-	    curwin->w_cursor.coladd = ecol - scol;
-	}
-	else
-	    curwin->w_cursor.coladd = 0;
-#endif
-#ifdef FEAT_VISUAL
-	adjust_for_sel(cap);
-#endif
-#ifdef FEAT_FOLDING
-	if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)
-	    foldOpenCursor();
-#endif
-    }
-}
-
-/*
- * "[" and "]" commands.
- * cap->arg is BACKWARD for "[" and FORWARD for "]".
- */
-    static void
-nv_brackets(cap)
-    cmdarg_T	*cap;
-{
-    pos_T	new_pos;
-    pos_T	prev_pos;
-    pos_T	*pos = NULL;	    /* init for GCC */
-    pos_T	old_pos;	    /* cursor position before command */
-    int		flag;
-    long	n;
-    int		findc;
-    int		c;
-
-    cap->oap->motion_type = MCHAR;
-    cap->oap->inclusive = FALSE;
-    old_pos = curwin->w_cursor;
-#ifdef FEAT_VIRTUALEDIT
-    curwin->w_cursor.coladd = 0;	    /* TODO: don't do this for an error. */
-#endif
-
-#ifdef FEAT_SEARCHPATH
-    /*
-     * "[f" or "]f" : Edit file under the cursor (same as "gf")
-     */
-    if (cap->nchar == 'f')
-	nv_gotofile(cap);
-    else
-#endif
-
-#ifdef FEAT_FIND_ID
-    /*
-     * Find the occurence(s) of the identifier or define under cursor
-     * in current and included files or jump to the first occurence.
-     *
-     *			search	     list	    jump
-     *		      fwd   bwd    fwd	 bwd	 fwd	bwd
-     * identifier     "]i"  "[i"   "]I"  "[I"	"]^I"  "[^I"
-     * define	      "]d"  "[d"   "]D"  "[D"	"]^D"  "[^D"
-     */
-    if (vim_strchr((char_u *)
-#ifdef EBCDIC
-		"iI\005dD\067",
-#else
-		"iI\011dD\004",
-#endif
-		cap->nchar) != NULL)
-    {
-	char_u	*ptr;
-	int	len;
-
-	if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)
-	    clearop(cap->oap);
-	else
-	{
-	    find_pattern_in_path(ptr, 0, len, TRUE,
-		cap->count0 == 0 ? !isupper(cap->nchar) : FALSE,
-		((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,
-		cap->count1,
-		isupper(cap->nchar) ? ACTION_SHOW_ALL :
-			    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,
-		cap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,
-		(linenr_T)MAXLNUM);
-	    curwin->w_set_curswant = TRUE;
-	}
-    }
-    else
-#endif
-
-    /*
-     * "[{", "[(", "]}" or "])": go to Nth unclosed '{', '(', '}' or ')'
-     * "[#", "]#": go to start/end of Nth innermost #if..#endif construct.
-     * "[/", "[*", "]/", "]*": go to Nth comment start/end.
-     * "[m" or "]m" search for prev/next start of (Java) method.
-     * "[M" or "]M" search for prev/next end of (Java) method.
-     */
-    if (  (cap->cmdchar == '['
-		&& vim_strchr((char_u *)"{(*/#mM", cap->nchar) != NULL)
-	    || (cap->cmdchar == ']'
-		&& vim_strchr((char_u *)"})*/#mM", cap->nchar) != NULL))
-    {
-	if (cap->nchar == '*')
-	    cap->nchar = '/';
-	new_pos.lnum = 0;
-	prev_pos.lnum = 0;
-	if (cap->nchar == 'm' || cap->nchar == 'M')
-	{
-	    if (cap->cmdchar == '[')
-		findc = '{';
-	    else
-		findc = '}';
-	    n = 9999;
-	}
-	else
-	{
-	    findc = cap->nchar;
-	    n = cap->count1;
-	}
-	for ( ; n > 0; --n)
-	{
-	    if ((pos = findmatchlimit(cap->oap, findc,
-		(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)
-	    {
-		if (new_pos.lnum == 0)	/* nothing found */
-		{
-		    if (cap->nchar != 'm' && cap->nchar != 'M')
-			clearopbeep(cap->oap);
-		}
-		else
-		    pos = &new_pos;	/* use last one found */
-		break;
-	    }
-	    prev_pos = new_pos;
-	    curwin->w_cursor = *pos;
-	    new_pos = *pos;
-	}
-	curwin->w_cursor = old_pos;
-
-	/*
-	 * Handle "[m", "]m", "[M" and "[M".  The findmatchlimit() only
-	 * brought us to the match for "[m" and "]M" when inside a method.
-	 * Try finding the '{' or '}' we want to be at.
-	 * Also repeat for the given count.
-	 */
-	if (cap->nchar == 'm' || cap->nchar == 'M')
-	{
-	    /* norm is TRUE for "]M" and "[m" */
-	    int	    norm = ((findc == '{') == (cap->nchar == 'm'));
-
-	    n = cap->count1;
-	    /* found a match: we were inside a method */
-	    if (prev_pos.lnum != 0)
-	    {
-		pos = &prev_pos;
-		curwin->w_cursor = prev_pos;
-		if (norm)
-		    --n;
-	    }
-	    else
-		pos = NULL;
-	    while (n > 0)
-	    {
-		for (;;)
-		{
-		    if ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)
-		    {
-			/* if not found anything, that's an error */
-			if (pos == NULL)
-			    clearopbeep(cap->oap);
-			n = 0;
-			break;
-		    }
-		    c = gchar_cursor();
-		    if (c == '{' || c == '}')
-		    {
-			/* Must have found end/start of class: use it.
-			 * Or found the place to be at. */
-			if ((c == findc && norm) || (n == 1 && !norm))
-			{
-			    new_pos = curwin->w_cursor;
-			    pos = &new_pos;
-			    n = 0;
-			}
-			/* if no match found at all, we started outside of the
-			 * class and we're inside now.  Just go on. */
-			else if (new_pos.lnum == 0)
-			{
-			    new_pos = curwin->w_cursor;
-			    pos = &new_pos;
-			}
-			/* found start/end of other method: go to match */
-			else if ((pos = findmatchlimit(cap->oap, findc,
-			    (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,
-								  0)) == NULL)
-			    n = 0;
-			else
-			    curwin->w_cursor = *pos;
-			break;
-		    }
-		}
-		--n;
-	    }
-	    curwin->w_cursor = old_pos;
-	    if (pos == NULL && new_pos.lnum != 0)
-		clearopbeep(cap->oap);
-	}
-	if (pos != NULL)
-	{
-	    setpcmark();
-	    curwin->w_cursor = *pos;
-	    curwin->w_set_curswant = TRUE;
-#ifdef FEAT_FOLDING
-	    if ((fdo_flags & FDO_BLOCK) && KeyTyped
-					       && cap->oap->op_type == OP_NOP)
-		foldOpenCursor();
-#endif
-	}
-    }
-
-    /*
-     * "[[", "[]", "]]" and "][": move to start or end of function
-     */
-    else if (cap->nchar == '[' || cap->nchar == ']')
-    {
-	if (cap->nchar == cap->cmdchar)		    /* "]]" or "[[" */
-	    flag = '{';
-	else
-	    flag = '}';		    /* "][" or "[]" */
-
-	curwin->w_set_curswant = TRUE;
-	/*
-	 * Imitate strange Vi behaviour: When using "]]" with an operator
-	 * we also stop at '}'.
-	 */
-	if (!findpar(cap->oap, cap->arg, cap->count1, flag,
-	      (cap->oap->op_type != OP_NOP
-				      && cap->arg == FORWARD && flag == '{')))
-	    clearopbeep(cap->oap);
-	else
-	{
-	    if (cap->oap->op_type == OP_NOP)
-		beginline(BL_WHITE | BL_FIX);
-#ifdef FEAT_FOLDING
-	    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)
-		foldOpenCursor();
-#endif
-	}
-    }
-
-    /*
-     * "[p", "[P", "]P" and "]p": put with indent adjustment
-     */
-    else if (cap->nchar == 'p' || cap->nchar == 'P')
-    {
-	if (!checkclearopq(cap->oap))
-	{
-	    prep_redo_cmd(cap);
-	    do_put(cap->oap->regname,
-	      (cap->cmdchar == ']' && cap->nchar == 'p') ? FORWARD : BACKWARD,
-						  cap->count1, PUT_FIXINDENT);
-	}
-    }
-
-    /*
-     * "['", "[`", "]'" and "]`": jump to next mark
-     */
-    else if (cap->nchar == '\'' || cap->nchar == '`')
-    {
-	pos = &curwin->w_cursor;
-	for (n = cap->count1; n > 0; --n)
-	{
-	    prev_pos = *pos;
-	    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,
-							  cap->nchar == '\'');
-	    if (pos == NULL)
-		break;
-	}
-	if (pos == NULL)
-	    pos = &prev_pos;
-	nv_cursormark(cap, cap->nchar == '\'', pos);
-    }
-
-#ifdef FEAT_MOUSE
-    /*
-     * [ or ] followed by a middle mouse click: put selected text with
-     * indent adjustment.  Any other button just does as usual.
-     */
-    else if (cap->nchar >= K_LEFTMOUSE && cap->nchar <= K_RIGHTRELEASE)
-    {
-	(void)do_mouse(cap->oap, cap->nchar,
-		       (cap->cmdchar == ']') ? FORWARD : BACKWARD,
-		       cap->count1, PUT_FIXINDENT);
-    }
-#endif /* FEAT_MOUSE */
-
-#ifdef FEAT_FOLDING
-    /*
-     * "[z" and "]z": move to start or end of open fold.
-     */
-    else if (cap->nchar == 'z')
-    {
-	if (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,
-							 cap->count1) == FAIL)
-	    clearopbeep(cap->oap);
-    }
-#endif
-
-#ifdef FEAT_DIFF
-    /*
-     * "[c" and "]c": move to next or previous diff-change.
-     */
-    else if (cap->nchar == 'c')
-    {
-	if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,
-							 cap->count1) == FAIL)
-	    clearopbeep(cap->oap);
-    }
-#endif
-
-    /* Not a valid cap->nchar. */
-    else
-	clearopbeep(cap->oap);
-}
-
-/*
- * Handle Normal mode "%" command.
- */
-    static void
-nv_percent(cap)
-    cmdarg_T	*cap;
-{
-    pos_T	*pos;
-#ifdef FEAT_FOLDING
-    linenr_T	lnum = curwin->w_cursor.lnum;
-#endif
-
-    cap->oap->inclusive = TRUE;
-    if (cap->count0)	    /* {cnt}% : goto {cnt} percentage in file */
-    {
-	if (cap->count0 > 100)
-	    clearopbeep(cap->oap);
-	else
-	{
-	    cap->oap->motion_type = MLINE;
-	    setpcmark();
-	    /* Round up, so CTRL-G will give same value.  Watch out for a
-	     * large line count, the line number must not go negative! */
-	    if (curbuf->b_ml.ml_line_count > 1000000)
-		curwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)
-							 / 100L * cap->count0;
-	    else
-		curwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *
-						    cap->count0 + 99L) / 100L;
-	    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
-		curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
-	    beginline(BL_SOL | BL_FIX);
-	}
-    }
-    else		    /* "%" : go to matching paren */
-    {
-	cap->oap->motion_type = MCHAR;
-	cap->oap->use_reg_one = TRUE;
-	if ((pos = findmatch(cap->oap, NUL)) == NULL)
-	    clearopbeep(cap->oap);
-	else
-	{
-	    setpcmark();
-	    curwin->w_cursor = *pos;
-	    curwin->w_set_curswant = TRUE;
-#ifdef FEAT_VIRTUALEDIT
-	    curwin->w_cursor.coladd = 0;
-#endif
-#ifdef FEAT_VISUAL
-	    adjust_for_sel(cap);
-#endif
-	}
-    }
-#ifdef FEAT_FOLDING
-    if (cap->oap->op_type == OP_NOP
-	    && lnum != curwin->w_cursor.lnum
-	    && (fdo_flags & FDO_PERCENT)
-	    && KeyTyped)
-	foldOpenCursor();
-#endif
-}
-
-/*
- * Handle "(" and ")" commands.
- * cap->arg is BACKWARD for "(" and FORWARD for ")".
- */
-    static void
-nv_brace(cap)
-    cmdarg_T	*cap;
-{
-    cap->oap->motion_type = MCHAR;
-    cap->oap->use_reg_one = TRUE;
-    if (cap->cmdchar == ')')
-	cap->oap->inclusive = FALSE;
-    else
-	cap->oap->inclusive = TRUE;
-    curwin->w_set_curswant = TRUE;
-
-    if (findsent(cap->arg, cap->count1) == FAIL)
-	clearopbeep(cap->oap);
-    else
-    {
-#ifdef FEAT_VIRTUALEDIT
-	curwin->w_cursor.coladd = 0;
-#endif
-#ifdef FEAT_FOLDING
-	if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)
-	    foldOpenCursor();
-#endif
-    }
-}
-
-/*
- * "m" command: Mark a position.
- */
-    static void
-nv_mark(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearop(cap->oap))
-    {
-	if (setmark(cap->nchar) == FAIL)
-	    clearopbeep(cap->oap);
-    }
-}
-
-/*
- * "{" and "}" commands.
- * cmd->arg is BACKWARD for "{" and FORWARD for "}".
- */
-    static void
-nv_findpar(cap)
-    cmdarg_T	*cap;
-{
-    cap->oap->motion_type = MCHAR;
-    cap->oap->inclusive = FALSE;
-    cap->oap->use_reg_one = TRUE;
-    curwin->w_set_curswant = TRUE;
-    if (!findpar(cap->oap, cap->arg, cap->count1, NUL, FALSE))
-	clearopbeep(cap->oap);
-    else
-    {
-#ifdef FEAT_VIRTUALEDIT
-	curwin->w_cursor.coladd = 0;
-#endif
-#ifdef FEAT_FOLDING
-	if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)
-	    foldOpenCursor();
-#endif
-    }
-}
-
-/*
- * "u" command: Undo or make lower case.
- */
-    static void
-nv_undo(cap)
-    cmdarg_T	*cap;
-{
-    if (cap->oap->op_type == OP_LOWER
-#ifdef FEAT_VISUAL
-	    || VIsual_active
-#endif
-	    )
-    {
-	/* translate "<Visual>u" to "<Visual>gu" and "guu" to "gugu" */
-	cap->cmdchar = 'g';
-	cap->nchar = 'u';
-	nv_operator(cap);
-    }
-    else
-	nv_kundo(cap);
-}
-
-/*
- * <Undo> command.
- */
-    static void
-nv_kundo(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearopq(cap->oap))
-    {
-	u_undo((int)cap->count1);
-	curwin->w_set_curswant = TRUE;
-    }
-}
-
-/*
- * Handle the "r" command.
- */
-    static void
-nv_replace(cap)
-    cmdarg_T	*cap;
-{
-    char_u	*ptr;
-    int		had_ctrl_v;
-    long	n;
-
-    if (checkclearop(cap->oap))
-	return;
-
-    /* get another character */
-    if (cap->nchar == Ctrl_V)
-    {
-	had_ctrl_v = Ctrl_V;
-	cap->nchar = get_literal();
-	/* Don't redo a multibyte character with CTRL-V. */
-	if (cap->nchar > DEL)
-	    had_ctrl_v = NUL;
-    }
-    else
-	had_ctrl_v = NUL;
-
-#ifdef FEAT_VISUAL
-    /* Visual mode "r" */
-    if (VIsual_active)
-    {
-	nv_operator(cap);
-	return;
-    }
-#endif
-
-#ifdef FEAT_VIRTUALEDIT
-    /* Break tabs, etc. */
-    if (virtual_active())
-    {
-	if (u_save_cursor() == FAIL)
-	    return;
-	if (gchar_cursor() == NUL)
-	{
-	    /* Add extra space and put the cursor on the first one. */
-	    coladvance_force((colnr_T)(getviscol() + cap->count1));
-	    curwin->w_cursor.col -= cap->count1;
-	}
-	else if (gchar_cursor() == TAB)
-	    coladvance_force(getviscol());
-    }
-#endif
-
-    /*
-     * Check for a special key or not enough characters to replace.
-     */
-    ptr = ml_get_cursor();
-    if (IS_SPECIAL(cap->nchar) || STRLEN(ptr) < (unsigned)cap->count1
-#ifdef FEAT_MBYTE
-	    || (has_mbyte && mb_charlen(ptr) < cap->count1)
-#endif
-	    )
-    {
-	clearopbeep(cap->oap);
-	return;
-    }
-
-    /*
-     * Replacing with a TAB is done by edit() when it is complicated because
-     * 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.
-     * Other characters are done below to avoid problems with things like
-     * CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).
-     */
-    if (had_ctrl_v != Ctrl_V && cap->nchar == '\t' && (curbuf->b_p_et || p_sta))
-    {
-	stuffnumReadbuff(cap->count1);
-	stuffcharReadbuff('R');
-	stuffcharReadbuff('\t');
-	stuffcharReadbuff(ESC);
-	return;
-    }
-
-    /* save line for undo */
-    if (u_save_cursor() == FAIL)
-	return;
-
-    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\r' || cap->nchar == '\n'))
-    {
-	/*
-	 * Replace character(s) by a single newline.
-	 * Strange vi behaviour: Only one newline is inserted.
-	 * Delete the characters here.
-	 * Insert the newline with an insert command, takes care of
-	 * autoindent.	The insert command depends on being on the last
-	 * character of a line or not.
-	 */
-#ifdef FEAT_MBYTE
-	(void)del_chars(cap->count1, FALSE);	/* delete the characters */
-#else
-	(void)del_bytes(cap->count1, FALSE);	/* delete the characters */
-#endif
-	stuffcharReadbuff('\r');
-	stuffcharReadbuff(ESC);
-
-	/* Give 'r' to edit(), to get the redo command right. */
-	invoke_edit(cap, TRUE, 'r', FALSE);
-    }
-    else
-    {
-	prep_redo(cap->oap->regname, cap->count1,
-				       NUL, 'r', NUL, had_ctrl_v, cap->nchar);
-
-	curbuf->b_op_start = curwin->w_cursor;
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	{
-	    int		old_State = State;
-
-	    if (cap->ncharC1 != 0)
-		AppendCharToRedobuff(cap->ncharC1);
-	    if (cap->ncharC2 != 0)
-		AppendCharToRedobuff(cap->ncharC2);
-
-	    /* This is slow, but it handles replacing a single-byte with a
-	     * multi-byte and the other way around.  Also handles adding
-	     * composing characters for utf-8. */
-	    for (n = cap->count1; n > 0; --n)
-	    {
-		State = REPLACE;
-		ins_char(cap->nchar);
-		State = old_State;
-		if (cap->ncharC1 != 0)
-		    ins_char(cap->ncharC1);
-		if (cap->ncharC2 != 0)
-		    ins_char(cap->ncharC2);
-	    }
-	}
-	else
-#endif
-	{
-	    /*
-	     * Replace the characters within one line.
-	     */
-	    for (n = cap->count1; n > 0; --n)
-	    {
-		/*
-		 * Get ptr again, because u_save and/or showmatch() will have
-		 * released the line.  At the same time we let know that the
-		 * line will be changed.
-		 */
-		ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
-		ptr[curwin->w_cursor.col] = cap->nchar;
-		if (p_sm && msg_silent == 0)
-		    showmatch(cap->nchar);
-		++curwin->w_cursor.col;
-	    }
-#ifdef FEAT_NETBEANS_INTG
-	    if (usingNetbeans)
-	    {
-		colnr_T start = (colnr_T)(curwin->w_cursor.col - cap->count1);
-
-		netbeans_inserted(curbuf, curwin->w_cursor.lnum, start,
-			     (int)cap->count1, &ptr[start], (int)cap->count1);
-	    }
-#endif
-
-	    /* mark the buffer as changed and prepare for displaying */
-	    changed_bytes(curwin->w_cursor.lnum,
-			       (colnr_T)(curwin->w_cursor.col - cap->count1));
-	}
-	--curwin->w_cursor.col;	    /* cursor on the last replaced char */
-#ifdef FEAT_MBYTE
-	/* if the character on the left of the current cursor is a multi-byte
-	 * character, move two characters left */
-	if (has_mbyte)
-	    mb_adjust_cursor();
-#endif
-	curbuf->b_op_end = curwin->w_cursor;
-	curwin->w_set_curswant = TRUE;
-	set_last_insert(cap->nchar);
-    }
-}
-
-#ifdef FEAT_VISUAL
-/*
- * 'o': Exchange start and end of Visual area.
- * 'O': same, but in block mode exchange left and right corners.
- */
-    static void
-v_swap_corners(cmdchar)
-    int		cmdchar;
-{
-    pos_T	old_cursor;
-    colnr_T	left, right;
-
-    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)
-    {
-	old_cursor = curwin->w_cursor;
-	getvcols(curwin, &old_cursor, &VIsual, &left, &right);
-	curwin->w_cursor.lnum = VIsual.lnum;
-	coladvance(left);
-	VIsual = curwin->w_cursor;
-
-	curwin->w_cursor.lnum = old_cursor.lnum;
-	curwin->w_curswant = right;
-	/* 'selection "exclusive" and cursor at right-bottom corner: move it
-	 * right one column */
-	if (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')
-	    ++curwin->w_curswant;
-	coladvance(curwin->w_curswant);
-	if (curwin->w_cursor.col == old_cursor.col
-#ifdef FEAT_VIRTUALEDIT
-		&& (!virtual_active()
-		    || curwin->w_cursor.coladd == old_cursor.coladd)
-#endif
-		)
-	{
-	    curwin->w_cursor.lnum = VIsual.lnum;
-	    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')
-		++right;
-	    coladvance(right);
-	    VIsual = curwin->w_cursor;
-
-	    curwin->w_cursor.lnum = old_cursor.lnum;
-	    coladvance(left);
-	    curwin->w_curswant = left;
-	}
-    }
-    else
-    {
-	old_cursor = curwin->w_cursor;
-	curwin->w_cursor = VIsual;
-	VIsual = old_cursor;
-	curwin->w_set_curswant = TRUE;
-    }
-}
-#endif /* FEAT_VISUAL */
-
-/*
- * "R" (cap->arg is FALSE) and "gR" (cap->arg is TRUE).
- */
-    static void
-nv_Replace(cap)
-    cmdarg_T	    *cap;
-{
-#ifdef FEAT_VISUAL
-    if (VIsual_active)		/* "R" is replace lines */
-    {
-	cap->cmdchar = 'c';
-	cap->nchar = NUL;
-	VIsual_mode = 'V';
-	nv_operator(cap);
-    }
-    else
-#endif
-	if (!checkclearopq(cap->oap))
-    {
-	if (!curbuf->b_p_ma)
-	    EMSG(_(e_modifiable));
-	else
-	{
-#ifdef FEAT_VIRTUALEDIT
-	    if (virtual_active())
-		coladvance(getviscol());
-#endif
-	    invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);
-	}
-    }
-}
-
-#ifdef FEAT_VREPLACE
-/*
- * "gr".
- */
-    static void
-nv_vreplace(cap)
-    cmdarg_T	*cap;
-{
-# ifdef FEAT_VISUAL
-    if (VIsual_active)
-    {
-	cap->cmdchar = 'r';
-	cap->nchar = cap->extra_char;
-	nv_replace(cap);	/* Do same as "r" in Visual mode for now */
-    }
-    else
-# endif
-	if (!checkclearopq(cap->oap))
-    {
-	if (!curbuf->b_p_ma)
-	    EMSG(_(e_modifiable));
-	else
-	{
-	    if (cap->extra_char == Ctrl_V)	/* get another character */
-		cap->extra_char = get_literal();
-	    stuffcharReadbuff(cap->extra_char);
-	    stuffcharReadbuff(ESC);
-# ifdef FEAT_VIRTUALEDIT
-	    if (virtual_active())
-		coladvance(getviscol());
-# endif
-	    invoke_edit(cap, TRUE, 'v', FALSE);
-	}
-    }
-}
-#endif
-
-/*
- * Swap case for "~" command, when it does not work like an operator.
- */
-    static void
-n_swapchar(cap)
-    cmdarg_T	*cap;
-{
-    long	n;
-    pos_T	startpos;
-    int		did_change = 0;
-#ifdef FEAT_NETBEANS_INTG
-    pos_T	pos;
-    char_u	*ptr;
-    int		count;
-#endif
-
-    if (checkclearopq(cap->oap))
-	return;
-
-    if (lineempty(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)
-    {
-	clearopbeep(cap->oap);
-	return;
-    }
-
-    prep_redo_cmd(cap);
-
-    if (u_save_cursor() == FAIL)
-	return;
-
-    startpos = curwin->w_cursor;
-#ifdef FEAT_NETBEANS_INTG
-    pos = startpos;
-#endif
-    for (n = cap->count1; n > 0; --n)
-    {
-	did_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);
-	inc_cursor();
-	if (gchar_cursor() == NUL)
-	{
-	    if (vim_strchr(p_ww, '~') != NULL
-		    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
-	    {
-#ifdef FEAT_NETBEANS_INTG
-		if (usingNetbeans)
-		{
-		    if (did_change)
-		    {
-			ptr = ml_get(pos.lnum);
-			count = STRLEN(ptr) - pos.col;
-			netbeans_inserted(curbuf, pos.lnum, pos.col,
-						 count, &ptr[pos.col], count);
-		    }
-		    pos.col = 0;
-		    pos.lnum++;
-		}
-#endif
-		++curwin->w_cursor.lnum;
-		curwin->w_cursor.col = 0;
-		if (n > 1)
-		{
-		    if (u_savesub(curwin->w_cursor.lnum) == FAIL)
-			break;
-		    u_clearline();
-		}
-	    }
-	    else
-		break;
-	}
-    }
-#ifdef FEAT_NETBEANS_INTG
-    if (did_change && usingNetbeans)
-    {
-	ptr = ml_get(pos.lnum);
-	count = curwin->w_cursor.col - pos.col;
-	netbeans_inserted(curbuf, pos.lnum, pos.col,
-						 count, &ptr[pos.col], count);
-    }
-#endif
-
-
-    check_cursor();
-    curwin->w_set_curswant = TRUE;
-    if (did_change)
-    {
-	changed_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,
-									  0L);
-	curbuf->b_op_start = startpos;
-	curbuf->b_op_end = curwin->w_cursor;
-	if (curbuf->b_op_end.col > 0)
-	    --curbuf->b_op_end.col;
-    }
-}
-
-/*
- * Move cursor to mark.
- */
-    static void
-nv_cursormark(cap, flag, pos)
-    cmdarg_T	*cap;
-    int		flag;
-    pos_T	*pos;
-{
-    if (check_mark(pos) == FAIL)
-	clearop(cap->oap);
-    else
-    {
-	if (cap->cmdchar == '\''
-		|| cap->cmdchar == '`'
-		|| cap->cmdchar == '['
-		|| cap->cmdchar == ']')
-	    setpcmark();
-	curwin->w_cursor = *pos;
-	if (flag)
-	    beginline(BL_WHITE | BL_FIX);
-	else
-	    check_cursor();
-    }
-    cap->oap->motion_type = flag ? MLINE : MCHAR;
-    if (cap->cmdchar == '`')
-	cap->oap->use_reg_one = TRUE;
-    cap->oap->inclusive = FALSE;		/* ignored if not MCHAR */
-    curwin->w_set_curswant = TRUE;
-}
-
-#ifdef FEAT_VISUAL
-/*
- * Handle commands that are operators in Visual mode.
- */
-    static void
-v_visop(cap)
-    cmdarg_T	*cap;
-{
-    static char_u trans[] = "YyDdCcxdXdAAIIrr";
-
-    /* Uppercase means linewise, except in block mode, then "D" deletes till
-     * the end of the line, and "C" replaces til EOL */
-    if (isupper(cap->cmdchar))
-    {
-	if (VIsual_mode != Ctrl_V)
-	    VIsual_mode = 'V';
-	else if (cap->cmdchar == 'C' || cap->cmdchar == 'D')
-	    curwin->w_curswant = MAXCOL;
-    }
-    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);
-    nv_operator(cap);
-}
-#endif
-
-/*
- * "s" and "S" commands.
- */
-    static void
-nv_subst(cap)
-    cmdarg_T	*cap;
-{
-#ifdef FEAT_VISUAL
-    if (VIsual_active)	/* "vs" and "vS" are the same as "vc" */
-    {
-	if (cap->cmdchar == 'S')
-	    VIsual_mode = 'V';
-	cap->cmdchar = 'c';
-	nv_operator(cap);
-    }
-    else
-#endif
-	nv_optrans(cap);
-}
-
-/*
- * Abbreviated commands.
- */
-    static void
-nv_abbrev(cap)
-    cmdarg_T	*cap;
-{
-    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)
-	cap->cmdchar = 'x';		/* DEL key behaves like 'x' */
-
-#ifdef FEAT_VISUAL
-    /* in Visual mode these commands are operators */
-    if (VIsual_active)
-	v_visop(cap);
-    else
-#endif
-	nv_optrans(cap);
-}
-
-/*
- * Translate a command into another command.
- */
-    static void
-nv_optrans(cap)
-    cmdarg_T	*cap;
-{
-    static char_u *(ar[8]) = {(char_u *)"dl", (char_u *)"dh",
-			      (char_u *)"d$", (char_u *)"c$",
-			      (char_u *)"cl", (char_u *)"cc",
-			      (char_u *)"yy", (char_u *)":s\r"};
-    static char_u *str = (char_u *)"xXDCsSY&";
-
-    if (!checkclearopq(cap->oap))
-    {
-	if (cap->count0)
-	    stuffnumReadbuff(cap->count0);
-	stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);
-    }
-    cap->opcount = 0;
-}
-
-/*
- * "'" and "`" commands.  Also for "g'" and "g`".
- * cap->arg is TRUE for "'" and "g'".
- */
-    static void
-nv_gomark(cap)
-    cmdarg_T	*cap;
-{
-    pos_T	*pos;
-    int		c;
-#ifdef FEAT_FOLDING
-    linenr_T	lnum = curwin->w_cursor.lnum;
-    int		old_KeyTyped = KeyTyped;    /* getting file may reset it */
-#endif
-
-    if (cap->cmdchar == 'g')
-	c = cap->extra_char;
-    else
-	c = cap->nchar;
-    pos = getmark(c, (cap->oap->op_type == OP_NOP));
-    if (pos == (pos_T *)-1)	    /* jumped to other file */
-    {
-	if (cap->arg)
-	{
-	    check_cursor_lnum();
-	    beginline(BL_WHITE | BL_FIX);
-	}
-	else
-	    check_cursor();
-    }
-    else
-	nv_cursormark(cap, cap->arg, pos);
-
-#ifdef FEAT_VIRTUALEDIT
-    /* May need to clear the coladd that a mark includes. */
-    if (!virtual_active())
-	curwin->w_cursor.coladd = 0;
-#endif
-#ifdef FEAT_FOLDING
-    if (cap->oap->op_type == OP_NOP
-	    && (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)
-	    && (fdo_flags & FDO_MARK)
-	    && old_KeyTyped)
-	foldOpenCursor();
-#endif
-}
-
-/*
- * Handle CTRL-O, CTRL-I, "g;" and "g," commands.
- */
-    static void
-nv_pcmark(cap)
-    cmdarg_T	*cap;
-{
-#ifdef FEAT_JUMPLIST
-    pos_T	*pos;
-# ifdef FEAT_FOLDING
-    linenr_T	lnum = curwin->w_cursor.lnum;
-    int		old_KeyTyped = KeyTyped;    /* getting file may reset it */
-# endif
-
-    if (!checkclearopq(cap->oap))
-    {
-	if (cap->cmdchar == 'g')
-	    pos = movechangelist((int)cap->count1);
-	else
-	    pos = movemark((int)cap->count1);
-	if (pos == (pos_T *)-1)		/* jump to other file */
-	{
-	    curwin->w_set_curswant = TRUE;
-	    check_cursor();
-	}
-	else if (pos != NULL)		    /* can jump */
-	    nv_cursormark(cap, FALSE, pos);
-	else if (cap->cmdchar == 'g')
-	{
-	    if (curbuf->b_changelistlen == 0)
-		EMSG(_("E664: changelist is empty"));
-	    else if (cap->count1 < 0)
-		EMSG(_("E662: At start of changelist"));
-	    else
-		EMSG(_("E663: At end of changelist"));
-	}
-	else
-	    clearopbeep(cap->oap);
-# ifdef FEAT_FOLDING
-	if (cap->oap->op_type == OP_NOP
-		&& (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)
-		&& (fdo_flags & FDO_MARK)
-		&& old_KeyTyped)
-	    foldOpenCursor();
-# endif
-    }
-#else
-    clearopbeep(cap->oap);
-#endif
-}
-
-/*
- * Handle '"' command.
- */
-    static void
-nv_regname(cap)
-    cmdarg_T	*cap;
-{
-    if (checkclearop(cap->oap))
-	return;
-#ifdef FEAT_EVAL
-    if (cap->nchar == '=')
-	cap->nchar = get_expr_register();
-#endif
-    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))
-    {
-	cap->oap->regname = cap->nchar;
-	cap->opcount = cap->count0;	/* remember count before '"' */
-#ifdef FEAT_EVAL
-	set_reg_var(cap->oap->regname);
-#endif
-    }
-    else
-	clearopbeep(cap->oap);
-}
-
-#ifdef FEAT_VISUAL
-/*
- * Handle "v", "V" and "CTRL-V" commands.
- * Also for "gh", "gH" and "g^H" commands: Always start Select mode, cap->arg
- * is TRUE.
- */
-    static void
-nv_visual(cap)
-    cmdarg_T	*cap;
-{
-    /* 'v', 'V' and CTRL-V can be used while an operator is pending to make it
-     * characterwise, linewise, or blockwise. */
-    if (cap->oap->op_type != OP_NOP)
-    {
-	cap->oap->motion_force = cap->cmdchar;
-	finish_op = FALSE;	/* operator doesn't finish now but later */
-	return;
-    }
-
-    VIsual_select = cap->arg;
-    if (VIsual_active)	    /* change Visual mode */
-    {
-	if (VIsual_mode == cap->cmdchar)    /* stop visual mode */
-	    end_visual_mode();
-	else				    /* toggle char/block mode */
-	{				    /*	   or char/line mode */
-	    VIsual_mode = cap->cmdchar;
-	    showmode();
-	}
-	redraw_curbuf_later(INVERTED);	    /* update the inversion */
-    }
-    else		    /* start Visual mode */
-    {
-	check_visual_highlight();
-	if (cap->count0)		    /* use previously selected part */
-	{
-	    if (resel_VIsual_mode == NUL)   /* there is none */
-	    {
-		beep_flush();
-		return;
-	    }
-	    VIsual = curwin->w_cursor;
-
-	    VIsual_active = TRUE;
-	    VIsual_reselect = TRUE;
-	    if (!cap->arg)
-		/* start Select mode when 'selectmode' contains "cmd" */
-		may_start_select('c');
-#ifdef FEAT_MOUSE
-	    setmouse();
-#endif
-	    if (p_smd)
-		redraw_cmdline = TRUE;	    /* show visual mode later */
-	    /*
-	     * For V and ^V, we multiply the number of lines even if there
-	     * was only one -- webb
-	     */
-	    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)
-	    {
-		curwin->w_cursor.lnum +=
-				    resel_VIsual_line_count * cap->count0 - 1;
-		if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
-		    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
-	    }
-	    VIsual_mode = resel_VIsual_mode;
-	    if (VIsual_mode == 'v')
-	    {
-		if (resel_VIsual_line_count <= 1)
-		    curwin->w_cursor.col += resel_VIsual_col * cap->count0 - 1;
-		else
-		    curwin->w_cursor.col = resel_VIsual_col;
-		check_cursor_col();
-	    }
-	    if (resel_VIsual_col == MAXCOL)
-	    {
-		curwin->w_curswant = MAXCOL;
-		coladvance((colnr_T)MAXCOL);
-	    }
-	    else if (VIsual_mode == Ctrl_V)
-	    {
-		validate_virtcol();
-		curwin->w_curswant = curwin->w_virtcol
-					 + resel_VIsual_col * cap->count0 - 1;
-		coladvance(curwin->w_curswant);
-	    }
-	    else
-		curwin->w_set_curswant = TRUE;
-	    redraw_curbuf_later(INVERTED);	/* show the inversion */
-	}
-	else
-	{
-	    if (!cap->arg)
-		/* start Select mode when 'selectmode' contains "cmd" */
-		may_start_select('c');
-	    n_start_visual_mode(cap->cmdchar);
-	}
-    }
-}
-
-/*
- * Start selection for Shift-movement keys.
- */
-    void
-start_selection()
-{
-    /* if 'selectmode' contains "key", start Select mode */
-    may_start_select('k');
-    n_start_visual_mode('v');
-}
-
-/*
- * Start Select mode, if "c" is in 'selectmode' and not in a mapping or menu.
- */
-    void
-may_start_select(c)
-    int		c;
-{
-    VIsual_select = (stuff_empty() && typebuf_typed()
-		    && (vim_strchr(p_slm, c) != NULL));
-}
-
-/*
- * Start Visual mode "c".
- * Should set VIsual_select before calling this.
- */
-    static void
-n_start_visual_mode(c)
-    int		c;
-{
-    VIsual_mode = c;
-    VIsual_active = TRUE;
-    VIsual_reselect = TRUE;
-#ifdef FEAT_VIRTUALEDIT
-    /* Corner case: the 0 position in a tab may change when going into
-     * virtualedit.  Recalculate curwin->w_cursor to avoid bad hilighting.
-     */
-    if (c == Ctrl_V && (ve_flags & VE_BLOCK) && gchar_cursor() == TAB)
-	coladvance(curwin->w_virtcol);
-#endif
-    VIsual = curwin->w_cursor;
-
-#ifdef FEAT_FOLDING
-    foldAdjustVisual();
-#endif
-
-#ifdef FEAT_MOUSE
-    setmouse();
-#endif
-    if (p_smd)
-	redraw_cmdline = TRUE;	/* show visual mode later */
-#ifdef FEAT_CLIPBOARD
-    /* Make sure the clipboard gets updated.  Needed because start and
-     * end may still be the same, and the selection needs to be owned */
-    clip_star.vmode = NUL;
-#endif
-
-    /* Only need to redraw this line, unless still need to redraw an old
-     * Visual area (when 'lazyredraw' is set). */
-    if (curwin->w_redr_type < INVERTED)
-    {
-	curwin->w_old_cursor_lnum = curwin->w_cursor.lnum;
-	curwin->w_old_visual_lnum = curwin->w_cursor.lnum;
-    }
-}
-
-#endif /* FEAT_VISUAL */
-
-/*
- * CTRL-W: Window commands
- */
-    static void
-nv_window(cap)
-    cmdarg_T	*cap;
-{
-#ifdef FEAT_WINDOWS
-    if (!checkclearop(cap->oap))
-	do_window(cap->nchar, cap->count0, NUL); /* everything is in window.c */
-#else
-    (void)checkclearop(cap->oap);
-#endif
-}
-
-/*
- * CTRL-Z: Suspend
- */
-    static void
-nv_suspend(cap)
-    cmdarg_T	*cap;
-{
-    clearop(cap->oap);
-#ifdef FEAT_VISUAL
-    if (VIsual_active)
-	end_visual_mode();		/* stop Visual mode */
-#endif
-    do_cmdline_cmd((char_u *)"st");
-}
-
-/*
- * Commands starting with "g".
- */
-    static void
-nv_g_cmd(cap)
-    cmdarg_T	*cap;
-{
-    oparg_T	*oap = cap->oap;
-#ifdef FEAT_VISUAL
-    pos_T	tpos;
-#endif
-    int		i;
-    int		flag = FALSE;
-
-    switch (cap->nchar)
-    {
-#ifdef MEM_PROFILE
-    /*
-     * "g^A": dump log of used memory.
-     */
-    case Ctrl_A:
-	vim_mem_profile_dump();
-	break;
-#endif
-
-#ifdef FEAT_VREPLACE
-    /*
-     * "gR": Enter virtual replace mode.
-     */
-    case 'R':
-	cap->arg = TRUE;
-	nv_Replace(cap);
-	break;
-
-    case 'r':
-	nv_vreplace(cap);
-	break;
-#endif
-
-    case '&':
-	do_cmdline_cmd((char_u *)"%s//~/&");
-	break;
-
-#ifdef FEAT_VISUAL
-    /*
-     * "gv": Reselect the previous Visual area.  If Visual already active,
-     *	     exchange previous and current Visual area.
-     */
-    case 'v':
-	if (checkclearop(oap))
-	    break;
-
-	if (	   curbuf->b_visual_start.lnum == 0
-		|| curbuf->b_visual_start.lnum > curbuf->b_ml.ml_line_count
-		|| curbuf->b_visual_end.lnum == 0)
-	    beep_flush();
-	else
-	{
-	    /* set w_cursor to the start of the Visual area, tpos to the end */
-	    if (VIsual_active)
-	    {
-		i = VIsual_mode;
-		VIsual_mode = curbuf->b_visual_mode;
-		curbuf->b_visual_mode = i;
-# ifdef FEAT_EVAL
-		curbuf->b_visual_mode_eval = i;
-# endif
-		i = curwin->w_curswant;
-		curwin->w_curswant = curbuf->b_visual_curswant;
-		curbuf->b_visual_curswant = i;
-
-		tpos = curbuf->b_visual_end;
-		curbuf->b_visual_end = curwin->w_cursor;
-		curwin->w_cursor = curbuf->b_visual_start;
-		curbuf->b_visual_start = VIsual;
-	    }
-	    else
-	    {
-		VIsual_mode = curbuf->b_visual_mode;
-		curwin->w_curswant = curbuf->b_visual_curswant;
-		tpos = curbuf->b_visual_end;
-		curwin->w_cursor = curbuf->b_visual_start;
-	    }
-
-	    VIsual_active = TRUE;
-	    VIsual_reselect = TRUE;
-
-	    /* Set Visual to the start and w_cursor to the end of the Visual
-	     * area.  Make sure they are on an existing character. */
-	    check_cursor();
-	    VIsual = curwin->w_cursor;
-	    curwin->w_cursor = tpos;
-	    check_cursor();
-	    update_topline();
-	    /*
-	     * When called from normal "g" command: start Select mode when
-	     * 'selectmode' contains "cmd".  When called for K_SELECT, always
-	     * start Select mode.
-	     */
-	    if (cap->arg)
-		VIsual_select = TRUE;
-	    else
-		may_start_select('c');
-#ifdef FEAT_MOUSE
-	    setmouse();
-#endif
-#ifdef FEAT_CLIPBOARD
-	    /* Make sure the clipboard gets updated.  Needed because start and
-	     * end are still the same, and the selection needs to be owned */
-	    clip_star.vmode = NUL;
-#endif
-	    redraw_curbuf_later(INVERTED);
-	    showmode();
-	}
-	break;
-    /*
-     * "gV": Don't reselect the previous Visual area after a Select mode
-     *	     mapping of menu.
-     */
-    case 'V':
-	VIsual_reselect = FALSE;
-	break;
-
-    /*
-     * "gh":  start Select mode.
-     * "gH":  start Select line mode.
-     * "g^H": start Select block mode.
-     */
-    case K_BS:
-	cap->nchar = Ctrl_H;
-	/* FALLTHROUGH */
-    case 'h':
-    case 'H':
-    case Ctrl_H:
-# ifdef EBCDIC
-	/* EBCDIC: 'v'-'h' != '^v'-'^h' */
-	if (cap->nchar == Ctrl_H)
-	    cap->cmdchar = Ctrl_V;
-	else
-# endif
-	cap->cmdchar = cap->nchar + ('v' - 'h');
-	cap->arg = TRUE;
-	nv_visual(cap);
-	break;
-#endif /* FEAT_VISUAL */
-
-    /*
-     * "gj" and "gk" two new funny movement keys -- up and down
-     * movement based on *screen* line rather than *file* line.
-     */
-    case 'j':
-    case K_DOWN:
-	/* with 'nowrap' it works just like the normal "j" command; also when
-	 * in a closed fold */
-	if (!curwin->w_p_wrap
-#ifdef FEAT_FOLDING
-		|| hasFolding(curwin->w_cursor.lnum, NULL, NULL)
-#endif
-		)
-	{
-	    oap->motion_type = MLINE;
-	    i = cursor_down(cap->count1, oap->op_type == OP_NOP);
-	}
-	else
-	    i = nv_screengo(oap, FORWARD, cap->count1);
-	if (i == FAIL)
-	    clearopbeep(oap);
-	break;
-
-    case 'k':
-    case K_UP:
-	/* with 'nowrap' it works just like the normal "k" command; also when
-	 * in a closed fold */
-	if (!curwin->w_p_wrap
-#ifdef FEAT_FOLDING
-		|| hasFolding(curwin->w_cursor.lnum, NULL, NULL)
-#endif
-	   )
-	{
-	    oap->motion_type = MLINE;
-	    i = cursor_up(cap->count1, oap->op_type == OP_NOP);
-	}
-	else
-	    i = nv_screengo(oap, BACKWARD, cap->count1);
-	if (i == FAIL)
-	    clearopbeep(oap);
-	break;
-
-    /*
-     * "gJ": join two lines without inserting a space.
-     */
-    case 'J':
-	nv_join(cap);
-	break;
-
-    /*
-     * "g0", "g^" and "g$": Like "0", "^" and "$" but for screen lines.
-     * "gm": middle of "g0" and "g$".
-     */
-    case '^':
-	flag = TRUE;
-	/* FALLTHROUGH */
-
-    case '0':
-    case 'm':
-    case K_HOME:
-    case K_KHOME:
-    case K_XHOME:
-	oap->motion_type = MCHAR;
-	oap->inclusive = FALSE;
-	if (curwin->w_p_wrap
-#ifdef FEAT_VERTSPLIT
-		&& curwin->w_width != 0
-#endif
-		)
-	{
-	    int		width1 = W_WIDTH(curwin) - curwin_col_off();
-	    int		width2 = width1 + curwin_col_off2();
-
-	    validate_virtcol();
-	    i = 0;
-	    if (curwin->w_virtcol >= (colnr_T)width1 && width2 > 0)
-		i = (curwin->w_virtcol - width1) / width2 * width2 + width1;
-	}
-	else
-	    i = curwin->w_leftcol;
-	/* Go to the middle of the screen line.  When 'number' is on and lines
-	 * are wrapping the middle can be more to the left.*/
-	if (cap->nchar == 'm')
-	    i += (W_WIDTH(curwin) - curwin_col_off()
-		    + ((curwin->w_p_wrap && i > 0)
-			? curwin_col_off2() : 0)) / 2;
-	coladvance((colnr_T)i);
-	if (flag)
-	{
-	    do
-		i = gchar_cursor();
-	    while (vim_iswhite(i) && oneright() == OK);
-	}
-	curwin->w_set_curswant = TRUE;
-	break;
-
-    case '_':
-	/* "g_": to the last non-blank character in the line or <count> lines
-	 * downward. */
-	cap->oap->motion_type = MCHAR;
-	cap->oap->inclusive = TRUE;
-	curwin->w_curswant = MAXCOL;
-	if (cursor_down((long)(cap->count1 - 1),
-					 cap->oap->op_type == OP_NOP) == FAIL)
-	    clearopbeep(cap->oap);
-	else
-	{
-	    char_u  *ptr = ml_get_curline();
-
-	    /* In Visual mode we may end up after the line. */
-	    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)
-		--curwin->w_cursor.col;
-
-	    /* Decrease the cursor column until it's on a non-blank. */
-	    while (curwin->w_cursor.col > 0
-				    && vim_iswhite(ptr[curwin->w_cursor.col]))
-		--curwin->w_cursor.col;
-	    curwin->w_set_curswant = TRUE;
-	}
-	break;
-
-    case '$':
-    case K_END:
-    case K_KEND:
-    case K_XEND:
-	{
-	    int col_off = curwin_col_off();
-
-	    oap->motion_type = MCHAR;
-	    oap->inclusive = TRUE;
-	    if (curwin->w_p_wrap
-#ifdef FEAT_VERTSPLIT
-		    && curwin->w_width != 0
-#endif
-	       )
-	    {
-		curwin->w_curswant = MAXCOL;    /* so we stay at the end */
-		if (cap->count1 == 1)
-		{
-		    int		width1 = W_WIDTH(curwin) - col_off;
-		    int		width2 = width1 + curwin_col_off2();
-
-		    validate_virtcol();
-		    i = width1 - 1;
-		    if (curwin->w_virtcol >= (colnr_T)width1)
-			i += ((curwin->w_virtcol - width1) / width2 + 1)
-								     * width2;
-		    coladvance((colnr_T)i);
-#if defined(FEAT_LINEBREAK) || defined(FEAT_MBYTE)
-		    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)
-		    {
-			/*
-			 * Check for landing on a character that got split at
-			 * the end of the line.  We do not want to advance to
-			 * the next screen line.
-			 */
-			validate_virtcol();
-			if (curwin->w_virtcol > (colnr_T)i)
-			    --curwin->w_cursor.col;
-		    }
-#endif
-		}
-		else if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)
-		    clearopbeep(oap);
-	    }
-	    else
-	    {
-		i = curwin->w_leftcol + W_WIDTH(curwin) - col_off - 1;
-		coladvance((colnr_T)i);
-		curwin->w_set_curswant = TRUE;
-	    }
-	}
-	break;
-
-    /*
-     * "g*" and "g#", like "*" and "#" but without using "\<" and "\>"
-     */
-    case '*':
-    case '#':
-#if POUND != '#'
-    case POUND:		/* pound sign (sometimes equal to '#') */
-#endif
-    case Ctrl_RSB:		/* :tag or :tselect for current identifier */
-    case ']':			/* :tselect for current identifier */
-	nv_ident(cap);
-	break;
-
-    /*
-     * ge and gE: go back to end of word
-     */
-    case 'e':
-    case 'E':
-	oap->motion_type = MCHAR;
-	curwin->w_set_curswant = TRUE;
-	oap->inclusive = TRUE;
-	if (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)
-	    clearopbeep(oap);
-	break;
-
-    /*
-     * "g CTRL-G": display info about cursor position
-     */
-    case Ctrl_G:
-	cursor_pos_info();
-	break;
-
-    /*
-     * "gi": start Insert at the last position.
-     */
-    case 'i':
-	if (curbuf->b_last_insert.lnum != 0)
-	{
-	    curwin->w_cursor = curbuf->b_last_insert;
-	    check_cursor_lnum();
-	    i = (int)STRLEN(ml_get_curline());
-	    if (curwin->w_cursor.col > (colnr_T)i)
-	    {
-#ifdef FEAT_VIRTUALEDIT
-		if (virtual_active())
-		    curwin->w_cursor.coladd += curwin->w_cursor.col - i;
-#endif
-		curwin->w_cursor.col = i;
-	    }
-	}
-	cap->cmdchar = 'i';
-	nv_edit(cap);
-	break;
-
-    /*
-     * "gI": Start insert in column 1.
-     */
-    case 'I':
-	beginline(0);
-	if (!checkclearopq(oap))
-	    invoke_edit(cap, FALSE, 'g', FALSE);
-	break;
-
-#ifdef FEAT_SEARCHPATH
-    /*
-     * "gf": goto file, edit file under cursor
-     * "]f" and "[f": can also be used.
-     */
-    case 'f':
-	nv_gotofile(cap);
-	break;
-#endif
-
-	/* "g'm" and "g`m": jump to mark without setting pcmark */
-    case '\'':
-	cap->arg = TRUE;
-	/*FALLTHROUGH*/
-    case '`':
-	nv_gomark(cap);
-	break;
-
-    /*
-     * "gs": Goto sleep.
-     */
-    case 's':
-	do_sleep(cap->count1 * 1000L);
-	break;
-
-    /*
-     * "ga": Display the ascii value of the character under the
-     * cursor.	It is displayed in decimal, hex, and octal. -- webb
-     */
-    case 'a':
-	do_ascii(NULL);
-	break;
-
-#ifdef FEAT_MBYTE
-    /*
-     * "g8": Display the bytes used for the UTF-8 character under the
-     * cursor.	It is displayed in hex.
-     */
-    case '8':
-	show_utf8();
-	break;
-#endif
-
-    /*
-     * "gg": Goto the first line in file.  With a count it goes to
-     * that line number like for "G". -- webb
-     */
-    case 'g':
-	cap->arg = FALSE;
-	nv_goto(cap);
-	break;
-
-    /*
-     *	 Two-character operators:
-     *	 "gq"	    Format text
-     *	 "gw"	    Format text and keep cursor position
-     *	 "g~"	    Toggle the case of the text.
-     *	 "gu"	    Change text to lower case.
-     *	 "gU"	    Change text to upper case.
-     *   "g?"	    rot13 encoding
-     */
-    case 'q':
-    case 'w':
-	oap->cursor_start = curwin->w_cursor;
-	/*FALLTHROUGH*/
-    case '~':
-    case 'u':
-    case 'U':
-    case '?':
-	nv_operator(cap);
-	break;
-
-    /*
-     * "gd": Find first occurence of pattern under the cursor in the
-     *	 current function
-     * "gD": idem, but in the current file.
-     */
-    case 'd':
-    case 'D':
-	nv_gd(oap, cap->nchar);
-	break;
-
-#ifdef FEAT_MOUSE
-    /*
-     * g<*Mouse> : <C-*mouse>
-     */
-    case K_MIDDLEMOUSE:
-    case K_MIDDLEDRAG:
-    case K_MIDDLERELEASE:
-    case K_LEFTMOUSE:
-    case K_LEFTDRAG:
-    case K_LEFTRELEASE:
-    case K_RIGHTMOUSE:
-    case K_RIGHTDRAG:
-    case K_RIGHTRELEASE:
-    case K_X1MOUSE:
-    case K_X1DRAG:
-    case K_X1RELEASE:
-    case K_X2MOUSE:
-    case K_X2DRAG:
-    case K_X2RELEASE:
-	mod_mask = MOD_MASK_CTRL;
-	(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);
-	break;
-#endif
-
-    case K_IGNORE:
-	break;
-
-    /*
-     * "gP" and "gp": same as "P" and "p" but leave cursor just after new text
-     */
-    case 'p':
-    case 'P':
-	nv_put(cap);
-	break;
-
-#ifdef FEAT_BYTEOFF
-    /* "go": goto byte count from start of buffer */
-    case 'o':
-	goto_byte(cap->count0);
-	break;
-#endif
-
-    /* "gQ": improved Ex mode */
-    case 'Q':
-#ifdef FEAT_CMDWIN
-	if (cmdwin_type != 0)
-	{
-	    clearopbeep(cap->oap);
-	    break;
-	}
-#endif
-	if (!checkclearopq(oap))
-	    do_exmode(TRUE);
-	break;
-
-#ifdef FEAT_JUMPLIST
-    case ',':
-	nv_pcmark(cap);
-	break;
-
-    case ';':
-	cap->count1 = -cap->count1;
-	nv_pcmark(cap);
-	break;
-#endif
-
-    default:
-	clearopbeep(oap);
-	break;
-    }
-}
-
-/*
- * Handle "o" and "O" commands.
- */
-    static void
-n_opencmd(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearopq(cap->oap))
-    {
-#ifdef FEAT_FOLDING
-	if (cap->cmdchar == 'O')
-	    /* Open above the first line of a folded sequence of lines */
-	    (void)hasFolding(curwin->w_cursor.lnum,
-						&curwin->w_cursor.lnum, NULL);
-	else
-	    /* Open below the last line of a folded sequence of lines */
-	    (void)hasFolding(curwin->w_cursor.lnum,
-						NULL, &curwin->w_cursor.lnum);
-#endif
-	if (u_save((linenr_T)(curwin->w_cursor.lnum -
-					       (cap->cmdchar == 'O' ? 1 : 0)),
-		   (linenr_T)(curwin->w_cursor.lnum +
-					       (cap->cmdchar == 'o' ? 1 : 0))
-		       ) == OK
-		&& open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,
-#ifdef FEAT_COMMENTS
-		    has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM :
-#endif
-		    0, 0))
-	{
-	    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);
-	}
-    }
-}
-
-/*
- * "." command: redo last change.
- */
-    static void
-nv_dot(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearopq(cap->oap))
-    {
-	/*
-	 * If "restart_edit" is TRUE, the last but one command is repeated
-	 * instead of the last command (inserting text). This is used for
-	 * CTRL-O <.> in insert mode.
-	 */
-	if (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)
-	    clearopbeep(cap->oap);
-    }
-}
-
-/*
- * CTRL-R: undo undo
- */
-    static void
-nv_redo(cap)
-    cmdarg_T	*cap;
-{
-    if (!checkclearopq(cap->oap))
-    {
-	u_redo((int)cap->count1);
-	curwin->w_set_curswant = TRUE;
-    }
-}
-
-/*
- * Handle "U" command.
- */
-    static void
-nv_Undo(cap)
-    cmdarg_T	*cap;
-{
-    /* In Visual mode and typing "gUU" triggers an operator */
-    if (cap->oap->op_type == OP_UPPER
-#ifdef FEAT_VISUAL
-	    || VIsual_active
-#endif
-	    )
-    {
-	/* translate "gUU" to "gUgU" */
-	cap->cmdchar = 'g';
-	cap->nchar = 'U';
-	nv_operator(cap);
-    }
-    else if (!checkclearopq(cap->oap))
-    {
-	u_undoline();
-	curwin->w_set_curswant = TRUE;
-    }
-}
-
-/*
- * '~' command: If tilde is not an operator and Visual is off: swap case of a
- * single character.
- */
-    static void
-nv_tilde(cap)
-    cmdarg_T	*cap;
-{
-    if (!p_to
-#ifdef FEAT_VISUAL
-	    && !VIsual_active
-#endif
-	    && cap->oap->op_type != OP_TILDE)
-	n_swapchar(cap);
-    else
-	nv_operator(cap);
-}
-
-/*
- * Handle an operator command.
- * The actual work is done by do_pending_operator().
- */
-    static void
-nv_operator(cap)
-    cmdarg_T	*cap;
-{
-    int	    op_type;
-
-    op_type = get_op_type(cap->cmdchar, cap->nchar);
-
-    if (op_type == cap->oap->op_type)	    /* double operator works on lines */
-	nv_lineop(cap);
-    else if (!checkclearop(cap->oap))
-    {
-	cap->oap->start = curwin->w_cursor;
-	cap->oap->op_type = op_type;
-    }
-}
-
-/*
- * Handle linewise operator "dd", "yy", etc.
- *
- * "_" is is a strange motion command that helps make operators more logical.
- * It is actually implemented, but not documented in the real Vi.  This motion
- * command actually refers to "the current line".  Commands like "dd" and "yy"
- * are really an alternate form of "d_" and "y_".  It does accept a count, so
- * "d3_" works to delete 3 lines.
- */
-    static void
-nv_lineop(cap)
-    cmdarg_T	*cap;
-{
-    cap->oap->motion_type = MLINE;
-    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)
-	clearopbeep(cap->oap);
-    else if (  cap->oap->op_type == OP_DELETE
-	    || cap->oap->op_type == OP_LSHIFT
-	    || cap->oap->op_type == OP_RSHIFT)
-	beginline(BL_SOL | BL_FIX);
-    else if (cap->oap->op_type != OP_YANK)	/* 'Y' does not move cursor */
-	beginline(BL_WHITE | BL_FIX);
-}
-
-/*
- * <Home> command.
- */
-    static void
-nv_home(cap)
-    cmdarg_T	*cap;
-{
-    cap->count0 = 1;
-    nv_pipe(cap);
-}
-
-/*
- * "|" command.
- */
-    static void
-nv_pipe(cap)
-    cmdarg_T *cap;
-{
-    cap->oap->motion_type = MCHAR;
-    cap->oap->inclusive = FALSE;
-    beginline(0);
-    if (cap->count0 > 0)
-    {
-	coladvance((colnr_T)(cap->count0 - 1));
-	curwin->w_curswant = (colnr_T)(cap->count0 - 1);
-    }
-    else
-	curwin->w_curswant = 0;
-    /* keep curswant at the column where we wanted to go, not where
-       we ended; differs if line is too short */
-    curwin->w_set_curswant = FALSE;
-}
-
-/*
- * Handle back-word command "b" and "B".
- * cap->arg is 1 for "B"
- */
-    static void
-nv_bck_word(cap)
-    cmdarg_T	*cap;
-{
-    cap->oap->motion_type = MCHAR;
-    cap->oap->inclusive = FALSE;
-    curwin->w_set_curswant = TRUE;
-    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)
-	clearopbeep(cap->oap);
-#ifdef FEAT_FOLDING
-    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)
-	foldOpenCursor();
-#endif
-}
-
-/*
- * Handle word motion commands "e", "E", "w" and "W".
- * cap->arg is TRUE for "E" and "W".
- */
-    static void
-nv_wordcmd(cap)
-    cmdarg_T	*cap;
-{
-    int		n;
-    int		word_end;
-    int		flag = FALSE;
-
-    /*
-     * Set inclusive for the "E" and "e" command.
-     */
-    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')
-	word_end = TRUE;
-    else
-	word_end = FALSE;
-    cap->oap->inclusive = word_end;
-
-    /*
-     * "cw" and "cW" are a special case.
-     */
-    if (!word_end && cap->oap->op_type == OP_CHANGE)
-    {
-	n = gchar_cursor();
-	if (n != NUL)			/* not an empty line */
-	{
-	    if (vim_iswhite(n))
-	    {
-		/*
-		 * Reproduce a funny Vi behaviour: "cw" on a blank only
-		 * changes one character, not all blanks until the start of
-		 * the next word.  Only do this when the 'w' flag is included
-		 * in 'cpoptions'.
-		 */
-		if (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)
-		{
-		    cap->oap->inclusive = TRUE;
-		    cap->oap->motion_type = MCHAR;
-		    return;
-		}
-	    }
-	    else
-	    {
-		/*
-		 * This is a little strange. To match what the real Vi does,
-		 * we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided
-		 * that we are not on a space or a TAB.  This seems impolite
-		 * at first, but it's really more what we mean when we say
-		 * 'cw'.
-		 * Another strangeness: When standing on the end of a word
-		 * "ce" will change until the end of the next wordt, but "cw"
-		 * will change only one character! This is done by setting
-		 * flag.
-		 */
-		cap->oap->inclusive = TRUE;
-		word_end = TRUE;
-		flag = TRUE;
-	    }
-	}
-    }
-
-    cap->oap->motion_type = MCHAR;
-    curwin->w_set_curswant = TRUE;
-    if (word_end)
-	n = end_word(cap->count1, cap->arg, flag, FALSE);
-    else
-	n = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);
-
-    /* Don't leave the cursor on the NUL past a line */
-    if (curwin->w_cursor.col && gchar_cursor() == NUL)
-    {
-	--curwin->w_cursor.col;
-	cap->oap->inclusive = TRUE;
-    }
-
-    if (n == FAIL && cap->oap->op_type == OP_NOP)
-	clearopbeep(cap->oap);
-    else
-    {
-#ifdef FEAT_VISUAL
-	adjust_for_sel(cap);
-#endif
-#ifdef FEAT_FOLDING
-	if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)
-	    foldOpenCursor();
-#endif
-    }
-}
-
-/*
- * "0" and "^" commands.
- * cap->arg is the argument for beginline().
- */
-    static void
-nv_beginline(cap)
-    cmdarg_T	*cap;
-{
-    cap->oap->motion_type = MCHAR;
-    cap->oap->inclusive = FALSE;
-    beginline(cap->arg);
-#ifdef FEAT_FOLDING
-    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)
-	foldOpenCursor();
-#endif
-}
-
-#ifdef FEAT_VISUAL
-/*
- * In exclusive Visual mode, may include the last character.
- */
-    static void
-adjust_for_sel(cap)
-    cmdarg_T	*cap;
-{
-    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
-	    && gchar_cursor() != NUL && lt(VIsual, curwin->w_cursor))
-    {
-# ifdef FEAT_MBYTE
-	if (has_mbyte)
-	    inc_cursor();
-	else
-# endif
-	    ++curwin->w_cursor.col;
-	cap->oap->inclusive = FALSE;
-    }
-}
-
-/*
- * Exclude last character at end of Visual area for 'selection' == "exclusive".
- * Should check VIsual_mode before calling this.
- * Returns TRUE when backed up to the previous line.
- */
-    static int
-unadjust_for_sel()
-{
-    pos_T	*pp;
-
-    if (*p_sel == 'e' && !equalpos(VIsual, curwin->w_cursor))
-    {
-	if (lt(VIsual, curwin->w_cursor))
-	    pp = &curwin->w_cursor;
-	else
-	    pp = &VIsual;
-#ifdef FEAT_VIRTUALEDIT
-	if (pp->coladd > 0)
-	    --pp->coladd;
-	else
-#endif
-	if (pp->col > 0)
-	{
-	    --pp->col;
-#ifdef FEAT_MBYTE
-	    mb_adjustpos(pp);
-#endif
-	}
-	else if (pp->lnum > 1)
-	{
-	    --pp->lnum;
-	    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));
-	    return TRUE;
-	}
-    }
-    return FALSE;
-}
-
-/*
- * SELECT key in Normal or Visual mode: end of Select mode mapping.
- */
-    static void
-nv_select(cap)
-    cmdarg_T	*cap;
-{
-    if (VIsual_active)
-	VIsual_select = TRUE;
-    else if (VIsual_reselect)
-    {
-	cap->nchar = 'v';	    /* fake "gv" command */
-	cap->arg = TRUE;
-	nv_g_cmd(cap);
-    }
-}
-
-#endif
-
-/*
- * "G", "gg", CTRL-END, CTRL-HOME.
- * cap->arg is TRUE for "G".
- */
-    static void
-nv_goto(cap)
-    cmdarg_T	*cap;
-{
-    linenr_T	lnum;
-
-    if (cap->arg)
-	lnum = curbuf->b_ml.ml_line_count;
-    else
-	lnum = 1L;
-    cap->oap->motion_type = MLINE;
-    setpcmark();
-
-    /* When a count is given, use it instead of the default lnum */
-    if (cap->count0 != 0)
-	lnum = cap->count0;
-    if (lnum < 1L)
-	lnum = 1L;
-    else if (lnum > curbuf->b_ml.ml_line_count)
-	lnum = curbuf->b_ml.ml_line_count;
-    curwin->w_cursor.lnum = lnum;
-    beginline(BL_SOL | BL_FIX);
-#ifdef FEAT_FOLDING
-    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)
-	foldOpenCursor();
-#endif
-}
-
-/*
- * CTRL-\ in Normal mode.
- */
-    static void
-nv_normal(cap)
-    cmdarg_T	*cap;
-{
-    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)
-    {
-	clearop(cap->oap);
-	if (restart_edit != 0 && p_smd)
-	    clear_cmdline = TRUE;		/* unshow mode later */
-	restart_edit = 0;
-#ifdef FEAT_CMDWIN
-	if (cmdwin_type != 0)
-	    cmdwin_result = Ctrl_C;
-#endif
-#ifdef FEAT_VISUAL
-	if (VIsual_active)
-	{
-	    end_visual_mode();		/* stop Visual */
-	    redraw_curbuf_later(INVERTED);
-	}
-#endif
-	/* CTRL-\ CTRL-G restarts Insert mode when 'insertmode' is set. */
-	if (cap->nchar == Ctrl_G && p_im)
-	    restart_edit = 'a';
-    }
-    else
-	clearopbeep(cap->oap);
-}
-
-/*
- * ESC in Normal mode: beep, but don't flush buffers.
- * Don't even beep if we are canceling a command.
- */
-    static void
-nv_esc(cap)
-    cmdarg_T	*cap;
-{
-    int		no_reason;
-
-    no_reason = (cap->oap->op_type == OP_NOP
-		&& cap->opcount == 0
-		&& cap->count0 == 0
-		&& cap->oap->regname == 0
-		&& !p_im);
-
-    if (cap->arg)		/* TRUE for CTRL-C */
-    {
-	if (restart_edit == 0
-#ifdef FEAT_CMDWIN
-		&& cmdwin_type == 0
-#endif
-#ifdef FEAT_VISUAL
-		&& !VIsual_active
-#endif
-		&& no_reason)
-	    MSG(_("Type  :quit<Enter>  to exit Vim"));
-
-	/* Don't reset "restart_edit" when 'insertmode' is set, it won't be
-	 * set again below when halfway a mapping. */
-	if (!p_im)
-	    restart_edit = 0;
-#ifdef FEAT_CMDWIN
-	if (cmdwin_type != 0)
-	{
-	    cmdwin_result = K_IGNORE;
-	    got_int = FALSE;	/* don't stop executing autocommands et al. */
-	    return;
-	}
-#endif
-    }
-
-#ifdef FEAT_VISUAL
-    if (VIsual_active)
-    {
-	end_visual_mode();	/* stop Visual */
-	check_cursor_col();	/* make sure cursor is not beyond EOL */
-	curwin->w_set_curswant = TRUE;
-	redraw_curbuf_later(INVERTED);
-    }
-    else
-#endif
-	if (no_reason)
-	    vim_beep();
-    clearop(cap->oap);
-
-    /* A CTRL-C is often used at the start of a menu.  When 'insertmode' is
-     * set return to Insert mode afterwards. */
-    if (restart_edit == 0 && goto_im()
-#ifdef FEAT_EX_EXTRA
-	    && ex_normal_busy == 0
-#endif
-	    )
-	restart_edit = 'a';
-}
-
-/*
- * Handle "A", "a", "I", "i" and <Insert> commands.
- */
-    static void
-nv_edit(cap)
-    cmdarg_T *cap;
-{
-    /* <Insert> is equal to "i" */
-    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)
-	cap->cmdchar = 'i';
-
-#ifdef FEAT_VISUAL
-    /* in Visual mode "A" and "I" are an operator */
-    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))
-	v_visop(cap);
-
-    /* in Visual mode and after an operator "a" and "i" are for text objects */
-    else
-#endif
-	if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')
-	    && (cap->oap->op_type != OP_NOP
-#ifdef FEAT_VISUAL
-		|| VIsual_active
-#endif
-		))
-    {
-#ifdef FEAT_TEXTOBJ
-	nv_object(cap);
-#else
-	clearopbeep(cap->oap);
-#endif
-    }
-    else if (!curbuf->b_p_ma && !p_im)
-    {
-	/* Only give this error when 'insertmode' is off. */
-	EMSG(_(e_modifiable));
-	clearop(cap->oap);
-    }
-    else if (!checkclearopq(cap->oap))
-    {
-	switch (cap->cmdchar)
-	{
-	    case 'A':	/* "A"ppend after the line */
-		curwin->w_set_curswant = TRUE;
-#ifdef FEAT_VIRTUALEDIT
-		if (ve_flags == VE_ALL)
-		{
-		    int save_State = State;
-
-		    /* Pretent Insert mode here to allow the cursor on the
-		     * character past the end of the line */
-		    State = INSERT;
-		    coladvance((colnr_T)MAXCOL);
-		    State = save_State;
-		}
-		else
-#endif
-		    curwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());
-		break;
-
-	    case 'I':	/* "I"nsert before the first non-blank */
-		beginline(BL_WHITE);
-		break;
-
-	    case 'a':	/* "a"ppend is like "i"nsert on the next character. */
-#ifdef FEAT_VIRTUALEDIT
-		/* increment coladd when in virtual space, increment the
-		 * column otherwise, also to append after an unprintable char */
-		if (virtual_active()
-			&& (curwin->w_cursor.coladd > 0
-			    || *ml_get_cursor() == NUL
-			    || *ml_get_cursor() == TAB))
-		    curwin->w_cursor.coladd++;
-		else
-#endif
-		if (*ml_get_cursor() != NUL)
-		    inc_cursor();
-		break;
-	}
-
-#ifdef FEAT_VIRTUALEDIT
-	if (curwin->w_cursor.coladd && cap->cmdchar != 'A')
-	{
-	    int save_State = State;
-
-	    /* Pretent Insert mode here to allow the cursor on the
-	     * character past the end of the line */
-	    State = INSERT;
-	    coladvance(getviscol());
-	    State = save_State;
-	}
-#endif
-
-	invoke_edit(cap, FALSE, cap->cmdchar, FALSE);
-    }
-}
-
-/*
- * Invoke edit() and take care of "restart_edit" and the return value.
- */
-    static void
-invoke_edit(cap, repl, cmd, startln)
-    cmdarg_T	*cap;
-    int		repl;		/* "r" or "gr" command */
-    int		cmd;
-    int		startln;
-{
-    int		restart_edit_save = 0;
-
-    /* Complicated: When the user types "a<C-O>a" we don't want to do Insert
-     * mode recursively.  But when doing "a<C-O>." or "a<C-O>rx" we do allow
-     * it. */
-    if (repl || !stuff_empty())
-	restart_edit_save = restart_edit;
-    else
-	restart_edit_save = 0;
-
-    /* Always reset "restart_edit", this is not a restarted edit. */
-    restart_edit = 0;
-
-    if (edit(cmd, startln, cap->count1))
-	cap->retval |= CA_COMMAND_BUSY;
-
-    if (restart_edit == 0)
-	restart_edit = restart_edit_save;
-}
-
-#ifdef FEAT_TEXTOBJ
-/*
- * "a" or "i" while an operator is pending or in Visual mode: object motion.
- */
-    static void
-nv_object(cap)
-    cmdarg_T	*cap;
-{
-    int		flag;
-    int		include;
-    char_u	*mps_save;
-
-    if (cap->cmdchar == 'i')
-	include = FALSE;    /* "ix" = inner object: exclude white space */
-    else
-	include = TRUE;	    /* "ax" = an object: include white space */
-
-    /* Make sure (), [], {} and <> are in 'matchpairs' */
-    mps_save = curbuf->b_p_mps;
-    curbuf->b_p_mps = (char_u *)"(:),{:},[:],<:>";
-
-    switch (cap->nchar)
-    {
-	case 'w': /* "aw" = a word */
-		flag = current_word(cap->oap, cap->count1, include, FALSE);
-		break;
-	case 'W': /* "aW" = a WORD */
-		flag = current_word(cap->oap, cap->count1, include, TRUE);
-		break;
-	case 'b': /* "ab" = a braces block */
-	case '(':
-	case ')':
-		flag = current_block(cap->oap, cap->count1, include, '(', ')');
-		break;
-	case 'B': /* "aB" = a Brackets block */
-	case '{':
-	case '}':
-		flag = current_block(cap->oap, cap->count1, include, '{', '}');
-		break;
-	case '[': /* "a[" = a [] block */
-	case ']':
-		flag = current_block(cap->oap, cap->count1, include, '[', ']');
-		break;
-	case '<': /* "a<" = a <> block */
-	case '>':
-		flag = current_block(cap->oap, cap->count1, include, '<', '>');
-		break;
-	case 'p': /* "ap" = a paragraph */
-		flag = current_par(cap->oap, cap->count1, include, 'p');
-		break;
-	case 's': /* "as" = a sentence */
-		flag = current_sent(cap->oap, cap->count1, include);
-		break;
-#if 0	/* TODO */
-	case 'S': /* "aS" = a section */
-	case 'f': /* "af" = a filename */
-	case 'u': /* "au" = a URL */
-#endif
-	default:
-		flag = FAIL;
-		break;
-    }
-
-    curbuf->b_p_mps = mps_save;
-    if (flag == FAIL)
-	clearopbeep(cap->oap);
-    adjust_cursor_col();
-    curwin->w_set_curswant = TRUE;
-}
-#endif
-
-/*
- * "q" command: Start/stop recording.
- * "q:", "q/", "q?": edit command-line in command-line window.
- */
-    static void
-nv_record(cap)
-    cmdarg_T	*cap;
-{
-    if (cap->oap->op_type == OP_FORMAT)
-    {
-	/* "gqq" is the same as "gqgq": format line */
-	cap->cmdchar = 'g';
-	cap->nchar = 'q';
-	nv_operator(cap);
-    }
-    else if (!checkclearop(cap->oap))
-    {
-#ifdef FEAT_CMDWIN
-	if (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')
-	{
-	    stuffcharReadbuff(cap->nchar);
-	    stuffcharReadbuff(K_CMDWIN);
-	}
-	else
-#endif
-	    /* (stop) recording into a named register, unless executing a
-	     * register */
-	    if (!Exec_reg && do_record(cap->nchar) == FAIL)
-		clearopbeep(cap->oap);
-    }
-}
-
-/*
- * Handle the "@r" command.
- */
-    static void
-nv_at(cap)
-    cmdarg_T	*cap;
-{
-    if (checkclearop(cap->oap))
-	return;
-#ifdef FEAT_EVAL
-    if (cap->nchar == '=')
-    {
-	if (get_expr_register() == NUL)
-	    return;
-    }
-#endif
-    while (cap->count1-- && !got_int)
-    {
-	if (do_execreg(cap->nchar, FALSE, FALSE) == FAIL)
-	{
-	    clearopbeep(cap->oap);
-	    break;
-	}
-	line_breakcheck();
-    }
-}
-
-/*
- * Handle the CTRL-U and CTRL-D commands.
- */
-    static void
-nv_halfpage(cap)
-    cmdarg_T	*cap;
-{
-    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)
-	    || (cap->cmdchar == Ctrl_D
-		&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))
-	clearopbeep(cap->oap);
-    else if (!checkclearop(cap->oap))
-	halfpage(cap->cmdchar == Ctrl_D, cap->count0);
-}
-
-/*
- * Handle "J" or "gJ" command.
- */
-    static void
-nv_join(cap)
-    cmdarg_T *cap;
-{
-#ifdef FEAT_VISUAL
-    if (VIsual_active)	/* join the visual lines */
-	nv_operator(cap);
-    else
-#endif
-	if (!checkclearop(cap->oap))
-    {
-	if (cap->count0 <= 1)
-	    cap->count0 = 2;	    /* default for join is two lines! */
-	if (curwin->w_cursor.lnum + cap->count0 - 1 >
-						   curbuf->b_ml.ml_line_count)
-	    clearopbeep(cap->oap);  /* beyond last line */
-	else
-	{
-	    prep_redo(cap->oap->regname, cap->count0,
-			 NUL, cap->cmdchar, NUL, NUL, cap->nchar);
-	    do_do_join(cap->count0, cap->nchar == NUL);
-	}
-    }
-}
-
-/*
- * "P", "gP", "p" and "gp" commands.
- */
-    static void
-nv_put(cap)
-    cmdarg_T  *cap;
-{
-#ifdef FEAT_VISUAL
-    int		regname = 0;
-    void	*reg1 = NULL, *reg2 = NULL;
-#endif
-    int		dir;
-    int		flags = 0;
-
-    if (cap->oap->op_type != OP_NOP)
-    {
-#ifdef FEAT_DIFF
-	/* "dp" is ":diffput" */
-	if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')
-	{
-	    clearop(cap->oap);
-	    nv_diffgetput(TRUE);
-	}
-	else
-#endif
-	clearopbeep(cap->oap);
-    }
-    else
-    {
-	dir = (cap->cmdchar == 'P'
-		|| (cap->cmdchar == 'g' && cap->nchar == 'P'))
-							 ? BACKWARD : FORWARD;
-	prep_redo_cmd(cap);
-	if (cap->cmdchar == 'g')
-	    flags |= PUT_CURSEND;
-
-#ifdef FEAT_VISUAL
-	if (VIsual_active)
-	{
-	    /* Putting in Visual mode: The put text replaces the selected
-	     * text.  First delete the selected text, then put the new text.
-	     * Need to save and restore the registers that the delete
-	     * overwrites if the old contents is being put.
-	     */
-	    regname = cap->oap->regname;
-# ifdef FEAT_CLIPBOARD
-	    adjust_clip_reg(&regname);
-# endif
-	    if (regname == 0 || VIM_ISDIGIT(regname)
-# ifdef FEAT_CLIPBOARD
-		    || (clip_unnamed && (regname == '*' || regname == '+'))
-# endif
-
-		    )
-	    {
-		/* the delete is going to overwrite the register we want to
-		 * put, save it first. */
-		reg1 = get_register(regname, TRUE);
-	    }
-
-	    /* Now delete the selected text. */
-	    cap->cmdchar = 'd';
-	    cap->nchar = NUL;
-	    cap->oap->regname = NUL;
-	    nv_operator(cap);
-	    do_pending_operator(cap, 0, FALSE);
-
-	    /* delete PUT_LINE_BACKWARD; */
-	    cap->oap->regname = regname;
-
-	    if (reg1 != NULL)
-	    {
-		/* Delete probably changed the register we want to put, save
-		 * it first. Then put back what was there before the delete. */
-		reg2 = get_register(regname, FALSE);
-		put_register(regname, reg1);
-	    }
-
-	    /* When deleted a linewise Visual area, put the register as
-	     * lines to avoid it joined with the next line.  When deletion was
-	     * characterwise, split a line when putting lines. */
-	    if (VIsual_mode == 'V')
-		flags |= PUT_LINE;
-	    else if (VIsual_mode == 'v')
-		flags |= PUT_LINE_SPLIT;
-	    if (VIsual_mode == Ctrl_V && dir == FORWARD)
-		flags |= PUT_LINE_FORWARD;
-	    dir = BACKWARD;
-	    if ((VIsual_mode != 'V'
-			&& curwin->w_cursor.col < curbuf->b_op_start.col)
-		    || (VIsual_mode == 'V'
-			&& curwin->w_cursor.lnum < curbuf->b_op_start.lnum))
-		/* cursor is at the end of the line or end of file, put
-		 * forward. */
-		dir = FORWARD;
-	}
-#endif
-	do_put(cap->oap->regname, dir, cap->count1, flags);
-
-#ifdef FEAT_VISUAL
-	/* If a register was saved, put it back now. */
-	if (reg2 != NULL)
-	    put_register(regname, reg2);
-#endif
-	auto_format(FALSE, TRUE);
-    }
-}
-
-/*
- * "o" and "O" commands.
- */
-    static void
-nv_open(cap)
-    cmdarg_T	*cap;
-{
-#ifdef FEAT_DIFF
-    /* "do" is ":diffget" */
-    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')
-    {
-	clearop(cap->oap);
-	nv_diffgetput(FALSE);
-    }
-    else
-#endif
-#ifdef FEAT_VISUAL
-    if (VIsual_active)  /* switch start and end of visual */
-	v_swap_corners(cap->cmdchar);
-    else
-#endif
-	n_opencmd(cap);
-}
-
-#ifdef FEAT_SNIFF
-/*ARGSUSED*/
-    static void
-nv_sniff(cap)
-    cmdarg_T	*cap;
-{
-    ProcessSniffRequests();
-}
-#endif
-
-#ifdef FEAT_NETBEANS_INTG
-    static void
-nv_nbcmd(cap)
-    cmdarg_T	*cap;
-{
-    netbeans_keycommand(cap->nchar);
-}
-#endif
-
-#ifdef FEAT_DND
-/*ARGSUSED*/
-    static void
-nv_drop(cap)
-    cmdarg_T	*cap;
-{
-    do_put('~', BACKWARD, 1L, PUT_CURSEND);
-}
-#endif
diff -Nur vim63/src/option.c.orig vim63-bonobo/src/option.c.orig
--- vim63/src/option.c.orig	2005-09-09 20:11:09.823870000 +0200
+++ vim63-bonobo/src/option.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,9405 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-
-/*
- * Code to handle user-settable options. This is all pretty much table-
- * driven. Checklist for adding a new option:
- * - Put it in the options array below (copy an existing entry).
- * - For a global option: Add a variable for it in option.h.
- * - For a buffer or window local option:
- *   - Add a PV_XX entry to the enum below.
- *   - Add a variable to the window or buffer struct in structs.h.
- *   - For a window option, add some code to copy_winopt().
- *   - For a buffer option, add some code to buf_copy_options().
- *   - For a buffer string option, add code to check_buf_options().
- * - If it's a numeric option, add any necessary bounds checks to do_set().
- * - If it's a list of flags, add some code in do_set(), search for WW_ALL.
- * - When adding an option with expansion (P_EXPAND), but with a different
- *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.
- * - Add documentation!  One line in doc/help.txt, full description in
- *   options.txt, and any other related places.
- * - Add an entry in runtime/optwin.vim.
- * When making changes:
- * - Adjust the help for the option in doc/option.txt.
- * - When an entry has the P_VIM flag, or is lacking the P_VI_DEF flag, add a
- *   comment at the help for the 'compatible' option.
- */
-
-#define IN_OPTION_C
-#include "vim.h"
-
-/*
- * The options that are local to a window or buffer have "indir" set to one of
- * these values.  Special values:
- * PV_NONE: global option.
- * PV_BOTH is added: global option which also has a local value.
- */
-#define PV_BOTH 0x1000
-#define OPT_BOTH(x) (idopt_T)(PV_BOTH + (int)(x))
-
-typedef enum
-{
-    PV_NONE = 0
-    , PV_AI
-    , PV_AR
-    , PV_ARAB
-    , PV_BH
-    , PV_BIN
-    , PV_BL
-    , PV_BOMB
-    , PV_BT
-    , PV_CI
-    , PV_CIN
-    , PV_CINK
-    , PV_CINO
-    , PV_CINW
-    , PV_CMS
-    , PV_COM
-    , PV_CPT
-    , PV_DEF
-    , PV_DICT
-    , PV_DIFF
-    , PV_EFM
-    , PV_EOL
-    , PV_EP
-    , PV_ET
-    , PV_FDC
-    , PV_FDE
-    , PV_FDI
-    , PV_FDL
-    , PV_FDM
-    , PV_FDN
-    , PV_FDT
-    , PV_FEN
-    , PV_FENC
-    , PV_FF
-    , PV_FML
-    , PV_FMR
-    , PV_FO
-    , PV_FT
-    , PV_GP
-    , PV_IMI
-    , PV_IMS
-    , PV_INC
-    , PV_INDE
-    , PV_INDK
-    , PV_INEX
-    , PV_INF
-    , PV_ISK
-    , PV_KEY
-    , PV_KMAP
-    , PV_KP
-    , PV_LBR
-    , PV_LISP
-    , PV_LIST
-    , PV_MA
-    , PV_ML
-    , PV_MOD
-    , PV_MP
-    , PV_MPS
-    , PV_NF
-    , PV_NU
-    , PV_OFT
-    , PV_PATH
-    , PV_PI
-    , PV_PVW
-    , PV_RL
-    , PV_RLC
-    , PV_RO
-    , PV_SCBIND
-    , PV_SCROLL
-    , PV_SI
-    , PV_SN
-    , PV_STS
-    , PV_SUA
-    , PV_SW
-    , PV_SWF
-    , PV_SYN
-    , PV_TAGS
-    , PV_TS
-    , PV_TSR
-    , PV_TW
-    , PV_TX
-    , PV_WFH
-    , PV_WM
-    , PV_WRAP
-} idopt_T;
-
-/*
- * Options local to a window have a value local to a buffer and global to all
- * buffers.  Indicate this by setting "var" to VAR_WIN.
- */
-#define VAR_WIN ((char_u *)-1)
-
-/*
- * These the global values for options which are also local to a buffer.
- * Only to be used in option.c!
- */
-static int	p_ai;
-static int	p_bin;
-#ifdef FEAT_MBYTE
-static int	p_bomb;
-#endif
-#if defined(FEAT_QUICKFIX)
-static char_u	*p_bh;
-static char_u	*p_bt;
-#endif
-static int	p_bl;
-static int	p_ci;
-#ifdef FEAT_CINDENT
-static int	p_cin;
-static char_u	*p_cink;
-static char_u	*p_cino;
-#endif
-#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
-static char_u	*p_cinw;
-#endif
-#ifdef FEAT_COMMENTS
-static char_u	*p_com;
-#endif
-#ifdef FEAT_FOLDING
-static char_u	*p_cms;
-#endif
-#ifdef FEAT_INS_EXPAND
-static char_u	*p_cpt;
-#endif
-static int	p_eol;
-static int	p_et;
-#ifdef FEAT_MBYTE
-static char_u	*p_fenc;
-#endif
-static char_u	*p_ff;
-static char_u	*p_fo;
-#ifdef FEAT_AUTOCMD
-static char_u	*p_ft;
-#endif
-static long	p_iminsert;
-static long	p_imsearch;
-#if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
-static char_u	*p_inex;
-#endif
-#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
-static char_u	*p_inde;
-static char_u	*p_indk;
-#endif
-static int	p_inf;
-static char_u	*p_isk;
-#ifdef FEAT_CRYPT
-static char_u	*p_key;
-#endif
-#ifdef FEAT_LISP
-static int	p_lisp;
-#endif
-static int	p_ml;
-static int	p_ma;
-static int	p_mod;
-static char_u	*p_mps;
-static char_u	*p_nf;
-#ifdef FEAT_OSFILETYPE
-static char_u	*p_oft;
-#endif
-static int	p_pi;
-static int	p_ro;
-#ifdef FEAT_SMARTINDENT
-static int	p_si;
-#endif
-#ifndef SHORT_FNAME
-static int	p_sn;
-#endif
-static long	p_sts;
-#if defined(FEAT_SEARCHPATH)
-static char_u	*p_sua;
-#endif
-static long	p_sw;
-static int	p_swf;
-#ifdef FEAT_SYN_HL
-static char_u	*p_syn;
-#endif
-static long	p_ts;
-static long	p_tw;
-static int	p_tx;
-static long	p_wm;
-#ifdef FEAT_KEYMAP
-static char_u	*p_keymap;
-#endif
-
-/* Saved values for when 'bin' is set. */
-static int	p_et_nobin;
-static int	p_ml_nobin;
-static long	p_tw_nobin;
-static long	p_wm_nobin;
-
-/* Saved values for when 'paste' is set */
-static long	p_tw_nopaste;
-static long	p_wm_nopaste;
-static long	p_sts_nopaste;
-static int	p_ai_nopaste;
-
-struct vimoption
-{
-    char	*fullname;	/* full option name */
-    char	*shortname;	/* permissible abbreviation */
-    long_u	flags;		/* see below */
-    char_u	*var;		/* global option: pointer to variable;
-				 * window-local option: VAR_WIN;
-				 * buffer-local option: global value */
-    idopt_T	indir;		/* global option: PV_NONE;
-				 * local option: indirect option index */
-    char_u	*def_val[2];	/* default values for variable (vi and vim) */
-#ifdef FEAT_EVAL
-    scid_T	scriptID;	/* script in which the option was last set */
-#endif
-};
-
-#define VI_DEFAULT  0	    /* def_val[VI_DEFAULT] is Vi default value */
-#define VIM_DEFAULT 1	    /* def_val[VIM_DEFAULT] is Vim default value */
-
-/*
- * Flags
- */
-#define P_BOOL		0x01	/* the option is boolean */
-#define P_NUM		0x02	/* the option is numeric */
-#define P_STRING	0x04	/* the option is a string */
-#define P_ALLOCED	0x08	/* the string option is in allocated memory,
-				    must use vim_free() when assigning new
-				    value. Not set if default is the same. */
-#define P_EXPAND	0x10	/* environment expansion.  NOTE: P_EXPAND can
-				   never be used for local or hidden options! */
-#define P_NODEFAULT	0x40	/* don't set to default value */
-#define P_DEF_ALLOCED	0x80	/* default value is in allocated memory, must
-				    use vim_free() when assigning new value */
-#define P_WAS_SET	0x100	/* option has been set/reset */
-#define P_NO_MKRC	0x200	/* don't include in :mkvimrc output */
-#define P_VI_DEF	0x400	/* Use Vi default for Vim */
-#define P_VIM		0x800	/* Vim option, reset when 'cp' set */
-
-				/* when option changed, what to display: */
-#define P_RSTAT		0x1000	/* redraw status lines */
-#define P_RWIN		0x2000	/* redraw current window */
-#define P_RBUF		0x4000	/* redraw current buffer */
-#define P_RALL		0x6000	/* redraw all windows */
-#define P_RCLR		0x7000	/* clear and redraw all */
-
-#define P_COMMA		0x8000	/* comma separated list */
-#define P_NODUP		0x10000L/* don't allow duplicate strings */
-#define P_FLAGLIST	0x20000L/* list of single-char flags */
-
-#define P_SECURE	0x40000L/* cannot change in modeline or secure mode */
-#define P_GETTEXT	0x80000L/* expand default value with _() */
-#define P_NOGLOB       0x100000L/* do not use local value for global vimrc */
-#define P_NFNAME       0x200000L/* only normal file name chars allowed */
-
-/*
- * options[] is initialized here.
- * The order of the options MUST be alphabetic for ":set all" and findoption().
- * All option names MUST start with a lowercase letter (for findoption()).
- * Exception: "t_" options are at the end.
- * The options with a NULL variable are 'hidden': a set command for them is
- * ignored and they are not printed.
- */
-static struct vimoption
-#ifdef FEAT_GUI_W16
-	_far
-#endif
-	options[] =
-{
-    {"aleph",	    "al",   P_NUM|P_VI_DEF,
-#ifdef FEAT_RIGHTLEFT
-			    (char_u *)&p_aleph, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {
-#if (defined(MSDOS) || defined(WIN3264) || defined(OS2)) && !defined(FEAT_GUI_W32)
-			    (char_u *)128L,
-#else
-			    (char_u *)224L,
-#endif
-					    (char_u *)0L}},
-    {"antialias",   "anti", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
-#if defined(FEAT_GUI) && defined(MACOS_X)
-			    (char_u *)&p_antialias, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)FALSE}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)FALSE}
-#endif
-			    },
-    {"arabic",	    "arab", P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_ARABIC
-			    (char_u *)VAR_WIN, PV_ARAB,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"arabicshape", "arshape", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
-#ifdef FEAT_ARABIC
-			    (char_u *)&p_arshape, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"allowrevins", "ari",  P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_RIGHTLEFT
-			    (char_u *)&p_ari, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"altkeymap",   "akm",  P_BOOL|P_VI_DEF,
-#ifdef FEAT_FKMAP
-			    (char_u *)&p_altkeymap, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"ambiwidth",  "ambw",  P_STRING|P_VI_DEF|P_RCLR,
-#if defined(FEAT_MBYTE)
-			    (char_u *)&p_ambw, PV_NONE,
-			    {(char_u *)"single", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_SUN_WORKSHOP)
-    {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_acd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-#endif
-    {"autoindent",  "ai",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_ai, PV_AI,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"autoprint",   "ap",   P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"autoread",    "ar",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_ar, OPT_BOTH(PV_AR),
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"autowrite",   "aw",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_aw, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"autowriteall","awa",  P_BOOL|P_VI_DEF,
-			    (char_u *)&p_awa, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"background",  "bg",   P_STRING|P_VI_DEF|P_RCLR,
-			    (char_u *)&p_bg, PV_NONE,
-			    {
-#if (defined(MSDOS) || defined(OS2) || defined(WIN3264)) && !defined(FEAT_GUI)
-			    (char_u *)"dark",
-#else
-			    (char_u *)"light",
-#endif
-					    (char_u *)0L}},
-    {"backspace",   "bs",   P_STRING|P_VI_DEF|P_VIM|P_COMMA|P_NODUP,
-			    (char_u *)&p_bs, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"backup",	    "bk",   P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_bk, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"backupcopy",  "bkc",  P_STRING|P_VIM|P_COMMA|P_NODUP,
-			    (char_u *)&p_bkc, PV_NONE,
-#ifdef UNIX
-			    {(char_u *)"yes", (char_u *)"auto"}
-#else
-			    {(char_u *)"auto", (char_u *)"auto"}
-#endif
-			    },
-    {"backupdir",   "bdir", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
-			    (char_u *)&p_bdir, PV_NONE,
-			    {(char_u *)DFLT_BDIR, (char_u *)0L}},
-    {"backupext",   "bex",  P_STRING|P_VI_DEF|P_NFNAME,
-			    (char_u *)&p_bex, PV_NONE,
-			    {
-#ifdef VMS
-			    (char_u *)"_",
-#else
-			    (char_u *)"~",
-#endif
-					    (char_u *)0L}},
-    {"backupskip",  "bsk",  P_STRING|P_VI_DEF|P_COMMA,
-#ifdef FEAT_WILDIGN
-			    (char_u *)&p_bsk, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-#ifdef FEAT_BEVAL
-    {"balloondelay","bdlay",P_NUM|P_VI_DEF,
-			    (char_u *)&p_bdlay, PV_NONE,
-			    {(char_u *)600L, (char_u *)0L}},
-#endif
-#if defined(FEAT_BEVAL) && (defined(FEAT_SUN_WORKSHOP) \
-	|| defined(FEAT_NETBEANS_INTG))
-    {"ballooneval", "beval",P_BOOL|P_VI_DEF|P_NO_MKRC,
-			    (char_u *)&p_beval, PV_NONE,
-			    {(char_u*)FALSE, (char_u *)0L}},
-#endif
-    {"beautify",    "bf",   P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"binary",	    "bin",  P_BOOL|P_VI_DEF|P_RSTAT,
-			    (char_u *)&p_bin, PV_BIN,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"bioskey",	    "biosk",P_BOOL|P_VI_DEF,
-#ifdef MSDOS
-			    (char_u *)&p_biosk, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"bomb",	    NULL,   P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
-#ifdef FEAT_MBYTE
-			    (char_u *)&p_bomb, PV_BOMB,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"breakat",	    "brk",  P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
-#ifdef FEAT_LINEBREAK
-			    (char_u *)&p_breakat, PV_NONE,
-			    {(char_u *)" \t!@*-+;:,./?", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"browsedir",   "bsdir",P_STRING|P_VI_DEF,
-#ifdef FEAT_BROWSE
-			    (char_u *)&p_bsdir, PV_NONE,
-			    {(char_u *)"last", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"bufhidden",   "bh",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
-#if defined(FEAT_QUICKFIX)
-			    (char_u *)&p_bh, PV_BH,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"buflisted",   "bl",   P_BOOL|P_VI_DEF|P_NOGLOB,
-			    (char_u *)&p_bl, PV_BL,
-			    {(char_u *)1L, (char_u *)0L}
-			    },
-    {"buftype",	    "bt",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
-#if defined(FEAT_QUICKFIX)
-			    (char_u *)&p_bt, PV_BT,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"casemap",	    "cmp",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_cmp, PV_NONE,
-			    {(char_u *)"internal,keepascii", (char_u *)0L}
-			    },
-    {"cdpath",	    "cd",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_SEARCHPATH
-			    (char_u *)&p_cdpath, PV_NONE,
-			    {(char_u *)",,", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"cedit",	    NULL,   P_STRING,
-#ifdef FEAT_CMDWIN
-			    (char_u *)&p_cedit, PV_NONE,
-			    {(char_u *)"", (char_u *)CTRL_F_STR}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"charconvert",  "ccv", P_STRING|P_VI_DEF|P_SECURE,
-#if defined(FEAT_MBYTE) && defined(FEAT_EVAL)
-			    (char_u *)&p_ccv, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"cindent",	    "cin",  P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_CINDENT
-			    (char_u *)&p_cin, PV_CIN,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"cinkeys",	    "cink", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_CINDENT
-			    (char_u *)&p_cink, PV_CINK,
-			    {(char_u *)"0{,0},0),:,0#,!^F,o,O,e", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"cinoptions",  "cino", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_CINDENT
-			    (char_u *)&p_cino, PV_CINO,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"cinwords",    "cinw", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
-#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
-			    (char_u *)&p_cinw, PV_CINW,
-			    {(char_u *)"if,else,while,do,for,switch",
-				(char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"clipboard",   "cb",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_CLIPBOARD
-			    (char_u *)&p_cb, PV_NONE,
-# ifdef FEAT_XCLIPBOARD
-			    {(char_u *)"autoselect,exclude:cons\\|linux",
-							       (char_u *)0L}
-# else
-			    {(char_u *)"", (char_u *)0L}
-# endif
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#endif
-			    },
-    {"cmdheight",   "ch",   P_NUM|P_VI_DEF|P_RALL,
-			    (char_u *)&p_ch, PV_NONE,
-			    {(char_u *)1L, (char_u *)0L}},
-    {"cmdwinheight", "cwh", P_NUM|P_VI_DEF,
-#ifdef FEAT_CMDWIN
-			    (char_u *)&p_cwh, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)7L, (char_u *)0L}},
-    {"columns",	    "co",   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
-			    (char_u *)&Columns, PV_NONE,
-			    {(char_u *)80L, (char_u *)0L}},
-    {"comments",    "com",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_COMMENTS
-			    (char_u *)&p_com, PV_COM,
-			    {(char_u *)"s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-",
-				(char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"commentstring", "cms", P_STRING|P_ALLOCED|P_VI_DEF,
-#ifdef FEAT_FOLDING
-			    (char_u *)&p_cms, PV_CMS,
-			    {(char_u *)"/*%s*/", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"compatible",  "cp",   P_BOOL|P_RALL,
-			    (char_u *)&p_cp, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)FALSE}},
-    {"complete",    "cpt",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_INS_EXPAND
-			    (char_u *)&p_cpt, PV_CPT,
-			    {(char_u *)".,w,b,u,t,i", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"confirm",     "cf",   P_BOOL|P_VI_DEF,
-#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-			    (char_u *)&p_confirm, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"conskey",	    "consk",P_BOOL|P_VI_DEF,
-#ifdef MSDOS
-			    (char_u *)&p_consk, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"copyindent",  "ci",   P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_ci, PV_CI,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"cpoptions",   "cpo",  P_STRING|P_VIM|P_RALL|P_FLAGLIST,
-			    (char_u *)&p_cpo, PV_NONE,
-			    {(char_u *)CPO_ALL, (char_u *)CPO_DEFAULT}},
-    {"cscopepathcomp", "cspc", P_NUM|P_VI_DEF|P_VIM,
-#ifdef FEAT_CSCOPE
-			    (char_u *)&p_cspc, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)0L, (char_u *)0L}},
-    {"cscopeprg",   "csprg", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-#ifdef FEAT_CSCOPE
-			    (char_u *)&p_csprg, PV_NONE,
-			    {(char_u *)"cscope", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"cscopequickfix", "csqf", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)
-			    (char_u *)&p_csqf, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"cscopetag",   "cst",  P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_CSCOPE
-			    (char_u *)&p_cst, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)0L, (char_u *)0L}},
-    {"cscopetagorder", "csto", P_NUM|P_VI_DEF|P_VIM,
-#ifdef FEAT_CSCOPE
-			    (char_u *)&p_csto, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)0L, (char_u *)0L}},
-    {"cscopeverbose", "csverb", P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_CSCOPE
-			    (char_u *)&p_csverbose, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)0L, (char_u *)0L}},
-    {"debug",	    NULL,   P_STRING|P_VI_DEF,
-			    (char_u *)&p_debug, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"define",	    "def",  P_STRING|P_ALLOCED|P_VI_DEF,
-#ifdef FEAT_FIND_ID
-			    (char_u *)&p_def, OPT_BOTH(PV_DEF),
-			    {(char_u *)"^\\s*#\\s*define", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"delcombine", "deco",  P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_MBYTE
-			    (char_u *)&p_deco, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}
-			    },
-    {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_INS_EXPAND
-			    (char_u *)&p_dict, OPT_BOTH(PV_DICT),
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"diff",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN|P_NOGLOB,
-#ifdef FEAT_DIFF
-			    (char_u *)VAR_WIN, PV_DIFF,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"diffexpr",    "dex",  P_STRING|P_VI_DEF|P_SECURE,
-#if defined(FEAT_DIFF) && defined(FEAT_EVAL)
-			    (char_u *)&p_dex, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"diffopt",	    "dip",  P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN|P_COMMA|P_NODUP,
-#ifdef FEAT_DIFF
-			    (char_u *)&p_dip, PV_NONE,
-			    {(char_u *)"filler", (char_u *)NULL}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)"", (char_u *)NULL}
-#endif
-			    },
-    {"digraph",	    "dg",   P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_DIGRAPHS
-			    (char_u *)&p_dg, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"directory",   "dir",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
-			    (char_u *)&p_dir, PV_NONE,
-			    {(char_u *)DFLT_DIR, (char_u *)0L}},
-    {"display",	    "dy",   P_STRING|P_VI_DEF|P_COMMA|P_RALL|P_NODUP,
-			    (char_u *)&p_dy, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"eadirection", "ead",  P_STRING|P_VI_DEF,
-#ifdef FEAT_VERTSPLIT
-			    (char_u *)&p_ead, PV_NONE,
-			    {(char_u *)"both", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"edcompatible","ed",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_ed, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"encoding",    "enc",  P_STRING|P_VI_DEF|P_RCLR,
-#ifdef FEAT_MBYTE
-			    (char_u *)&p_enc, PV_NONE,
-			    {(char_u *)ENC_DFLT, (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"endofline",   "eol",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
-			    (char_u *)&p_eol, PV_EOL,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"equalalways", "ea",   P_BOOL|P_VI_DEF|P_RALL,
-			    (char_u *)&p_ea, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"equalprg",    "ep",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_ep, OPT_BOTH(PV_EP),
-			    {(char_u *)"", (char_u *)0L}},
-    {"errorbells",  "eb",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_eb, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"errorfile",   "ef",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-#ifdef FEAT_QUICKFIX
-			    (char_u *)&p_ef, PV_NONE,
-			    {(char_u *)DFLT_ERRORFILE, (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"errorformat", "efm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_QUICKFIX
-			    (char_u *)&p_efm, OPT_BOTH(PV_EFM),
-			    {(char_u *)DFLT_EFM, (char_u *)0L},
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"esckeys",	    "ek",   P_BOOL|P_VIM,
-			    (char_u *)&p_ek, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
-    {"eventignore", "ei",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_AUTOCMD
-			    (char_u *)&p_ei, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"expandtab",   "et",   P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_et, PV_ET,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"exrc",	    "ex",   P_BOOL|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_exrc, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"fileencoding","fenc", P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_RBUF|P_NO_MKRC,
-#ifdef FEAT_MBYTE
-			    (char_u *)&p_fenc, PV_FENC,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"fileencodings","fencs", P_STRING|P_VI_DEF|P_COMMA,
-#ifdef FEAT_MBYTE
-			    (char_u *)&p_fencs, PV_NONE,
-			    {(char_u *)"ucs-bom", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"fileformat",  "ff",   P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_NO_MKRC,
-			    (char_u *)&p_ff, PV_FF,
-			    {(char_u *)DFLT_FF, (char_u *)0L}},
-    {"fileformats", "ffs",  P_STRING|P_VIM|P_COMMA|P_NODUP,
-			    (char_u *)&p_ffs, PV_NONE,
-			    {(char_u *)DFLT_FFS_VI, (char_u *)DFLT_FFS_VIM}},
-    {"filetype",    "ft",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
-#ifdef FEAT_AUTOCMD
-			    (char_u *)&p_ft, PV_FT,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"fillchars",   "fcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
-#if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
-			    (char_u *)&p_fcs, PV_NONE,
-			    {(char_u *)"vert:|,fold:-", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#endif
-			    },
-    {"fkmap",	    "fk",   P_BOOL|P_VI_DEF,
-#ifdef FEAT_FKMAP
-			    (char_u *)&p_fkmap, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"flash",	    "fl",   P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-#ifdef FEAT_FOLDING
-    {"foldclose",   "fcl",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP|P_RWIN,
-			    (char_u *)&p_fcl, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"foldcolumn",  "fdc",  P_NUM|P_VI_DEF|P_RWIN,
-			    (char_u *)VAR_WIN, PV_FDC,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"foldenable",  "fen",  P_BOOL|P_VI_DEF|P_RWIN,
-			    (char_u *)VAR_WIN, PV_FEN,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"foldexpr",    "fde",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
-# ifdef FEAT_EVAL
-			    (char_u *)VAR_WIN, PV_FDE,
-			    {(char_u *)"0", (char_u *)NULL}
-# else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-# endif
-			    },
-    {"foldignore",  "fdi",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
-			    (char_u *)VAR_WIN, PV_FDI,
-			    {(char_u *)"#", (char_u *)NULL}},
-    {"foldlevel",   "fdl",  P_NUM|P_VI_DEF|P_RWIN,
-			    (char_u *)VAR_WIN, PV_FDL,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"foldlevelstart","fdls", P_NUM|P_VI_DEF,
-			    (char_u *)&p_fdls, PV_NONE,
-			    {(char_u *)-1L, (char_u *)0L}},
-    {"foldmarker",  "fmr",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|
-						       P_RWIN|P_COMMA|P_NODUP,
-			    (char_u *)VAR_WIN, PV_FMR,
-			    {(char_u *)"{{{,}}}", (char_u *)NULL}},
-    {"foldmethod",  "fdm",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
-			    (char_u *)VAR_WIN, PV_FDM,
-			    {(char_u *)"manual", (char_u *)NULL}},
-    {"foldminlines","fml",  P_NUM|P_VI_DEF|P_RWIN,
-			    (char_u *)VAR_WIN, PV_FML,
-			    {(char_u *)1L, (char_u *)0L}},
-    {"foldnestmax", "fdn",  P_NUM|P_VI_DEF|P_RWIN,
-			    (char_u *)VAR_WIN, PV_FDN,
-			    {(char_u *)20L, (char_u *)0L}},
-    {"foldopen",    "fdo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_fdo, PV_NONE,
-		 {(char_u *)"block,hor,mark,percent,quickfix,search,tag,undo",
-							       (char_u *)0L}},
-    {"foldtext",    "fdt",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
-# ifdef FEAT_EVAL
-			    (char_u *)VAR_WIN, PV_FDT,
-			    {(char_u *)"foldtext()", (char_u *)NULL}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-#endif
-    {"formatoptions","fo",  P_STRING|P_ALLOCED|P_VIM|P_FLAGLIST,
-			    (char_u *)&p_fo, PV_FO,
-			    {(char_u *)DFLT_FO_VI, (char_u *)DFLT_FO_VIM}},
-    {"formatprg",   "fp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_fp, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"gdefault",    "gd",   P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_gd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"graphic",	    "gr",   P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"grepformat",  "gfm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_QUICKFIX
-			    (char_u *)&p_gefm, PV_NONE,
-			    {(char_u *)DFLT_GREPFORMAT, (char_u *)0L},
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"grepprg",	    "gp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-#ifdef FEAT_QUICKFIX
-			    (char_u *)&p_gp, OPT_BOTH(PV_GP),
-			    {
-# ifdef WIN3264
-			    /* may be changed to "grep -n" in os_win32.c */
-			    (char_u *)"findstr /n",
-# else
-#  ifdef UNIX
-			    /* Add an extra file name so that grep will always
-			     * insert a file name in the match line. */
-			    (char_u *)"grep -n $* /dev/null",
-#  else
-#   ifdef VMS
-			    (char_u *)"SEARCH/NUMBERS ",
-#   else
-			    (char_u *)"grep -n ",
-#endif
-#endif
-# endif
-			    (char_u *)0L},
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"guicursor",    "gcr",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef CURSOR_SHAPE
-			    (char_u *)&p_guicursor, PV_NONE,
-			    {
-# ifdef FEAT_GUI
-				(char_u *)"n-v-c:block-Cursor/lCursor,ve:ver35-Cursor,o:hor50-Cursor,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor,sm:block-Cursor-blinkwait175-blinkoff150-blinkon175",
-# else	/* MSDOS or Win32 console */
-				(char_u *)"n-v-c:block,o:hor50,i-ci:hor15,r-cr:hor30,sm:block",
-# endif
-				    (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-				    },
-    {"guifont",	    "gfn",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
-#ifdef FEAT_GUI
-			    (char_u *)&p_guifont, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-				    },
-    {"guifontset",  "gfs",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA,
-#if defined(FEAT_GUI) && defined(FEAT_XFONTSET)
-			    (char_u *)&p_guifontset, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-				    },
-    {"guifontwide", "gfw",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
-#if defined(FEAT_GUI) && defined(FEAT_MBYTE)
-			    (char_u *)&p_guifontwide, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-				    },
-    {"guiheadroom", "ghr",  P_NUM|P_VI_DEF,
-#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
-			    (char_u *)&p_ghr, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)50L, (char_u *)0L}},
-    {"guioptions",  "go",   P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
-#if defined(FEAT_GUI)
-			    (char_u *)&p_go, PV_NONE,
-# if defined(UNIX) && !defined(MACOS)
-			    {(char_u *)"agimrLtT", (char_u *)0L}
-# else
-			    {(char_u *)"gmrLtT", (char_u *)0L}
-# endif
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-				    },
-    {"guipty",	    NULL,   P_BOOL|P_VI_DEF,
-#if defined(FEAT_GUI)
-			    (char_u *)&p_guipty, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"hardtabs",    "ht",   P_NUM|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"helpfile",    "hf",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_hf, PV_NONE,
-			    {(char_u *)DFLT_HELPFILE, (char_u *)0L}},
-    {"helpheight",  "hh",   P_NUM|P_VI_DEF,
-#ifdef FEAT_WINDOWS
-			    (char_u *)&p_hh, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)20L, (char_u *)0L}},
-    {"helplang",    "hlg",  P_STRING|P_VI_DEF|P_COMMA,
-#ifdef FEAT_MULTI_LANG
-			    (char_u *)&p_hlg, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-    },
-    {"hidden",	    "hid",  P_BOOL|P_VI_DEF,
-			    (char_u *)&p_hid, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"highlight",   "hl",   P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
-			    (char_u *)&p_hl, PV_NONE,
-			    {(char_u *)"8:SpecialKey,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu,f:Folded,F:FoldColumn,A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,>:SignColumn",
-				(char_u *)0L}},
-    {"history",	    "hi",   P_NUM|P_VIM,
-			    (char_u *)&p_hi, PV_NONE,
-			    {(char_u *)0L, (char_u *)20L}},
-    {"hkmap",	    "hk",   P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_RIGHTLEFT
-			    (char_u *)&p_hkmap, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"hkmapp",	    "hkp",  P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_RIGHTLEFT
-			    (char_u *)&p_hkmapp, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"hlsearch",    "hls",  P_BOOL|P_VI_DEF|P_VIM|P_RALL,
-			    (char_u *)&p_hls, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"icon",	    NULL,   P_BOOL|P_VI_DEF,
-#ifdef FEAT_TITLE
-			    (char_u *)&p_icon, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"iconstring",  NULL,   P_STRING|P_VI_DEF,
-#ifdef FEAT_TITLE
-			    (char_u *)&p_iconstring, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"ignorecase",  "ic",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_ic, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"imactivatekey","imak",P_STRING|P_VI_DEF,
-#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
-			    (char_u *)&p_imak, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"imcmdline",   "imc",  P_BOOL|P_VI_DEF,
-#ifdef USE_IM_CONTROL
-			    (char_u *)&p_imcmdline, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"imdisable",   "imd",  P_BOOL|P_VI_DEF,
-#ifdef USE_IM_CONTROL
-			    (char_u *)&p_imdisable, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-#ifdef __sgi
-			    {(char_u *)TRUE, (char_u *)0L}
-#else
-			    {(char_u *)FALSE, (char_u *)0L}
-#endif
-			    },
-    {"iminsert",    "imi",  P_NUM|P_VI_DEF,
-			    (char_u *)&p_iminsert, PV_IMI,
-#ifdef B_IMODE_IM
-			    {(char_u *)B_IMODE_IM, (char_u *)0L}
-#else
-			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
-#endif
-			    },
-    {"imsearch",    "ims",  P_NUM|P_VI_DEF,
-			    (char_u *)&p_imsearch, PV_IMS,
-#ifdef B_IMODE_IM
-			    {(char_u *)B_IMODE_IM, (char_u *)0L}
-#else
-			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
-#endif
-			    },
-    {"include",	    "inc",  P_STRING|P_ALLOCED|P_VI_DEF,
-#ifdef FEAT_FIND_ID
-			    (char_u *)&p_inc, OPT_BOTH(PV_INC),
-			    {(char_u *)"^\\s*#\\s*include", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"includeexpr", "inex", P_STRING|P_ALLOCED|P_VI_DEF,
-#if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
-			    (char_u *)&p_inex, PV_INEX,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"incsearch",   "is",   P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_is, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"indentexpr", "inde",  P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
-#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
-			    (char_u *)&p_inde, PV_INDE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"indentkeys", "indk",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
-#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
-			    (char_u *)&p_indk, PV_INDK,
-			    {(char_u *)"0{,0},:,0#,!^F,o,O,e", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"infercase",   "inf",  P_BOOL|P_VI_DEF,
-			    (char_u *)&p_inf, PV_INF,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"insertmode",  "im",   P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_im, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"isfname",	    "isf",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_isf, PV_NONE,
-			    {
-#ifdef BACKSLASH_IN_FILENAME
-				/* Excluded are: & and ^ are special in cmd.exe
-				 * ( and ) are used in text separating fnames */
-			    (char_u *)"@,48-57,/,\\,.,-,_,+,,,#,$,%,{,},[,],:,@-@,!,~,=",
-#else
-# ifdef AMIGA
-			    (char_u *)"@,48-57,/,.,-,_,+,,,$,:",
-# else
-#  ifdef VMS
-			    (char_u *)"@,48-57,/,.,-,_,+,,,#,$,%,<,>,[,],:,;,~",
-#  else /* UNIX et al. */
-#   ifdef EBCDIC
-			    (char_u *)"@,240-249,/,.,-,_,+,,,#,$,%,~,=",
-#   else
-			    (char_u *)"@,48-57,/,.,-,_,+,,,#,$,%,~,=",
-#   endif
-#  endif
-# endif
-#endif
-				(char_u *)0L}},
-    {"isident",	    "isi",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_isi, PV_NONE,
-			    {
-#if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-			    (char_u *)"@,48-57,_,128-167,224-235",
-#else
-# ifdef EBCDIC
-			    /* TODO: EBCDIC Check this! @ == isalpha()*/
-			    (char_u *)"@,240-249,_,66-73,81-89,98-105,"
-				    "112-120,128,140-142,156,158,172,"
-				    "174,186,191,203-207,219-225,235-239,"
-				    "251-254",
-# else
-			    (char_u *)"@,48-57,_,192-255",
-# endif
-#endif
-				(char_u *)0L}},
-    {"iskeyword",   "isk",  P_STRING|P_ALLOCED|P_VIM|P_COMMA|P_NODUP,
-			    (char_u *)&p_isk, PV_ISK,
-			    {
-#ifdef EBCDIC
-			     (char_u *)"@,240-249,_",
-			     /* TODO: EBCDIC Check this! @ == isalpha()*/
-			     (char_u *)"@,240-249,_,66-73,81-89,98-105,"
-				    "112-120,128,140-142,156,158,172,"
-				    "174,186,191,203-207,219-225,235-239,"
-				    "251-254",
-#else
-				(char_u *)"@,48-57,_",
-# if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-				(char_u *)"@,48-57,_,128-167,224-235"
-# else
-				(char_u *)"@,48-57,_,192-255"
-# endif
-#endif
-				}},
-    {"isprint",	    "isp",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
-			    (char_u *)&p_isp, PV_NONE,
-			    {
-#if defined(MSDOS) || defined(MSWIN) || defined(OS2) || defined(MACOS) \
-		|| defined(VMS)
-			    (char_u *)"@,~-255",
-#else
-# ifdef EBCDIC
-			    /* all chars above 63 are printable */
-			    (char_u *)"63-255",
-# else
-			    (char_u *)"@,161-255",
-# endif
-#endif
-				(char_u *)0L}},
-    {"joinspaces",  "js",   P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_js, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"key",	    NULL,   P_STRING|P_ALLOCED|P_VI_DEF|P_NO_MKRC,
-#ifdef FEAT_CRYPT
-			    (char_u *)&p_key, PV_KEY,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"keymap",	    "kmp",  P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_RSTAT|P_NFNAME,
-#ifdef FEAT_KEYMAP
-			    (char_u *)&p_keymap, PV_KMAP,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#endif
-	},
-    {"keymodel",    "km",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_VISUAL
-			    (char_u *)&p_km, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"keywordprg",  "kp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_kp, OPT_BOTH(PV_KP),
-			    {
-#if defined(MSDOS) || defined(MSWIN)
-			    (char_u *)":help",
-#else
-#ifdef VMS
-			    (char_u *)"help",
-#else
-# if defined(OS2)
-			    (char_u *)"view /",
-# else
-#  ifdef USEMAN_S
-			    (char_u *)"man -s",
-#  else
-			    (char_u *)"man",
-#  endif
-# endif
-#endif
-#endif
-				(char_u *)0L}},
-    {"langmap",     "lmap", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_LANGMAP
-			    (char_u *)&p_langmap, PV_NONE,
-			    {(char_u *)"",	/* unmatched } */
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL,
-#endif
-				(char_u *)0L}},
-    {"langmenu",    "lm",   P_STRING|P_VI_DEF|P_NFNAME,
-#if defined(FEAT_MENU) && defined(FEAT_MULTI_LANG)
-			    (char_u *)&p_lm, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"laststatus",  "ls",   P_NUM|P_VI_DEF|P_RALL,
-#ifdef FEAT_WINDOWS
-			    (char_u *)&p_ls, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)1L, (char_u *)0L}},
-    {"lazyredraw",  "lz",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_lz, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"linebreak",   "lbr",  P_BOOL|P_VI_DEF|P_RWIN,
-#ifdef FEAT_LINEBREAK
-			    (char_u *)VAR_WIN, PV_LBR,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"lines",	    NULL,   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
-			    (char_u *)&Rows, PV_NONE,
-			    {
-#if defined(MSDOS) || defined(WIN3264) || defined(OS2)
-			    (char_u *)25L,
-#else
-			    (char_u *)24L,
-#endif
-					    (char_u *)0L}},
-    {"linespace",   "lsp",  P_NUM|P_VI_DEF|P_RCLR,
-#ifdef FEAT_GUI
-			    (char_u *)&p_linespace, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-#ifdef FEAT_GUI_W32
-			    {(char_u *)1L, (char_u *)0L}
-#else
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"lisp",	    NULL,   P_BOOL|P_VI_DEF,
-#ifdef FEAT_LISP
-			    (char_u *)&p_lisp, PV_LISP,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"lispwords",   "lw",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_LISP
-			    (char_u *)&p_lispwords, PV_NONE,
-			    {(char_u *)LISPWORD_VALUE, (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#endif
-			    },
-    {"list",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
-			    (char_u *)VAR_WIN, PV_LIST,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"listchars",   "lcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
-			    (char_u *)&p_lcs, PV_NONE,
-			    {(char_u *)"eol:$", (char_u *)0L}},
-    {"loadplugins", "lpl",  P_BOOL|P_VI_DEF,
-			    (char_u *)&p_lpl, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"magic",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_magic, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"makeef",	    "mef",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-#ifdef FEAT_QUICKFIX
-			    (char_u *)&p_mef, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"makeprg",	    "mp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-#ifdef FEAT_QUICKFIX
-			    (char_u *)&p_mp, OPT_BOTH(PV_MP),
-# ifdef VMS
-			    {(char_u *)"MMS", (char_u *)0L}
-# else
-			    {(char_u *)"make", (char_u *)0L}
-# endif
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"matchpairs",  "mps",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_mps, PV_MPS,
-			    {(char_u *)"(:),{:},[:]", (char_u *)0L}},
-    {"matchtime",   "mat",  P_NUM|P_VI_DEF,
-			    (char_u *)&p_mat, PV_NONE,
-			    {(char_u *)5L, (char_u *)0L}},
-    {"maxfuncdepth", "mfd", P_NUM|P_VI_DEF,
-#ifdef FEAT_EVAL
-			    (char_u *)&p_mfd, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)100L, (char_u *)0L}},
-    {"maxmapdepth", "mmd",  P_NUM|P_VI_DEF,
-			    (char_u *)&p_mmd, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
-    {"maxmem",	    "mm",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_mm, PV_NONE,
-			    {(char_u *)DFLT_MAXMEM, (char_u *)0L}},
-    {"maxmemtot",   "mmt",  P_NUM|P_VI_DEF,
-			    (char_u *)&p_mmt, PV_NONE,
-			    {(char_u *)DFLT_MAXMEMTOT, (char_u *)0L}},
-    {"menuitems",   "mis",  P_NUM|P_VI_DEF,
-#ifdef FEAT_MENU
-			    (char_u *)&p_mis, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)25L, (char_u *)0L}},
-    {"mesg",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"modeline",    "ml",   P_BOOL|P_VIM,
-			    (char_u *)&p_ml, PV_ML,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
-    {"modelines",   "mls",  P_NUM|P_VI_DEF,
-			    (char_u *)&p_mls, PV_NONE,
-			    {(char_u *)5L, (char_u *)0L}},
-    {"modifiable",  "ma",   P_BOOL|P_VI_DEF|P_NOGLOB,
-			    (char_u *)&p_ma, PV_MA,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"modified",    "mod",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
-			    (char_u *)&p_mod, PV_MOD,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"more",	    NULL,   P_BOOL|P_VIM,
-			    (char_u *)&p_more, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
-    {"mouse",	    NULL,   P_STRING|P_VI_DEF|P_FLAGLIST,
-			    (char_u *)&p_mouse, PV_NONE,
-			    {
-#if defined(MSDOS) || defined(WIN3264)
-				(char_u *)"a",
-#else
-				(char_u *)"",
-#endif
-				(char_u *)0L}},
-    {"mousefocus",   "mousef", P_BOOL|P_VI_DEF,
-#ifdef FEAT_GUI
-			    (char_u *)&p_mousef, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"mousehide",   "mh",   P_BOOL|P_VI_DEF,
-#ifdef FEAT_GUI
-			    (char_u *)&p_mh, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"mousemodel",  "mousem", P_STRING|P_VI_DEF,
-			    (char_u *)&p_mousem, PV_NONE,
-			    {
-#if defined(MSDOS) || defined(MSWIN)
-				(char_u *)"popup",
-#else
-# if defined(MACOS)
-				(char_u *)"popup_setpos",
-# else
-				(char_u *)"extend",
-# endif
-#endif
-				(char_u *)0L}},
-    {"mouseshape",  "mouses",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_MOUSESHAPE
-			    (char_u *)&p_mouseshape, PV_NONE,
-			    {(char_u *)"i-r:beam,s:updown,sd:udsizing,vs:leftright,vd:lrsizing,m:no,ml:up-arrow,v:rightup-arrow", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"mousetime",   "mouset",	P_NUM|P_VI_DEF,
-			    (char_u *)&p_mouset, PV_NONE,
-			    {(char_u *)500L, (char_u *)0L}},
-    {"novice",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"nrformats",   "nf",   P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_nf, PV_NF,
-			    {(char_u *)"octal,hex", (char_u *)0L}},
-    {"number",	    "nu",   P_BOOL|P_VI_DEF|P_RWIN,
-			    (char_u *)VAR_WIN, PV_NU,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"open",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"optimize",    "opt",  P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"osfiletype",  "oft",  P_STRING|P_ALLOCED|P_VI_DEF,
-#ifdef FEAT_OSFILETYPE
-			    (char_u *)&p_oft, PV_OFT,
-			    {(char_u *)DFLT_OFT, (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"paragraphs",  "para", P_STRING|P_VI_DEF,
-			    (char_u *)&p_para, PV_NONE,
-			    {(char_u *)"IPLPPPQPP LIpplpipbp", (char_u *)0L}},
-    {"paste",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_paste, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"pastetoggle", "pt",   P_STRING|P_VI_DEF,
-			    (char_u *)&p_pt, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"patchexpr",   "pex",  P_STRING|P_VI_DEF|P_SECURE,
-#if defined(FEAT_DIFF) && defined(FEAT_EVAL)
-			    (char_u *)&p_pex, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"patchmode",   "pm",   P_STRING|P_VI_DEF|P_NFNAME,
-			    (char_u *)&p_pm, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"path",	    "pa",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_path, OPT_BOTH(PV_PATH),
-			    {
-#if defined AMIGA || defined MSDOS || defined MSWIN
-			    (char_u *)".,,",
-#else
-# if defined(__EMX__)
-			    (char_u *)".,/emx/include,,",
-# else /* Unix, probably */
-			    (char_u *)".,/usr/include,,",
-# endif
-#endif
-				(char_u *)0L}},
-    {"preserveindent", "pi", P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_pi, PV_PI,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"previewheight", "pvh",P_NUM|P_VI_DEF,
-#if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-			    (char_u *)&p_pvh, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)12L, (char_u *)0L}},
-    {"previewwindow", "pvw", P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
-#if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-			    (char_u *)VAR_WIN, PV_PVW,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"printdevice", "pdev", P_STRING|P_VI_DEF|P_SECURE,
-#ifdef FEAT_PRINTER
-			    (char_u *)&p_pdev, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"printencoding", "penc", P_STRING|P_VI_DEF,
-#ifdef FEAT_POSTSCRIPT
-			    (char_u *)&p_penc, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"printexpr", "pexpr",  P_STRING|P_VI_DEF,
-#ifdef FEAT_POSTSCRIPT
-			    (char_u *)&p_pexpr, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"printfont", "pfn",    P_STRING|P_VI_DEF,
-#ifdef FEAT_PRINTER
-			    (char_u *)&p_pfn, PV_NONE,
-			    {
-# ifdef MSWIN
-				(char_u *)"Courier_New:h10",
-# else
-				(char_u *)"courier",
-# endif
-				(char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"printheader", "pheader",  P_STRING|P_VI_DEF|P_GETTEXT,
-#ifdef FEAT_PRINTER
-			    (char_u *)&p_header, PV_NONE,
-			    {(char_u *)N_("%<%f%h%m%=Page %N"), (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"printoptions", "popt", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_PRINTER
-			    (char_u *)&p_popt, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"prompt",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"readonly",    "ro",   P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
-			    (char_u *)&p_ro, PV_RO,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"redraw",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"remap",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_remap, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"report",	    NULL,   P_NUM|P_VI_DEF,
-			    (char_u *)&p_report, PV_NONE,
-			    {(char_u *)2L, (char_u *)0L}},
-    {"restorescreen", "rs", P_BOOL|P_VI_DEF,
-#ifdef WIN3264
-			    (char_u *)&p_rs, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"revins",	    "ri",   P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_RIGHTLEFT
-			    (char_u *)&p_ri, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"rightleft",   "rl",   P_BOOL|P_VI_DEF|P_RWIN,
-#ifdef FEAT_RIGHTLEFT
-			    (char_u *)VAR_WIN, PV_RL,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"rightleftcmd", "rlc", P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN,
-#ifdef FEAT_RIGHTLEFT
-			    (char_u *)VAR_WIN, PV_RLC,
-			    {(char_u *)"search", (char_u *)NULL}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"ruler",	    "ru",   P_BOOL|P_VI_DEF|P_VIM|P_RSTAT,
-#ifdef FEAT_CMDL_INFO
-			    (char_u *)&p_ru, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"rulerformat", "ruf",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
-#ifdef FEAT_STL_OPT
-			    (char_u *)&p_ruf, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"runtimepath", "rtp",  P_STRING|P_VI_DEF|P_EXPAND|P_COMMA|P_NODUP|P_SECURE,
-			    (char_u *)&p_rtp, PV_NONE,
-			    {(char_u *)DFLT_RUNTIMEPATH, (char_u *)0L}},
-    {"scroll",	    "scr",  P_NUM|P_NO_MKRC|P_VI_DEF,
-			    (char_u *)VAR_WIN, PV_SCROLL,
-			    {(char_u *)12L, (char_u *)0L}},
-    {"scrollbind",  "scb",  P_BOOL|P_VI_DEF,
-#ifdef FEAT_SCROLLBIND
-			    (char_u *)VAR_WIN, PV_SCBIND,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"scrolljump",  "sj",   P_NUM|P_VI_DEF|P_VIM,
-			    (char_u *)&p_sj, PV_NONE,
-			    {(char_u *)1L, (char_u *)0L}},
-    {"scrolloff",   "so",   P_NUM|P_VI_DEF|P_VIM|P_RALL,
-			    (char_u *)&p_so, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"scrollopt",   "sbo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_SCROLLBIND
-			    (char_u *)&p_sbo, PV_NONE,
-			    {(char_u *)"ver,jump", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"sections",    "sect", P_STRING|P_VI_DEF,
-			    (char_u *)&p_sections, PV_NONE,
-			    {(char_u *)"SHNHH HUnhsh", (char_u *)0L}},
-    {"secure",	    NULL,   P_BOOL|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_secure, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"selection",   "sel",  P_STRING|P_VI_DEF,
-#ifdef FEAT_VISUAL
-			    (char_u *)&p_sel, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"inclusive", (char_u *)0L}},
-    {"selectmode",  "slm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_VISUAL
-			    (char_u *)&p_slm, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"sessionoptions", "ssop", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_SESSION
-			    (char_u *)&p_ssop, PV_NONE,
-		 {(char_u *)"blank,buffers,curdir,folds,help,options,winsize",
-							       (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"shell",	    "sh",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_sh, PV_NONE,
-			    {
-#ifdef VMS
-			    (char_u *)"-",
-#else
-# if defined(MSDOS)
-			    (char_u *)"command",
-# else
-#  if defined(WIN16)
-			    (char_u *)"command.com",
-#  else
-#   if defined(WIN3264)
-			    (char_u *)"",	/* set in set_init_1() */
-#   else
-#    if defined(OS2)
-			    (char_u *)"cmd.exe",
-#    else
-#     if defined(ARCHIE)
-			    (char_u *)"gos",
-#     else
-			    (char_u *)"sh",
-#     endif
-#    endif
-#   endif
-#  endif
-# endif
-#endif /* VMS */
-				(char_u *)0L}},
-    {"shellcmdflag","shcf", P_STRING|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_shcf, PV_NONE,
-			    {
-#if defined(MSDOS) || defined(MSWIN)
-			    (char_u *)"/c",
-#else
-# if defined(OS2)
-			    (char_u *)"/c",
-# else
-			    (char_u *)"-c",
-# endif
-#endif
-				(char_u *)0L}},
-    {"shellpipe",   "sp",   P_STRING|P_VI_DEF|P_SECURE,
-#ifdef FEAT_QUICKFIX
-			    (char_u *)&p_sp, PV_NONE,
-			    {
-#if defined(UNIX) || defined(OS2)
-# ifdef ARCHIE
-			    (char_u *)"2>",
-# else
-			    (char_u *)"| tee",
-# endif
-#else
-			    (char_u *)">",
-#endif
-				(char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-    },
-    {"shellquote",  "shq",  P_STRING|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_shq, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"shellredir",  "srr",  P_STRING|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_srr, PV_NONE,
-			    {(char_u *)">", (char_u *)0L}},
-    {"shellslash",  "ssl",   P_BOOL|P_VI_DEF,
-#ifdef BACKSLASH_IN_FILENAME
-			    (char_u *)&p_ssl, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"shelltype",   "st",   P_NUM|P_VI_DEF,
-#ifdef AMIGA
-			    (char_u *)&p_st, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)0L, (char_u *)0L}},
-    {"shellxquote", "sxq",  P_STRING|P_VI_DEF|P_SECURE,
-			    (char_u *)&p_sxq, PV_NONE,
-			    {
-#if defined(UNIX) && defined(USE_SYSTEM) && !defined(__EMX__)
-			    (char_u *)"\"",
-#else
-			    (char_u *)"",
-#endif
-				(char_u *)0L}},
-    {"shiftround",  "sr",   P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_sr, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"shiftwidth",  "sw",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_sw, PV_SW,
-			    {(char_u *)8L, (char_u *)0L}},
-    {"shortmess",   "shm",  P_STRING|P_VIM|P_FLAGLIST,
-			    (char_u *)&p_shm, PV_NONE,
-			    {(char_u *)"", (char_u *)"filnxtToO"}},
-    {"shortname",   "sn",   P_BOOL|P_VI_DEF,
-#ifdef SHORT_FNAME
-			    (char_u *)NULL, PV_NONE,
-#else
-			    (char_u *)&p_sn, PV_SN,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"showbreak",   "sbr",  P_STRING|P_VI_DEF|P_RALL,
-#ifdef FEAT_LINEBREAK
-			    (char_u *)&p_sbr, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"showcmd",	    "sc",   P_BOOL|P_VIM,
-#ifdef FEAT_CMDL_INFO
-			    (char_u *)&p_sc, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE,
-#ifdef UNIX
-				(char_u *)FALSE
-#else
-				(char_u *)TRUE
-#endif
-				}},
-    {"showfulltag", "sft",  P_BOOL|P_VI_DEF,
-			    (char_u *)&p_sft, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"showmatch",   "sm",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_sm, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"showmode",    "smd",  P_BOOL|P_VIM,
-			    (char_u *)&p_smd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
-    {"sidescroll",  "ss",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_ss, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"sidescrolloff", "siso", P_NUM|P_VI_DEF|P_VIM|P_RBUF,
-			    (char_u *)&p_siso, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"slowopen",    "slow", P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"smartcase",   "scs",  P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_scs, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"smartindent", "si",   P_BOOL|P_VI_DEF|P_VIM,
-#ifdef FEAT_SMARTINDENT
-			    (char_u *)&p_si, PV_SI,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"smarttab",    "sta",  P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_sta, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"softtabstop", "sts",  P_NUM|P_VI_DEF|P_VIM,
-			    (char_u *)&p_sts, PV_STS,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"sourceany",   NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"splitbelow",  "sb",   P_BOOL|P_VI_DEF,
-#ifdef FEAT_WINDOWS
-			    (char_u *)&p_sb, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"splitright",  "spr",  P_BOOL|P_VI_DEF,
-#ifdef FEAT_VERTSPLIT
-			    (char_u *)&p_spr, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"startofline", "sol",  P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_sol, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"statusline"  ,"stl",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
-#ifdef FEAT_STL_OPT
-			    (char_u *)&p_stl, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"suffixes",    "su",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_su, PV_NONE,
-			    {(char_u *)".bak,~,.o,.h,.info,.swp,.obj",
-				(char_u *)0L}},
-    {"suffixesadd", "sua",  P_STRING|P_VI_DEF|P_ALLOCED|P_COMMA|P_NODUP,
-#if defined(FEAT_SEARCHPATH)
-			    (char_u *)&p_sua, PV_SUA,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"swapfile",    "swf",  P_BOOL|P_VI_DEF|P_RSTAT,
-			    (char_u *)&p_swf, PV_SWF,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"swapsync",    "sws",  P_STRING|P_VI_DEF,
-			    (char_u *)&p_sws, PV_NONE,
-			    {(char_u *)"fsync", (char_u *)0L}},
-    {"switchbuf",   "swb",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_swb, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"syntax",	    "syn",  P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
-#ifdef FEAT_SYN_HL
-			    (char_u *)&p_syn, PV_SYN,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"tabstop",	    "ts",   P_NUM|P_VI_DEF|P_RBUF,
-			    (char_u *)&p_ts, PV_TS,
-			    {(char_u *)8L, (char_u *)0L}},
-    {"tagbsearch",  "tbs",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_tbs, PV_NONE,
-#ifdef VMS	/* binary searching doesn't appear to work on VMS */
-			    {(char_u *)0L, (char_u *)0L}
-#else
-			    {(char_u *)TRUE, (char_u *)0L}
-#endif
-			    },
-    {"taglength",   "tl",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_tl, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"tagrelative", "tr",   P_BOOL|P_VIM,
-			    (char_u *)&p_tr, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
-    {"tags",	    "tag",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_tags, OPT_BOTH(PV_TAGS),
-			    {
-#if defined(FEAT_EMACS_TAGS) && !defined(CASE_INSENSITIVE_FILENAME)
-			    (char_u *)"./tags,./TAGS,tags,TAGS",
-#else
-			    (char_u *)"./tags,tags",
-#endif
-				(char_u *)0L}},
-    {"tagstack",    "tgst", P_BOOL|P_VI_DEF,
-			    (char_u *)&p_tgst, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"term",	    NULL,   P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
-			    (char_u *)&T_NAME, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"termbidi", "tbidi",   P_BOOL|P_VI_DEF,
-#ifdef FEAT_ARABIC
-			    (char_u *)&p_tbidi, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"termencoding", "tenc", P_STRING|P_VI_DEF|P_RCLR,
-#ifdef FEAT_MBYTE
-			    (char_u *)&p_tenc, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"terse",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_terse, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"textauto",    "ta",   P_BOOL|P_VIM,
-			    (char_u *)&p_ta, PV_NONE,
-			    {(char_u *)DFLT_TEXTAUTO, (char_u *)TRUE}},
-    {"textmode",    "tx",   P_BOOL|P_VI_DEF|P_NO_MKRC,
-			    (char_u *)&p_tx, PV_TX,
-			    {
-#ifdef USE_CRNL
-			    (char_u *)TRUE,
-#else
-			    (char_u *)FALSE,
-#endif
-				(char_u *)0L}},
-    {"textwidth",   "tw",   P_NUM|P_VI_DEF|P_VIM,
-			    (char_u *)&p_tw, PV_TW,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"thesaurus",   "tsr",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_INS_EXPAND
-			    (char_u *)&p_tsr, OPT_BOTH(PV_TSR),
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"tildeop",	    "top",  P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_to, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"timeout",	    "to",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_timeout, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"timeoutlen",  "tm",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_tm, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
-    {"title",	    NULL,   P_BOOL|P_VI_DEF,
-#ifdef FEAT_TITLE
-			    (char_u *)&p_title, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"titlelen",    NULL,   P_NUM|P_VI_DEF,
-#ifdef FEAT_TITLE
-			    (char_u *)&p_titlelen, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)85L, (char_u *)0L}},
-    {"titleold",    NULL,   P_STRING|P_VI_DEF|P_GETTEXT|P_SECURE,
-#ifdef FEAT_TITLE
-			    (char_u *)&p_titleold, PV_NONE,
-			    {(char_u *)N_("Thanks for flying Vim"),
-							       (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"titlestring", NULL,   P_STRING|P_VI_DEF,
-#ifdef FEAT_TITLE
-			    (char_u *)&p_titlestring, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
-    {"toolbar",     "tb",   P_STRING|P_COMMA|P_VI_DEF|P_NODUP,
-			    (char_u *)&p_toolbar, PV_NONE,
-			    {(char_u *)"icons,tooltips", (char_u *)0L}},
-#endif
-#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK) && defined(HAVE_GTK2)
-    {"toolbariconsize",	"tbis", P_STRING|P_VI_DEF,
-			    (char_u *)&p_tbis, PV_NONE,
-			    {(char_u *)"small", (char_u *)0L}},
-#endif
-    {"ttimeout",    NULL,   P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_ttimeout, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"ttimeoutlen", "ttm",  P_NUM|P_VI_DEF,
-			    (char_u *)&p_ttm, PV_NONE,
-			    {(char_u *)-1L, (char_u *)0L}},
-    {"ttybuiltin",  "tbi",  P_BOOL|P_VI_DEF,
-			    (char_u *)&p_tbi, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"ttyfast",	    "tf",   P_BOOL|P_NO_MKRC|P_VI_DEF,
-			    (char_u *)&p_tf, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"ttymouse",    "ttym", P_STRING|P_NODEFAULT|P_NO_MKRC|P_VI_DEF,
-#if defined(FEAT_MOUSE) && (defined(UNIX) || defined(VMS))
-			    (char_u *)&p_ttym, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"ttyscroll",   "tsl",  P_NUM|P_VI_DEF,
-			    (char_u *)&p_ttyscroll, PV_NONE,
-			    {(char_u *)999L, (char_u *)0L}},
-    {"ttytype",	    "tty",  P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
-			    (char_u *)&T_NAME, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
-    {"undolevels",  "ul",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_ul, PV_NONE,
-			    {
-#if defined(UNIX) || defined(WIN3264) || defined(OS2) || defined(VMS)
-			    (char_u *)1000L,
-#else
-			    (char_u *)100L,
-#endif
-				(char_u *)0L}},
-    {"updatecount", "uc",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_uc, PV_NONE,
-			    {(char_u *)200L, (char_u *)0L}},
-    {"updatetime",  "ut",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_ut, PV_NONE,
-			    {(char_u *)4000L, (char_u *)0L}},
-    {"verbose",	    "vbs",  P_NUM|P_VI_DEF,
-			    (char_u *)&p_verbose, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"viewdir",     "vdir", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
-#ifdef FEAT_SESSION
-			    (char_u *)&p_vdir, PV_NONE,
-			    {(char_u *)DFLT_VDIR, (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"viewoptions", "vop",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_SESSION
-			    (char_u *)&p_vop, PV_NONE,
-			    {(char_u *)"folds,options,cursor", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"viminfo",	    "vi",   P_STRING|P_COMMA|P_NODUP|P_SECURE,
-#ifdef FEAT_VIMINFO
-			    (char_u *)&p_viminfo, PV_NONE,
-#if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-			    {(char_u *)"", (char_u *)"'20,<50,s10,h,rA:,rB:"}
-#else
-# ifdef AMIGA
-			    {(char_u *)"",
-				 (char_u *)"'20,<50,s10,h,rdf0:,rdf1:,rdf2:"}
-# else
-			    {(char_u *)"", (char_u *)"'20,<50,s10,h"}
-# endif
-#endif
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"virtualedit", "ve",   P_STRING|P_COMMA|P_NODUP|P_VI_DEF|P_VIM,
-#ifdef FEAT_VIRTUALEDIT
-			    (char_u *)&p_ve, PV_NONE,
-			    {(char_u *)"", (char_u *)""}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}
-#endif
-			    },
-    {"visualbell",  "vb",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_vb, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"w300",	    NULL,   P_NUM|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"w1200",	    NULL,   P_NUM|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"w9600",	    NULL,   P_NUM|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"warn",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_warn, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"weirdinvert", "wiv",  P_BOOL|P_VI_DEF|P_RCLR,
-			    (char_u *)&p_wiv, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"whichwrap",   "ww",   P_STRING|P_VIM|P_COMMA|P_FLAGLIST,
-			    (char_u *)&p_ww, PV_NONE,
-			    {(char_u *)"", (char_u *)"b,s"}},
-    {"wildchar",    "wc",   P_NUM|P_VIM,
-			    (char_u *)&p_wc, PV_NONE,
-			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}},
-    {"wildcharm",   "wcm",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_wcm, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"wildignore",  "wig",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_WILDIGN
-			    (char_u *)&p_wig, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)"", (char_u *)0L}},
-    {"wildmenu",    "wmnu", P_BOOL|P_VI_DEF,
-#ifdef FEAT_WILDMENU
-			    (char_u *)&p_wmnu, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"wildmode",    "wim",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-			    (char_u *)&p_wim, PV_NONE,
-			    {(char_u *)"full", (char_u *)0L}},
-    {"winaltkeys",  "wak",  P_STRING|P_VI_DEF,
-#ifdef FEAT_WAK
-			    (char_u *)&p_wak, PV_NONE,
-			    {(char_u *)"menu", (char_u *)0L}
-#else
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)NULL, (char_u *)0L}
-#endif
-			    },
-    {"window",	    "wi",   P_NUM|P_VI_DEF,
-			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"winheight",   "wh",   P_NUM|P_VI_DEF,
-#ifdef FEAT_WINDOWS
-			    (char_u *)&p_wh, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)1L, (char_u *)0L}},
-    {"winfixheight", "wfh", P_BOOL|P_VI_DEF|P_RSTAT,
-#if defined(FEAT_WINDOWS)
-			    (char_u *)VAR_WIN, PV_WFH,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"winminheight", "wmh", P_NUM|P_VI_DEF,
-#ifdef FEAT_WINDOWS
-			    (char_u *)&p_wmh, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)1L, (char_u *)0L}},
-    {"winminwidth", "wmw", P_NUM|P_VI_DEF,
-#ifdef FEAT_VERTSPLIT
-			    (char_u *)&p_wmw, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)1L, (char_u *)0L}},
-    {"winwidth",   "wiw",   P_NUM|P_VI_DEF,
-#ifdef FEAT_VERTSPLIT
-			    (char_u *)&p_wiw, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
-			    {(char_u *)20L, (char_u *)0L}},
-    {"wrap",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
-			    (char_u *)VAR_WIN, PV_WRAP,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"wrapmargin",  "wm",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_wm, PV_WM,
-			    {(char_u *)0L, (char_u *)0L}},
-    {"wrapscan",    "ws",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_ws, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"write",	    NULL,   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_write, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
-    {"writeany",    "wa",   P_BOOL|P_VI_DEF,
-			    (char_u *)&p_wa, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
-    {"writebackup", "wb",   P_BOOL|P_VI_DEF|P_VIM,
-			    (char_u *)&p_wb, PV_NONE,
-			    {
-#ifdef FEAT_WRITEBACKUP
-			    (char_u *)TRUE,
-#else
-			    (char_u *)FALSE,
-#endif
-				(char_u *)0L}},
-    {"writedelay",  "wd",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_wd, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
-
-/* terminal output codes */
-#define p_term(sss, vvv)   {sss, NULL, P_STRING|P_VI_DEF|P_RALL|P_SECURE, \
-			    (char_u *)&vvv, PV_NONE, \
-			    {(char_u *)"", (char_u *)0L}},
-
-    p_term("t_AB", T_CAB)
-    p_term("t_AF", T_CAF)
-    p_term("t_AL", T_CAL)
-    p_term("t_al", T_AL)
-    p_term("t_bc", T_BC)
-    p_term("t_cd", T_CD)
-    p_term("t_ce", T_CE)
-    p_term("t_cl", T_CL)
-    p_term("t_cm", T_CM)
-    p_term("t_Co", T_CCO)
-    p_term("t_CS", T_CCS)
-    p_term("t_cs", T_CS)
-#ifdef FEAT_VERTSPLIT
-    p_term("t_CV", T_CSV)
-#endif
-    p_term("t_ut", T_UT)
-    p_term("t_da", T_DA)
-    p_term("t_db", T_DB)
-    p_term("t_DL", T_CDL)
-    p_term("t_dl", T_DL)
-    p_term("t_fs", T_FS)
-    p_term("t_IE", T_CIE)
-    p_term("t_IS", T_CIS)
-    p_term("t_ke", T_KE)
-    p_term("t_ks", T_KS)
-    p_term("t_le", T_LE)
-    p_term("t_mb", T_MB)
-    p_term("t_md", T_MD)
-    p_term("t_me", T_ME)
-    p_term("t_mr", T_MR)
-    p_term("t_ms", T_MS)
-    p_term("t_nd", T_ND)
-    p_term("t_op", T_OP)
-    p_term("t_RI", T_CRI)
-    p_term("t_RV", T_CRV)
-    p_term("t_Sb", T_CSB)
-    p_term("t_Sf", T_CSF)
-    p_term("t_se", T_SE)
-    p_term("t_so", T_SO)
-    p_term("t_sr", T_SR)
-    p_term("t_ts", T_TS)
-    p_term("t_te", T_TE)
-    p_term("t_ti", T_TI)
-    p_term("t_ue", T_UE)
-    p_term("t_us", T_US)
-    p_term("t_vb", T_VB)
-    p_term("t_ve", T_VE)
-    p_term("t_vi", T_VI)
-    p_term("t_vs", T_VS)
-    p_term("t_WP", T_CWP)
-    p_term("t_WS", T_CWS)
-    p_term("t_xs", T_XS)
-    p_term("t_ZH", T_CZH)
-    p_term("t_ZR", T_CZR)
-
-/* terminal key codes are not in here */
-
-    {NULL, NULL, 0, NULL, PV_NONE, {NULL, NULL}}	/* end marker */
-};
-
-#define PARAM_COUNT (sizeof(options) / sizeof(struct vimoption))
-
-#ifdef FEAT_MBYTE
-static char *(p_ambw_values[]) = {"single", "double", NULL};
-#endif
-static char *(p_bg_values[]) = {"light", "dark", NULL};
-static char *(p_nf_values[]) = {"octal", "hex", "alpha", NULL};
-static char *(p_ff_values[]) = {FF_UNIX, FF_DOS, FF_MAC, NULL};
-#ifdef FEAT_WAK
-static char *(p_wak_values[]) = {"yes", "menu", "no", NULL};
-#endif
-static char *(p_mousem_values[]) = {"extend", "popup", "popup_setpos", "mac", NULL};
-#ifdef FEAT_VISUAL
-static char *(p_sel_values[]) = {"inclusive", "exclusive", "old", NULL};
-static char *(p_slm_values[]) = {"mouse", "key", "cmd", NULL};
-#endif
-#ifdef FEAT_VISUAL
-static char *(p_km_values[]) = {"startsel", "stopsel", NULL};
-#endif
-#ifdef FEAT_BROWSE
-static char *(p_bsdir_values[]) = {"current", "last", "buffer", NULL};
-#endif
-#ifdef FEAT_SCROLLBIND
-static char *(p_scbopt_values[]) = {"ver", "hor", "jump", NULL};
-#endif
-static char *(p_swb_values[]) = {"useopen", "split", NULL};
-static char *(p_debug_values[]) = {"msg", NULL};
-#ifdef FEAT_VERTSPLIT
-static char *(p_ead_values[]) = {"both", "ver", "hor", NULL};
-#endif
-#if defined(FEAT_QUICKFIX)
-static char *(p_buftype_values[]) = {"nofile", "nowrite", "quickfix", "help", NULL};
-static char *(p_bufhidden_values[]) = {"hide", "unload", "delete", "wipe", NULL};
-#endif
-static char *(p_bs_values[]) = {"indent", "eol", "start", NULL};
-#ifdef FEAT_FOLDING
-static char *(p_fdm_values[]) = {"manual", "expr", "marker", "indent", "syntax",
-#ifdef FEAT_DIFF
-				"diff",
-#endif
-				NULL};
-static char *(p_fcl_values[]) = {"all", NULL};
-#endif
-
-static void set_option_default __ARGS((int, int opt_flags, int compatible));
-static void set_options_default __ARGS((int opt_flags));
-static char_u *illegal_char __ARGS((char_u *, int));
-static int string_to_key __ARGS((char_u *arg));
-#ifdef FEAT_CMDWIN
-static char_u *check_cedit __ARGS((void));
-#endif
-#ifdef FEAT_TITLE
-static void did_set_title __ARGS((int icon));
-#endif
-static char_u *option_expand __ARGS((int opt_idx, char_u *val));
-static void didset_options __ARGS((void));
-static void check_string_option __ARGS((char_u **pp));
-static void set_string_option_global __ARGS((int opt_idx, char_u **varp));
-static void set_string_option __ARGS((int opt_idx, char_u *value, int opt_flags));
-static char_u *did_set_string_option __ARGS((int opt_idx, char_u **varp, int new_value_alloced, char_u *oldval, char_u *errbuf, int opt_flags));
-static char_u *set_chars_option __ARGS((char_u **varp));
-#ifdef FEAT_CLIPBOARD
-static char_u *check_clipboard_option __ARGS((void));
-#endif
-static char_u *set_bool_option __ARGS((int opt_idx, char_u *varp, int value, int opt_flags));
-static char_u *set_num_option __ARGS((int opt_idx, char_u *varp, long value, char_u *errbuf, int opt_flags));
-static void check_redraw __ARGS((long_u flags));
-static int findoption __ARGS((char_u *));
-static int find_key_option __ARGS((char_u *));
-static void showoptions __ARGS((int all, int opt_flags));
-static int optval_default __ARGS((struct vimoption *, char_u *varp));
-static void showoneopt __ARGS((struct vimoption *, int opt_flags));
-static int put_setstring __ARGS((FILE *fd, char *cmd, char *name, char_u **valuep, int expand));
-static int put_setnum __ARGS((FILE *fd, char *cmd, char *name, long *valuep));
-static int put_setbool __ARGS((FILE *fd, char *cmd, char *name, int value));
-static int  istermoption __ARGS((struct vimoption *));
-static char_u *get_varp_scope __ARGS((struct vimoption *p, int opt_flags));
-static char_u *get_varp __ARGS((struct vimoption *));
-static void option_value2string __ARGS((struct vimoption *, int opt_flags));
-static int wc_use_keyname __ARGS((char_u *varp, long *wcp));
-#ifdef FEAT_LANGMAP
-static void langmap_init __ARGS((void));
-static void langmap_set __ARGS((void));
-#endif
-static void paste_option_changed __ARGS((void));
-static void compatible_set __ARGS((void));
-#ifdef FEAT_LINEBREAK
-static void fill_breakat_flags __ARGS((void));
-#endif
-static int opt_strings_flags __ARGS((char_u *val, char **values, unsigned *flagp, int list));
-static int check_opt_strings __ARGS((char_u *val, char **values, int));
-static int check_opt_wim __ARGS((void));
-
-/*
- * Initialize the options, first part.
- *
- * Called only once from main(), just after creating the first buffer.
- */
-    void
-set_init_1()
-{
-    char_u	*p;
-    int		opt_idx;
-    long	n;
-
-#ifdef FEAT_LANGMAP
-    langmap_init();
-#endif
-
-    /* Be Vi compatible by default */
-    p_cp = TRUE;
-
-    /*
-     * Find default value for 'shell' option.
-     */
-    if ((p = mch_getenv((char_u *)"SHELL")) != NULL
-#if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-# ifdef __EMX__
-	    || (p = mch_getenv((char_u *)"EMXSHELL")) != NULL
-# endif
-	    || (p = mch_getenv((char_u *)"COMSPEC")) != NULL
-# ifdef WIN3264
-	    || (p = default_shell()) != NULL
-# endif
-#endif
-       )
-	set_string_default("sh", p);
-
-#ifdef FEAT_WILDIGN
-    /*
-     * Set the default for 'backupskip' to include environment variables for
-     * temp files.
-     */
-    {
-# ifdef UNIX
-	static char	*(names[4]) = {"", "TMPDIR", "TEMP", "TMP"};
-# else
-	static char	*(names[3]) = {"TMPDIR", "TEMP", "TMP"};
-# endif
-	int	len;
-	garray_T ga;
-
-	ga_init2(&ga, 1, 100);
-	for (n = 0; n < (long)(sizeof(names) / sizeof(char *)); ++n)
-	{
-# ifdef UNIX
-	    if (*names[n] == NUL)
-		p = (char_u *)"/tmp";
-	    else
-# endif
-		p = mch_getenv((char_u *)names[n]);
-	    if (p != NULL && *p != NUL)
-	    {
-		/* First time count the NUL, otherwise count the ','. */
-		len = STRLEN(p) + 3;
-		if (ga_grow(&ga, len) == OK)
-		{
-		    if (ga.ga_len > 0)
-			STRCAT(ga.ga_data, ",");
-		    STRCAT(ga.ga_data, p);
-		    add_pathsep(ga.ga_data);
-		    STRCAT(ga.ga_data, "*");
-		    ga.ga_room -= len;
-		    ga.ga_len += len;
-		}
-	    }
-	}
-	if (ga.ga_data != NULL)
-	{
-	    set_string_default("bsk", ga.ga_data);
-	    vim_free(ga.ga_data);
-	}
-    }
-#endif
-
-    /*
-     * 'maxmemtot' and 'maxmem' may have to be adjusted for available memory
-     */
-    opt_idx = findoption((char_u *)"maxmemtot");
-#if !defined(HAVE_AVAIL_MEM) && !defined(HAVE_TOTAL_MEM)
-    if (options[opt_idx].def_val[VI_DEFAULT] == (char_u *)0L)
-#endif
-    {
-#ifdef HAVE_AVAIL_MEM
-	/* Use amount of memory available at this moment. */
-	n = (mch_avail_mem(FALSE) >> 11);
-#else
-# ifdef HAVE_TOTAL_MEM
-	/* Use amount of memory available to Vim. */
-	n = (mch_total_mem(FALSE) >> 11);
-# else
-	n = (0x7fffffff >> 11);
-# endif
-#endif
-	options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;
-	opt_idx = findoption((char_u *)"maxmem");
-#if !defined(HAVE_AVAIL_MEM) && !defined(HAVE_TOTAL_MEM)
-	if ((long)options[opt_idx].def_val[VI_DEFAULT] > n
-			  || (long)options[opt_idx].def_val[VI_DEFAULT] == 0L)
-#endif
-	    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;
-    }
-
-#ifdef FEAT_GUI_W32
-    /* force 'shortname' for Win32s */
-    if (gui_is_win32s())
-	options[findoption((char_u *)"shortname")].def_val[VI_DEFAULT] =
-							       (char_u *)TRUE;
-#endif
-
-#ifdef FEAT_SEARCHPATH
-    {
-	char_u	*cdpath;
-	char_u	*buf;
-	int	i;
-	int	j;
-
-	/* Initialize the 'cdpath' option's default value. */
-	cdpath = mch_getenv((char_u *)"CDPATH");
-	if (cdpath != NULL)
-	{
-	    buf = alloc((unsigned)((STRLEN(cdpath) << 1) + 2));
-	    if (buf != NULL)
-	    {
-		buf[0] = ',';	    /* start with ",", current dir first */
-		j = 1;
-		for (i = 0; cdpath[i] != NUL; ++i)
-		{
-		    if (vim_ispathlistsep(cdpath[i]))
-			buf[j++] = ',';
-		    else
-		    {
-			if (cdpath[i] == ' ' || cdpath[i] == ',')
-			    buf[j++] = '\\';
-			buf[j++] = cdpath[i];
-		    }
-		}
-		buf[j] = NUL;
-		opt_idx = findoption((char_u *)"cdpath");
-		options[opt_idx].def_val[VI_DEFAULT] = buf;
-		options[opt_idx].flags |= P_DEF_ALLOCED;
-	    }
-	}
-    }
-#endif
-
-#if defined(FEAT_POSTSCRIPT) && (defined(MSWIN) || defined(OS2) || defined(VMS) || defined(EBCDIC) || defined(MAC) || defined(hpux))
-    /* Set print encoding on platforms that don't default to latin1 */
-    set_string_default("penc",
-# if defined(MSWIN) || defined(OS2)
-		       (char_u *)"cp1252"
-# else
-#  ifdef VMS
-		       (char_u *)"dec-mcs"
-#  else
-#   ifdef EBCDIC
-		       (char_u *)"ebcdic-uk"
-#   else
-#    ifdef MAC
-		       (char_u *)"mac-roman"
-#    else /* HPUX */
-		       (char_u *)"hp-roman8"
-#    endif
-#   endif
-#  endif
-# endif
-		       );
-#endif
-
-#ifdef FEAT_POSTSCRIPT
-    /* 'printexpr' must be allocated to be able to evaluate it. */
-    set_string_default("pexpr",
-# ifdef MSWIN
-	    (char_u *)"system('copy' . ' ' . v:fname_in . ' \"' . &printdevice . '\"') . delete(v:fname_in)"
-# else
-#  ifdef VMS
-	    (char_u *)"system('print/delete' . (&printdevice == '' ? '' : ' /queue=' . &printdevice) . ' ' . v:fname_in)"
-
-#  else
-	    (char_u *)"system('lpr' . (&printdevice == '' ? '' : ' -P' . &printdevice) . ' ' . v:fname_in) . delete(v:fname_in) + v:shell_error"
-#  endif
-# endif
-	    );
-#endif
-
-    /*
-     * Set all the options (except the terminal options) to their default
-     * value.  Also set the global value for local options.
-     */
-    set_options_default(0);
-
-#ifdef FEAT_GUI
-    if (found_reverse_arg)
-	set_option_value((char_u *)"bg", 0L, (char_u *)"dark", 0);
-#endif
-
-    curbuf->b_p_initialized = TRUE;
-    curbuf->b_p_ar = -1;	/* no local 'autoread' value */
-    check_buf_options(curbuf);
-    check_win_options(curwin);
-    check_options();
-
-    /* Must be before option_expand(), because that one needs vim_isIDc() */
-    didset_options();
-
-#ifdef FEAT_LINEBREAK
-    /*
-     * initialize the table for 'breakat'.
-     */
-    fill_breakat_flags();
-#endif
-
-    /*
-     * Expand environment variables and things like "~" for the defaults.
-     * If option_expand() returns non-NULL the variable is expanded.  This can
-     * only happen for non-indirect options.
-     * Also set the default to the expanded value, so ":set" does not list
-     * them.
-     * Don't set the P_ALLOCED flag, because we don't want to free the
-     * default.
-     */
-    for (opt_idx = 0; !istermoption(&options[opt_idx]); opt_idx++)
-    {
-	if ((options[opt_idx].flags & P_GETTEXT)
-					      && options[opt_idx].var != NULL)
-	    p = (char_u *)_(*(char **)options[opt_idx].var);
-	else
-	    p = option_expand(opt_idx, NULL);
-	if (p != NULL && (p = vim_strsave(p)) != NULL)
-	{
-	    *(char_u **)options[opt_idx].var = p;
-	    /* VIMEXP
-	     * Defaults for all expanded options are currently the same for Vi
-	     * and Vim.  When this changes, add some code here!  Also need to
-	     * split P_DEF_ALLOCED in two.
-	     */
-	    if (options[opt_idx].flags & P_DEF_ALLOCED)
-		vim_free(options[opt_idx].def_val[VI_DEFAULT]);
-	    options[opt_idx].def_val[VI_DEFAULT] = p;
-	    options[opt_idx].flags |= P_DEF_ALLOCED;
-	}
-    }
-
-    /* Initialize the highlight_attr[] table. */
-    highlight_changed();
-
-    save_file_ff(curbuf);	/* Buffer is unchanged */
-
-    /* Parse default for 'wildmode'  */
-    check_opt_wim();
-
-#if defined(FEAT_ARABIC)
-    /* Detect use of mlterm.
-     * Mlterm is a terminal emulator akin to xterm that has some special
-     * abilities (bidi namely).
-     * NOTE: mlterm's author is being asked to 'set' a variable
-     *       instead of an environment variable due to inheritance.
-     */
-    if (mch_getenv((char_u *)"MLTERM") != NULL)
-	set_option_value((char_u *)"tbidi", 1L, NULL, 0);
-#endif
-
-#if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
-    /* Parse default for 'fillchars'. */
-    (void)set_chars_option(&p_fcs);
-#endif
-
-#ifdef FEAT_CLIPBOARD
-    /* Parse default for 'clipboard' */
-    (void)check_clipboard_option();
-#endif
-
-#ifdef FEAT_MBYTE
-# if defined(WIN3264) && defined(FEAT_GETTEXT)
-    /*
-     * If $LANG isn't set, try to get a good value for it.  This makes the
-     * right language be used automatically.  Don't do this for English.
-     */
-    if (mch_getenv((char_u *)"LANG") == NULL)
-    {
-	char	buf[20];
-
-	/* Could use LOCALE_SISO639LANGNAME, but it's not in Win95.
-	 * LOCALE_SABBREVLANGNAME gives us three letters, like "enu", we use
-	 * only the first two. */
-	n = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SABBREVLANGNAME,
-							     (LPTSTR)buf, 20);
-	if (n >= 2 && STRNICMP(buf, "en", 2) != 0)
-	{
-	    /* There are a few exceptions (probably more) */
-	    if (STRNICMP(buf, "cht", 3) == 0 || STRNICMP(buf, "zht", 3) == 0)
-		STRCPY(buf, "zh_TW");
-	    else if (STRNICMP(buf, "chs", 3) == 0
-					      || STRNICMP(buf, "zhc", 3) == 0)
-		STRCPY(buf, "zh_CN");
-	    else if (STRNICMP(buf, "jp", 2) == 0)
-		STRCPY(buf, "ja");
-	    else
-		buf[2] = NUL;		/* truncate to two-letter code */
-	    vim_setenv("LANG", buf);
-	}
-    }
-# endif
-
-    /* enc_locale() will try to find the encoding of the current locale. */
-    p = enc_locale();
-    if (p != NULL)
-    {
-	char_u *save_enc;
-
-	/* Try setting 'encoding' and check if the value is valid.
-	 * If not, go back to the default "latin1". */
-	save_enc = p_enc;
-	p_enc = p;
-	if (mb_init() == NULL)
-	{
-	    opt_idx = findoption((char_u *)"encoding");
-	    options[opt_idx].def_val[VI_DEFAULT] = p_enc;
-	    options[opt_idx].flags |= P_DEF_ALLOCED;
-
-# if defined(WIN3264) && !defined(FEAT_GUI)
-	    /* Win32 console: When GetACP() returns a different value from
-	     * GetConsoleCP() set 'termencoding'. */
-	    if (GetACP() != GetConsoleCP())
-	    {
-		char	buf[50];
-
-		sprintf(buf, "cp%ld", (long)GetConsoleCP());
-		p_tenc = vim_strsave((char_u *)buf);
-		if (p_tenc != NULL)
-		{
-		    opt_idx = findoption((char_u *)"termencoding");
-		    options[opt_idx].def_val[VI_DEFAULT] = p_tenc;
-		    options[opt_idx].flags |= P_DEF_ALLOCED;
-		    convert_setup(&input_conv, p_tenc, p_enc);
-		    convert_setup(&output_conv, p_enc, p_tenc);
-		}
-		else
-		    p_tenc = empty_option;
-	    }
-# endif
-	}
-	else
-	{
-	    vim_free(p_enc);
-	    p_enc = save_enc;
-	}
-    }
-#endif
-
-#ifdef FEAT_MULTI_LANG
-    /* Set the default for 'helplang'. */
-    set_helplang_default(get_mess_lang());
-#endif
-}
-
-/*
- * Set an option to its default value.
- * This does not take care of side effects!
- */
-    static void
-set_option_default(opt_idx, opt_flags, compatible)
-    int		opt_idx;
-    int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
-    int		compatible;	/* use Vi default value */
-{
-    char_u	*varp;		/* pointer to variable for current option */
-    int		dvi;		/* index in def_val[] */
-    long_u	flags;
-    int		both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;
-
-    varp = get_varp_scope(&(options[opt_idx]), both ? OPT_LOCAL : opt_flags);
-    flags = options[opt_idx].flags;
-    if (varp != NULL)	    /* nothing to do for hidden option */
-    {
-	dvi = ((flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;
-	if (flags & P_STRING)
-	{
-	    /* Use set_string_option_direct() for local options to handle
-	     * freeing and allocating the value. */
-	    if (options[opt_idx].indir != PV_NONE)
-		set_string_option_direct(NULL, opt_idx,
-				    options[opt_idx].def_val[dvi], opt_flags);
-	    else
-	    {
-		if ((opt_flags & OPT_FREE) && (flags & P_ALLOCED))
-		    free_string_option(*(char_u **)(varp));
-		*(char_u **)varp = options[opt_idx].def_val[dvi];
-		options[opt_idx].flags &= ~P_ALLOCED;
-	    }
-	}
-	else if (flags & P_NUM)
-	{
-	    if (varp == (char_u *)PV_SCROLL)
-		win_comp_scroll(curwin);
-	    else
-	    {
-		*(long *)varp = (long)options[opt_idx].def_val[dvi];
-		/* May also set global value for local option. */
-		if (both)
-		    *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =
-								*(long *)varp;
-	    }
-	}
-	else	/* P_BOOL */
-	{
-	    /* the cast to long is required for Manx C */
-	    *(int *)varp = (int)(long)options[opt_idx].def_val[dvi];
-	    /* May also set global value for local option. */
-	    if (both)
-		*(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =
-								*(int *)varp;
-	}
-    }
-
-#ifdef FEAT_EVAL
-    /* Remember where the option was set. */
-    options[opt_idx].scriptID = current_SID;
-#endif
-}
-
-/*
- * Set all options (except terminal options) to their default value.
- */
-    static void
-set_options_default(opt_flags)
-    int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
-{
-    int		i;
-#ifdef FEAT_WINDOWS
-    win_T	*wp;
-#endif
-
-    for (i = 0; !istermoption(&options[i]); i++)
-	if (!(options[i].flags & P_NODEFAULT))
-	    set_option_default(i, opt_flags, p_cp);
-
-#ifdef FEAT_WINDOWS
-    /* The 'scroll' option must be computed for all windows. */
-    for (wp = firstwin; wp != NULL; wp = wp->w_next)
-	win_comp_scroll(wp);
-#else
-	win_comp_scroll(curwin);
-#endif
-}
-
-/*
- * Set the Vi-default value of a string option.
- * Used for 'sh', 'backupskip' and 'term'.
- */
-    void
-set_string_default(name, val)
-    char	*name;
-    char_u	*val;
-{
-    char_u	*p;
-    int		opt_idx;
-
-    p = vim_strsave(val);
-    if (p != NULL)		/* we don't want a NULL */
-    {
-	opt_idx = findoption((char_u *)name);
-	if (options[opt_idx].flags & P_DEF_ALLOCED)
-	    vim_free(options[opt_idx].def_val[VI_DEFAULT]);
-	options[opt_idx].def_val[VI_DEFAULT] = p;
-	options[opt_idx].flags |= P_DEF_ALLOCED;
-    }
-}
-
-/*
- * Set the Vi-default value of a number option.
- * Used for 'lines' and 'columns'.
- */
-    void
-set_number_default(name, val)
-    char	*name;
-    long	val;
-{
-    options[findoption((char_u *)name)].def_val[VI_DEFAULT] = (char_u *)val;
-}
-
-/*
- * Initialize the options, part two: After getting Rows and Columns and
- * setting 'term'.
- */
-    void
-set_init_2()
-{
-    /*
-     * 'scroll' defaults to half the window height. Note that this default is
-     * wrong when the window height changes.
-     */
-    options[findoption((char_u *)"scroll")].def_val[VI_DEFAULT]
-					      = (char_u *)((long_u)Rows >> 1);
-    comp_col();
-
-#if !((defined(MSDOS) || defined(OS2) || defined(WIN3264)) && !defined(FEAT_GUI))
-    {
-	int	idx4;
-
-	/*
-	 * If 'background' wasn't set by the user, try guessing the value,
-	 * depending on the terminal name.  Only need to check for terminals
-	 * with a dark background, that can handle color.  Only "linux"
-	 * console at the moment.
-	 */
-	idx4 = findoption((char_u *)"bg");
-	if (!(options[idx4].flags & P_WAS_SET) && STRCMP(T_NAME, "linux") == 0)
-	{
-	    set_string_option_direct(NULL, idx4, (char_u *)"dark", OPT_FREE);
-	    /* don't mark it as set, when starting the GUI it may be changed
-	     * again */
-	    options[idx4].flags &= ~P_WAS_SET;
-	}
-    }
-#endif
-}
-
-/*
- * Initialize the options, part three: After reading the .vimrc
- */
-    void
-set_init_3()
-{
-#if defined(UNIX) || defined(OS2) || defined(WIN3264)
-/*
- * Set 'shellpipe' and 'shellredir', depending on the 'shell' option.
- * This is done after other initializations, where 'shell' might have been
- * set, but only if they have not been set before.
- */
-    char_u  *p;
-    int	    idx_srr;
-    int	    do_srr;
-#ifdef FEAT_QUICKFIX
-    int	    idx_sp;
-    int	    do_sp;
-#endif
-
-    idx_srr = findoption((char_u *)"srr");
-    do_srr = !(options[idx_srr].flags & P_WAS_SET);
-#ifdef FEAT_QUICKFIX
-    idx_sp = findoption((char_u *)"sp");
-    do_sp = !(options[idx_sp].flags & P_WAS_SET);
-#endif
-
-    /*
-     * Isolate the name of the shell:
-     * - Skip beyond any path.  E.g., "/usr/bin/csh -f" -> "csh -f".
-     * - Remove any argument.  E.g., "csh -f" -> "csh".
-     */
-    p = gettail(p_sh);
-    p = vim_strnsave(p, (int)(skiptowhite(p) - p));
-    if (p != NULL)
-    {
-	/*
-	 * Default for p_sp is "| tee", for p_srr is ">".
-	 * For known shells it is changed here to include stderr.
-	 */
-	if (	   fnamecmp(p, "csh") == 0
-		|| fnamecmp(p, "tcsh") == 0
-# if defined(OS2) || defined(WIN3264)	/* also check with .exe extension */
-		|| fnamecmp(p, "csh.exe") == 0
-		|| fnamecmp(p, "tcsh.exe") == 0
-# endif
-	   )
-	{
-#if defined(FEAT_QUICKFIX)
-	    if (do_sp)
-	    {
-# ifdef WIN3264
-		p_sp = (char_u *)">&";
-# else
-		p_sp = (char_u *)"|& tee";
-# endif
-		options[idx_sp].def_val[VI_DEFAULT] = p_sp;
-	    }
-#endif
-	    if (do_srr)
-	    {
-		p_srr = (char_u *)">&";
-		options[idx_srr].def_val[VI_DEFAULT] = p_srr;
-	    }
-	}
-	else
-# ifndef OS2	/* Always use bourne shell style redirection if we reach this */
-	    if (       fnamecmp(p, "sh") == 0
-		    || fnamecmp(p, "ksh") == 0
-		    || fnamecmp(p, "zsh") == 0
-		    || fnamecmp(p, "bash") == 0
-#  ifdef WIN3264
-		    || fnamecmp(p, "cmd") == 0
-		    || fnamecmp(p, "sh.exe") == 0
-		    || fnamecmp(p, "ksh.exe") == 0
-		    || fnamecmp(p, "zsh.exe") == 0
-		    || fnamecmp(p, "bash.exe") == 0
-		    || fnamecmp(p, "cmd.exe") == 0
-#  endif
-		    )
-# endif
-	    {
-#if defined(FEAT_QUICKFIX)
-		if (do_sp)
-		{
-# ifdef WIN3264
-		    p_sp = (char_u *)">%s 2>&1";
-# else
-		    p_sp = (char_u *)"2>&1| tee";
-# endif
-		    options[idx_sp].def_val[VI_DEFAULT] = p_sp;
-		}
-#endif
-		if (do_srr)
-		{
-		    p_srr = (char_u *)">%s 2>&1";
-		    options[idx_srr].def_val[VI_DEFAULT] = p_srr;
-		}
-	    }
-	vim_free(p);
-    }
-#endif
-
-#if defined(MSDOS) || defined(WIN3264) || defined(OS2)
-    /*
-     * Set 'shellcmdflag and 'shellquote' depending on the 'shell' option.
-     * This is done after other initializations, where 'shell' might have been
-     * set, but only if they have not been set before.  Default for p_shcf is
-     * "/c", for p_shq is "".  For "sh" like  shells it is changed here to
-     * "-c" and "\"", but not for DJGPP, because it starts the shell without
-     * command.com.  And for Win32 we need to set p_sxq instead.
-     */
-    if (strstr((char *)p_sh, "sh") != NULL)
-    {
-	int	idx3;
-
-	idx3 = findoption((char_u *)"shcf");
-	if (!(options[idx3].flags & P_WAS_SET))
-	{
-	    p_shcf = (char_u *)"-c";
-	    options[idx3].def_val[VI_DEFAULT] = p_shcf;
-	}
-
-# ifndef DJGPP
-#  ifdef WIN3264
-	/* Somehow Win32 requires the quotes around the redirection too */
-	idx3 = findoption((char_u *)"sxq");
-	if (!(options[idx3].flags & P_WAS_SET))
-	{
-	    p_sxq = (char_u *)"\"";
-	    options[idx3].def_val[VI_DEFAULT] = p_sxq;
-	}
-#  else
-	idx3 = findoption((char_u *)"shq");
-	if (!(options[idx3].flags & P_WAS_SET))
-	{
-	    p_shq = (char_u *)"\"";
-	    options[idx3].def_val[VI_DEFAULT] = p_shq;
-	}
-#  endif
-# endif
-    }
-#endif
-
-#ifdef FEAT_TITLE
-    set_title_defaults();
-#endif
-}
-
-#if defined(FEAT_MULTI_LANG) || defined(PROTO)
-/*
- * When 'helplang' is still at its default value, set it to "lang".
- * Only the first two characters of "lang" are used.
- */
-    void
-set_helplang_default(lang)
-    char_u	*lang;
-{
-    int		idx;
-
-    if (lang == NULL || STRLEN(lang) < 2)	/* safety check */
-	return;
-    idx = findoption((char_u *)"hlg");
-    if (!(options[idx].flags & P_WAS_SET))
-    {
-	if (options[idx].flags & P_ALLOCED)
-	    free_string_option(p_hlg);
-	p_hlg = vim_strsave(lang);
-	if (p_hlg == NULL)
-	    p_hlg = empty_option;
-	else
-	{
-	    /* zh_CN becomes "cn", zh_TW becomes "tw". */
-	    if (STRNICMP(p_hlg, "zh_", 3) == 0 && STRLEN(p_hlg) >= 5)
-	    {
-		p_hlg[0] = TOLOWER_ASC(p_hlg[3]);
-		p_hlg[1] = TOLOWER_ASC(p_hlg[4]);
-	    }
-	    p_hlg[2] = NUL;
-	}
-	options[idx].flags |= P_ALLOCED;
-    }
-}
-#endif
-
-#ifdef FEAT_GUI
-static char_u *gui_bg_default __ARGS((void));
-
-    static char_u *
-gui_bg_default()
-{
-    if (gui_get_lightness(gui.back_pixel) < 127)
-	return (char_u *)"dark";
-    return (char_u *)"light";
-}
-
-/*
- * Option initializations that can only be done after opening the GUI window.
- */
-    void
-init_gui_options()
-{
-    /* Set the 'background' option according to the lightness of the
-     * background color, unless the user has set it already. */
-    if (!option_was_set((char_u *)"bg") && STRCMP(p_bg, gui_bg_default()) != 0)
-    {
-	set_option_value((char_u *)"bg", 0L, gui_bg_default(), 0);
-	highlight_changed();
-    }
-}
-#endif
-
-#ifdef FEAT_TITLE
-/*
- * 'title' and 'icon' only default to true if they have not been set or reset
- * in .vimrc and we can read the old value.
- * When 'title' and 'icon' have been reset in .vimrc, we won't even check if
- * they can be reset.  This reduces startup time when using X on a remote
- * machine.
- */
-    void
-set_title_defaults()
-{
-    int	    idx1;
-    long    val;
-
-    /*
-     * If GUI is (going to be) used, we can always set the window title and
-     * icon name.  Saves a bit of time, because the X11 display server does
-     * not need to be contacted.
-     */
-    idx1 = findoption((char_u *)"title");
-    if (!(options[idx1].flags & P_WAS_SET))
-    {
-#ifdef FEAT_GUI
-	if (gui.starting || gui.in_use)
-	    val = TRUE;
-	else
-#endif
-	    val = mch_can_restore_title();
-	options[idx1].def_val[VI_DEFAULT] = (char_u *)val;
-	p_title = val;
-    }
-    idx1 = findoption((char_u *)"icon");
-    if (!(options[idx1].flags & P_WAS_SET))
-    {
-#ifdef FEAT_GUI
-	if (gui.starting || gui.in_use)
-	    val = TRUE;
-	else
-#endif
-	    val = mch_can_restore_icon();
-	options[idx1].def_val[VI_DEFAULT] = (char_u *)val;
-	p_icon = val;
-    }
-}
-#endif
-
-/*
- * Parse 'arg' for option settings.
- *
- * 'arg' may be IObuff, but only when no errors can be present and option
- * does not need to be expanded with option_expand().
- * "opt_flags":
- * 0 for ":set"
- * OPT_GLOBAL for ":setglobal"
- * OPT_LOCAL for ":setlocal" and a modeline
- * OPT_MODELINE for a modeline
- *
- * returns FAIL if an error is detected, OK otherwise
- */
-    int
-do_set(arg, opt_flags)
-    char_u	*arg;		/* option string (may be written to!) */
-    int		opt_flags;
-{
-    int		opt_idx;
-    char_u	*errmsg;
-    char_u	errbuf[80];
-    char_u	*startarg;
-    int		prefix;	/* 1: nothing, 0: "no", 2: "inv" in front of name */
-    int		nextchar;	    /* next non-white char after option name */
-    int		afterchar;	    /* character just after option name */
-    int		len;
-    int		i;
-    long	value;
-    int		key;
-    long_u	flags;		    /* flags for current option */
-    char_u	*varp = NULL;	    /* pointer to variable for current option */
-    int		did_show = FALSE;   /* already showed one value */
-    int		adding;		    /* "opt+=arg" */
-    int		prepending;	    /* "opt^=arg" */
-    int		removing;	    /* "opt-=arg" */
-    int		cp_val = 0;
-    char_u	key_name[2];
-
-    if (*arg == NUL)
-    {
-	showoptions(0, opt_flags);
-	return OK;
-    }
-
-    while (*arg != NUL)		/* loop to process all options */
-    {
-	errmsg = NULL;
-	startarg = arg;		/* remember for error message */
-
-	if (STRNCMP(arg, "all", 3) == 0 && !isalpha(arg[3])
-						&& !(opt_flags & OPT_MODELINE))
-	{
-	    /*
-	     * ":set all"  show all options.
-	     * ":set all&" set all options to their default value.
-	     */
-	    arg += 3;
-	    if (*arg == '&')
-	    {
-		++arg;
-		/* Only for :set command set global value of local options. */
-		set_options_default(OPT_FREE | opt_flags);
-	    }
-	    else
-		showoptions(1, opt_flags);
-	}
-	else if (STRNCMP(arg, "termcap", 7) == 0 && !(opt_flags & OPT_MODELINE))
-	{
-	    showoptions(2, opt_flags);
-	    show_termcodes();
-	    arg += 7;
-	}
-	else
-	{
-	    prefix = 1;
-	    if (STRNCMP(arg, "no", 2) == 0)
-	    {
-		prefix = 0;
-		arg += 2;
-	    }
-	    else if (STRNCMP(arg, "inv", 3) == 0)
-	    {
-		prefix = 2;
-		arg += 3;
-	    }
-
-	    /* find end of name */
-	    key = 0;
-	    if (*arg == '<')
-	    {
-		nextchar = 0;
-		opt_idx = -1;
-		/* look out for <t_>;> */
-		if (arg[1] == 't' && arg[2] == '_' && arg[3] && arg[4])
-		    len = 5;
-		else
-		{
-		    len = 1;
-		    while (arg[len] != NUL && arg[len] != '>')
-			++len;
-		}
-		if (arg[len] != '>')
-		{
-		    errmsg = e_invarg;
-		    goto skip;
-		}
-		arg[len] = NUL;			    /* put NUL after name */
-		if (arg[1] == 't' && arg[2] == '_') /* could be term code */
-		    opt_idx = findoption(arg + 1);
-		arg[len++] = '>';		    /* restore '>' */
-		if (opt_idx == -1)
-		    key = find_key_option(arg + 1);
-	    }
-	    else
-	    {
-		len = 0;
-		/*
-		 * The two characters after "t_" may not be alphanumeric.
-		 */
-		if (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])
-		    len = 4;
-		else
-		    while (ASCII_ISALNUM(arg[len]) || arg[len] == '_')
-			++len;
-		nextchar = arg[len];
-		arg[len] = NUL;			    /* put NUL after name */
-		opt_idx = findoption(arg);
-		arg[len] = nextchar;		    /* restore nextchar */
-		if (opt_idx == -1)
-		    key = find_key_option(arg);
-	    }
-
-	    /* remember character after option name */
-	    afterchar = arg[len];
-
-	    /* skip white space, allow ":set ai  ?" */
-	    while (vim_iswhite(arg[len]))
-		++len;
-
-	    adding = FALSE;
-	    prepending = FALSE;
-	    removing = FALSE;
-	    if (arg[len] != NUL && arg[len + 1] == '=')
-	    {
-		if (arg[len] == '+')
-		{
-		    adding = TRUE;		/* "+=" */
-		    ++len;
-		}
-		else if (arg[len] == '^')
-		{
-		    prepending = TRUE;		/* "^=" */
-		    ++len;
-		}
-		else if (arg[len] == '-')
-		{
-		    removing = TRUE;		/* "-=" */
-		    ++len;
-		}
-	    }
-	    nextchar = arg[len];
-
-	    if (opt_idx == -1 && key == 0)	/* found a mismatch: skip */
-	    {
-		errmsg = (char_u *)N_("E518: Unknown option");
-		goto skip;
-	    }
-
-	    if (opt_idx >= 0)
-	    {
-		if (options[opt_idx].var == NULL)   /* hidden option: skip */
-		{
-		    /* Only give an error message when requesting the value of
-		     * a hidden option, ignore setting it. */
-		    if (vim_strchr((char_u *)"=:!&<", nextchar) == NULL
-			    && (!(options[opt_idx].flags & P_BOOL)
-				|| nextchar == '?'))
-			errmsg = (char_u *)N_("E519: Option not supported");
-		    goto skip;
-		}
-
-		flags = options[opt_idx].flags;
-		varp = get_varp_scope(&(options[opt_idx]), opt_flags);
-	    }
-	    else
-	    {
-		flags = P_STRING;
-		if (key < 0)
-		{
-		    key_name[0] = KEY2TERMCAP0(key);
-		    key_name[1] = KEY2TERMCAP1(key);
-		}
-		else
-		{
-		    key_name[0] = KS_KEY;
-		    key_name[1] = (key & 0xff);
-		}
-	    }
-
-	    /* Disallow changing some options from modelines */
-	    if ((opt_flags & OPT_MODELINE) && (flags & P_SECURE))
-	    {
-		errmsg = (char_u *)_("E520: Not allowed in a modeline");
-		goto skip;
-	    }
-
-#ifdef HAVE_SANDBOX
-	    /* Disallow changing some options in the sandbox */
-	    if (sandbox > 0 && (flags & P_SECURE))
-	    {
-		errmsg = (char_u *)_(e_sandbox);
-		goto skip;
-	    }
-#endif
-
-	    if (vim_strchr((char_u *)"?=:!&<", nextchar) != NULL)
-	    {
-		arg += len;
-		cp_val = p_cp;
-		if (nextchar == '&' && arg[1] == 'v' && arg[2] == 'i')
-		{
-		    if (arg[3] == 'm')	/* "opt&vim": set to Vim default */
-		    {
-			cp_val = FALSE;
-			arg += 3;
-		    }
-		    else		/* "opt&vi": set to Vi default */
-		    {
-			cp_val = TRUE;
-			arg += 2;
-		    }
-		}
-		if (vim_strchr((char_u *)"?!&<", nextchar) != NULL
-			&& arg[1] != NUL && !vim_iswhite(arg[1]))
-		{
-		    errmsg = e_trailing;
-		    goto skip;
-		}
-	    }
-
-	    /*
-	     * allow '=' and ':' as MSDOS command.com allows only one
-	     * '=' character per "set" command line. grrr. (jw)
-	     */
-	    if (nextchar == '?'
-		    || (prefix == 1
-			&& vim_strchr((char_u *)"=:&<", nextchar) == NULL
-			&& !(flags & P_BOOL)))
-	    {
-		/*
-		 * print value
-		 */
-		if (did_show)
-		    msg_putchar('\n');	    /* cursor below last one */
-		else
-		{
-		    gotocmdline(TRUE);	    /* cursor at status line */
-		    did_show = TRUE;	    /* remember that we did a line */
-		}
-		if (opt_idx >= 0)
-		{
-		    showoneopt(&options[opt_idx], opt_flags);
-#ifdef FEAT_EVAL
-		    if (p_verbose > 0)
-		    {
-			if (options[opt_idx].scriptID != 0)
-			{
-			    MSG_PUTS(_("\n\tLast set from "));
-			    MSG_PUTS(get_scriptname(options[opt_idx].scriptID));
-			}
-		    }
-#endif
-		}
-		else
-		{
-		    char_u	    *p;
-
-		    p = find_termcode(key_name);
-		    if (p == NULL)
-		    {
-			errmsg = (char_u *)N_("E518: Unknown option");
-			goto skip;
-		    }
-		    else
-			(void)show_one_termcode(key_name, p, TRUE);
-		}
-		if (nextchar != '?'
-			&& nextchar != NUL && !vim_iswhite(afterchar))
-		    errmsg = e_trailing;
-	    }
-	    else
-	    {
-		if (flags & P_BOOL)		    /* boolean */
-		{
-		    if (nextchar == '=' || nextchar == ':')
-		    {
-			errmsg = e_invarg;
-			goto skip;
-		    }
-
-		    /*
-		     * ":set opt!": invert
-		     * ":set opt&": reset to default value
-		     * ":set opt<": reset to global value
-		     */
-		    if (nextchar == '!')
-			value = *(int *)(varp) ^ 1;
-		    else if (nextchar == '&')
-			value = (int)(long)options[opt_idx].def_val[
-						((flags & P_VI_DEF) || cp_val)
-						 ?  VI_DEFAULT : VIM_DEFAULT];
-		    else if (nextchar == '<')
-		    {
-			/* For 'autoread' -1 means to use global value. */
-			if ((int *)varp == &curbuf->b_p_ar
-						    && opt_flags == OPT_LOCAL)
-			    value = -1;
-			else
-			    value = *(int *)get_varp_scope(&(options[opt_idx]),
-								  OPT_GLOBAL);
-		    }
-		    else
-		    {
-			/*
-			 * ":set invopt": invert
-			 * ":set opt" or ":set noopt": set or reset
-			 */
-			if (nextchar != NUL && !vim_iswhite(afterchar))
-			{
-			    errmsg = e_trailing;
-			    goto skip;
-			}
-			if (prefix == 2)	/* inv */
-			    value = *(int *)(varp) ^ 1;
-			else
-			    value = prefix;
-		    }
-
-		    errmsg = set_bool_option(opt_idx, varp, (int)value,
-								   opt_flags);
-		}
-		else				    /* numeric or string */
-		{
-		    if (vim_strchr((char_u *)"=:&<", nextchar) == NULL
-							       || prefix != 1)
-		    {
-			errmsg = e_invarg;
-			goto skip;
-		    }
-
-		    if (flags & P_NUM)		    /* numeric */
-		    {
-			/*
-			 * Different ways to set a number option:
-			 * &	    set to default value
-			 * <	    set to global value
-			 * <xx>	    accept special key codes for 'wildchar'
-			 * c	    accept any non-digit for 'wildchar'
-			 * [-]0-9   set number
-			 * other    error
-			 */
-			++arg;
-			if (nextchar == '&')
-			    value = (long)options[opt_idx].def_val[
-						((flags & P_VI_DEF) || cp_val)
-						 ?  VI_DEFAULT : VIM_DEFAULT];
-			else if (nextchar == '<')
-			    value = *(long *)get_varp_scope(&(options[opt_idx]),
-								  OPT_GLOBAL);
-			else if (((long *)varp == &p_wc
-				    || (long *)varp == &p_wcm)
-				&& (*arg == '<'
-				    || *arg == '^'
-				    || ((!arg[1] || vim_iswhite(arg[1]))
-					&& !VIM_ISDIGIT(*arg))))
-			{
-			    value = string_to_key(arg);
-			    if (value == 0 && (long *)varp != &p_wcm)
-			    {
-				errmsg = e_invarg;
-				goto skip;
-			    }
-			}
-				/* allow negative numbers (for 'undolevels') */
-			else if (*arg == '-' || VIM_ISDIGIT(*arg))
-			{
-			    i = 0;
-			    if (*arg == '-')
-				i = 1;
-#ifdef HAVE_STRTOL
-			    value = strtol((char *)arg, NULL, 0);
-			    if (arg[i] == '0' && TOLOWER_ASC(arg[i + 1]) == 'x')
-				i += 2;
-#else
-			    value = atol((char *)arg);
-#endif
-			    while (VIM_ISDIGIT(arg[i]))
-				++i;
-			    if (arg[i] != NUL && !vim_iswhite(arg[i]))
-			    {
-				errmsg = e_invarg;
-				goto skip;
-			    }
-			}
-			else
-			{
-			    errmsg = (char_u *)N_("E521: Number required after =");
-			    goto skip;
-			}
-
-			if (adding)
-			    value = *(long *)varp + value;
-			if (prepending)
-			    value = *(long *)varp * value;
-			if (removing)
-			    value = *(long *)varp - value;
-			errmsg = set_num_option(opt_idx, varp, value,
-							   errbuf, opt_flags);
-		    }
-		    else if (opt_idx >= 0)		    /* string */
-		    {
-			char_u	    *save_arg = NULL;
-			char_u	    *s = NULL;
-			char_u	    *oldval;	/* previous value if *varp */
-			char_u	    *newval;
-			char_u	    *origval;
-			unsigned    newlen;
-			int	    comma;
-			int	    bs;
-			int	    new_value_alloced;	/* new string option
-							   was allocated */
-
-			/* When using ":set opt=val" for a global option
-			 * with a local value the local value will be
-			 * reset, use the global value here. */
-			if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0
-				&& (int)options[opt_idx].indir >= PV_BOTH)
-			    varp = options[opt_idx].var;
-
-			/* The old value is kept until we are sure that the
-			 * new value is valid. */
-			oldval = *(char_u **)varp;
-			if (nextchar == '&')	/* set to default val */
-			{
-			    newval = options[opt_idx].def_val[
-						((flags & P_VI_DEF) || cp_val)
-						 ?  VI_DEFAULT : VIM_DEFAULT];
-			    if ((char_u **)varp == &p_bg)
-			    {
-				/* guess the value of 'background' */
-#ifdef FEAT_GUI
-				if (gui.in_use)
-				    newval = gui_bg_default();
-				else
-#endif
-				    if (STRCMP(T_NAME, "linux") == 0)
-					newval = (char_u *)"dark";
-			    }
-
-			    /* expand environment variables and ~ (since the
-			     * default value was already expanded, only
-			     * required when an environment variable was set
-			     * later */
-			    if (newval == NULL)
-				newval = empty_option;
-			    else
-			    {
-				s = option_expand(opt_idx, newval);
-				if (s == NULL)
-				    s = newval;
-				newval = vim_strsave(s);
-			    }
-			    new_value_alloced = TRUE;
-			}
-			else if (nextchar == '<')	/* set to global val */
-			{
-			    newval = vim_strsave(*(char_u **)get_varp_scope(
-					     &(options[opt_idx]), OPT_GLOBAL));
-			    new_value_alloced = TRUE;
-			}
-			else
-			{
-			    ++arg;	/* jump to after the '=' or ':' */
-
-			    /*
-			     * Set 'keywordprg' to ":help" if an empty
-			     * value was passed to :set by the user.
-			     * Misuse errbuf[] for the resulting string.
-			     */
-			    if (varp == (char_u *)&p_kp
-					      && (*arg == NUL || *arg == ' '))
-			    {
-				STRCPY(errbuf, ":help");
-				save_arg = arg;
-				arg = errbuf;
-			    }
-			    /*
-			     * Convert 'whichwrap' number to string, for
-			     * backwards compatibility with Vim 3.0.
-			     * Misuse errbuf[] for the resulting string.
-			     */
-			    else if (varp == (char_u *)&p_ww
-							 && VIM_ISDIGIT(*arg))
-			    {
-				*errbuf = NUL;
-				i = getdigits(&arg);
-				if (i & 1)
-				    STRCAT(errbuf, "b,");
-				if (i & 2)
-				    STRCAT(errbuf, "s,");
-				if (i & 4)
-				    STRCAT(errbuf, "h,l,");
-				if (i & 8)
-				    STRCAT(errbuf, "<,>,");
-				if (i & 16)
-				    STRCAT(errbuf, "[,],");
-				if (*errbuf != NUL)	/* remove trailing , */
-				    errbuf[STRLEN(errbuf) - 1] = NUL;
-				save_arg = arg;
-				arg = errbuf;
-			    }
-			    /*
-			     * Remove '>' before 'dir' and 'bdir', for
-			     * backwards compatibility with version 3.0
-			     */
-			    else if (  *arg == '>'
-				    && (varp == (char_u *)&p_dir
-					    || varp == (char_u *)&p_bdir))
-			    {
-				++arg;
-			    }
-
-			    /* When setting the local value of a global
-			     * option, the old value may be the global value. */
-			    if ((int)options[opt_idx].indir >= PV_BOTH
-						   && (opt_flags & OPT_LOCAL))
-				origval = *(char_u **)get_varp(
-							   &options[opt_idx]);
-			    else
-				origval = oldval;
-
-			    /*
-			     * Copy the new string into allocated memory.
-			     * Can't use set_string_option_direct(), because
-			     * we need to remove the backslashes.
-			     */
-			    /* get a bit too much */
-			    newlen = (unsigned)STRLEN(arg) + 1;
-			    if (adding || prepending || removing)
-				newlen += (unsigned)STRLEN(origval) + 1;
-			    newval = alloc(newlen);
-			    if (newval == NULL)  /* out of mem, don't change */
-				break;
-			    s = newval;
-
-			    /*
-			     * Copy the string, skip over escaped chars.
-			     * For MS-DOS and WIN32 backslashes before normal
-			     * file name characters are not removed, and keep
-			     * backslash at start, for "\\machine\path", but
-			     * do remove it for "\\\\machine\\path".
-			     * The reverse is found in ExpandOldSetting().
-			     */
-			    while (*arg && !vim_iswhite(*arg))
-			    {
-				if (*arg == '\\' && arg[1] != NUL
-#ifdef BACKSLASH_IN_FILENAME
-					&& !((flags & P_EXPAND)
-						&& vim_isfilec(arg[1])
-						&& (arg[1] != '\\'
-						    || (s == newval
-							&& arg[2] != '\\')))
-#endif
-								    )
-				    ++arg;	/* remove backslash */
-#ifdef FEAT_MBYTE
-				if (has_mbyte
-					&& (i = (*mb_ptr2len_check)(arg)) > 1)
-				{
-				    /* copy multibyte char */
-				    mch_memmove(s, arg, (size_t)i);
-				    arg += i;
-				    s += i;
-				}
-				else
-#endif
-				    *s++ = *arg++;
-			    }
-			    *s = NUL;
-
-			    /*
-			     * Expand environment variables and ~.
-			     * Don't do it when adding without inserting a
-			     * comma.
-			     */
-			    if (!(adding || prepending || removing)
-							 || (flags & P_COMMA))
-			    {
-				s = option_expand(opt_idx, newval);
-				if (s != NULL)
-				{
-				    vim_free(newval);
-				    newlen = (unsigned)STRLEN(s) + 1;
-				    if (adding || prepending || removing)
-					newlen += (unsigned)STRLEN(origval) + 1;
-				    newval = alloc(newlen);
-				    if (newval == NULL)
-					break;
-				    STRCPY(newval, s);
-				}
-			    }
-
-			    /* locate newval[] in origval[] when removing it
-			     * and when adding to avoid duplicates */
-			    i = 0;	/* init for GCC */
-			    if (removing || (flags & P_NODUP))
-			    {
-				i = (int)STRLEN(newval);
-				bs = 0;
-				for (s = origval; *s; ++s)
-				{
-				    if ((!(flags & P_COMMA)
-						|| s == origval
-						|| (s[-1] == ',' && !(bs & 1)))
-					    && STRNCMP(s, newval, i) == 0
-					    && (!(flags & P_COMMA)
-						|| s[i] == ','
-						|| s[i] == NUL))
-					break;
-				    /* Count backspaces.  Only a comma with an
-				     * even number of backspaces before it is
-				     * recognized as a separator */
-				    if (s > origval && s[-1] == '\\')
-					++bs;
-				    else
-					bs = 0;
-				}
-
-				/* do not add if already there */
-				if ((adding || prepending) && *s)
-				{
-				    prepending = FALSE;
-				    adding = FALSE;
-				    STRCPY(newval, origval);
-				}
-			    }
-
-			    /* concatenate the two strings; add a ',' if
-			     * needed */
-			    if (adding || prepending)
-			    {
-				comma = ((flags & P_COMMA) && *origval != NUL
-							   && *newval != NUL);
-				if (adding)
-				{
-				    i = (int)STRLEN(origval);
-				    mch_memmove(newval + i + comma, newval,
-							  STRLEN(newval) + 1);
-				    mch_memmove(newval, origval, (size_t)i);
-				}
-				else
-				{
-				    i = (int)STRLEN(newval);
-				    mch_memmove(newval + i + comma, origval,
-							  STRLEN(origval) + 1);
-				}
-				if (comma)
-				    newval[i] = ',';
-			    }
-
-			    /* Remove newval[] from origval[]. (Note: "i" has
-			     * been set above and is used here). */
-			    if (removing)
-			    {
-				STRCPY(newval, origval);
-				if (*s)
-				{
-				    /* may need to remove a comma */
-				    if (flags & P_COMMA)
-				    {
-					if (s == origval)
-					{
-					    /* include comma after string */
-					    if (s[i] == ',')
-						++i;
-					}
-					else
-					{
-					    /* include comma before string */
-					    --s;
-					    ++i;
-					}
-				    }
-				    mch_memmove(newval + (s - origval), s + i,
-							   STRLEN(s + i) + 1);
-				}
-			    }
-
-			    if (flags & P_FLAGLIST)
-			    {
-				/* Remove flags that appear twice. */
-				for (s = newval; *s; ++s)
-				    if ((!(flags & P_COMMA) || *s != ',')
-					    && vim_strchr(s + 1, *s) != NULL)
-				    {
-					STRCPY(s, s + 1);
-					--s;
-				    }
-			    }
-
-			    if (save_arg != NULL)   /* number for 'whichwrap' */
-				arg = save_arg;
-			    new_value_alloced = TRUE;
-			}
-
-			/* Set the new value. */
-			*(char_u **)(varp) = newval;
-
-			/* Handle side effects, and set the global value for
-			 * ":set" on local options. */
-			errmsg = did_set_string_option(opt_idx, (char_u **)varp,
-				new_value_alloced, oldval, errbuf, opt_flags);
-
-			/* If error detected, print the error message. */
-			if (errmsg != NULL)
-			    goto skip;
-		    }
-		    else	    /* key code option */
-		    {
-			char_u	    *p;
-
-			if (nextchar == '&')
-			{
-			    if (add_termcap_entry(key_name, TRUE) == FAIL)
-				errmsg = (char_u *)N_("E522: Not found in termcap");
-			}
-			else
-			{
-			    ++arg; /* jump to after the '=' or ':' */
-			    for (p = arg; *p && !vim_iswhite(*p); ++p)
-				if (*p == '\\' && p[1] != NUL)
-				    ++p;
-			    nextchar = *p;
-			    *p = NUL;
-			    add_termcode(key_name, arg, FALSE);
-			    *p = nextchar;
-			}
-			if (full_screen)
-			    ttest(FALSE);
-			redraw_all_later(CLEAR);
-		    }
-		}
-		if (opt_idx >= 0)
-		    options[opt_idx].flags |= P_WAS_SET;
-	    }
-
-skip:
-	    /*
-	     * Advance to next argument.
-	     * - skip until a blank found, taking care of backslashes
-	     * - skip blanks
-	     * - skip one "=val" argument (for hidden options ":set gfn =xx")
-	     */
-	    for (i = 0; i < 2 ; ++i)
-	    {
-		while (*arg != NUL && !vim_iswhite(*arg))
-		    if (*arg++ == '\\' && *arg != NUL)
-			++arg;
-		arg = skipwhite(arg);
-		if (*arg != '=')
-		    break;
-	    }
-	}
-
-	if (errmsg != NULL)
-	{
-	    STRNCPY(IObuff, _(errmsg), IOSIZE - 1);
-	    IObuff[IOSIZE - 1] = NUL;
-	    i = STRLEN(IObuff) + 2;
-	    if (i + (arg - startarg) < IOSIZE)
-	    {
-		/* append the argument with the error */
-		STRCAT(IObuff, ": ");
-		mch_memmove(IObuff + i, startarg, (arg - startarg));
-		IObuff[i + (arg - startarg)] = NUL;
-	    }
-	    /* make sure all characters are printable */
-	    trans_characters(IObuff, IOSIZE);
-
-	    ++no_wait_return;	/* wait_return done later */
-	    emsg(IObuff);	/* show error highlighted */
-	    --no_wait_return;
-
-	    return FAIL;
-	}
-
-	arg = skipwhite(arg);
-    }
-
-    return OK;
-}
-
-    static char_u *
-illegal_char(errbuf, c)
-    char_u	*errbuf;
-    int		c;
-{
-    if (errbuf == NULL)
-	return (char_u *)"";
-    sprintf((char *)errbuf, _("E539: Illegal character <%s>"),
-	    (char *)transchar(c));
-    return errbuf;
-}
-
-/*
- * Convert a key name or string into a key value.
- * Used for 'wildchar' and 'cedit' options.
- */
-    static int
-string_to_key(arg)
-    char_u	*arg;
-{
-    if (*arg == '<')
-	return find_key_option(arg + 1);
-    if (*arg == '^')
-	return Ctrl_chr(arg[1]);
-    return *arg;
-}
-
-#ifdef FEAT_CMDWIN
-/*
- * Check value of 'cedit' and set cedit_key.
- * Returns NULL if value is OK, error message otherwise.
- */
-    static char_u *
-check_cedit()
-{
-    int n;
-
-    if (*p_cedit == NUL)
-	cedit_key = -1;
-    else
-    {
-	n = string_to_key(p_cedit);
-	if (vim_isprintc(n))
-	    return e_invarg;
-	cedit_key = n;
-    }
-    return NULL;
-}
-#endif
-
-#ifdef FEAT_TITLE
-/*
- * When changing 'title', 'titlestring', 'icon' or 'iconstring', call
- * maketitle() to create and display it.
- * When switching the title or icon off, call mch_restore_title() to get
- * the old value back.
- */
-    static void
-did_set_title(icon)
-    int	    icon;	    /* Did set icon instead of title */
-{
-    if (starting != NO_SCREEN
-#ifdef FEAT_GUI
-	    && !gui.starting
-#endif
-				)
-    {
-	maketitle();
-	if (icon)
-	{
-	    if (!p_icon)
-		mch_restore_title(2);
-	}
-	else
-	{
-	    if (!p_title)
-		mch_restore_title(1);
-	}
-    }
-}
-#endif
-
-/*
- * set_options_bin -  called when 'bin' changes value.
- */
-    void
-set_options_bin(oldval, newval, opt_flags)
-    int		oldval;
-    int		newval;
-    int		opt_flags;	/* OPT_LOCAL and/or OPT_GLOBAL */
-{
-    /*
-     * The option values that are changed when 'bin' changes are
-     * copied when 'bin is set and restored when 'bin' is reset.
-     */
-    if (newval)
-    {
-	if (!oldval)		/* switched on */
-	{
-	    if (!(opt_flags & OPT_GLOBAL))
-	    {
-		curbuf->b_p_tw_nobin = curbuf->b_p_tw;
-		curbuf->b_p_wm_nobin = curbuf->b_p_wm;
-		curbuf->b_p_ml_nobin = curbuf->b_p_ml;
-		curbuf->b_p_et_nobin = curbuf->b_p_et;
-	    }
-	    if (!(opt_flags & OPT_LOCAL))
-	    {
-		p_tw_nobin = p_tw;
-		p_wm_nobin = p_wm;
-		p_ml_nobin = p_ml;
-		p_et_nobin = p_et;
-	    }
-	}
-
-	if (!(opt_flags & OPT_GLOBAL))
-	{
-	    curbuf->b_p_tw = 0;	/* no automatic line wrap */
-	    curbuf->b_p_wm = 0;	/* no automatic line wrap */
-	    curbuf->b_p_ml = 0;	/* no modelines */
-	    curbuf->b_p_et = 0;	/* no expandtab */
-	}
-	if (!(opt_flags & OPT_LOCAL))
-	{
-	    p_tw = 0;
-	    p_wm = 0;
-	    p_ml = FALSE;
-	    p_et = FALSE;
-	    p_bin = TRUE;	/* needed when called for the "-b" argument */
-	}
-    }
-    else if (oldval)		/* switched off */
-    {
-	if (!(opt_flags & OPT_GLOBAL))
-	{
-	    curbuf->b_p_tw = curbuf->b_p_tw_nobin;
-	    curbuf->b_p_wm = curbuf->b_p_wm_nobin;
-	    curbuf->b_p_ml = curbuf->b_p_ml_nobin;
-	    curbuf->b_p_et = curbuf->b_p_et_nobin;
-	}
-	if (!(opt_flags & OPT_LOCAL))
-	{
-	    p_tw = p_tw_nobin;
-	    p_wm = p_wm_nobin;
-	    p_ml = p_ml_nobin;
-	    p_et = p_et_nobin;
-	}
-    }
-}
-
-#ifdef FEAT_VIMINFO
-/*
- * Find the parameter represented by the given character (eg ', :, ", or /),
- * and return its associated value in the 'viminfo' string.
- * Only works for number parameters, not for 'r' or 'n'.
- * If the parameter is not specified in the string, return -1.
- */
-    int
-get_viminfo_parameter(type)
-    int	    type;
-{
-    char_u  *p;
-
-    p = find_viminfo_parameter(type);
-    if (p != NULL && VIM_ISDIGIT(*p))
-	return atoi((char *)p);
-    return -1;
-}
-
-/*
- * Find the parameter represented by the given character (eg ''', ':', '"', or
- * '/') in the 'viminfo' option and return a pointer to the string after it.
- * Return NULL if the parameter is not specified in the string.
- */
-    char_u *
-find_viminfo_parameter(type)
-    int	    type;
-{
-    char_u  *p;
-
-    for (p = p_viminfo; *p; ++p)
-    {
-	if (*p == type)
-	    return p + 1;
-	if (*p == 'n')		    /* 'n' is always the last one */
-	    break;
-	p = vim_strchr(p, ',');	    /* skip until next ',' */
-	if (p == NULL)		    /* hit the end without finding parameter */
-	    break;
-    }
-    return NULL;
-}
-#endif
-
-/*
- * Expand environment variables for some string options.
- * These string options cannot be indirect!
- * If "val" is NULL expand the current value of the option.
- * Return pointer to NameBuff, or NULL when not expanded.
- */
-    static char_u *
-option_expand(opt_idx, val)
-    int		opt_idx;
-    char_u	*val;
-{
-    /* if option doesn't need expansion nothing to do */
-    if (!(options[opt_idx].flags & P_EXPAND) || options[opt_idx].var == NULL)
-	return NULL;
-
-    /* If val is longer than MAXPATHL no meaningful expansion can be done,
-     * expand_env() would truncate the string. */
-    if (val != NULL && STRLEN(val) > MAXPATHL)
-	return NULL;
-
-    if (val == NULL)
-	val = *(char_u **)options[opt_idx].var;
-
-    /*
-     * Expanding this with NameBuff, expand_env() must not be passed IObuff.
-     * Escape spaces when expanding 'tags', they are used to separate file
-     * names.
-     */
-    expand_env_esc(val, NameBuff, MAXPATHL,
-				  (char_u **)options[opt_idx].var == &p_tags);
-    if (STRCMP(NameBuff, val) == 0)   /* they are the same */
-	return NULL;
-
-    return NameBuff;
-}
-
-/*
- * After setting various option values: recompute variables that depend on
- * option values.
- */
-    static void
-didset_options()
-{
-    /* initialize the table for 'iskeyword' et.al. */
-    (void)init_chartab();
-
-    (void)opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, TRUE);
-    (void)opt_strings_flags(p_bkc, p_bkc_values, &bkc_flags, TRUE);
-#ifdef FEAT_SESSION
-    (void)opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, TRUE);
-    (void)opt_strings_flags(p_vop, p_ssop_values, &vop_flags, TRUE);
-#endif
-#ifdef FEAT_FOLDING
-    (void)opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, TRUE);
-#endif
-    (void)opt_strings_flags(p_dy, p_dy_values, &dy_flags, TRUE);
-#ifdef FEAT_VIRTUALEDIT
-    (void)opt_strings_flags(p_ve, p_ve_values, &ve_flags, TRUE);
-#endif
-#if defined(FEAT_MOUSE) && (defined(UNIX) || defined(VMS))
-    (void)opt_strings_flags(p_ttym, p_ttym_values, &ttym_flags, FALSE);
-#endif
-#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
-    (void)opt_strings_flags(p_toolbar, p_toolbar_values, &toolbar_flags, TRUE);
-#endif
-#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK) && defined(HAVE_GTK2)
-    (void)opt_strings_flags(p_tbis, p_tbis_values, &tbis_flags, FALSE);
-#endif
-#ifdef FEAT_CMDWIN
-    /* set cedit_key */
-    (void)check_cedit();
-#endif
-}
-
-/*
- * Check for string options that are NULL (normally only termcap options).
- */
-    void
-check_options()
-{
-    int		opt_idx;
-
-    for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++)
-	if ((options[opt_idx].flags & P_STRING) && options[opt_idx].var != NULL)
-	    check_string_option((char_u **)get_varp(&(options[opt_idx])));
-}
-
-/*
- * Check string options in a buffer for NULL value.
- */
-    void
-check_buf_options(buf)
-    buf_T	*buf;
-{
-#if defined(FEAT_QUICKFIX)
-    check_string_option(&buf->b_p_bh);
-    check_string_option(&buf->b_p_bt);
-#endif
-#ifdef FEAT_MBYTE
-    check_string_option(&buf->b_p_fenc);
-#endif
-    check_string_option(&buf->b_p_ff);
-#ifdef FEAT_FIND_ID
-    check_string_option(&buf->b_p_def);
-    check_string_option(&buf->b_p_inc);
-# ifdef FEAT_EVAL
-    check_string_option(&buf->b_p_inex);
-# endif
-#endif
-#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
-    check_string_option(&buf->b_p_inde);
-    check_string_option(&buf->b_p_indk);
-#endif
-#ifdef FEAT_CRYPT
-    check_string_option(&buf->b_p_key);
-#endif
-    check_string_option(&buf->b_p_kp);
-    check_string_option(&buf->b_p_mps);
-    check_string_option(&buf->b_p_fo);
-    check_string_option(&buf->b_p_isk);
-#ifdef FEAT_COMMENTS
-    check_string_option(&buf->b_p_com);
-#endif
-#ifdef FEAT_FOLDING
-    check_string_option(&buf->b_p_cms);
-#endif
-    check_string_option(&buf->b_p_nf);
-#ifdef FEAT_SYN_HL
-    check_string_option(&buf->b_p_syn);
-#endif
-#ifdef FEAT_SEARCHPATH
-    check_string_option(&buf->b_p_sua);
-#endif
-#ifdef FEAT_CINDENT
-    check_string_option(&buf->b_p_cink);
-    check_string_option(&buf->b_p_cino);
-#endif
-#ifdef FEAT_AUTOCMD
-    check_string_option(&buf->b_p_ft);
-#endif
-#ifdef FEAT_OSFILETYPE
-    check_string_option(&buf->b_p_oft);
-#endif
-#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
-    check_string_option(&buf->b_p_cinw);
-#endif
-#ifdef FEAT_INS_EXPAND
-    check_string_option(&buf->b_p_cpt);
-#endif
-#ifdef FEAT_KEYMAP
-    check_string_option(&buf->b_p_keymap);
-#endif
-#ifdef FEAT_QUICKFIX
-    check_string_option(&buf->b_p_gp);
-    check_string_option(&buf->b_p_mp);
-    check_string_option(&buf->b_p_efm);
-#endif
-    check_string_option(&buf->b_p_ep);
-    check_string_option(&buf->b_p_path);
-    check_string_option(&buf->b_p_tags);
-#ifdef FEAT_INS_EXPAND
-    check_string_option(&buf->b_p_dict);
-    check_string_option(&buf->b_p_tsr);
-#endif
-}
-
-/*
- * Free the string allocated for an option.
- * Checks for the string being empty_option. This may happen if we're out of
- * memory, vim_strsave() returned NULL, which was replaced by empty_option by
- * check_options().
- * Does NOT check for P_ALLOCED flag!
- */
-    void
-free_string_option(p)
-    char_u	*p;
-{
-    if (p != empty_option)
-	vim_free(p);
-}
-
-    void
-clear_string_option(pp)
-    char_u	**pp;
-{
-    if (*pp != empty_option)
-	vim_free(*pp);
-    *pp = empty_option;
-}
-
-    static void
-check_string_option(pp)
-    char_u	**pp;
-{
-    if (*pp == NULL)
-	*pp = empty_option;
-}
-
-/*
- * Mark a terminal option as allocated, found by a pointer into term_strings[].
- */
-    void
-set_term_option_alloced(p)
-    char_u **p;
-{
-    int		opt_idx;
-
-    for (opt_idx = 1; options[opt_idx].fullname != NULL; opt_idx++)
-	if (options[opt_idx].var == (char_u *)p)
-	{
-	    options[opt_idx].flags |= P_ALLOCED;
-	    return;
-	}
-    return; /* cannot happen: didn't find it! */
-}
-
-/*
- * Set a string option to a new value (without checking the effect).
- * The string is copied into allocated memory.
- * if ("opt_idx" == -1) "name" is used, otherwise "opt_idx" is used.
- */
-    void
-set_string_option_direct(name, opt_idx, val, opt_flags)
-    char_u	*name;
-    int		opt_idx;
-    char_u	*val;
-    int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
-{
-    char_u	*s;
-    char_u	**varp;
-    int		both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;
-
-    if (opt_idx == -1)		/* use name */
-    {
-	opt_idx = findoption(name);
-	if (opt_idx == -1)	/* not found (should not happen) */
-	    return;
-    }
-
-    if (options[opt_idx].var == NULL)	/* can't set hidden option */
-	return;
-
-    s = vim_strsave(val);
-    if (s != NULL)
-    {
-	varp = (char_u **)get_varp_scope(&(options[opt_idx]),
-					       both ? OPT_LOCAL : opt_flags);
-	if ((opt_flags & OPT_FREE) && (options[opt_idx].flags & P_ALLOCED))
-	    free_string_option(*varp);
-	*varp = s;
-
-	/* For buffer/window local option may also set the global value. */
-	if (both)
-	    set_string_option_global(opt_idx, varp);
-
-	options[opt_idx].flags |= P_ALLOCED;
-
-	/* When setting both values of a global option with a local value,
-	 * make the local value empty, so that the global value is used. */
-	if ((int)options[opt_idx].indir >= PV_BOTH && both)
-	{
-	    free_string_option(*varp);
-	    *varp = empty_option;
-	}
-    }
-}
-
-/*
- * Set global value for string option when it's a local option.
- */
-    static void
-set_string_option_global(opt_idx, varp)
-    int		opt_idx;	/* option index */
-    char_u	**varp;		/* pointer to option variable */
-{
-    char_u	**p, *s;
-
-    /* the global value is always allocated */
-    if (options[opt_idx].var == VAR_WIN)
-	p = (char_u **)GLOBAL_WO(varp);
-    else
-	p = (char_u **)options[opt_idx].var;
-    if (options[opt_idx].indir != PV_NONE
-	    && p != varp
-	    && (s = vim_strsave(*varp)) != NULL)
-    {
-	free_string_option(*p);
-	*p = s;
-    }
-}
-
-/*
- * Set a string option to a new value, and handle the effects.
- */
-    static void
-set_string_option(opt_idx, value, opt_flags)
-    int		opt_idx;
-    char_u	*value;
-    int		opt_flags;	/* OPT_LOCAL and/or OPT_GLOBAL */
-{
-    char_u	*s;
-    char_u	**varp;
-    char_u	*oldval;
-
-    if (options[opt_idx].var == NULL)	/* don't set hidden option */
-	return;
-
-    s = vim_strsave(value);
-    if (s != NULL)
-    {
-	varp = (char_u **)get_varp_scope(&(options[opt_idx]),
-		(opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0
-		    ? ((int)options[opt_idx].indir >= PV_BOTH
-			? OPT_GLOBAL : OPT_LOCAL)
-		    : opt_flags);
-	oldval = *varp;
-	*varp = s;
-	options[opt_idx].flags |= P_WAS_SET;
-	(void)did_set_string_option(opt_idx, varp, TRUE, oldval, NULL,
-								   opt_flags);
-    }
-}
-
-/*
- * Handle string options that need some action to perform when changed.
- * Returns NULL for success, or an error message for an error.
- */
-    static char_u *
-did_set_string_option(opt_idx, varp, new_value_alloced, oldval, errbuf,
-								    opt_flags)
-    int		opt_idx;		/* index in options[] table */
-    char_u	**varp;			/* pointer to the option variable */
-    int		new_value_alloced;	/* new value was allocated */
-    char_u	*oldval;		/* previous value of the option */
-    char_u	*errbuf;		/* buffer for errors, or NULL */
-    int		opt_flags;		/* OPT_LOCAL and/or OPT_GLOBAL */
-{
-    char_u	*errmsg = NULL;
-    char_u	*s, *p;
-    int		did_chartab = FALSE;
-    char_u	**gvarp;
-    int		free_oldval = (options[opt_idx].flags & P_ALLOCED);
-
-    /* Get the global option to compare with, otherwise we would have to check
-     * two values for all local options. */
-    gvarp = (char_u **)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);
-
-    /* Disallow changing some options from secure mode */
-    if ((secure
-#ifdef HAVE_SANDBOX
-		|| sandbox != 0
-#endif
-		) && (options[opt_idx].flags & P_SECURE))
-    {
-	errmsg = e_secure;
-    }
-
-    /* Check for a "normal" file name in some options.  Disallow a path
-     * separator (slash and/or backslash), wildcards and characters that are
-     * often illegal in a file name. */
-    else if ((options[opt_idx].flags & P_NFNAME)
-			 && vim_strpbrk(*varp, (char_u *)"/\\*?[|<>") != NULL)
-    {
-	errmsg = e_invarg;
-    }
-
-    /* 'term' */
-    else if (varp == &T_NAME)
-    {
-	if (T_NAME[0] == NUL)
-	    errmsg = (char_u *)N_("E529: Cannot set 'term' to empty string");
-#ifdef FEAT_GUI
-	if (gui.in_use)
-	    errmsg = (char_u *)N_("E530: Cannot change term in GUI");
-	else if (term_is_gui(T_NAME))
-	    errmsg = (char_u *)N_("E531: Use \":gui\" to start the GUI");
-#endif
-	else if (set_termname(T_NAME) == FAIL)
-	    errmsg = (char_u *)N_("E522: Not found in termcap");
-	else
-	    /* Screen colors may have changed. */
-	    redraw_later_clear();
-    }
-
-    /* 'backupcopy' */
-    else if (varp == &p_bkc)
-    {
-	if (opt_strings_flags(p_bkc, p_bkc_values, &bkc_flags, TRUE) != OK)
-	    errmsg = e_invarg;
-	if (((bkc_flags & BKC_AUTO) != 0)
-		+ ((bkc_flags & BKC_YES) != 0)
-		+ ((bkc_flags & BKC_NO) != 0) != 1)
-	{
-	    /* Must have exactly one of "auto", "yes"  and "no". */
-	    (void)opt_strings_flags(oldval, p_bkc_values, &bkc_flags, TRUE);
-	    errmsg = e_invarg;
-	}
-    }
-
-    /* 'backupext' and 'patchmode' */
-    else if (varp == &p_bex || varp == &p_pm)
-    {
-	if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,
-		     *p_pm == '.' ? p_pm + 1 : p_pm) == 0)
-	    errmsg = (char_u *)N_("E589: 'backupext' and 'patchmode' are equal");
-    }
-
-    /*
-     * 'isident', 'iskeyword', 'isprint or 'isfname' option: refill chartab[]
-     * If the new option is invalid, use old value.  'lisp' option: refill
-     * chartab[] for '-' char
-     */
-    else if (  varp == &p_isi
-	    || varp == &(curbuf->b_p_isk)
-	    || varp == &p_isp
-	    || varp == &p_isf)
-    {
-	if (init_chartab() == FAIL)
-	{
-	    did_chartab = TRUE;	    /* need to restore it below */
-	    errmsg = e_invarg;	    /* error in value */
-	}
-    }
-
-    /* 'helpfile' */
-    else if (varp == &p_hf)
-    {
-	/* May compute new values for $VIM and $VIMRUNTIME */
-	if (didset_vim)
-	{
-	    vim_setenv((char_u *)"VIM", (char_u *)"");
-	    didset_vim = FALSE;
-	}
-	if (didset_vimruntime)
-	{
-	    vim_setenv((char_u *)"VIMRUNTIME", (char_u *)"");
-	    didset_vimruntime = FALSE;
-	}
-    }
-
-#ifdef FEAT_MULTI_LANG
-    /* 'helplang' */
-    else if (varp == &p_hlg)
-    {
-	/* Check for "", "ab", "ab,cd", etc. */
-	for (s = p_hlg; *s != NUL; s += 3)
-	{
-	    if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) && s[2] != NUL))
-	    {
-		errmsg = e_invarg;
-		break;
-	    }
-	    if (s[2] == NUL)
-		break;
-	}
-    }
-#endif
-
-    /* 'highlight' */
-    else if (varp == &p_hl)
-    {
-	if (highlight_changed() == FAIL)
-	    errmsg = e_invarg;	/* invalid flags */
-    }
-
-    /* 'nrformats' */
-    else if (gvarp == &p_nf)
-    {
-	if (check_opt_strings(*varp, p_nf_values, TRUE) != OK)
-	    errmsg = e_invarg;
-    }
-
-#ifdef FEAT_SESSION
-    /* 'sessionoptions' */
-    else if (varp == &p_ssop)
-    {
-	if (opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, TRUE) != OK)
-	    errmsg = e_invarg;
-	if ((ssop_flags & SSOP_CURDIR) && (ssop_flags & SSOP_SESDIR))
-	{
-	    /* Don't allow both "sesdir" and "curdir". */
-	    (void)opt_strings_flags(oldval, p_ssop_values, &ssop_flags, TRUE);
-	    errmsg = e_invarg;
-	}
-    }
-    /* 'viewoptions' */
-    else if (varp == &p_vop)
-    {
-	if (opt_strings_flags(p_vop, p_ssop_values, &vop_flags, TRUE) != OK)
-	    errmsg = e_invarg;
-    }
-#endif
-
-    /* 'scrollopt' */
-#ifdef FEAT_SCROLLBIND
-    else if (varp == &p_sbo)
-    {
-	if (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)
-	    errmsg = e_invarg;
-    }
-#endif
-
-    /* 'ambiwidth' */
-#ifdef FEAT_MBYTE
-    else if (varp == &p_ambw)
-    {
-	if (check_opt_strings(p_ambw, p_ambw_values, FALSE) != OK)
-	    errmsg = e_invarg;
-    }
-#endif
-
-    /* 'background' */
-    else if (varp == &p_bg)
-    {
-	if (check_opt_strings(p_bg, p_bg_values, FALSE) == OK)
-	{
-#ifdef FEAT_EVAL
-	    int dark = (*p_bg == 'd');
-#endif
-
-	    init_highlight(FALSE, FALSE);
-
-#ifdef FEAT_EVAL
-	    if (dark != (*p_bg == 'd')
-			  && get_var_value((char_u *)"g:colors_name") != NULL)
-	    {
-		/* The color scheme must have set 'background' back to another
-		 * value, that's not what we want here.  Disable the color
-		 * scheme and set the colors again. */
-		do_unlet((char_u *)"g:colors_name");
-		free_string_option(p_bg);
-		p_bg = vim_strsave((char_u *)(dark ? "dark" : "light"));
-		check_string_option(&p_bg);
-		init_highlight(FALSE, FALSE);
-	    }
-#endif
-	}
-	else
-	    errmsg = e_invarg;
-    }
-
-    /* 'wildmode' */
-    else if (varp == &p_wim)
-    {
-	if (check_opt_wim() == FAIL)
-	    errmsg = e_invarg;
-    }
-
-#ifdef FEAT_WAK
-    /* 'winaltkeys' */
-    else if (varp == &p_wak)
-    {
-	if (*p_wak == NUL
-		|| check_opt_strings(p_wak, p_wak_values, FALSE) != OK)
-	    errmsg = e_invarg;
-# ifdef FEAT_MENU
-#  ifdef FEAT_GUI_MOTIF
-	else if (gui.in_use)
-	    gui_motif_set_mnemonics(p_wak[0] == 'y' || p_wak[0] == 'm');
-#  else
-#   ifdef FEAT_GUI_GTK
-	else if (gui.in_use)
-	    gui_gtk_set_mnemonics(p_wak[0] == 'y' || p_wak[0] == 'm');
-#   endif
-#  endif
-# endif
-    }
-#endif
-
-#ifdef FEAT_AUTOCMD
-    /* 'eventignore' */
-    else if (varp == &p_ei)
-    {
-	if (check_ei() == FAIL)
-	    errmsg = e_invarg;
-    }
-#endif
-
-#ifdef FEAT_MBYTE
-    /* 'encoding' and 'fileencoding' */
-    else if (varp == &p_enc || gvarp == &p_fenc || varp == &p_tenc)
-    {
-	if (gvarp == &p_fenc)
-	{
-	    if (!curbuf->b_p_ma)
-		errmsg = e_modifiable;
-	    else if (vim_strchr(*varp, ',') != NULL)
-		/* No comma allowed in 'fileencoding'; catches confusing it
-		 * with 'fileencodings'. */
-		errmsg = e_invarg;
-# ifdef FEAT_TITLE
-	    else
-		/* May show a "+" in the title now. */
-		need_maketitle = TRUE;
-# endif
-	}
-	if (errmsg == NULL)
-	{
-	    /* canonize the value, so that STRCMP() can be used on it */
-	    p = enc_canonize(*varp);
-	    if (p != NULL)
-	    {
-		vim_free(*varp);
-		*varp = p;
-	    }
-	    if (varp == &p_enc)
-	    {
-		errmsg = mb_init();
-# ifdef FEAT_TITLE
-		need_maketitle = TRUE;
-# endif
-	    }
-	}
-
-# if defined(FEAT_GUI_GTK) && defined(HAVE_GTK2)
-	if (errmsg == NULL && varp == &p_tenc && gui.in_use)
-	{
-	    /* GTK+ 2 uses only a single encoding, and that is UTF-8. */
-	    if (STRCMP(p_tenc, "utf-8") != 0)
-		errmsg = (char_u *)N_("E617: Cannot be changed in the GTK+ 2 GUI");
-	}
-# endif
-
-	if (errmsg == NULL)
-	{
-# ifdef FEAT_KEYMAP
-	    /* When 'keymap' is used and 'encoding' changes, reload the keymap
-	     * (with another encoding). */
-	    if (varp == &p_enc && *curbuf->b_p_keymap != NUL)
-		(void)keymap_init();
-# endif
-
-	    /* When 'termencoding' is not empty and 'encoding' changes or when
-	     * 'termencoding' changes, need to setup for keyboard input and
-	     * display output conversion. */
-	    if (((varp == &p_enc && *p_tenc != NUL) || varp == &p_tenc))
-	    {
-		convert_setup(&input_conv, p_tenc, p_enc);
-		convert_setup(&output_conv, p_enc, p_tenc);
-	    }
-	}
-    }
-#endif
-
-#if defined(FEAT_POSTSCRIPT)
-    else if (varp == &p_penc)
-    {
-	/* Canonize printencoding if VIM standard one */
-	p = enc_canonize(p_penc);
-	if (p != NULL)
-	{
-	    vim_free(p_penc);
-	    p_penc = p;
-	}
-	else
-	{
-	    /* Ensure lower case and '-' for '_' */
-	    for (s = p_penc; *s != NUL; s++)
-	    {
-		if (*s == '_')
-		    *s = '-';
-		else
-		    *s = TOLOWER_ASC(*s);
-	    }
-	}
-    }
-#endif
-
-#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
-    else if (varp == &p_imak)
-    {
-	if (gui.in_use && !im_xim_isvalid_imactivate())
-	    errmsg = e_invarg;
-    }
-#endif
-
-#ifdef FEAT_KEYMAP
-    else if (varp == &curbuf->b_p_keymap)
-    {
-	/* load or unload key mapping tables */
-	errmsg = keymap_init();
-
-	/* When successfully installed a new keymap switch on using it. */
-	if (*curbuf->b_p_keymap != NUL && errmsg == NULL)
-	{
-	    curbuf->b_p_iminsert = B_IMODE_LMAP;
-	    if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)
-		curbuf->b_p_imsearch = B_IMODE_LMAP;
-	    set_iminsert_global();
-	    set_imsearch_global();
-# ifdef FEAT_WINDOWS
-	    status_redraw_curbuf();
-# endif
-	}
-    }
-#endif
-
-    /* 'fileformat' */
-    else if (gvarp == &p_ff)
-    {
-	if (!curbuf->b_p_ma && !(opt_flags & OPT_GLOBAL))
-	    errmsg = e_modifiable;
-	else if (check_opt_strings(*varp, p_ff_values, FALSE) != OK)
-	    errmsg = e_invarg;
-	else
-	{
-	    /* may also change 'textmode' */
-	    if (get_fileformat(curbuf) == EOL_DOS)
-		curbuf->b_p_tx = TRUE;
-	    else
-		curbuf->b_p_tx = FALSE;
-#ifdef FEAT_TITLE
-	    need_maketitle = TRUE;
-#endif
-	}
-    }
-
-    /* 'fileformats' */
-    else if (varp == &p_ffs)
-    {
-	if (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK)
-	    errmsg = e_invarg;
-	else
-	{
-	    /* also change 'textauto' */
-	    if (*p_ffs == NUL)
-		p_ta = FALSE;
-	    else
-		p_ta = TRUE;
-	}
-    }
-
-#if defined(FEAT_CRYPT) && defined(FEAT_CMDHIST)
-    /* 'cryptkey' */
-    else if (gvarp == &p_key)
-    {
-	/* Make sure the ":set" command doesn't show the new value in the
-	 * history. */
-	remove_key_from_history();
-    }
-#endif
-
-    /* 'matchpairs' */
-    else if (gvarp == &p_mps)
-    {
-	/* Check for "x:y,x:y" */
-	for (p = *varp; *p != NUL; p += 4)
-	{
-	    if (p[1] != ':' || p[2] == NUL || (p[3] != NUL && p[3] != ','))
-	    {
-		errmsg = e_invarg;
-		break;
-	    }
-	    if (p[3] == NUL)
-		break;
-	}
-    }
-
-#ifdef FEAT_COMMENTS
-    /* 'comments' */
-    else if (gvarp == &p_com)
-    {
-	for (s = *varp; *s; )
-	{
-	    while (*s && *s != ':')
-	    {
-		if (vim_strchr((char_u *)COM_ALL, *s) == NULL
-					     && !VIM_ISDIGIT(*s) && *s != '-')
-		{
-		    errmsg = illegal_char(errbuf, *s);
-		    break;
-		}
-		++s;
-	    }
-	    if (*s++ == NUL)
-		errmsg = (char_u *)N_("E524: Missing colon");
-	    else if (*s == ',' || *s == NUL)
-		errmsg = (char_u *)N_("E525: Zero length string");
-	    if (errmsg != NULL)
-		break;
-	    while (*s && *s != ',')
-	    {
-		if (*s == '\\' && s[1] != NUL)
-		    ++s;
-		++s;
-	    }
-	    s = skip_to_option_part(s);
-	}
-    }
-#endif
-
-    /* 'listchars' */
-    else if (varp == &p_lcs)
-    {
-	errmsg = set_chars_option(varp);
-    }
-
-#if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
-    /* 'fillchars' */
-    else if (varp == &p_fcs)
-    {
-	errmsg = set_chars_option(varp);
-    }
-#endif
-
-#ifdef FEAT_CMDWIN
-    /* 'cedit' */
-    else if (varp == &p_cedit)
-    {
-	errmsg = check_cedit();
-    }
-#endif
-
-#ifdef FEAT_VIMINFO
-    /* 'viminfo' */
-    else if (varp == &p_viminfo)
-    {
-	for (s = p_viminfo; *s;)
-	{
-	    /* Check it's a valid character */
-	    if (vim_strchr((char_u *)"!\"%'/:<@cfhnrs", *s) == NULL)
-	    {
-		errmsg = illegal_char(errbuf, *s);
-		break;
-	    }
-	    if (*s == 'n')	/* name is always last one */
-	    {
-		break;
-	    }
-	    else if (*s == 'r') /* skip until next ',' */
-	    {
-		while (*++s && *s != ',')
-		    ;
-	    }
-	    else if (*s == '%' || *s == '!' || *s == 'h' || *s == 'c')
-		++s;		/* no extra chars */
-	    else		/* must have a number */
-	    {
-		while (vim_isdigit(*++s))
-		    ;
-
-		if (!VIM_ISDIGIT(*(s - 1)))
-		{
-		    if (errbuf != NULL)
-		    {
-			sprintf((char *)errbuf, _("E526: Missing number after <%s>"),
-						    transchar_byte(*(s - 1)));
-			errmsg = errbuf;
-		    }
-		    else
-			errmsg = (char_u *)"";
-		    break;
-		}
-	    }
-	    if (*s == ',')
-		++s;
-	    else if (*s)
-	    {
-		if (errbuf != NULL)
-		    errmsg = (char_u *)N_("E527: Missing comma");
-		else
-		    errmsg = (char_u *)"";
-		break;
-	    }
-	}
-	if (*p_viminfo && errmsg == NULL && get_viminfo_parameter('\'') < 0)
-	    errmsg = (char_u *)N_("E528: Must specify a ' value");
-    }
-#endif /* FEAT_VIMINFO */
-
-    /* terminal options */
-    else if (istermoption(&options[opt_idx]) && full_screen)
-    {
-	/* ":set t_Co=0" and ":set t_Co=1" do ":set t_Co=" */
-	if (varp == &T_CCO)
-	{
-	    t_colors = atoi((char *)T_CCO);
-	    if (t_colors <= 1)
-	    {
-		if (new_value_alloced)
-		    vim_free(T_CCO);
-		T_CCO = empty_option;
-	    }
-	    /* We now have a different color setup, initialize it again. */
-	    init_highlight(TRUE, FALSE);
-	}
-	ttest(FALSE);
-	if (varp == &T_ME)
-	{
-	    out_str(T_ME);
-	    redraw_later(CLEAR);
-#if defined(MSDOS) || (defined(WIN3264) && !defined(FEAT_GUI_W32))
-	    /* Since t_me has been set, this probably means that the user
-	     * wants to use this as default colors.  Need to reset default
-	     * background/foreground colors. */
-	    mch_set_normal_colors();
-#endif
-	}
-    }
-
-#ifdef FEAT_LINEBREAK
-    /* 'showbreak' */
-    else if (varp == &p_sbr)
-    {
-	for (s = p_sbr; *s; )
-	{
-	    if (ptr2cells(s) != 1)
-		errmsg = (char_u *)N_("E595: contains unprintable or wide character");
-# ifdef FEAT_MBYTE
-	    if (has_mbyte)
-		s += (*mb_ptr2len_check)(s);
-	    else
-# endif
-		++s;
-	}
-    }
-#endif
-
-#ifdef FEAT_GUI
-    /* 'guifont' */
-    else if (varp == &p_guifont)
-    {
-	if (gui.in_use)
-	{
-	    p = p_guifont;
-# ifdef FEAT_GUI_GTK
-	    /*
-	     * Put up a font dialog and let the user select a new value.
-	     * If this is cancelled go back to the old value but don't
-	     * give an error message.
-	     */
-	    if (STRCMP(p, "*") == 0)
-	    {
-		p = gui_mch_font_dialog(oldval);
-
-		if (new_value_alloced)
-		    free_string_option(p_guifont);
-
-		p_guifont = (p != NULL) ? p : vim_strsave(oldval);
-		new_value_alloced = TRUE;
-	    }
-# endif
-	    if (p != NULL && gui_init_font(p_guifont, FALSE) != OK)
-	    {
-# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_PHOTON)
-		if (STRCMP(p_guifont, "*") == 0)
-		{
-		    /* Dialog was cancelled: Keep the old value without giving
-		     * an error message. */
-		    if (new_value_alloced)
-			free_string_option(p_guifont);
-		    p_guifont = vim_strsave(oldval);
-		    new_value_alloced = TRUE;
-		}
-		else
-# endif
-		    errmsg = (char_u *)N_("E596: Invalid font(s)");
-	    }
-	}
-    }
-# ifdef FEAT_XFONTSET
-    else if (varp == &p_guifontset)
-    {
-	if (STRCMP(p_guifontset, "*") == 0)
-	    errmsg = (char_u *)N_("E597: can't select fontset");
-	else if (gui.in_use && gui_init_font(p_guifontset, TRUE) != OK)
-	    errmsg = (char_u *)N_("E598: Invalid fontset");
-    }
-# endif
-# ifdef FEAT_MBYTE
-    else if (varp == &p_guifontwide)
-    {
-	if (STRCMP(p_guifontwide, "*") == 0)
-	    errmsg = (char_u *)N_("E533: can't select wide font");
-	else if (gui_get_wide_font() == FAIL)
-	    errmsg = (char_u *)N_("E534: Invalid wide font");
-    }
-# endif
-#endif
-
-#ifdef CURSOR_SHAPE
-    /* 'guicursor' */
-    else if (varp == &p_guicursor)
-	errmsg = parse_shape_opt(SHAPE_CURSOR);
-#endif
-
-#ifdef FEAT_MOUSESHAPE
-    /* 'mouseshape' */
-    else if (varp == &p_mouseshape)
-    {
-	errmsg = parse_shape_opt(SHAPE_MOUSE);
-	update_mouseshape(-1);
-    }
-#endif
-
-#ifdef FEAT_PRINTER
-    else if (varp == &p_popt)
-	errmsg = parse_list_options(p_popt, printer_opts, OPT_PRINT_NUM_OPTIONS);
-#endif
-
-#ifdef FEAT_LANGMAP
-    /* 'langmap' */
-    else if (varp == &p_langmap)
-	langmap_set();
-#endif
-
-#ifdef FEAT_LINEBREAK
-    /* 'breakat' */
-    else if (varp == &p_breakat)
-	fill_breakat_flags();
-#endif
-
-#ifdef FEAT_TITLE
-    /* 'titlestring' and 'iconstring' */
-    else if (varp == &p_titlestring || varp == &p_iconstring)
-    {
-# ifdef FEAT_STL_OPT
-	int	flagval = (varp == &p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;
-
-	/* NULL => statusline syntax */
-	if (vim_strchr(*varp, '%') && check_stl_option(*varp) == NULL)
-	    stl_syntax |= flagval;
-	else
-	    stl_syntax &= ~flagval;
-# endif
-	did_set_title(varp == &p_iconstring);
-
-    }
-#endif
-
-#ifdef FEAT_GUI
-    /* 'guioptions' */
-    else if (varp == &p_go)
-	gui_init_which_components(oldval);
-#endif
-
-#if defined(FEAT_MOUSE_TTY) && (defined(UNIX) || defined(VMS))
-    /* 'ttymouse' */
-    else if (varp == &p_ttym)
-    {
-	if (opt_strings_flags(p_ttym, p_ttym_values, &ttym_flags, FALSE) != OK)
-	    errmsg = e_invarg;
-	else
-	    check_mouse_termcode();
-    }
-#endif
-
-#ifdef FEAT_VISUAL
-    /* 'selection' */
-    else if (varp == &p_sel)
-    {
-	if (*p_sel == NUL
-		|| check_opt_strings(p_sel, p_sel_values, FALSE) != OK)
-	    errmsg = e_invarg;
-    }
-
-    /* 'selectmode' */
-    else if (varp == &p_slm)
-    {
-	if (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)
-	    errmsg = e_invarg;
-    }
-#endif
-
-#ifdef FEAT_BROWSE
-    /* 'browsedir' */
-    else if (varp == &p_bsdir)
-    {
-	if (check_opt_strings(p_bsdir, p_bsdir_values, FALSE) != OK
-		&& !mch_isdir(p_bsdir))
-	    errmsg = e_invarg;
-    }
-#endif
-
-#ifdef FEAT_VISUAL
-    /* 'keymodel' */
-    else if (varp == &p_km)
-    {
-	if (check_opt_strings(p_km, p_km_values, TRUE) != OK)
-	    errmsg = e_invarg;
-	else
-	{
-	    km_stopsel = (vim_strchr(p_km, 'o') != NULL);
-	    km_startsel = (vim_strchr(p_km, 'a') != NULL);
-	}
-    }
-#endif
-
-    /* 'mousemodel' */
-    else if (varp == &p_mousem)
-    {
-	if (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)
-	    errmsg = e_invarg;
-#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU) && (XmVersion <= 1002)
-	else if (*p_mousem != *oldval)
-	    /* Changed from "extend" to "popup" or "popup_setpos" or vv: need
-	     * to create or delete the popup menus. */
-	    gui_motif_update_mousemodel(root_menu);
-#endif
-    }
-
-    /* 'switchbuf' */
-    else if (varp == &p_swb)
-    {
-	if (check_opt_strings(p_swb, p_swb_values, TRUE) != OK)
-	    errmsg = e_invarg;
-    }
-
-    /* 'debug' */
-    else if (varp == &p_debug)
-    {
-	if (check_opt_strings(p_debug, p_debug_values, FALSE) != OK)
-	    errmsg = e_invarg;
-    }
-
-    /* 'display' */
-    else if (varp == &p_dy)
-    {
-	if (opt_strings_flags(p_dy, p_dy_values, &dy_flags, TRUE) != OK)
-	    errmsg = e_invarg;
-	else
-	    (void)init_chartab();
-
-    }
-
-#ifdef FEAT_VERTSPLIT
-    /* 'eadirection' */
-    else if (varp == &p_ead)
-    {
-	if (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)
-	    errmsg = e_invarg;
-    }
-#endif
-
-#ifdef FEAT_CLIPBOARD
-    /* 'clipboard' */
-    else if (varp == &p_cb)
-	errmsg = check_clipboard_option();
-#endif
-
-#ifdef FEAT_AUTOCMD
-# ifdef FEAT_SYN_HL
-    /* When 'syntax' is set, load the syntax of that name */
-    else if (varp == &(curbuf->b_p_syn))
-    {
-	apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn,
-					     curbuf->b_fname, TRUE, curbuf);
-    }
-# endif
-
-    /* When 'filetype' is set, trigger the FileType autocommands of that name */
-    else if (varp == &(curbuf->b_p_ft))
-    {
-	did_filetype = TRUE;
-	apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft,
-					     curbuf->b_fname, TRUE, curbuf);
-    }
-#endif
-
-#ifdef FEAT_QUICKFIX
-    /* When 'bufhidden' is set, check for valid value. */
-    else if (gvarp == &p_bh)
-    {
-	if (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)
-	    errmsg = e_invarg;
-    }
-
-    /* When 'buftype' is set, check for valid value. */
-    else if (gvarp == &p_bt)
-    {
-	if (check_opt_strings(curbuf->b_p_bt, p_buftype_values, FALSE) != OK)
-	    errmsg = e_invarg;
-	else
-	{
-# ifdef FEAT_WINDOWS
-	    if (curwin->w_status_height)
-	    {
-		curwin->w_redr_status = TRUE;
-		redraw_later(VALID);
-	    }
-# endif
-	    curbuf->b_help = (curbuf->b_p_bt[0] == 'h');
-	}
-    }
-#endif
-
-#ifdef FEAT_STL_OPT
-    /* 'statusline' or 'rulerformat' */
-    else if (varp == &p_stl || varp == &p_ruf)
-    {
-	int wid;
-
-	if (varp == &p_ruf)	/* reset ru_wid first */
-	    ru_wid = 0;
-	s = *varp;
-	if (varp == &p_ruf && *s == '%')
-	{
-	    /* set ru_wid if 'ruf' starts with "%99(" */
-	    if (*++s == '-')	/* ignore a '-' */
-		s++;
-	    wid = getdigits(&s);
-	    if (wid && *s == '(' && (errmsg = check_stl_option(p_ruf)) == NULL)
-		ru_wid = wid;
-	    else
-		errmsg = check_stl_option(p_ruf);
-	}
-	else
-	    errmsg = check_stl_option(s);
-	if (varp == &(p_ruf) && errmsg == NULL)
-	    comp_col();
-    }
-#endif
-
-#ifdef FEAT_INS_EXPAND
-    /* check if it is a valid value for 'complete' -- Acevedo */
-    else if (gvarp == &p_cpt)
-    {
-	for (s = *varp; *s;)
-	{
-	    while(*s == ',' || *s == ' ')
-		s++;
-	    if (!*s)
-		break;
-	    if (vim_strchr((char_u *)".wbuksid]tU", *s) == NULL)
-	    {
-		errmsg = illegal_char(errbuf, *s);
-		break;
-	    }
-	    if (*++s != NUL && *s != ',' && *s != ' ')
-	    {
-		if (s[-1] == 'k' || s[-1] == 's')
-		{
-		    /* skip optional filename after 'k' and 's' */
-		    while (*s && *s != ',' && *s != ' ')
-		    {
-			if (*s == '\\')
-			    ++s;
-			++s;
-		    }
-		}
-		else
-		{
-		    if (errbuf != NULL)
-		    {
-			sprintf((char *)errbuf,
-				     _("E535: Illegal character after <%c>"),
-				     *--s);
-			errmsg = errbuf;
-		    }
-		    else
-			errmsg = (char_u *)"";
-		    break;
-		}
-	    }
-	}
-    }
-#endif /* FEAT_INS_EXPAND */
-
-
-#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
-    else if (varp == &p_toolbar)
-    {
-	if (opt_strings_flags(p_toolbar, p_toolbar_values,
-			      &toolbar_flags, TRUE) != OK)
-	    errmsg = e_invarg;
-	else
-	{
-	    out_flush();
-	    gui_mch_show_toolbar((toolbar_flags &
-				  (TOOLBAR_TEXT | TOOLBAR_ICONS)) != 0);
-	}
-    }
-#endif
-
-#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK) && defined(HAVE_GTK2)
-    /* 'toolbariconsize': GTK+ 2 only */
-    else if (varp == &p_tbis)
-    {
-	if (opt_strings_flags(p_tbis, p_tbis_values, &tbis_flags, FALSE) != OK)
-	    errmsg = e_invarg;
-	else
-	{
-	    out_flush();
-	    gui_mch_show_toolbar((toolbar_flags &
-				  (TOOLBAR_TEXT | TOOLBAR_ICONS)) != 0);
-	}
-    }
-#endif
-
-    /* 'pastetoggle': translate key codes like in a mapping */
-    else if (varp == &p_pt)
-    {
-	if (*p_pt)
-	{
-	    (void)replace_termcodes(p_pt, &p, TRUE, TRUE);
-	    if (p != NULL)
-	    {
-		if (new_value_alloced)
-		    free_string_option(p_pt);
-		p_pt = p;
-		new_value_alloced = TRUE;
-	    }
-	}
-    }
-
-    /* 'backspace' */
-    else if (varp == &p_bs)
-    {
-	if (VIM_ISDIGIT(*p_bs))
-	{
-	    if (*p_bs >'2' || p_bs[1] != NUL)
-		errmsg = e_invarg;
-	}
-	else if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)
-	    errmsg = e_invarg;
-    }
-
-    /* 'casemap' */
-    else if (varp == &p_cmp)
-    {
-	if (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, TRUE) != OK)
-	    errmsg = e_invarg;
-    }
-
-#ifdef FEAT_DIFF
-    /* 'diffopt' */
-    else if (varp == &p_dip)
-    {
-	if (diffopt_changed() == FAIL)
-	    errmsg = e_invarg;
-    }
-#endif
-
-#ifdef FEAT_FOLDING
-    /* 'foldmethod' */
-    else if (gvarp == &curwin->w_allbuf_opt.wo_fdm)
-    {
-	if (check_opt_strings(*varp, p_fdm_values, FALSE) != OK
-		|| *curwin->w_p_fdm == NUL)
-	    errmsg = e_invarg;
-	else
-	    foldUpdateAll(curwin);
-    }
-# ifdef FEAT_EVAL
-    /* 'foldexpr' */
-    else if (varp == &curwin->w_p_fde)
-    {
-	if (foldmethodIsExpr(curwin))
-	    foldUpdateAll(curwin);
-    }
-# endif
-    /* 'foldmarker' */
-    else if (gvarp == &curwin->w_allbuf_opt.wo_fmr)
-    {
-	p = vim_strchr(*varp, ',');
-	if (p == NULL)
-	    errmsg = (char_u *)N_("E536: comma required");
-	else if (p == *varp || p[1] == NUL)
-	    errmsg = e_invarg;
-	else if (foldmethodIsMarker(curwin))
-	    foldUpdateAll(curwin);
-    }
-    /* 'commentstring' */
-    else if (gvarp == &p_cms)
-    {
-	if (**varp != NUL && strstr((char *)*varp, "%s") == NULL)
-	    errmsg = (char_u *)N_("E537: 'commentstring' must be empty or contain %s");
-    }
-    /* 'foldopen' */
-    else if (varp == &p_fdo)
-    {
-	if (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, TRUE) != OK)
-	    errmsg = e_invarg;
-    }
-    /* 'foldclose' */
-    else if (varp == &p_fcl)
-    {
-	if (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)
-	    errmsg = e_invarg;
-    }
-#endif
-
-#ifdef FEAT_VIRTUALEDIT
-    /* 'virtualedit' */
-    else if (varp == &p_ve)
-    {
-	if (opt_strings_flags(p_ve, p_ve_values, &ve_flags, TRUE) != OK)
-	    errmsg = e_invarg;
-	else if (STRCMP(p_ve, oldval) != 0)
-	{
-	    /* Recompute cursor position in case the new 've' setting
-	     * changes something. */
-	    validate_virtcol();
-	    coladvance(curwin->w_virtcol);
-	}
-    }
-#endif
-
-#if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)
-    else if (varp == &p_csqf)
-    {
-	if (p_csqf != NULL)
-	{
-	    p = p_csqf;
-	    while (*p != NUL)
-	    {
-		if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL
-			|| p[1] == NUL
-			|| vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL
-			|| (p[2] != NUL && p[2] != ','))
-		{
-		    errmsg = e_invarg;
-		    break;
-		}
-		else if (p[2] == NUL)
-		    break;
-		else
-		    p += 3;
-	    }
-	}
-    }
-#endif
-
-    /* Options that are a list of flags. */
-    else
-    {
-	p = NULL;
-	if (varp == &p_ww)
-	    p = (char_u *)WW_ALL;
-	if (varp == &p_shm)
-	    p = (char_u *)SHM_ALL;
-	else if (varp == &(p_cpo))
-	    p = (char_u *)CPO_ALL;
-	else if (varp == &(curbuf->b_p_fo))
-	    p = (char_u *)FO_ALL;
-	else if (varp == &p_mouse)
-	{
-#ifdef FEAT_MOUSE
-	    p = (char_u *)MOUSE_ALL;
-#else
-	    if (*p_mouse != NUL)
-		errmsg = (char_u *)N_("E538: No mouse support");
-#endif
-	}
-#if defined(FEAT_GUI)
-	else if (varp == &p_go)
-	    p = (char_u *)GO_ALL;
-#endif
-	if (p != NULL)
-	{
-	    for (s = *varp; *s; ++s)
-		if (vim_strchr(p, *s) == NULL)
-		{
-		    errmsg = illegal_char(errbuf, *s);
-		    break;
-		}
-	}
-    }
-
-    /*
-     * If error detected, restore the previous value.
-     */
-    if (errmsg != NULL)
-    {
-	if (new_value_alloced)
-	    free_string_option(*varp);
-	*varp = oldval;
-	/*
-	 * When resetting some values, need to act on it.
-	 */
-	if (did_chartab)
-	    (void)init_chartab();
-	if (varp == &p_hl)
-	    (void)highlight_changed();
-    }
-    else
-    {
-#ifdef FEAT_EVAL
-	/* Remember where the option was set. */
-	options[opt_idx].scriptID = current_SID;
-#endif
-	/*
-	 * Free string options that are in allocated memory.
-	 * Use "free_oldval", because recursiveness may change the flags under
-	 * our fingers (esp. init_highlight()).
-	 */
-	if (free_oldval)
-	    free_string_option(oldval);
-	if (new_value_alloced)
-	    options[opt_idx].flags |= P_ALLOCED;
-	else
-	    options[opt_idx].flags &= ~P_ALLOCED;
-
-	if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0
-		&& (int)options[opt_idx].indir >= PV_BOTH)
-	{
-	    /* global option with local value set to use global value; free
-	     * the local value and make it empty */
-	    p = get_varp_scope(&(options[opt_idx]), OPT_LOCAL);
-	    free_string_option(*(char_u **)p);
-	    *(char_u **)p = empty_option;
-	}
-
-	/* May set global value for local option. */
-	else if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)
-	    set_string_option_global(opt_idx, varp);
-    }
-
-#ifdef FEAT_MOUSE
-    if (varp == &p_mouse)
-    {
-# ifdef FEAT_MOUSE_TTY
-	if (*p_mouse == NUL)
-	    mch_setmouse(FALSE);    /* switch mouse off */
-	else
-# endif
-	    setmouse();		    /* in case 'mouse' changed */
-    }
-#endif
-
-    if (curwin->w_curswant != MAXCOL)
-	curwin->w_set_curswant = TRUE;  /* in case 'showbreak' changed */
-    check_redraw(options[opt_idx].flags);
-
-    return errmsg;
-}
-
-/*
- * Handle setting 'listchars' or 'fillchars'.
- * Returns error message, NULL if it's OK.
- */
-    static char_u *
-set_chars_option(varp)
-    char_u	**varp;
-{
-    int		round, i, len, entries;
-    char_u	*p, *s;
-    int		c1, c2 = 0;
-    struct charstab
-    {
-	int	*cp;
-	char	*name;
-    };
-#if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
-    static struct charstab filltab[] =
-    {
-	{&fill_stl,	"stl"},
-	{&fill_stlnc,	"stlnc"},
-	{&fill_vert,	"vert"},
-	{&fill_fold,	"fold"},
-	{&fill_diff,	"diff"},
-    };
-#endif
-    static struct charstab lcstab[] =
-    {
-	{&lcs_eol,	"eol"},
-	{&lcs_ext,	"extends"},
-	{&lcs_prec,	"precedes"},
-	{&lcs_tab2,	"tab"},
-	{&lcs_trail,	"trail"},
-    };
-    struct charstab *tab;
-
-#if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
-    if (varp == &p_lcs)
-#endif
-    {
-	tab = lcstab;
-	entries = sizeof(lcstab) / sizeof(struct charstab);
-    }
-#if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
-    else
-    {
-	tab = filltab;
-	entries = sizeof(filltab) / sizeof(struct charstab);
-    }
-#endif
-
-    /* first round: check for valid value, second round: assign values */
-    for (round = 0; round <= 1; ++round)
-    {
-	if (round)
-	{
-	    /* After checking that the value is valid: set defaults: space for
-	     * 'fillchars', NUL for 'listchars' */
-	    for (i = 0; i < entries; ++i)
-		*(tab[i].cp) = (varp == &p_lcs ? NUL : ' ');
-	    if (varp == &p_lcs)
-		lcs_tab1 = NUL;
-#if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
-	    else
-		fill_diff = '-';
-#endif
-	}
-	p = *varp;
-	while (*p)
-	{
-	    for (i = 0; i < entries; ++i)
-	    {
-		len = (int)STRLEN(tab[i].name);
-		if (STRNCMP(p, tab[i].name, len) == 0
-			&& p[len] == ':'
-			&& p[len + 1] != NUL)
-		{
-		    s = p + len + 1;
-#ifdef FEAT_MBYTE
-		    c1 = mb_ptr2char_adv(&s);
-#else
-		    c1 = *s++;
-#endif
-		    if (tab[i].cp == &lcs_tab2)
-		    {
-			if (*s == NUL)
-			    continue;
-#ifdef FEAT_MBYTE
-			c2 = mb_ptr2char_adv(&s);
-#else
-			c2 = *s++;
-#endif
-		    }
-		    if (*s == ',' || *s == NUL)
-		    {
-			if (round)
-			{
-			    if (tab[i].cp == &lcs_tab2)
-			    {
-				lcs_tab1 = c1;
-				lcs_tab2 = c2;
-			    }
-			    else
-				*(tab[i].cp) = c1;
-
-			}
-			p = s;
-			break;
-		    }
-		}
-	    }
-
-	    if (i == entries)
-		return e_invarg;
-	    if (*p == ',')
-		++p;
-	}
-    }
-
-    return NULL;	/* no error */
-}
-
-#ifdef FEAT_STL_OPT
-/*
- * Check validity of options with the 'statusline' format.
- * Return error message or NULL.
- */
-    char_u *
-check_stl_option(s)
-    char_u	*s;
-{
-    int		itemcnt = 0;
-    int		groupdepth = 0;
-    static char_u   errbuf[80];
-
-    while (*s && itemcnt < STL_MAX_ITEM)
-    {
-	/* Check for valid keys after % sequences */
-	while (*s && *s != '%')
-	    s++;
-	if (!*s)
-	    break;
-	s++;
-	if (*s != '%' && *s != ')')
-	    ++itemcnt;
-	if (*s == '%' || *s == STL_TRUNCMARK || *s == STL_MIDDLEMARK)
-	{
-	    s++;
-	    continue;
-	}
-	if (*s == ')')
-	{
-	    s++;
-	    if (--groupdepth < 0)
-		break;
-	    continue;
-	}
-	if (*s == '-')
-	    s++;
-	while (VIM_ISDIGIT(*s))
-	    s++;
-	if (*s == STL_HIGHLIGHT)
-	    continue;
-	if (*s == '.')
-	{
-	    s++;
-	    while (*s && VIM_ISDIGIT(*s))
-		s++;
-	}
-	if (*s == '(')
-	{
-	    groupdepth++;
-	    continue;
-	}
-	if (vim_strchr(STL_ALL, *s) == NULL)
-	{
-	    return illegal_char(errbuf, *s);
-	}
-	if (*s == '{')
-	{
-	    s++;
-	    while (*s != '}' && *s)
-		s++;
-	    if (*s != '}')
-		return (char_u *)N_("E540: Unclosed expression sequence");
-	}
-    }
-    if (itemcnt >= STL_MAX_ITEM)
-	return (char_u *)N_("E541: too many items");
-    if (groupdepth != 0)
-	return (char_u *)N_("E542: unbalanced groups");
-    return NULL;
-}
-#endif
-
-#ifdef FEAT_CLIPBOARD
-/*
- * Extract the items in the 'clipboard' option and set global values.
- */
-    static char_u *
-check_clipboard_option()
-{
-    int		new_unnamed = FALSE;
-    int		new_autoselect = FALSE;
-    int		new_autoselectml = FALSE;
-    regprog_T	*new_exclude_prog = NULL;
-    char_u	*errmsg = NULL;
-    char_u	*p;
-
-    for (p = p_cb; *p != NUL; )
-    {
-	if (STRNCMP(p, "unnamed", 7) == 0 && (p[7] == ',' || p[7] == NUL))
-	{
-	    new_unnamed = TRUE;
-	    p += 7;
-	}
-	else if (STRNCMP(p, "autoselect", 10) == 0
-					&& (p[10] == ',' || p[10] == NUL))
-	{
-	    new_autoselect = TRUE;
-	    p += 10;
-	}
-	else if (STRNCMP(p, "autoselectml", 12) == 0
-					&& (p[12] == ',' || p[12] == NUL))
-	{
-	    new_autoselectml = TRUE;
-	    p += 12;
-	}
-	else if (STRNCMP(p, "exclude:", 8) == 0 && new_exclude_prog == NULL)
-	{
-	    p += 8;
-	    new_exclude_prog = vim_regcomp(p, RE_MAGIC);
-	    if (new_exclude_prog == NULL)
-		errmsg = e_invarg;
-	    break;
-	}
-	else
-	{
-	    errmsg = e_invarg;
-	    break;
-	}
-	if (*p == ',')
-	    ++p;
-    }
-    if (errmsg == NULL)
-    {
-	clip_unnamed = new_unnamed;
-	clip_autoselect = new_autoselect;
-	clip_autoselectml = new_autoselectml;
-	vim_free(clip_exclude_prog);
-	clip_exclude_prog = new_exclude_prog;
-    }
-    else
-	vim_free(new_exclude_prog);
-
-    return errmsg;
-}
-#endif
-
-/*
- * Set the value of a boolean option, and take care of side effects.
- * Returns NULL for success, or an error message for an error.
- */
-    static char_u *
-set_bool_option(opt_idx, varp, value, opt_flags)
-    int		opt_idx;		/* index in options[] table */
-    char_u	*varp;			/* pointer to the option variable */
-    int		value;			/* new value */
-    int		opt_flags;		/* OPT_LOCAL and/or OPT_GLOBAL */
-{
-    int		old_value = *(int *)varp;
-
-#ifdef FEAT_GUI
-    need_mouse_correct = TRUE;
-#endif
-
-    /* Disallow changing some options from secure mode */
-    if ((secure
-#ifdef HAVE_SANDBOX
-		|| sandbox != 0
-#endif
-		) && (options[opt_idx].flags & P_SECURE))
-	return e_secure;
-
-    *(int *)varp = value;	    /* set the new value */
-#ifdef FEAT_EVAL
-    /* Remember where the option was set. */
-    options[opt_idx].scriptID = current_SID;
-#endif
-
-    /* May set global value for local option. */
-    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)
-	*(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = value;
-
-    /*
-     * Handle side effects of changing a bool option.
-     */
-
-    /* 'compatible' */
-    if ((int *)varp == &p_cp)
-    {
-	compatible_set();
-    }
-
-    /* when 'readonly' is reset globally, also reset readonlymode */
-    else if ((int *)varp == &curbuf->b_p_ro)
-    {
-	if (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0)
-	    readonlymode = FALSE;
-#ifdef FEAT_TITLE
-	need_maketitle = TRUE;
-#endif
-    }
-
-#ifdef FEAT_TITLE
-    /* when 'modifiable' is changed, redraw the window title */
-    else if ((int *)varp == &curbuf->b_p_ma)
-	need_maketitle = TRUE;
-    /* when 'endofline' is changed, redraw the window title */
-    else if ((int *)varp == &curbuf->b_p_eol)
-	need_maketitle = TRUE;
-#endif
-
-    /* when 'bin' is set also set some other options */
-    else if ((int *)varp == &curbuf->b_p_bin)
-    {
-	set_options_bin(old_value, curbuf->b_p_bin, opt_flags);
-#ifdef FEAT_TITLE
-	need_maketitle = TRUE;
-#endif
-    }
-
-#ifdef FEAT_AUTOCMD
-    /* when 'buflisted' changes, trigger autocommands */
-    else if ((int *)varp == &curbuf->b_p_bl && old_value != curbuf->b_p_bl)
-    {
-	apply_autocmds(curbuf->b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,
-						    NULL, NULL, TRUE, curbuf);
-    }
-#endif
-
-    /* when 'swf' is set, create swapfile, when reset remove swapfile */
-    else if ((int *)varp == &curbuf->b_p_swf)
-    {
-	if (curbuf->b_p_swf && p_uc)
-	    ml_open_file(curbuf);		/* create the swap file */
-	else
-	    mf_close_file(curbuf, TRUE);	/* remove the swap file */
-    }
-
-    /* when 'terse' is set change 'shortmess' */
-    else if ((int *)varp == &p_terse)
-    {
-	char_u	*p;
-
-	p = vim_strchr(p_shm, SHM_SEARCH);
-
-	/* insert 's' in p_shm */
-	if (p_terse && p == NULL)
-	{
-	    STRCPY(IObuff, p_shm);
-	    STRCAT(IObuff, "s");
-	    set_string_option_direct((char_u *)"shm", -1, IObuff, OPT_FREE);
-	}
-	/* remove 's' from p_shm */
-	else if (!p_terse && p != NULL)
-	    mch_memmove(p, p + 1, STRLEN(p));
-    }
-
-    /* when 'paste' is set or reset also change other options */
-    else if ((int *)varp == &p_paste)
-    {
-	paste_option_changed();
-    }
-
-    /* when 'insertmode' is set from an autocommand need to do work here */
-    else if ((int *)varp == &p_im)
-    {
-	if (p_im)
-	{
-	    if ((State & INSERT) == 0)
-		need_start_insertmode = TRUE;
-	    stop_insert_mode = FALSE;
-	}
-	else
-	{
-	    need_start_insertmode = FALSE;
-	    stop_insert_mode = TRUE;
-	    if (p_smd && restart_edit != 0)
-		clear_cmdline = TRUE;	/* remove "(insert)" */
-	    restart_edit = 0;
-	}
-    }
-
-    /* when 'ignorecase' is set or reset and 'hlsearch' is set, redraw */
-    else if ((int *)varp == &p_ic && p_hls)
-    {
-	redraw_all_later(NOT_VALID);
-    }
-
-#ifdef FEAT_SEARCH_EXTRA
-    /* when 'hlsearch' is set or reset: reset no_hlsearch */
-    else if ((int *)varp == &p_hls)
-    {
-	no_hlsearch = FALSE;
-    }
-#endif
-
-#ifdef FEAT_SCROLLBIND
-    /* when 'scrollbind' is set: snapshot the current position to avoid a jump
-     * at the end of normal_cmd() */
-    else if ((int *)varp == &curwin->w_p_scb)
-    {
-	if (curwin->w_p_scb)
-	    do_check_scrollbind(FALSE);
-    }
-#endif
-
-#if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-    /* There can be only one window with 'previewwindow' set. */
-    else if ((int *)varp == &curwin->w_p_pvw)
-    {
-	if (curwin->w_p_pvw)
-	{
-	    win_T	*win;
-
-	    for (win = firstwin; win != NULL; win = win->w_next)
-		if (win->w_p_pvw && win != curwin)
-		{
-		    curwin->w_p_pvw = FALSE;
-		    return (char_u *)N_("E590: A preview window already exists");
-		}
-	}
-    }
-#endif
-
-    /* when 'textmode' is set or reset also change 'fileformat' */
-    else if ((int *)varp == &curbuf->b_p_tx)
-    {
-	set_fileformat(curbuf->b_p_tx ? EOL_DOS : EOL_UNIX, opt_flags);
-    }
-
-    /* when 'textauto' is set or reset also change 'fileformats' */
-    else if ((int *)varp == &p_ta)
-    {
-	set_string_option_direct((char_u *)"ffs", -1,
-				 p_ta ? (char_u *)DFLT_FFS_VIM : (char_u *)"",
-							OPT_FREE | opt_flags);
-    }
-
-    /*
-     * When 'lisp' option changes include/exclude '-' in
-     * keyword characters.
-     */
-#ifdef FEAT_LISP
-    else if (varp == (char_u *)&(curbuf->b_p_lisp))
-    {
-	(void)buf_init_chartab(curbuf, FALSE);	    /* ignore errors */
-    }
-#endif
-
-#ifdef FEAT_TITLE
-    /* when 'title' changed, may need to change the title; same for 'icon' */
-    else if ((int *)varp == &p_title)
-    {
-	did_set_title(FALSE);
-    }
-
-    else if ((int *)varp == &p_icon)
-    {
-	did_set_title(TRUE);
-    }
-#endif
-
-    else if ((int *)varp == &curbuf->b_changed)
-    {
-	if (!value)
-	    save_file_ff(curbuf);	/* Buffer is unchanged */
-#ifdef FEAT_TITLE
-	need_maketitle = TRUE;
-#endif
-#ifdef FEAT_AUTOCMD
-	modified_was_set = value;
-#endif
-    }
-
-#ifdef BACKSLASH_IN_FILENAME
-    else if ((int *)varp == &p_ssl)
-    {
-	if (p_ssl)
-	{
-	    psepc = '/';
-	    psepcN = '\\';
-	    pseps[0] = '/';
-	    psepsN[0] = '\\';
-	}
-	else
-	{
-	    psepc = '\\';
-	    psepcN = '/';
-	    pseps[0] = '\\';
-	    psepsN[0] = '/';
-	}
-
-	/* need to adjust the file name arguments and buffer names. */
-	buflist_slash_adjust();
-	alist_slash_adjust();
-# ifdef FEAT_EVAL
-	scriptnames_slash_adjust();
-# endif
-    }
-#endif
-
-    /* If 'wrap' is set, set w_leftcol to zero. */
-    else if ((int *)varp == &curwin->w_p_wrap)
-    {
-	if (curwin->w_p_wrap)
-	    curwin->w_leftcol = 0;
-    }
-
-#ifdef FEAT_WINDOWS
-    else if ((int *)varp == &p_ea)
-    {
-	if (p_ea && !old_value)
-	    win_equal(curwin, FALSE, 0);
-    }
-#endif
-
-    else if ((int *)varp == &p_wiv)
-    {
-	/*
-	 * When 'weirdinvert' changed, set/reset 't_xs'.
-	 * Then set 'weirdinvert' according to value of 't_xs'.
-	 */
-	if (p_wiv && !old_value)
-	    T_XS = (char_u *)"y";
-	else if (!p_wiv && old_value)
-	    T_XS = empty_option;
-	p_wiv = (*T_XS != NUL);
-    }
-
-#if defined(FEAT_BEVAL) && (defined(FEAT_SUN_WORKSHOP) \
-	|| defined(FEAT_NETBEANS_INTG))
-    else if ((int *)varp == &p_beval)
-    {
-	extern BalloonEval	*balloonEval;
-
-	if (p_beval == TRUE)
-	    gui_mch_enable_beval_area(balloonEval);
-	else
-	    gui_mch_disable_beval_area(balloonEval);
-    }
-
-    else if ((int *)varp == &p_acd)
-    {
-	if (p_acd && curbuf->b_ffname != NULL
-				     && vim_chdirfile(curbuf->b_ffname) == OK)
-	    shorten_fnames(TRUE);
-    }
-#endif
-
-#ifdef FEAT_DIFF
-    /* 'diff' */
-    else if ((int *)varp == &curwin->w_p_diff)
-    {
-	win_T	*wp;
-
-	if (!curwin->w_p_diff)
-	{
-	    /* When there is no window showing a diff for this buffer, remove
-	     * it from the diffs. */
-	    for (wp = firstwin; wp != NULL; wp = wp->w_next)
-		if (wp->w_buffer == curwin->w_buffer && wp->w_p_diff)
-		    break;
-	    if (wp == NULL)
-		diff_buf_delete(curwin->w_buffer);
-	}
-	else
-	    diff_buf_add(curwin->w_buffer);
-#ifdef FEAT_FOLDING
-	if (foldmethodIsDiff(curwin))
-	    foldUpdateAll(curwin);
-#endif
-    }
-#endif
-
-#ifdef USE_IM_CONTROL
-    /* 'imdisable' */
-    else if ((int *)varp == &p_imdisable)
-    {
-	/* Only de-activate it here, it will be enabled when changing mode. */
-	if (p_imdisable)
-	    im_set_active(FALSE);
-    }
-#endif
-
-#ifdef FEAT_FKMAP
-    else if ((int *)varp == &p_altkeymap)
-    {
-	if (old_value != p_altkeymap)
-	{
-	    if (!p_altkeymap)
-	    {
-		p_hkmap = p_fkmap;
-		p_fkmap = 0;
-	    }
-	    else
-	    {
-		p_fkmap = p_hkmap;
-		p_hkmap = 0;
-	    }
-	    (void)init_chartab();
-	}
-    }
-
-    /*
-     * In case some second language keymapping options have changed, check
-     * and correct the setting in a consistent way.
-     */
-
-    /*
-     * If hkmap or fkmap are set, reset Arabic keymapping.
-     */
-    if ((p_hkmap || p_fkmap) && p_altkeymap)
-    {
-	p_altkeymap = p_fkmap;
-# ifdef FEAT_ARABIC
-	curwin->w_p_arab = FALSE;
-# endif
-	(void)init_chartab();
-    }
-
-    /*
-     * If hkmap set, reset Farsi keymapping.
-     */
-    if (p_hkmap && p_altkeymap)
-    {
-	p_altkeymap = 0;
-	p_fkmap = 0;
-# ifdef FEAT_ARABIC
-	curwin->w_p_arab = FALSE;
-# endif
-	(void)init_chartab();
-    }
-
-    /*
-     * If fkmap set, reset Hebrew keymapping.
-     */
-    if (p_fkmap && !p_altkeymap)
-    {
-	p_altkeymap = 1;
-	p_hkmap = 0;
-# ifdef FEAT_ARABIC
-	curwin->w_p_arab = FALSE;
-# endif
-	(void)init_chartab();
-    }
-#endif
-
-#ifdef FEAT_ARABIC
-    if ((int *)varp == &curwin->w_p_arab)
-    {
-	if (curwin->w_p_arab)
-	{
-	    /*
-	     * 'arabic' is set, handle various sub-settings.
-	     */
-	    if (!p_tbidi)
-	    {
-		/* set rightleft mode */
-		if (!curwin->w_p_rl)
-		{
-		    curwin->w_p_rl = TRUE;
-		    changed_window_setting();
-		}
-
-		/* Enable Arabic shaping (major part of what Arabic requires) */
-		if (!p_arshape)
-		{
-		    p_arshape = TRUE;
-		    redraw_later_clear();
-		}
-	    }
-
-	    /* Arabic requires a utf-8 encoding, inform the user if its not
-	     * set. */
-	    if (STRCMP(p_enc, "utf-8") != 0)
-		MSG_ATTR(_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'"),
-			hl_attr(HLF_W));
-
-# ifdef FEAT_MBYTE
-	    /* set 'delcombine' */
-	    p_deco = TRUE;
-# endif
-
-# ifdef FEAT_KEYMAP
-	    /* Force-set the necessary keymap for arabic */
-	    set_option_value((char_u *)"keymap", 0L, (char_u *)"arabic",
-								   OPT_LOCAL);
-# endif
-# ifdef FEAT_FKMAP
-	    p_altkeymap = 0;
-	    p_hkmap = 0;
-	    p_fkmap = 0;
-	    (void)init_chartab();
-# endif
-	}
-	else
-	{
-	    /*
-	     * 'arabic' is reset, handle various sub-settings.
-	     */
-	    if (!p_tbidi)
-	    {
-		/* reset rightleft mode */
-		if (curwin->w_p_rl)
-		{
-		    curwin->w_p_rl = FALSE;
-		    changed_window_setting();
-		}
-
-		/* 'arabicshape' isn't reset, it is a global option and
-		 * another window may still need it "on". */
-	    }
-
-	    /* 'delcombine' isn't reset, it is a global option and another
-	     * window may still want it "on". */
-
-# ifdef FEAT_KEYMAP
-	    /* Revert to the default keymap */
-	    curbuf->b_p_iminsert = B_IMODE_NONE;
-	    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;
-# endif
-	}
-    }
-#endif
-
-    /*
-     * End of handling side effects for bool options.
-     */
-
-    options[opt_idx].flags |= P_WAS_SET;
-
-    comp_col();			    /* in case 'ruler' or 'showcmd' changed */
-    if (curwin->w_curswant != MAXCOL)
-	curwin->w_set_curswant = TRUE;  /* in case 'list' changed */
-    check_redraw(options[opt_idx].flags);
-
-    return NULL;
-}
-
-/*
- * Set the value of a number option, and take care of side effects.
- * Returns NULL for success, or an error message for an error.
- */
-    static char_u *
-set_num_option(opt_idx, varp, value, errbuf, opt_flags)
-    int		opt_idx;		/* index in options[] table */
-    char_u	*varp;			/* pointer to the option variable */
-    long	value;			/* new value */
-    char_u	*errbuf;		/* buffer for error messages */
-    int		opt_flags;		/* OPT_LOCAL, OPT_GLOBAL and
-					   OPT_MODELINE */
-{
-    char_u	*errmsg = NULL;
-    long	old_value = *(long *)varp;
-    long	old_Rows = Rows;	/* remember old Rows */
-    long	old_Columns = Columns;	/* remember old Columns */
-    long	*pp = (long *)varp;
-
-#ifdef FEAT_GUI
-    need_mouse_correct = TRUE;
-#endif
-
-    *pp = value;
-#ifdef FEAT_EVAL
-    /* Remember where the option was set. */
-    options[opt_idx].scriptID = current_SID;
-#endif
-
-    if (curbuf->b_p_sw <= 0)
-    {
-	errmsg = e_positive;
-	curbuf->b_p_sw = curbuf->b_p_ts;
-    }
-
-    /*
-     * Number options that need some action when changed
-     */
-#ifdef FEAT_WINDOWS
-    if (pp == &p_wh || pp == &p_hh)
-    {
-	if (p_wh < 1)
-	{
-	    errmsg = e_positive;
-	    p_wh = 1;
-	}
-	if (p_wmh > p_wh)
-	{
-	    errmsg = e_winheight;
-	    p_wh = p_wmh;
-	}
-	if (p_hh < 0)
-	{
-	    errmsg = e_positive;
-	    p_hh = 0;
-	}
-
-	/* Change window height NOW */
-	if (lastwin != firstwin)
-	{
-	    if (pp == &p_wh && curwin->w_height < p_wh)
-		win_setheight((int)p_wh);
-	    if (pp == &p_hh && curbuf->b_help && curwin->w_height < p_hh)
-		win_setheight((int)p_hh);
-	}
-    }
-
-    /* 'winminheight' */
-    else if (pp == &p_wmh)
-    {
-	if (p_wmh < 0)
-	{
-	    errmsg = e_positive;
-	    p_wmh = 0;
-	}
-	if (p_wmh > p_wh)
-	{
-	    errmsg = e_winheight;
-	    p_wmh = p_wh;
-	}
-	win_setminheight();
-    }
-
-# ifdef FEAT_VERTSPLIT
-    if (pp == &p_wiw)
-    {
-	if (p_wiw < 1)
-	{
-	    errmsg = e_positive;
-	    p_wiw = 1;
-	}
-	if (p_wmw > p_wiw)
-	{
-	    errmsg = e_winwidth;
-	    p_wiw = p_wmw;
-	}
-
-	/* Change window width NOW */
-	if (lastwin != firstwin && curwin->w_width < p_wiw)
-	    win_setwidth((int)p_wiw);
-    }
-
-    /* 'winminwidth' */
-    else if (pp == &p_wmw)
-    {
-	if (p_wmw < 0)
-	{
-	    errmsg = e_positive;
-	    p_wmw = 0;
-	}
-	if (p_wmw > p_wiw)
-	{
-	    errmsg = e_winwidth;
-	    p_wmw = p_wiw;
-	}
-	win_setminheight();
-    }
-# endif
-
-#endif
-
-#ifdef FEAT_WINDOWS
-    /* (re)set last window status line */
-    else if (pp == &p_ls)
-    {
-	last_status(FALSE);
-    }
-#endif
-
-#ifdef FEAT_GUI
-    else if (pp == &p_linespace)
-    {
-	if (gui.in_use && gui_mch_adjust_charsize() == OK)
-	    gui_set_shellsize(FALSE, FALSE);
-    }
-#endif
-
-#ifdef FEAT_FOLDING
-    /* 'foldlevel' */
-    else if (pp == &curwin->w_p_fdl)
-    {
-	if (curwin->w_p_fdl < 0)
-	    curwin->w_p_fdl = 0;
-	newFoldLevel();
-    }
-
-    /* 'foldminlevel' */
-    else if (pp == &curwin->w_p_fml)
-    {
-	foldUpdateAll(curwin);
-    }
-
-    /* 'foldnestmax' */
-    else if (pp == &curwin->w_p_fdn)
-    {
-	if (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin))
-	    foldUpdateAll(curwin);
-    }
-
-    /* 'foldcolumn' */
-    else if (pp == &curwin->w_p_fdc)
-    {
-	if (curwin->w_p_fdc < 0)
-	{
-	    errmsg = e_positive;
-	    curwin->w_p_fdc = 0;
-	}
-	else if (curwin->w_p_fdc > 12)
-	{
-	    errmsg = e_invarg;
-	    curwin->w_p_fdc = 12;
-	}
-    }
-
-    /* 'shiftwidth' or 'tabstop' */
-    else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts)
-    {
-	if (foldmethodIsIndent(curwin))
-	    foldUpdateAll(curwin);
-    }
-#endif /* FEAT_FOLDING */
-
-    else if (pp == &curbuf->b_p_iminsert)
-    {
-	if (curbuf->b_p_iminsert < 0 || curbuf->b_p_iminsert > B_IMODE_LAST)
-	{
-	    errmsg = e_invarg;
-	    curbuf->b_p_iminsert = B_IMODE_NONE;
-	}
-	p_iminsert = curbuf->b_p_iminsert;
-	if (termcap_active)	/* don't do this in the alternate screen */
-	    showmode();
-#if defined(FEAT_WINDOWS) && defined(FEAT_KEYMAP)
-	/* Show/unshow value of 'keymap' in status lines. */
-	status_redraw_curbuf();
-#endif
-    }
-
-    else if (pp == &curbuf->b_p_imsearch)
-    {
-	if (curbuf->b_p_imsearch < -1 || curbuf->b_p_imsearch > B_IMODE_LAST)
-	{
-	    errmsg = e_invarg;
-	    curbuf->b_p_imsearch = B_IMODE_NONE;
-	}
-	p_imsearch = curbuf->b_p_imsearch;
-    }
-
-#ifdef FEAT_TITLE
-    /* if 'titlelen' has changed, redraw the title */
-    else if (pp == &p_titlelen)
-    {
-	if (p_titlelen < 0)
-	{
-	    errmsg = e_positive;
-	    p_titlelen = 85;
-	}
-	if (starting != NO_SCREEN && old_value != p_titlelen)
-	    need_maketitle = TRUE;
-    }
-#endif
-
-    /* if p_ch changed value, change the command line height */
-    else if (pp == &p_ch)
-    {
-	if (p_ch < 1)
-	{
-	    errmsg = e_positive;
-	    p_ch = 1;
-	}
-
-	/* Only compute the new window layout when startup has been
-	 * completed. Otherwise the frame sizes may be wrong. */
-	if (p_ch != old_value && full_screen
-#ifdef FEAT_GUI
-		&& !gui.starting
-#endif
-	   )
-	    command_height(old_value);
-    }
-
-    /* when 'updatecount' changes from zero to non-zero, open swap files */
-    else if (pp == &p_uc)
-    {
-	if (p_uc < 0)
-	{
-	    errmsg = e_positive;
-	    p_uc = 100;
-	}
-	if (p_uc && !old_value)
-	    ml_open_files();
-    }
-
-    /* sync undo before 'undolevels' changes */
-    else if (pp == &p_ul)
-    {
-	/* use the old value, otherwise u_sync() may not work properly */
-	p_ul = old_value;
-	u_sync();
-	p_ul = value;
-    }
-
-    /*
-     * Check the bounds for numeric options here
-     */
-    if (Rows < min_rows() && full_screen)
-    {
-	if (errbuf != NULL)
-	{
-	    sprintf((char *)errbuf, _("E593: Need at least %d lines"),
-								  min_rows());
-	    errmsg = errbuf;
-	}
-	Rows = min_rows();
-    }
-    if (Columns < MIN_COLUMNS && full_screen)
-    {
-	if (errbuf != NULL)
-	{
-	    sprintf((char *)errbuf, _("E594: Need at least %d columns"),
-								 MIN_COLUMNS);
-	    errmsg = errbuf;
-	}
-	Columns = MIN_COLUMNS;
-    }
-
-#ifdef DJGPP
-    /* avoid a crash by checking for a too large value of 'columns' */
-    if (old_Columns != Columns && full_screen && term_console)
-	mch_check_columns();
-#endif
-
-    /*
-     * If the screen (shell) height has been changed, assume it is the
-     * physical screenheight.
-     */
-    if (old_Rows != Rows || old_Columns != Columns)
-    {
-	/* Changing the screen size is not allowed while updating the screen. */
-	if (updating_screen)
-	    *pp = old_value;
-	else if (full_screen
-#ifdef FEAT_GUI
-		&& !gui.starting
-#endif
-	    )
-	    set_shellsize((int)Columns, (int)Rows, TRUE);
-	else
-	{
-	    /* Postpone the resizing; check the size and cmdline position for
-	     * messages. */
-	    check_shellsize();
-	    if (cmdline_row > Rows - p_ch && Rows > p_ch)
-		cmdline_row = Rows - p_ch;
-	}
-    }
-
-    if (curbuf->b_p_sts < 0)
-    {
-	errmsg = e_positive;
-	curbuf->b_p_sts = 0;
-    }
-    if (curbuf->b_p_ts <= 0)
-    {
-	errmsg = e_positive;
-	curbuf->b_p_ts = 8;
-    }
-    if (curbuf->b_p_tw < 0)
-    {
-	errmsg = e_positive;
-	curbuf->b_p_tw = 0;
-    }
-    if (p_tm < 0)
-    {
-	errmsg = e_positive;
-	p_tm = 0;
-    }
-    if ((curwin->w_p_scr <= 0
-		|| (curwin->w_p_scr > curwin->w_height
-		    && curwin->w_height > 0))
-	    && full_screen)
-    {
-	if (pp == &(curwin->w_p_scr))
-	{
-	    if (curwin->w_p_scr != 0)
-		errmsg = e_scroll;
-	    win_comp_scroll(curwin);
-	}
-	/* If 'scroll' became invalid because of a side effect silently adjust
-	 * it. */
-	else if (curwin->w_p_scr <= 0)
-	    curwin->w_p_scr = 1;
-	else /* curwin->w_p_scr > curwin->w_height */
-	    curwin->w_p_scr = curwin->w_height;
-    }
-    if (p_report < 0)
-    {
-	errmsg = e_positive;
-	p_report = 1;
-    }
-    if ((p_sj < 0 || p_sj >= Rows) && full_screen)
-    {
-	if (Rows != old_Rows)	/* Rows changed, just adjust p_sj */
-	    p_sj = Rows / 2;
-	else
-	{
-	    errmsg = e_scroll;
-	    p_sj = 1;
-	}
-    }
-    if (p_so < 0 && full_screen)
-    {
-	errmsg = e_scroll;
-	p_so = 0;
-    }
-    if (p_siso < 0 && full_screen)
-    {
-	errmsg = e_positive;
-	p_siso = 0;
-    }
-#ifdef FEAT_CMDWIN
-    if (p_cwh < 1)
-    {
-	errmsg = e_positive;
-	p_cwh = 1;
-    }
-#endif
-    if (p_ut < 0)
-    {
-	errmsg = e_positive;
-	p_ut = 2000;
-    }
-    if (p_ss < 0)
-    {
-	errmsg = e_positive;
-	p_ss = 0;
-    }
-
-    /* May set global value for local option. */
-    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)
-	*(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = *pp;
-
-    options[opt_idx].flags |= P_WAS_SET;
-
-    comp_col();			    /* in case 'columns' or 'ls' changed */
-    if (curwin->w_curswant != MAXCOL)
-	curwin->w_set_curswant = TRUE;  /* in case 'tabstop' changed */
-    check_redraw(options[opt_idx].flags);
-
-    return errmsg;
-}
-
-/*
- * Called after an option changed: check if something needs to be redrawn.
- */
-    static void
-check_redraw(flags)
-    long_u	flags;
-{
-    /* Careful: P_RCLR and P_RALL are a combination of other P_ flags */
-    int		clear = (flags & P_RCLR) == P_RCLR;
-    int		all = ((flags & P_RALL) == P_RALL || clear);
-
-#ifdef FEAT_WINDOWS
-    if ((flags & P_RSTAT) || all)	/* mark all status lines dirty */
-	status_redraw_all();
-#endif
-
-    if ((flags & P_RBUF) || (flags & P_RWIN) || all)
-	changed_window_setting();
-    if (flags & P_RBUF)
-	redraw_curbuf_later(NOT_VALID);
-    if (clear)
-	redraw_all_later(CLEAR);
-    else if (all)
-	redraw_all_later(NOT_VALID);
-}
-
-/*
- * Find index for option 'arg'.
- * Return -1 if not found.
- */
-    static int
-findoption(arg)
-    char_u *arg;
-{
-    int		    opt_idx;
-    char	    *s, *p;
-    static short    quick_tab[27] = {0, 0};	/* quick access table */
-    int		    is_term_opt;
-
-    /*
-     * For first call: Initialize the quick-access table.
-     * It contains the index for the first option that starts with a certain
-     * letter.  There are 26 letters, plus the first "t_" option.
-     */
-    if (quick_tab[1] == 0)
-    {
-	p = options[0].fullname;
-	for (opt_idx = 1; (s = options[opt_idx].fullname) != NULL; opt_idx++)
-	{
-	    if (s[0] != p[0])
-	    {
-		if (s[0] == 't' && s[1] == '_')
-		    quick_tab[26] = opt_idx;
-		else
-		    quick_tab[CharOrdLow(s[0])] = opt_idx;
-	    }
-	    p = s;
-	}
-    }
-
-    /*
-     * Check for name starting with an illegal character.
-     */
-#ifdef EBCDIC
-    if (!islower(arg[0]))
-#else
-    if (arg[0] < 'a' || arg[0] > 'z')
-#endif
-	return -1;
-
-    is_term_opt = (arg[0] == 't' && arg[1] == '_');
-    if (is_term_opt)
-	opt_idx = quick_tab[26];
-    else
-	opt_idx = quick_tab[CharOrdLow(arg[0])];
-    for ( ; (s = options[opt_idx].fullname) != NULL; opt_idx++)
-    {
-	if (STRCMP(arg, s) == 0)		    /* match full name */
-	    break;
-    }
-    if (s == NULL && !is_term_opt)
-    {
-	opt_idx = quick_tab[CharOrdLow(arg[0])];
-	for ( ; options[opt_idx].fullname != NULL; opt_idx++)
-	{
-	    s = options[opt_idx].shortname;
-	    if (s != NULL && STRCMP(arg, s) == 0)   /* match short name */
-		break;
-	    s = NULL;
-	}
-    }
-    if (s == NULL)
-	opt_idx = -1;
-    return opt_idx;
-}
-
-#if defined(FEAT_EVAL) || defined(FEAT_TCL)
-/*
- * Get the value for an option.
- *
- * Returns:
- * Number or Toggle option: 1, *numval gets value.
- *	     String option: 0, *stringval gets allocated string.
- * Hidden Number or Toggle option: -1.
- *	     hidden String option: -2.
- *		   unknown option: -3.
- */
-    int
-get_option_value(name, numval, stringval, opt_flags)
-    char_u	*name;
-    long	*numval;
-    char_u	**stringval;	    /* NULL when only checking existance */
-    int		opt_flags;
-{
-    int		opt_idx;
-    char_u	*varp;
-
-    opt_idx = findoption(name);
-    if (opt_idx < 0)		    /* unknown option */
-	return -3;
-
-    varp = get_varp_scope(&(options[opt_idx]), opt_flags);
-
-    if (options[opt_idx].flags & P_STRING)
-    {
-	if (varp == NULL)		    /* hidden option */
-	    return -2;
-	if (stringval != NULL)
-	{
-#ifdef FEAT_CRYPT
-	    /* never return the value of the crypt key */
-	    if ((char_u **)varp == &curbuf->b_p_key)
-		*stringval = vim_strsave((char_u *)"*****");
-	    else
-#endif
-		*stringval = vim_strsave(*(char_u **)(varp));
-	}
-	return 0;
-    }
-
-    if (varp == NULL)		    /* hidden option */
-	return -1;
-    if (options[opt_idx].flags & P_NUM)
-	*numval = *(long *)varp;
-    else
-    {
-	/* Special case: 'modified' is b_changed, but we also want to consider
-	 * it set when 'ff' or 'fenc' changed. */
-	if ((int *)varp == &curbuf->b_changed)
-	    *numval = curbufIsChanged();
-	else
-	    *numval = *(int *)varp;
-    }
-    return 1;
-}
-#endif
-
-/*
- * Set the value of option "name".
- * Use "string" for string options, use "number" for other options.
- */
-    void
-set_option_value(name, number, string, opt_flags)
-    char_u	*name;
-    long	number;
-    char_u	*string;
-    int		opt_flags;	/* OPT_LOCAL or 0 (both) */
-{
-    int		opt_idx;
-    char_u	*varp;
-    int		flags;
-
-    opt_idx = findoption(name);
-    if (opt_idx == -1)
-	EMSG2(_("E355: Unknown option: %s"), name);
-    else
-    {
-	flags = options[opt_idx].flags;
-#ifdef HAVE_SANDBOX
-	/* Disallow changing some options in the sandbox */
-	if (sandbox > 0 && (flags & P_SECURE))
-	    EMSG(_(e_sandbox));
-	else
-#endif
-	  if (flags & P_STRING)
-	    set_string_option(opt_idx, string, opt_flags);
-	else
-	{
-	    varp = get_varp(&options[opt_idx]);
-	    if (varp != NULL)	/* hidden option is not changed */
-	    {
-		if (flags & P_NUM)
-		    (void)set_num_option(opt_idx, varp, number, NULL, opt_flags);
-		else
-		    (void)set_bool_option(opt_idx, varp, (int)number, opt_flags);
-	    }
-	}
-    }
-}
-
-/*
- * Get the terminal code for a terminal option.
- * Returns NULL when not found.
- */
-    char_u *
-get_term_code(tname)
-    char_u	*tname;
-{
-    int	    opt_idx;
-    char_u  *varp;
-
-    if (tname[0] != 't' || tname[1] != '_' ||
-	    tname[2] == NUL || tname[3] == NUL)
-	return NULL;
-    if ((opt_idx = findoption(tname)) >= 0)
-    {
-	varp = get_varp(&(options[opt_idx]));
-	if (varp != NULL)
-	    varp = *(char_u **)(varp);
-	return varp;
-    }
-    return find_termcode(tname + 2);
-}
-
-    char_u *
-get_highlight_default()
-{
-    int i;
-
-    i = findoption((char_u *)"hl");
-    if (i >= 0)
-	return options[i].def_val[VI_DEFAULT];
-    return (char_u *)NULL;
-}
-
-/*
- * Translate a string like "t_xx", "<t_xx>" or "<S-Tab>" to a key number.
- */
-    static int
-find_key_option(arg)
-    char_u *arg;
-{
-    int		key;
-    int		modifiers;
-
-    /*
-     * Don't use get_special_key_code() for t_xx, we don't want it to call
-     * add_termcap_entry().
-     */
-    if (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])
-	key = TERMCAP2KEY(arg[2], arg[3]);
-    else
-    {
-	--arg;			    /* put arg at the '<' */
-	modifiers = 0;
-	key = find_special_key(&arg, &modifiers, TRUE);
-	if (modifiers)		    /* can't handle modifiers here */
-	    key = 0;
-    }
-    return key;
-}
-
-/*
- * if 'all' == 0: show changed options
- * if 'all' == 1: show all normal options
- * if 'all' == 2: show all terminal options
- */
-    static void
-showoptions(all, opt_flags)
-    int		all;
-    int		opt_flags;	/* OPT_LOCAL and/or OPT_GLOBAL */
-{
-    struct vimoption	*p;
-    int			col;
-    int			isterm;
-    char_u		*varp;
-    struct vimoption	**items;
-    int			item_count;
-    int			run;
-    int			row, rows;
-    int			cols;
-    int			i;
-    int			len;
-
-#define INC 20
-#define GAP 3
-
-    items = (struct vimoption **)alloc((unsigned)(sizeof(struct vimoption *) *
-								PARAM_COUNT));
-    if (items == NULL)
-	return;
-
-    /* Highlight title */
-    if (all == 2)
-	MSG_PUTS_TITLE(_("\n--- Terminal codes ---"));
-    else if (opt_flags & OPT_GLOBAL)
-	MSG_PUTS_TITLE(_("\n--- Global option values ---"));
-    else if (opt_flags & OPT_LOCAL)
-	MSG_PUTS_TITLE(_("\n--- Local option values ---"));
-    else
-	MSG_PUTS_TITLE(_("\n--- Options ---"));
-
-    /*
-     * do the loop two times:
-     * 1. display the short items
-     * 2. display the long items (only strings and numbers)
-     */
-    for (run = 1; run <= 2 && !got_int; ++run)
-    {
-	/*
-	 * collect the items in items[]
-	 */
-	item_count = 0;
-	for (p = &options[0]; p->fullname != NULL; p++)
-	{
-	    varp = NULL;
-	    isterm = istermoption(p);
-	    if (opt_flags != 0)
-	    {
-		if (p->indir != PV_NONE && !isterm)
-		    varp = get_varp_scope(p, opt_flags);
-	    }
-	    else
-		varp = get_varp(p);
-	    if (varp != NULL
-		    && ((all == 2 && isterm)
-			|| (all == 1 && !isterm)
-			|| (all == 0 && !optval_default(p, varp))))
-	    {
-		if (p->flags & P_BOOL)
-		    len = 1;		/* a toggle option fits always */
-		else
-		{
-		    option_value2string(p, opt_flags);
-		    len = (int)STRLEN(p->fullname) + vim_strsize(NameBuff) + 1;
-		}
-		if ((len <= INC - GAP && run == 1) ||
-						(len > INC - GAP && run == 2))
-		    items[item_count++] = p;
-	    }
-	}
-
-	/*
-	 * display the items
-	 */
-	if (run == 1)
-	{
-	    cols = (Columns + GAP - 3) / INC;
-	    if (cols == 0)
-		cols = 1;
-	    rows = (item_count + cols - 1) / cols;
-	}
-	else	/* run == 2 */
-	    rows = item_count;
-	for (row = 0; row < rows && !got_int; ++row)
-	{
-	    msg_putchar('\n');			/* go to next line */
-	    if (got_int)			/* 'q' typed in more */
-		break;
-	    col = 0;
-	    for (i = row; i < item_count; i += rows)
-	    {
-		msg_col = col;			/* make columns */
-		showoneopt(items[i], opt_flags);
-		col += INC;
-	    }
-	    out_flush();
-	    ui_breakcheck();
-	}
-    }
-    vim_free(items);
-}
-
-/*
- * Return TRUE if option "p" has its default value.
- */
-    static int
-optval_default(p, varp)
-    struct vimoption	*p;
-    char_u		*varp;
-{
-    int		dvi;
-
-    if (varp == NULL)
-	return TRUE;	    /* hidden option is always at default */
-    dvi = ((p->flags & P_VI_DEF) || p_cp) ? VI_DEFAULT : VIM_DEFAULT;
-    if (p->flags & P_NUM)
-	return (*(long *)varp == (long)p->def_val[dvi]);
-    if (p->flags & P_BOOL)
-			/* the cast to long is required for Manx C */
-	return (*(int *)varp == (int)(long)p->def_val[dvi]);
-    /* P_STRING */
-    return (STRCMP(*(char_u **)varp, p->def_val[dvi]) == 0);
-}
-
-/*
- * showoneopt: show the value of one option
- * must not be called with a hidden option!
- */
-    static void
-showoneopt(p, opt_flags)
-    struct vimoption	*p;
-    int			opt_flags;	/* OPT_LOCAL or OPT_GLOBAL */
-{
-    char_u		*varp;
-
-    varp = get_varp_scope(p, opt_flags);
-
-    /* for 'modified' we also need to check if 'ff' or 'fenc' changed. */
-    if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed
-					? !curbufIsChanged() : !*(int *)varp))
-	MSG_PUTS("no");
-    else if ((p->flags & P_BOOL) && *(int *)varp < 0)
-	MSG_PUTS("--");
-    else
-	MSG_PUTS("  ");
-    MSG_PUTS(p->fullname);
-    if (!(p->flags & P_BOOL))
-    {
-	msg_putchar('=');
-	/* put value string in NameBuff */
-	option_value2string(p, opt_flags);
-	msg_outtrans(NameBuff);
-    }
-}
-
-/*
- * Write modified options as ":set" commands to a file.
- *
- * There are three values for "opt_flags":
- * OPT_GLOBAL:		   Write global option values and fresh values of
- *			   buffer-local options (used for start of a session
- *			   file).
- * OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for
- *			   curwin (used for a vimrc file).
- * OPT_LOCAL:		   Write buffer-local option values for curbuf, fresh
- *			   and local values for window-local options of
- *			   curwin.  Local values are also written when at the
- *			   default value, because a modeline or autocommand
- *			   may have set them when doing ":edit file" and the
- *			   user has set them back at the default or fresh
- *			   value.
- *			   When "local_only" is TRUE, don't write fresh
- *			   values, only local values (for ":mkview").
- * (fresh value = value used for a new buffer or window for a local option).
- *
- * Return FAIL on error, OK otherwise.
- */
-    int
-makeset(fd, opt_flags, local_only)
-    FILE	*fd;
-    int		opt_flags;
-    int		local_only;
-{
-    struct vimoption	*p;
-    char_u		*varp;			/* currently used value */
-    char_u		*varp_fresh;		/* local value */
-    char_u		*varp_local = NULL;	/* fresh value */
-    char		*cmd;
-    int			round;
-
-    /*
-     * The options that don't have a default (terminal name, columns, lines)
-     * are never written.  Terminal options are also not written.
-     */
-    for (p = &options[0]; !istermoption(p); p++)
-	if (!(p->flags & P_NO_MKRC) && !istermoption(p))
-	{
-	    /* skip global option when only doing locals */
-	    if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))
-		continue;
-
-	    /* Do not store options like 'bufhidden' and 'syntax' in a vimrc
-	     * file, they are always buffer-specific. */
-	    if ((opt_flags & OPT_GLOBAL) && (p->flags & P_NOGLOB))
-		continue;
-
-	    /* Global values are only written when not at the default value. */
-	    varp = get_varp_scope(p, opt_flags);
-	    if ((opt_flags & OPT_GLOBAL) && optval_default(p, varp))
-		continue;
-
-	    round = 2;
-	    if (p->indir != PV_NONE)
-	    {
-		if (p->var == VAR_WIN)
-		{
-		    /* skip window-local option when only doing globals */
-		    if (!(opt_flags & OPT_LOCAL))
-			continue;
-		    /* When fresh value of window-local option is not at the
-		     * default, need to write it too. */
-		    if (!(opt_flags & OPT_GLOBAL) && !local_only)
-		    {
-			varp_fresh = get_varp_scope(p, OPT_GLOBAL);
-			if (!optval_default(p, varp_fresh))
-			{
-			    round = 1;
-			    varp_local = varp;
-			    varp = varp_fresh;
-			}
-		    }
-		}
-	    }
-
-	    /* Round 1: fresh value for window-local options.
-	     * Round 2: other values */
-	    for ( ; round <= 2; varp = varp_local, ++round)
-	    {
-		if (round == 1 || (opt_flags & OPT_GLOBAL))
-		    cmd = "set";
-		else
-		    cmd = "setlocal";
-
-		if (p->flags & P_BOOL)
-		{
-		    if (put_setbool(fd, cmd, p->fullname, *(int *)varp) == FAIL)
-			return FAIL;
-		}
-		else if (p->flags & P_NUM)
-		{
-		    if (put_setnum(fd, cmd, p->fullname, (long *)varp) == FAIL)
-			return FAIL;
-		}
-		else    /* P_STRING */
-		{
-		    /* Don't set 'syntax' and 'filetype' again if the value is
-		     * already right, avoids reloading the syntax file. */
-		    if (p->indir == PV_SYN || p->indir == PV_FT)
-		    {
-			if (fprintf(fd, "if &%s != '%s'", p->fullname,
-						       *(char_u **)(varp)) < 0
-				|| put_eol(fd) < 0)
-			    return FAIL;
-		    }
-		    if (put_setstring(fd, cmd, p->fullname, (char_u **)varp,
-					  (p->flags & P_EXPAND) != 0) == FAIL)
-			return FAIL;
-		    if (p->indir == PV_SYN || p->indir == PV_FT)
-		    {
-			if (put_line(fd, "endif") == FAIL)
-			    return FAIL;
-		    }
-		}
-	    }
-	}
-    return OK;
-}
-
-#if defined(FEAT_FOLDING) || defined(PROTO)
-/*
- * Generate set commands for the local fold options only.  Used when
- * 'sessionoptions' or 'viewoptions' contains "folds" but not "options".
- */
-    int
-makefoldset(fd)
-    FILE	*fd;
-{
-    if (put_setstring(fd, "setlocal", "fdm", &curwin->w_p_fdm, FALSE) == FAIL
-# ifdef FEAT_EVAL
-	    || put_setstring(fd, "setlocal", "fde", &curwin->w_p_fde, FALSE)
-								       == FAIL
-# endif
-	    || put_setstring(fd, "setlocal", "fmr", &curwin->w_p_fmr, FALSE)
-								       == FAIL
-	    || put_setstring(fd, "setlocal", "fdi", &curwin->w_p_fdi, FALSE)
-								       == FAIL
-	    || put_setnum(fd, "setlocal", "fdl", &curwin->w_p_fdl) == FAIL
-	    || put_setnum(fd, "setlocal", "fml", &curwin->w_p_fml) == FAIL
-	    || put_setnum(fd, "setlocal", "fdn", &curwin->w_p_fdn) == FAIL
-	    || put_setbool(fd, "setlocal", "fen", curwin->w_p_fen) == FAIL
-	    )
-	return FAIL;
-
-    return OK;
-}
-#endif
-
-    static int
-put_setstring(fd, cmd, name, valuep, expand)
-    FILE	*fd;
-    char	*cmd;
-    char	*name;
-    char_u	**valuep;
-    int		expand;
-{
-    char_u	*s;
-    char_u	buf[MAXPATHL];
-
-    if (fprintf(fd, "%s %s=", cmd, name) < 0)
-	return FAIL;
-    if (*valuep != NULL)
-    {
-	/* Output 'pastetoggle' as key names.  For other
-	 * options some characters have to be escaped with
-	 * CTRL-V or backslash */
-	if (valuep == &p_pt)
-	{
-	    s = *valuep;
-	    while (*s != NUL)
-		if (fputs((char *)str2special(&s, FALSE), fd) < 0)
-		    return FAIL;
-	}
-	else if (expand)
-	{
-	    home_replace(NULL, *valuep, buf, MAXPATHL, FALSE);
-	    if (put_escstr(fd, buf, 2) == FAIL)
-		return FAIL;
-	}
-	else if (put_escstr(fd, *valuep, 2) == FAIL)
-	    return FAIL;
-    }
-    if (put_eol(fd) < 0)
-	return FAIL;
-    return OK;
-}
-
-    static int
-put_setnum(fd, cmd, name, valuep)
-    FILE	*fd;
-    char	*cmd;
-    char	*name;
-    long	*valuep;
-{
-    long	wc;
-
-    if (fprintf(fd, "%s %s=", cmd, name) < 0)
-	return FAIL;
-    if (wc_use_keyname((char_u *)valuep, &wc))
-    {
-	/* print 'wildchar' and 'wildcharm' as a key name */
-	if (fputs((char *)get_special_key_name((int)wc, 0), fd) < 0)
-	    return FAIL;
-    }
-    else if (fprintf(fd, "%ld", *valuep) < 0)
-	return FAIL;
-    if (put_eol(fd) < 0)
-	return FAIL;
-    return OK;
-}
-
-    static int
-put_setbool(fd, cmd, name, value)
-    FILE	*fd;
-    char	*cmd;
-    char	*name;
-    int		value;
-{
-    if (fprintf(fd, "%s %s%s", cmd, value ? "" : "no", name) < 0
-	    || put_eol(fd) < 0)
-	return FAIL;
-    return OK;
-}
-
-/*
- * Clear all the terminal options.
- * If the option has been allocated, free the memory.
- * Terminal options are never hidden or indirect.
- */
-    void
-clear_termoptions()
-{
-    struct vimoption   *p;
-
-    /*
-     * Reset a few things before clearing the old options. This may cause
-     * outputting a few things that the terminal doesn't understand, but the
-     * screen will be cleared later, so this is OK.
-     */
-#ifdef FEAT_MOUSE_TTY
-    mch_setmouse(FALSE);	    /* switch mouse off */
-#endif
-#ifdef FEAT_TITLE
-    mch_restore_title(3);	    /* restore window titles */
-#endif
-#if defined(FEAT_XCLIPBOARD) && defined(FEAT_GUI)
-    /* When starting the GUI close the display opened for the clipboard.
-     * After restoring the title, because that will need the display. */
-    if (gui.starting)
-	clear_xterm_clip();
-#endif
-#ifdef WIN3264
-    /*
-     * Check if this is allowed now.
-     */
-    if (can_end_termcap_mode(FALSE) == TRUE)
-#endif
-	stoptermcap();			/* stop termcap mode */
-
-    for (p = &options[0]; p->fullname != NULL; p++)
-	if (istermoption(p))
-	{
-	    if (p->flags & P_ALLOCED)
-		free_string_option(*(char_u **)(p->var));
-	    if (p->flags & P_DEF_ALLOCED)
-		free_string_option(p->def_val[VI_DEFAULT]);
-	    *(char_u **)(p->var) = empty_option;
-	    p->def_val[VI_DEFAULT] = empty_option;
-	    p->flags &= ~(P_ALLOCED|P_DEF_ALLOCED);
-	}
-    clear_termcodes();
-}
-
-/*
- * Set the terminal option defaults to the current value.
- * Used after setting the terminal name.
- */
-    void
-set_term_defaults()
-{
-    struct vimoption   *p;
-
-    for (p = &options[0]; p->fullname != NULL; p++)
-    {
-	if (istermoption(p) && p->def_val[VI_DEFAULT] != *(char_u **)(p->var))
-	{
-	    if (p->flags & P_DEF_ALLOCED)
-	    {
-		free_string_option(p->def_val[VI_DEFAULT]);
-		p->flags &= ~P_DEF_ALLOCED;
-	    }
-	    p->def_val[VI_DEFAULT] = *(char_u **)(p->var);
-	    if (p->flags & P_ALLOCED)
-	    {
-		p->flags |= P_DEF_ALLOCED;
-		p->flags &= ~P_ALLOCED;	 /* don't free the value now */
-	    }
-	}
-    }
-}
-
-/*
- * return TRUE if 'p' starts with 't_'
- */
-    static int
-istermoption(p)
-    struct vimoption *p;
-{
-    return (p->fullname[0] == 't' && p->fullname[1] == '_');
-}
-
-/*
- * Compute columns for ruler and shown command. 'sc_col' is also used to
- * decide what the maximum length of a message on the status line can be.
- * If there is a status line for the last window, 'sc_col' is independent
- * of 'ru_col'.
- */
-
-#define COL_RULER 17	    /* columns needed by standard ruler */
-
-    void
-comp_col()
-{
-#if defined(FEAT_CMDL_INFO) && defined(FEAT_WINDOWS)
-    int last_has_status = (p_ls == 2 || (p_ls == 1 && firstwin != lastwin));
-
-    sc_col = 0;
-    ru_col = 0;
-    if (p_ru)
-    {
-#ifdef FEAT_STL_OPT
-	ru_col = (ru_wid ? ru_wid : COL_RULER) + 1;
-#else
-	ru_col = COL_RULER + 1;
-#endif
-	/* no last status line, adjust sc_col */
-	if (!last_has_status)
-	    sc_col = ru_col;
-    }
-    if (p_sc)
-    {
-	sc_col += SHOWCMD_COLS;
-	if (!p_ru || last_has_status)	    /* no need for separating space */
-	    ++sc_col;
-    }
-    sc_col = Columns - sc_col;
-    ru_col = Columns - ru_col;
-    if (sc_col <= 0)		/* screen too narrow, will become a mess */
-	sc_col = 1;
-    if (ru_col <= 0)
-	ru_col = 1;
-#else
-    sc_col = Columns;
-    ru_col = Columns;
-#endif
-}
-
-/*
- * Get pointer to option variable, depending on local or global scope.
- */
-    static char_u *
-get_varp_scope(p, opt_flags)
-    struct vimoption	*p;
-    int			opt_flags;
-{
-    if ((opt_flags & OPT_GLOBAL) && p->indir != PV_NONE)
-    {
-	if (p->var == VAR_WIN)
-	    return (char_u *)GLOBAL_WO(get_varp(p));
-	return p->var;
-    }
-    if ((opt_flags & OPT_LOCAL) && (int)p->indir >= PV_BOTH)
-    {
-	switch ((int)p->indir)
-	{
-#ifdef FEAT_QUICKFIX
-	    case OPT_BOTH(PV_GP):   return (char_u *)&(curbuf->b_p_gp);
-	    case OPT_BOTH(PV_MP):   return (char_u *)&(curbuf->b_p_mp);
-	    case OPT_BOTH(PV_EFM):  return (char_u *)&(curbuf->b_p_efm);
-#endif
-	    case OPT_BOTH(PV_EP):   return (char_u *)&(curbuf->b_p_ep);
-	    case OPT_BOTH(PV_KP):   return (char_u *)&(curbuf->b_p_kp);
-	    case OPT_BOTH(PV_PATH): return (char_u *)&(curbuf->b_p_path);
-	    case OPT_BOTH(PV_AR):   return (char_u *)&(curbuf->b_p_ar);
-	    case OPT_BOTH(PV_TAGS): return (char_u *)&(curbuf->b_p_tags);
-#ifdef FEAT_FIND_ID
-	    case OPT_BOTH(PV_DEF):  return (char_u *)&(curbuf->b_p_def);
-	    case OPT_BOTH(PV_INC):  return (char_u *)&(curbuf->b_p_inc);
-#endif
-#ifdef FEAT_INS_EXPAND
-	    case OPT_BOTH(PV_DICT): return (char_u *)&(curbuf->b_p_dict);
-	    case OPT_BOTH(PV_TSR):  return (char_u *)&(curbuf->b_p_tsr);
-#endif
-	}
-	return NULL; /* "cannot happen" */
-    }
-    return get_varp(p);
-}
-
-/*
- * Get pointer to option variable.
- */
-    static char_u *
-get_varp(p)
-    struct vimoption	*p;
-{
-    /* hidden option, always return NULL */
-    if (p->var == NULL)
-	return NULL;
-
-    switch ((int)p->indir)
-    {
-	case PV_NONE:	return p->var;
-
-	/* global option with local value: use local value if it's been set */
-	case OPT_BOTH(PV_EP):	return *curbuf->b_p_ep != NUL
-				    ? (char_u *)&curbuf->b_p_ep : p->var;
-	case OPT_BOTH(PV_KP):	return *curbuf->b_p_kp != NUL
-				    ? (char_u *)&curbuf->b_p_kp : p->var;
-	case OPT_BOTH(PV_PATH):	return *curbuf->b_p_path != NUL
-				    ? (char_u *)&(curbuf->b_p_path) : p->var;
-	case OPT_BOTH(PV_AR):	return curbuf->b_p_ar >= 0
-				    ? (char_u *)&(curbuf->b_p_ar) : p->var;
-	case OPT_BOTH(PV_TAGS):	return *curbuf->b_p_tags != NUL
-				    ? (char_u *)&(curbuf->b_p_tags) : p->var;
-#ifdef FEAT_FIND_ID
-	case OPT_BOTH(PV_DEF):	return *curbuf->b_p_def != NUL
-				    ? (char_u *)&(curbuf->b_p_def) : p->var;
-	case OPT_BOTH(PV_INC):	return *curbuf->b_p_inc != NUL
-				    ? (char_u *)&(curbuf->b_p_inc) : p->var;
-#endif
-#ifdef FEAT_INS_EXPAND
-	case OPT_BOTH(PV_DICT):	return *curbuf->b_p_dict != NUL
-				    ? (char_u *)&(curbuf->b_p_dict) : p->var;
-	case OPT_BOTH(PV_TSR):	return *curbuf->b_p_tsr != NUL
-				    ? (char_u *)&(curbuf->b_p_tsr) : p->var;
-#endif
-#ifdef FEAT_QUICKFIX
-	case OPT_BOTH(PV_GP):	return *curbuf->b_p_gp != NUL
-				    ? (char_u *)&(curbuf->b_p_gp) : p->var;
-	case OPT_BOTH(PV_MP):	return *curbuf->b_p_mp != NUL
-				    ? (char_u *)&(curbuf->b_p_mp) : p->var;
-	case OPT_BOTH(PV_EFM):	return *curbuf->b_p_efm != NUL
-				    ? (char_u *)&(curbuf->b_p_efm) : p->var;
-#endif
-
-#ifdef FEAT_ARABIC
-	case PV_ARAB:	return (char_u *)&(curwin->w_p_arab);
-#endif
-	case PV_LIST:	return (char_u *)&(curwin->w_p_list);
-#ifdef FEAT_DIFF
-	case PV_DIFF:	return (char_u *)&(curwin->w_p_diff);
-#endif
-#ifdef FEAT_FOLDING
-	case PV_FDC:	return (char_u *)&(curwin->w_p_fdc);
-	case PV_FEN:	return (char_u *)&(curwin->w_p_fen);
-	case PV_FDI:	return (char_u *)&(curwin->w_p_fdi);
-	case PV_FDL:	return (char_u *)&(curwin->w_p_fdl);
-	case PV_FDM:	return (char_u *)&(curwin->w_p_fdm);
-	case PV_FML:	return (char_u *)&(curwin->w_p_fml);
-	case PV_FDN:	return (char_u *)&(curwin->w_p_fdn);
-# ifdef FEAT_EVAL
-	case PV_FDE:	return (char_u *)&(curwin->w_p_fde);
-	case PV_FDT:	return (char_u *)&(curwin->w_p_fdt);
-# endif
-	case PV_FMR:	return (char_u *)&(curwin->w_p_fmr);
-#endif
-	case PV_NU:	return (char_u *)&(curwin->w_p_nu);
-#if defined(FEAT_WINDOWS)
-	case PV_WFH:	return (char_u *)&(curwin->w_p_wfh);
-#endif
-#if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-	case PV_PVW:	return (char_u *)&(curwin->w_p_pvw);
-#endif
-#ifdef FEAT_RIGHTLEFT
-	case PV_RL:	return (char_u *)&(curwin->w_p_rl);
-	case PV_RLC:	return (char_u *)&(curwin->w_p_rlc);
-#endif
-	case PV_SCROLL:	return (char_u *)&(curwin->w_p_scr);
-	case PV_WRAP:	return (char_u *)&(curwin->w_p_wrap);
-#ifdef FEAT_LINEBREAK
-	case PV_LBR:	return (char_u *)&(curwin->w_p_lbr);
-#endif
-#ifdef FEAT_SCROLLBIND
-	case PV_SCBIND: return (char_u *)&(curwin->w_p_scb);
-#endif
-
-	case PV_AI:	return (char_u *)&(curbuf->b_p_ai);
-	case PV_BIN:	return (char_u *)&(curbuf->b_p_bin);
-#ifdef FEAT_MBYTE
-	case PV_BOMB:	return (char_u *)&(curbuf->b_p_bomb);
-#endif
-#if defined(FEAT_QUICKFIX)
-	case PV_BH:	return (char_u *)&(curbuf->b_p_bh);
-	case PV_BT:	return (char_u *)&(curbuf->b_p_bt);
-#endif
-	case PV_BL:	return (char_u *)&(curbuf->b_p_bl);
-	case PV_CI:	return (char_u *)&(curbuf->b_p_ci);
-#ifdef FEAT_CINDENT
-	case PV_CIN:	return (char_u *)&(curbuf->b_p_cin);
-	case PV_CINK:	return (char_u *)&(curbuf->b_p_cink);
-	case PV_CINO:	return (char_u *)&(curbuf->b_p_cino);
-#endif
-#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
-	case PV_CINW:	return (char_u *)&(curbuf->b_p_cinw);
-#endif
-#ifdef FEAT_COMMENTS
-	case PV_COM:	return (char_u *)&(curbuf->b_p_com);
-#endif
-#ifdef FEAT_FOLDING
-	case PV_CMS:	return (char_u *)&(curbuf->b_p_cms);
-#endif
-#ifdef FEAT_INS_EXPAND
-	case PV_CPT:	return (char_u *)&(curbuf->b_p_cpt);
-#endif
-	case PV_EOL:	return (char_u *)&(curbuf->b_p_eol);
-	case PV_ET:	return (char_u *)&(curbuf->b_p_et);
-#ifdef FEAT_MBYTE
-	case PV_FENC:	return (char_u *)&(curbuf->b_p_fenc);
-#endif
-	case PV_FF:	return (char_u *)&(curbuf->b_p_ff);
-#ifdef FEAT_AUTOCMD
-	case PV_FT:	return (char_u *)&(curbuf->b_p_ft);
-#endif
-	case PV_FO:	return (char_u *)&(curbuf->b_p_fo);
-	case PV_IMI:	return (char_u *)&(curbuf->b_p_iminsert);
-	case PV_IMS:	return (char_u *)&(curbuf->b_p_imsearch);
-	case PV_INF:	return (char_u *)&(curbuf->b_p_inf);
-	case PV_ISK:	return (char_u *)&(curbuf->b_p_isk);
-#ifdef FEAT_FIND_ID
-# ifdef FEAT_EVAL
-	case PV_INEX:	return (char_u *)&(curbuf->b_p_inex);
-# endif
-#endif
-#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
-	case PV_INDE:	return (char_u *)&(curbuf->b_p_inde);
-	case PV_INDK:	return (char_u *)&(curbuf->b_p_indk);
-#endif
-#ifdef FEAT_CRYPT
-	case PV_KEY:	return (char_u *)&(curbuf->b_p_key);
-#endif
-#ifdef FEAT_LISP
-	case PV_LISP:	return (char_u *)&(curbuf->b_p_lisp);
-#endif
-	case PV_ML:	return (char_u *)&(curbuf->b_p_ml);
-	case PV_MPS:	return (char_u *)&(curbuf->b_p_mps);
-	case PV_MA:	return (char_u *)&(curbuf->b_p_ma);
-	case PV_MOD:	return (char_u *)&(curbuf->b_changed);
-	case PV_NF:	return (char_u *)&(curbuf->b_p_nf);
-#ifdef FEAT_OSFILETYPE
-	case PV_OFT:	return (char_u *)&(curbuf->b_p_oft);
-#endif
-	case PV_PI:	return (char_u *)&(curbuf->b_p_pi);
-	case PV_RO:	return (char_u *)&(curbuf->b_p_ro);
-#ifdef FEAT_SMARTINDENT
-	case PV_SI:	return (char_u *)&(curbuf->b_p_si);
-#endif
-#ifndef SHORT_FNAME
-	case PV_SN:	return (char_u *)&(curbuf->b_p_sn);
-#endif
-	case PV_STS:	return (char_u *)&(curbuf->b_p_sts);
-#ifdef FEAT_SEARCHPATH
-	case PV_SUA:	return (char_u *)&(curbuf->b_p_sua);
-#endif
-	case PV_SWF:	return (char_u *)&(curbuf->b_p_swf);
-#ifdef FEAT_SYN_HL
-	case PV_SYN:	return (char_u *)&(curbuf->b_p_syn);
-#endif
-	case PV_SW:	return (char_u *)&(curbuf->b_p_sw);
-	case PV_TS:	return (char_u *)&(curbuf->b_p_ts);
-	case PV_TW:	return (char_u *)&(curbuf->b_p_tw);
-	case PV_TX:	return (char_u *)&(curbuf->b_p_tx);
-	case PV_WM:	return (char_u *)&(curbuf->b_p_wm);
-#ifdef FEAT_KEYMAP
-	case PV_KMAP:	return (char_u *)&(curbuf->b_p_keymap);
-#endif
-	default:	EMSG(_("E356: get_varp ERROR"));
-    }
-    /* always return a valid pointer to avoid a crash! */
-    return (char_u *)&(curbuf->b_p_wm);
-}
-
-/*
- * Get the value of 'equalprg', either the buffer-local one or the global one.
- */
-    char_u *
-get_equalprg()
-{
-    if (*curbuf->b_p_ep == NUL)
-	return p_ep;
-    return curbuf->b_p_ep;
-}
-
-#if defined(FEAT_WINDOWS) || defined(PROTO)
-/*
- * Copy options from one window to another.
- * Used when splitting a window.
- */
-    void
-win_copy_options(wp_from, wp_to)
-    win_T	*wp_from;
-    win_T	*wp_to;
-{
-    copy_winopt(&wp_from->w_onebuf_opt, &wp_to->w_onebuf_opt);
-    copy_winopt(&wp_from->w_allbuf_opt, &wp_to->w_allbuf_opt);
-# ifdef FEAT_RIGHTLEFT
-#  ifdef FEAT_FKMAP
-    /* Is this right? */
-    wp_to->w_farsi = wp_from->w_farsi;
-#  endif
-# endif
-}
-#endif
-
-/*
- * Copy the options from one winopt_T to another.
- * Doesn't free the old option values in "to", use clear_winopt() for that.
- * The 'scroll' option is not copied, because it depends on the window height.
- * The 'previewwindow' option is reset, there can be only one preview window.
- */
-    void
-copy_winopt(from, to)
-    winopt_T	*from;
-    winopt_T	*to;
-{
-#ifdef FEAT_ARABIC
-    to->wo_arab = from->wo_arab;
-#endif
-    to->wo_list = from->wo_list;
-    to->wo_nu = from->wo_nu;
-#ifdef FEAT_RIGHTLEFT
-    to->wo_rl  = from->wo_rl;
-    to->wo_rlc = vim_strsave(from->wo_rlc);
-#endif
-    to->wo_wrap = from->wo_wrap;
-#ifdef FEAT_LINEBREAK
-    to->wo_lbr = from->wo_lbr;
-#endif
-#ifdef FEAT_SCROLLBIND
-    to->wo_scb = from->wo_scb;
-#endif
-#ifdef FEAT_DIFF
-    to->wo_diff = from->wo_diff;
-#endif
-#ifdef FEAT_FOLDING
-    to->wo_fdc = from->wo_fdc;
-    to->wo_fen = from->wo_fen;
-    to->wo_fdi = vim_strsave(from->wo_fdi);
-    to->wo_fml = from->wo_fml;
-    to->wo_fdl = from->wo_fdl;
-    to->wo_fdm = vim_strsave(from->wo_fdm);
-    to->wo_fdn = from->wo_fdn;
-# ifdef FEAT_EVAL
-    to->wo_fde = vim_strsave(from->wo_fde);
-    to->wo_fdt = vim_strsave(from->wo_fdt);
-# endif
-    to->wo_fmr = vim_strsave(from->wo_fmr);
-#endif
-    check_winopt(to);		/* don't want NULL pointers */
-}
-
-/*
- * Check string options in a window for a NULL value.
- */
-    void
-check_win_options(win)
-    win_T	*win;
-{
-    check_winopt(&win->w_onebuf_opt);
-    check_winopt(&win->w_allbuf_opt);
-}
-
-/*
- * Check for NULL pointers in a winopt_T and replace them with empty_option.
- */
-/*ARGSUSED*/
-    void
-check_winopt(wop)
-    winopt_T	*wop;
-{
-#ifdef FEAT_FOLDING
-    check_string_option(&wop->wo_fdi);
-    check_string_option(&wop->wo_fdm);
-# ifdef FEAT_EVAL
-    check_string_option(&wop->wo_fde);
-    check_string_option(&wop->wo_fdt);
-# endif
-    check_string_option(&wop->wo_fmr);
-#endif
-#ifdef FEAT_RIGHTLEFT
-    check_string_option(&wop->wo_rlc);
-#endif
-}
-
-/*
- * Free the allocated memory inside a winopt_T.
- */
-/*ARGSUSED*/
-    void
-clear_winopt(wop)
-    winopt_T	*wop;
-{
-#ifdef FEAT_FOLDING
-    clear_string_option(&wop->wo_fdi);
-    clear_string_option(&wop->wo_fdm);
-# ifdef FEAT_EVAL
-    clear_string_option(&wop->wo_fde);
-    clear_string_option(&wop->wo_fdt);
-# endif
-    clear_string_option(&wop->wo_fmr);
-#endif
-#ifdef FEAT_RIGHTLEFT
-    clear_string_option(&wop->wo_rlc);
-#endif
-}
-
-/*
- * Copy global option values to local options for one buffer.
- * Used when creating a new buffer and sometimes when entering a buffer.
- * flags:
- * BCO_ENTER	We will enter the buf buffer.
- * BCO_ALWAYS	Always copy the options, but only set b_p_initialized when
- *		appropriate.
- * BCO_NOHELP	Don't copy the values to a help buffer.
- */
-    void
-buf_copy_options(buf, flags)
-    buf_T	*buf;
-    int		flags;
-{
-    int		should_copy = TRUE;
-    char_u	*save_p_isk = NULL;	    /* init for GCC */
-    int		dont_do_help;
-    int		did_isk = FALSE;
-
-    /*
-     * Don't do anything of the buffer is invalid.
-     */
-    if (buf == NULL || !buf_valid(buf))
-	return;
-
-    /*
-     * Skip this when the option defaults have not been set yet.  Happens when
-     * main() allocates the first buffer.
-     */
-    if (p_cpo != NULL)
-    {
-	/*
-	 * Always copy when entering and 'cpo' contains 'S'.
-	 * Don't copy when already initialized.
-	 * Don't copy when 'cpo' contains 's' and not entering.
-	 * 'S'	BCO_ENTER  initialized	's'  should_copy
-	 * yes	  yes	       X	 X	TRUE
-	 * yes	  no	      yes	 X	FALSE
-	 * no	   X	      yes	 X	FALSE
-	 *  X	  no	      no	yes	FALSE
-	 *  X	  no	      no	no	TRUE
-	 * no	  yes	      no	 X	TRUE
-	 */
-	if ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))
-		&& (buf->b_p_initialized
-		    || (!(flags & BCO_ENTER)
-			&& vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))
-	    should_copy = FALSE;
-
-	if (should_copy || (flags & BCO_ALWAYS))
-	{
-	    /* Don't copy the options specific to a help buffer when
-	     * BCO_NOHELP is given or the options were initialized already
-	     * (jumping back to a help file with CTRL-T or CTRL-O) */
-	    dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)
-						       || buf->b_p_initialized;
-	    if (dont_do_help)		/* don't free b_p_isk */
-	    {
-		save_p_isk = buf->b_p_isk;
-		buf->b_p_isk = NULL;
-	    }
-	    /*
-	     * Always free the allocated strings.
-	     * If not already initialized, set 'readonly' and copy 'fileformat'.
-	     */
-	    if (!buf->b_p_initialized)
-	    {
-		free_buf_options(buf, TRUE);
-		buf->b_p_ro = FALSE;		/* don't copy readonly */
-		buf->b_p_tx = p_tx;
-#ifdef FEAT_MBYTE
-		buf->b_p_fenc = vim_strsave(p_fenc);
-#endif
-		buf->b_p_ff = vim_strsave(p_ff);
-#if defined(FEAT_QUICKFIX)
-		buf->b_p_bh = empty_option;
-		buf->b_p_bt = empty_option;
-#endif
-	    }
-	    else
-		free_buf_options(buf, FALSE);
-
-	    buf->b_p_ai = p_ai;
-	    buf->b_p_ai_nopaste = p_ai_nopaste;
-	    buf->b_p_sw = p_sw;
-	    buf->b_p_tw = p_tw;
-	    buf->b_p_tw_nopaste = p_tw_nopaste;
-	    buf->b_p_tw_nobin = p_tw_nobin;
-	    buf->b_p_wm = p_wm;
-	    buf->b_p_wm_nopaste = p_wm_nopaste;
-	    buf->b_p_wm_nobin = p_wm_nobin;
-	    buf->b_p_bin = p_bin;
-	    buf->b_p_et = p_et;
-	    buf->b_p_et_nobin = p_et_nobin;
-	    buf->b_p_ml = p_ml;
-	    buf->b_p_ml_nobin = p_ml_nobin;
-	    buf->b_p_inf = p_inf;
-	    buf->b_p_swf = p_swf;
-#ifdef FEAT_INS_EXPAND
-	    buf->b_p_cpt = vim_strsave(p_cpt);
-#endif
-	    buf->b_p_sts = p_sts;
-	    buf->b_p_sts_nopaste = p_sts_nopaste;
-#ifndef SHORT_FNAME
-	    buf->b_p_sn = p_sn;
-#endif
-#ifdef FEAT_COMMENTS
-	    buf->b_p_com = vim_strsave(p_com);
-#endif
-#ifdef FEAT_FOLDING
-	    buf->b_p_cms = vim_strsave(p_cms);
-#endif
-	    buf->b_p_fo = vim_strsave(p_fo);
-	    buf->b_p_nf = vim_strsave(p_nf);
-	    buf->b_p_mps = vim_strsave(p_mps);
-#ifdef FEAT_SMARTINDENT
-	    buf->b_p_si = p_si;
-#endif
-	    buf->b_p_ci = p_ci;
-#ifdef FEAT_CINDENT
-	    buf->b_p_cin = p_cin;
-	    buf->b_p_cink = vim_strsave(p_cink);
-	    buf->b_p_cino = vim_strsave(p_cino);
-#endif
-#ifdef FEAT_AUTOCMD
-	    /* Don't copy 'filetype', it must be detected */
-	    buf->b_p_ft = empty_option;
-#endif
-#ifdef FEAT_OSFILETYPE
-	    buf->b_p_oft = vim_strsave(p_oft);
-#endif
-	    buf->b_p_pi = p_pi;
-#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
-	    buf->b_p_cinw = vim_strsave(p_cinw);
-#endif
-#ifdef FEAT_LISP
-	    buf->b_p_lisp = p_lisp;
-#endif
-#ifdef FEAT_SYN_HL
-	    /* Don't copy 'syntax', it must be set */
-	    buf->b_p_syn = empty_option;
-#endif
-#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
-	    buf->b_p_inde = vim_strsave(p_inde);
-	    buf->b_p_indk = vim_strsave(p_indk);
-#endif
-#ifdef FEAT_CRYPT
-	    buf->b_p_key = vim_strsave(p_key);
-#endif
-#ifdef FEAT_SEARCHPATH
-	    buf->b_p_sua = vim_strsave(p_sua);
-#endif
-#ifdef FEAT_KEYMAP
-	    buf->b_p_keymap = vim_strsave(p_keymap);
-	    buf->b_kmap_state |= KEYMAP_INIT;
-#endif
-	    /* This isn't really an option, but copying the langmap and IME
-	     * state from the current buffer is better than resetting it. */
-	    buf->b_p_iminsert = p_iminsert;
-	    buf->b_p_imsearch = p_imsearch;
-
-	    /* options that are normally global but also have a local value
-	     * are not copied, start using the global value */
-	    buf->b_p_ar = -1;
-#ifdef FEAT_QUICKFIX
-	    buf->b_p_gp = empty_option;
-	    buf->b_p_mp = empty_option;
-	    buf->b_p_efm = empty_option;
-#endif
-	    buf->b_p_ep = empty_option;
-	    buf->b_p_kp = empty_option;
-	    buf->b_p_path = empty_option;
-	    buf->b_p_tags = empty_option;
-#ifdef FEAT_FIND_ID
-	    buf->b_p_def = empty_option;
-	    buf->b_p_inc = empty_option;
-# ifdef FEAT_EVAL
-	    buf->b_p_inex = vim_strsave(p_inex);
-# endif
-#endif
-#ifdef FEAT_INS_EXPAND
-	    buf->b_p_dict = empty_option;
-	    buf->b_p_tsr = empty_option;
-#endif
-
-	    /*
-	     * Don't copy the options set by ex_help(), use the saved values,
-	     * when going from a help buffer to a non-help buffer.
-	     * Don't touch these at all when BCO_NOHELP is used and going from
-	     * or to a help buffer.
-	     */
-	    if (dont_do_help)
-		buf->b_p_isk = save_p_isk;
-	    else
-	    {
-		buf->b_p_isk = vim_strsave(p_isk);
-		did_isk = TRUE;
-		buf->b_p_ts = p_ts;
-		buf->b_help = FALSE;
-#ifdef FEAT_QUICKFIX
-		if (buf->b_p_bt[0] == 'h')
-		    clear_string_option(&buf->b_p_bt);
-#endif
-		buf->b_p_ma = p_ma;
-	    }
-	}
-
-	/*
-	 * When the options should be copied (ignoring BCO_ALWAYS), set the
-	 * flag that indicates that the options have been initialized.
-	 */
-	if (should_copy)
-	    buf->b_p_initialized = TRUE;
-    }
-
-    check_buf_options(buf);	    /* make sure we don't have NULLs */
-    if (did_isk)
-	(void)buf_init_chartab(buf, FALSE);
-}
-
-/*
- * Reset the 'modifiable' option and its default value.
- */
-    void
-reset_modifiable()
-{
-    int		opt_idx;
-
-    curbuf->b_p_ma = FALSE;
-    p_ma = FALSE;
-    opt_idx = findoption((char_u *)"ma");
-    options[opt_idx].def_val[VI_DEFAULT] = FALSE;
-}
-
-/*
- * Set the global value for 'iminsert' to the local value.
- */
-    void
-set_iminsert_global()
-{
-    p_iminsert = curbuf->b_p_iminsert;
-}
-
-/*
- * Set the global value for 'imsearch' to the local value.
- */
-    void
-set_imsearch_global()
-{
-    p_imsearch = curbuf->b_p_imsearch;
-}
-
-#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
-static int expand_option_idx = -1;
-static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};
-static int expand_option_flags = 0;
-
-    void
-set_context_in_set_cmd(xp, arg, opt_flags)
-    expand_T	*xp;
-    char_u	*arg;
-    int		opt_flags;	/* OPT_GLOBAL and/or OPT_LOCAL */
-{
-    int		nextchar;
-    long_u	flags = 0;	/* init for GCC */
-    int		opt_idx = 0;	/* init for GCC */
-    char_u	*p;
-    char_u	*s;
-    int		is_term_option = FALSE;
-    int		key;
-
-    expand_option_flags = opt_flags;
-
-    xp->xp_context = EXPAND_SETTINGS;
-    if (*arg == NUL)
-    {
-	xp->xp_pattern = arg;
-	return;
-    }
-    p = arg + STRLEN(arg) - 1;
-    if (*p == ' ' && *(p - 1) != '\\')
-    {
-	xp->xp_pattern = p + 1;
-	return;
-    }
-    while (p > arg)
-    {
-	s = p;
-	/* count number of backslashes before ' ' or ',' */
-	if (*p == ' ' || *p == ',')
-	{
-	    while (s > arg && *(s - 1) == '\\')
-		--s;
-	}
-	/* break at a space with an even number of backslashes */
-	if (*p == ' ' && ((p - s) & 1) == 0)
-	{
-	    ++p;
-	    break;
-	}
-	--p;
-    }
-    if (STRNCMP(p, "no", 2) == 0)
-    {
-	xp->xp_context = EXPAND_BOOL_SETTINGS;
-	p += 2;
-    }
-    if (STRNCMP(p, "inv", 3) == 0)
-    {
-	xp->xp_context = EXPAND_BOOL_SETTINGS;
-	p += 3;
-    }
-    xp->xp_pattern = arg = p;
-    if (*arg == '<')
-    {
-	while (*p != '>')
-	    if (*p++ == NUL)	    /* expand terminal option name */
-		return;
-	key = get_special_key_code(arg + 1);
-	if (key == 0)		    /* unknown name */
-	{
-	    xp->xp_context = EXPAND_NOTHING;
-	    return;
-	}
-	nextchar = *++p;
-	is_term_option = TRUE;
-	expand_option_name[2] = KEY2TERMCAP0(key);
-	expand_option_name[3] = KEY2TERMCAP1(key);
-    }
-    else
-    {
-	if (p[0] == 't' && p[1] == '_')
-	{
-	    p += 2;
-	    if (*p != NUL)
-		++p;
-	    if (*p == NUL)
-		return;		/* expand option name */
-	    nextchar = *++p;
-	    is_term_option = TRUE;
-	    expand_option_name[2] = p[-2];
-	    expand_option_name[3] = p[-1];
-	}
-	else
-	{
-		/* Allow * wildcard */
-	    while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*')
-		p++;
-	    if (*p == NUL)
-		return;
-	    nextchar = *p;
-	    *p = NUL;
-	    opt_idx = findoption(arg);
-	    *p = nextchar;
-	    if (opt_idx == -1 || options[opt_idx].var == NULL)
-	    {
-		xp->xp_context = EXPAND_NOTHING;
-		return;
-	    }
-	    flags = options[opt_idx].flags;
-	    if (flags & P_BOOL)
-	    {
-		xp->xp_context = EXPAND_NOTHING;
-		return;
-	    }
-	}
-    }
-    /* handle "-=" and "+=" */
-    if ((nextchar == '-' || nextchar == '+' || nextchar == '^') && p[1] == '=')
-    {
-	++p;
-	nextchar = '=';
-    }
-    if ((nextchar != '=' && nextchar != ':')
-				    || xp->xp_context == EXPAND_BOOL_SETTINGS)
-    {
-	xp->xp_context = EXPAND_UNSUCCESSFUL;
-	return;
-    }
-    if (xp->xp_context != EXPAND_BOOL_SETTINGS && p[1] == NUL)
-    {
-	xp->xp_context = EXPAND_OLD_SETTING;
-	if (is_term_option)
-	    expand_option_idx = -1;
-	else
-	    expand_option_idx = opt_idx;
-	xp->xp_pattern = p + 1;
-	return;
-    }
-    xp->xp_context = EXPAND_NOTHING;
-    if (is_term_option || (flags & P_NUM))
-	return;
-
-    xp->xp_pattern = p + 1;
-
-    if (flags & P_EXPAND)
-    {
-	p = options[opt_idx].var;
-	if (p == (char_u *)&p_bdir
-		|| p == (char_u *)&p_dir
-		|| p == (char_u *)&p_path
-		|| p == (char_u *)&p_rtp
-#ifdef FEAT_SEARCHPATH
-		|| p == (char_u *)&p_cdpath
-#endif
-#ifdef FEAT_SESSION
-		|| p == (char_u *)&p_vdir
-#endif
-		)
-	{
-	    xp->xp_context = EXPAND_DIRECTORIES;
-	    if (p == (char_u *)&p_path
-#ifdef FEAT_SEARCHPATH
-		    || p == (char_u *)&p_cdpath
-#endif
-		   )
-		xp->xp_backslash = XP_BS_THREE;
-	    else
-		xp->xp_backslash = XP_BS_ONE;
-	}
-	else
-	{
-	    xp->xp_context = EXPAND_FILES;
-	    /* for 'tags' need three backslashes for a space */
-	    if (p == (char_u *)&p_tags)
-		xp->xp_backslash = XP_BS_THREE;
-	    else
-		xp->xp_backslash = XP_BS_ONE;
-	}
-    }
-
-    /* For an option that is a list of file names, find the start of the
-     * last file name. */
-    for (p = arg + STRLEN(arg) - 1; p > xp->xp_pattern; --p)
-    {
-	/* count number of backslashes before ' ' or ',' */
-	if (*p == ' ' || *p == ',')
-	{
-	    s = p;
-	    while (s > xp->xp_pattern && *(s - 1) == '\\')
-		--s;
-	    if ((*p == ' ' && (xp->xp_backslash == XP_BS_THREE && (p - s) < 3))
-		    || (*p == ',' && (flags & P_COMMA) && ((p - s) & 1) == 0))
-	    {
-		xp->xp_pattern = p + 1;
-		break;
-	    }
-	}
-    }
-
-    return;
-}
-
-    int
-ExpandSettings(xp, regmatch, num_file, file)
-    expand_T	*xp;
-    regmatch_T	*regmatch;
-    int		*num_file;
-    char_u	***file;
-{
-    int		num_normal = 0;	    /* Nr of matching non-term-code settings */
-    int		num_term = 0;	    /* Nr of matching terminal code settings */
-    int		opt_idx;
-    int		match;
-    int		count = 0;
-    char_u	*str;
-    int		loop;
-    int		is_term_opt;
-    char_u	name_buf[MAX_KEY_NAME_LEN];
-    static char *(names[]) = {"all", "termcap"};
-    int		ic = regmatch->rm_ic;	/* remember the ignore-case flag */
-
-    /* do this loop twice:
-     * loop == 0: count the number of matching options
-     * loop == 1: copy the matching options into allocated memory
-     */
-    for (loop = 0; loop <= 1; ++loop)
-    {
-	regmatch->rm_ic = ic;
-	if (xp->xp_context != EXPAND_BOOL_SETTINGS)
-	{
-	    for (match = 0; match < sizeof(names) / sizeof(char *); ++match)
-		if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))
-		{
-		    if (loop == 0)
-			num_normal++;
-		    else
-			(*file)[count++] = vim_strsave((char_u *)names[match]);
-		}
-	}
-	for (opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;
-								    opt_idx++)
-	{
-	    if (options[opt_idx].var == NULL)
-		continue;
-	    if (xp->xp_context == EXPAND_BOOL_SETTINGS
-	      && !(options[opt_idx].flags & P_BOOL))
-		continue;
-	    is_term_opt = istermoption(&options[opt_idx]);
-	    if (is_term_opt && num_normal > 0)
-		continue;
-	    match = FALSE;
-	    if (vim_regexec(regmatch, str, (colnr_T)0)
-		    || (options[opt_idx].shortname != NULL
-			&& vim_regexec(regmatch,
-			   (char_u *)options[opt_idx].shortname, (colnr_T)0)))
-		match = TRUE;
-	    else if (is_term_opt)
-	    {
-		name_buf[0] = '<';
-		name_buf[1] = 't';
-		name_buf[2] = '_';
-		name_buf[3] = str[2];
-		name_buf[4] = str[3];
-		name_buf[5] = '>';
-		name_buf[6] = NUL;
-		if (vim_regexec(regmatch, name_buf, (colnr_T)0))
-		{
-		    match = TRUE;
-		    str = name_buf;
-		}
-	    }
-	    if (match)
-	    {
-		if (loop == 0)
-		{
-		    if (is_term_opt)
-			num_term++;
-		    else
-			num_normal++;
-		}
-		else
-		    (*file)[count++] = vim_strsave(str);
-	    }
-	}
-	/*
-	 * Check terminal key codes, these are not in the option table
-	 */
-	if (xp->xp_context != EXPAND_BOOL_SETTINGS  && num_normal == 0)
-	{
-	    for (opt_idx = 0; (str = get_termcode(opt_idx)) != NULL; opt_idx++)
-	    {
-		if (!isprint(str[0]) || !isprint(str[1]))
-		    continue;
-
-		name_buf[0] = 't';
-		name_buf[1] = '_';
-		name_buf[2] = str[0];
-		name_buf[3] = str[1];
-		name_buf[4] = NUL;
-
-		match = FALSE;
-		if (vim_regexec(regmatch, name_buf, (colnr_T)0))
-		    match = TRUE;
-		else
-		{
-		    name_buf[0] = '<';
-		    name_buf[1] = 't';
-		    name_buf[2] = '_';
-		    name_buf[3] = str[0];
-		    name_buf[4] = str[1];
-		    name_buf[5] = '>';
-		    name_buf[6] = NUL;
-
-		    if (vim_regexec(regmatch, name_buf, (colnr_T)0))
-			match = TRUE;
-		}
-		if (match)
-		{
-		    if (loop == 0)
-			num_term++;
-		    else
-			(*file)[count++] = vim_strsave(name_buf);
-		}
-	    }
-
-	    /*
-	     * Check special key names.
-	     */
-	    regmatch->rm_ic = TRUE;		/* ignore case here */
-	    for (opt_idx = 0; (str = get_key_name(opt_idx)) != NULL; opt_idx++)
-	    {
-		name_buf[0] = '<';
-		STRCPY(name_buf + 1, str);
-		STRCAT(name_buf, ">");
-
-		if (vim_regexec(regmatch, name_buf, (colnr_T)0))
-		{
-		    if (loop == 0)
-			num_term++;
-		    else
-			(*file)[count++] = vim_strsave(name_buf);
-		}
-	    }
-	}
-	if (loop == 0)
-	{
-	    if (num_normal > 0)
-		*num_file = num_normal;
-	    else if (num_term > 0)
-		*num_file = num_term;
-	    else
-		return OK;
-	    *file = (char_u **)alloc((unsigned)(*num_file * sizeof(char_u *)));
-	    if (*file == NULL)
-	    {
-		*file = (char_u **)"";
-		return FAIL;
-	    }
-	}
-    }
-    return OK;
-}
-
-    int
-ExpandOldSetting(num_file, file)
-    int	    *num_file;
-    char_u  ***file;
-{
-    char_u  *var = NULL;	/* init for GCC */
-    char_u  *buf;
-
-    *num_file = 0;
-    *file = (char_u **)alloc((unsigned)sizeof(char_u *));
-    if (*file == NULL)
-	return FAIL;
-
-    /*
-     * For a terminal key code expand_option_idx is < 0.
-     */
-    if (expand_option_idx < 0)
-    {
-	var = find_termcode(expand_option_name + 2);
-	if (var == NULL)
-	    expand_option_idx = findoption(expand_option_name);
-    }
-
-    if (expand_option_idx >= 0)
-    {
-	/* put string of option value in NameBuff */
-	option_value2string(&options[expand_option_idx], expand_option_flags);
-	var = NameBuff;
-    }
-    else if (var == NULL)
-	var = (char_u *)"";
-
-    /* A backslash is required before some characters.  This is the reverse of
-     * what happens in do_set(). */
-    buf = vim_strsave_escaped(var, escape_chars);
-
-    if (buf == NULL)
-    {
-	vim_free(*file);
-	*file = NULL;
-	return FAIL;
-    }
-
-#ifdef BACKSLASH_IN_FILENAME
-    /* For MS-Windows et al. we don't double backslashes at the start and
-     * before a file name character. */
-    for (var = buf; *var != NUL; )
-    {
-	if (var[0] == '\\' && var[1] == '\\'
-		&& expand_option_idx >= 0
-		&& (options[expand_option_idx].flags & P_EXPAND)
-		&& vim_isfilec(var[2])
-		&& (var[2] != '\\' || (var == buf && var[4] != '\\')))
-	    mch_memmove(var, var + 1, STRLEN(var));
-#ifdef FEAT_MBYTE
-	else if (has_mbyte)
-	    var += (*mb_ptr2len_check)(var) - 1;
-#endif
-	++var;
-    }
-#endif
-
-    *file[0] = buf;
-    *num_file = 1;
-    return OK;
-}
-#endif
-
-/*
- * Get the value for the numeric or string option *opp in a nice format into
- * NameBuff[].  Must not be called with a hidden option!
- */
-    static void
-option_value2string(opp, opt_flags)
-    struct vimoption	*opp;
-    int			opt_flags;	/* OPT_GLOBAL and/or OPT_LOCAL */
-{
-    char_u	*varp;
-
-    varp = get_varp_scope(opp, opt_flags);
-
-    if (opp->flags & P_NUM)
-    {
-	long wc = 0;
-
-	if (wc_use_keyname(varp, &wc))
-	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
-	else if (wc != 0)
-	    STRCPY(NameBuff, transchar((int)wc));
-	else
-	    sprintf((char *)NameBuff, "%ld", *(long *)varp);
-    }
-    else    /* P_STRING */
-    {
-	varp = *(char_u **)(varp);
-	if (varp == NULL)		    /* just in case */
-	    NameBuff[0] = NUL;
-#ifdef FEAT_CRYPT
-	/* don't show the actual value of 'key', only that it's set */
-	if (opp->var == (char_u *)&p_key && *varp)
-	    STRCPY(NameBuff, "*****");
-#endif
-	else if (opp->flags & P_EXPAND)
-	    home_replace(NULL, varp, NameBuff, MAXPATHL, FALSE);
-	/* Translate 'pastetoggle' into special key names */
-	else if ((char_u **)opp->var == &p_pt)
-	    str2specialbuf(p_pt, NameBuff, MAXPATHL);
-	else
-	    STRNCPY(NameBuff, varp, MAXPATHL);
-    }
-}
-
-/*
- * Return TRUE if "varp" points to 'wildchar' or 'wildcharm' and it can be
- * printed as a keyname.
- * "*wcp" is set to the value of the option if it's 'wildchar' or 'wildcharm'.
- */
-    static int
-wc_use_keyname(varp, wcp)
-    char_u	*varp;
-    long	*wcp;
-{
-    if (((long *)varp == &p_wc) || ((long *)varp == &p_wcm))
-    {
-	*wcp = *(long *)varp;
-	if (IS_SPECIAL(*wcp) || find_special_key_in_table((int)*wcp) >= 0)
-	    return TRUE;
-    }
-    return FALSE;
-}
-
-#ifdef FEAT_LANGMAP
-/*
- * Any character has an equivalent character.  This is used for keyboards that
- * have a special language mode that sends characters above 128 (although
- * other characters can be translated too).
- */
-
-/*
- * char_u langmap_mapchar[256];
- * Normally maps each of the 128 upper chars to an <128 ascii char; used to
- * "translate" native lang chars in normal mode or some cases of
- * insert mode without having to tediously switch lang mode back&forth.
- */
-
-    static void
-langmap_init()
-{
-    int i;
-
-    for (i = 0; i < 256; i++)		/* we init with a-one-to one map */
-	langmap_mapchar[i] = i;
-}
-
-/*
- * Called when langmap option is set; the language map can be
- * changed at any time!
- */
-    static void
-langmap_set()
-{
-    char_u  *p;
-    char_u  *p2;
-    int	    from, to;
-
-    langmap_init();			    /* back to one-to-one map first */
-
-    for (p = p_langmap; p[0] != NUL; )
-    {
-	for (p2 = p; p2[0] != NUL && p2[0] != ',' && p2[0] != ';'; ++p2)
-	{
-	    if (p2[0] == '\\' && p2[1] != NUL)
-		++p2;
-#ifdef FEAT_MBYTE
-	    p2 += (*mb_ptr2len_check)(p2) - 1;
-#endif
-	}
-	if (p2[0] == ';')
-	    ++p2;	    /* abcd;ABCD form, p2 points to A */
-	else
-	    p2 = NULL;	    /* aAbBcCdD form, p2 is NULL */
-	while (p[0])
-	{
-	    if (p[0] == '\\' && p[1] != NUL)
-		++p;
-#ifdef FEAT_MBYTE
-	    from = (*mb_ptr2char)(p);
-#else
-	    from = p[0];
-#endif
-	    if (p2 == NULL)
-	    {
-#ifdef FEAT_MBYTE
-		p += (*mb_ptr2len_check)(p);
-#else
-		++p;
-#endif
-		if (p[0] == '\\')
-		    ++p;
-#ifdef FEAT_MBYTE
-		to = (*mb_ptr2char)(p);
-#else
-		to = p[0];
-#endif
-	    }
-	    else
-	    {
-		if (p2[0] == '\\')
-		    ++p2;
-#ifdef FEAT_MBYTE
-		to = (*mb_ptr2char)(p2);
-#else
-		to = p2[0];
-#endif
-	    }
-	    if (to == NUL)
-	    {
-		EMSG2(_("E357: 'langmap': Matching character missing for %s"),
-							     transchar(from));
-		return;
-	    }
-	    langmap_mapchar[from & 255] = to;
-
-	    /* Advance to next pair */
-#ifdef FEAT_MBYTE
-	    p += (*mb_ptr2len_check)(p);
-#else
-	    ++p;
-#endif
-	    if (p2 == NULL)
-	    {
-		if (p[0] == ',')
-		{
-		    ++p;
-		    break;
-		}
-	    }
-	    else
-	    {
-#ifdef FEAT_MBYTE
-		p2 += (*mb_ptr2len_check)(p2);
-#else
-		++p2;
-#endif
-		if (*p == ';')
-		{
-		    p = p2;
-		    if (p[0] != NUL)
-		    {
-			if (p[0] != ',')
-			{
-			    EMSG2(_("E358: 'langmap': Extra characters after semicolon: %s"), p);
-			    return;
-			}
-			++p;
-		    }
-		    break;
-		}
-	    }
-	}
-    }
-}
-#endif
-
-/*
- * Return TRUE if format option 'x' is in effect.
- * Take care of no formatting when 'paste' is set.
- */
-    int
-has_format_option(x)
-    int		x;
-{
-    if (p_paste)
-	return FALSE;
-    return (vim_strchr(curbuf->b_p_fo, x) != NULL);
-}
-
-/*
- * Return TRUE if "x" is present in 'shortmess' option, or
- * 'shortmess' contains 'a' and "x" is present in SHM_A.
- */
-    int
-shortmess(x)
-    int	    x;
-{
-    return (   vim_strchr(p_shm, x) != NULL
-	    || (vim_strchr(p_shm, 'a') != NULL
-		&& vim_strchr((char_u *)SHM_A, x) != NULL));
-}
-
-/*
- * paste_option_changed() - Called after p_paste was set or reset.
- */
-    static void
-paste_option_changed()
-{
-    static int	old_p_paste = FALSE;
-    static int	save_sm = 0;
-#ifdef FEAT_CMDL_INFO
-    static int	save_ru = 0;
-#endif
-#ifdef FEAT_RIGHTLEFT
-    static int	save_ri = 0;
-    static int	save_hkmap = 0;
-#endif
-    buf_T	*buf;
-
-    if (p_paste)
-    {
-	/*
-	 * Paste switched from off to on.
-	 * Save the current values, so they can be restored later.
-	 */
-	if (!old_p_paste)
-	{
-	    /* save options for each buffer */
-	    for (buf = firstbuf; buf != NULL; buf = buf->b_next)
-	    {
-		buf->b_p_tw_nopaste = buf->b_p_tw;
-		buf->b_p_wm_nopaste = buf->b_p_wm;
-		buf->b_p_sts_nopaste = buf->b_p_sts;
-		buf->b_p_ai_nopaste = buf->b_p_ai;
-	    }
-
-	    /* save global options */
-	    save_sm = p_sm;
-#ifdef FEAT_CMDL_INFO
-	    save_ru = p_ru;
-#endif
-#ifdef FEAT_RIGHTLEFT
-	    save_ri = p_ri;
-	    save_hkmap = p_hkmap;
-#endif
-	    /* save global values for local buffer options */
-	    p_tw_nopaste = p_tw;
-	    p_wm_nopaste = p_wm;
-	    p_sts_nopaste = p_sts;
-	    p_ai_nopaste = p_ai;
-	}
-
-	/*
-	 * Always set the option values, also when 'paste' is set when it is
-	 * already on.
-	 */
-	/* set options for each buffer */
-	for (buf = firstbuf; buf != NULL; buf = buf->b_next)
-	{
-	    buf->b_p_tw = 0;	    /* textwidth is 0 */
-	    buf->b_p_wm = 0;	    /* wrapmargin is 0 */
-	    buf->b_p_sts = 0;	    /* softtabstop is 0 */
-	    buf->b_p_ai = 0;	    /* no auto-indent */
-	}
-
-	/* set global options */
-	p_sm = 0;		    /* no showmatch */
-#ifdef FEAT_CMDL_INFO
-# ifdef FEAT_WINDOWS
-	if (p_ru)
-	    status_redraw_all();    /* redraw to remove the ruler */
-# endif
-	p_ru = 0;		    /* no ruler */
-#endif
-#ifdef FEAT_RIGHTLEFT
-	p_ri = 0;		    /* no reverse insert */
-	p_hkmap = 0;		    /* no Hebrew keyboard */
-#endif
-	/* set global values for local buffer options */
-	p_tw = 0;
-	p_wm = 0;
-	p_sts = 0;
-	p_ai = 0;
-    }
-
-    /*
-     * Paste switched from on to off: Restore saved values.
-     */
-    else if (old_p_paste)
-    {
-	/* restore options for each buffer */
-	for (buf = firstbuf; buf != NULL; buf = buf->b_next)
-	{
-	    buf->b_p_tw = buf->b_p_tw_nopaste;
-	    buf->b_p_wm = buf->b_p_wm_nopaste;
-	    buf->b_p_sts = buf->b_p_sts_nopaste;
-	    buf->b_p_ai = buf->b_p_ai_nopaste;
-	}
-
-	/* restore global options */
-	p_sm = save_sm;
-#ifdef FEAT_CMDL_INFO
-# ifdef FEAT_WINDOWS
-	if (p_ru != save_ru)
-	    status_redraw_all();    /* redraw to draw the ruler */
-# endif
-	p_ru = save_ru;
-#endif
-#ifdef FEAT_RIGHTLEFT
-	p_ri = save_ri;
-	p_hkmap = save_hkmap;
-#endif
-	/* set global values for local buffer options */
-	p_tw = p_tw_nopaste;
-	p_wm = p_wm_nopaste;
-	p_sts = p_sts_nopaste;
-	p_ai = p_ai_nopaste;
-    }
-
-    old_p_paste = p_paste;
-}
-
-/*
- * vimrc_found() - Called when a ".vimrc" or "VIMINIT" has been found.
- *
- * Reset 'compatible' and set the values for options that didn't get set yet
- * to the Vim defaults.
- * Don't do this if the 'compatible' option has been set or reset before.
- */
-    void
-vimrc_found()
-{
-    int	    opt_idx;
-
-    if (!option_was_set((char_u *)"cp"))
-    {
-	p_cp = FALSE;
-	for (opt_idx = 0; !istermoption(&options[opt_idx]); opt_idx++)
-	    if (!(options[opt_idx].flags & (P_WAS_SET|P_VI_DEF)))
-		set_option_default(opt_idx, OPT_FREE, FALSE);
-	didset_options();
-    }
-}
-
-/*
- * Set 'compatible' on or off.  Called for "-C" and "-N" command line arg.
- */
-    void
-change_compatible(on)
-    int	    on;
-{
-    if (p_cp != on)
-    {
-	p_cp = on;
-	compatible_set();
-    }
-    options[findoption((char_u *)"cp")].flags |= P_WAS_SET;
-}
-
-/*
- * Return TRUE when option "name" has been set.
- */
-    int
-option_was_set(name)
-    char_u	*name;
-{
-    int idx;
-
-    idx = findoption(name);
-    if (idx < 0)	/* unknown option */
-	return FALSE;
-    if (options[idx].flags & P_WAS_SET)
-	return TRUE;
-    return FALSE;
-}
-
-/*
- * compatible_set() - Called when 'compatible' has been set or unset.
- *
- * When 'compatible' set: Set all relevant options (those that have the P_VIM)
- * flag) to a Vi compatible value.
- * When 'compatible' is unset: Set all options that have a different default
- * for Vim (without the P_VI_DEF flag) to that default.
- */
-    static void
-compatible_set()
-{
-    int	    opt_idx;
-
-    for (opt_idx = 0; !istermoption(&options[opt_idx]); opt_idx++)
-	if (	   ((options[opt_idx].flags & P_VIM) && p_cp)
-		|| (!(options[opt_idx].flags & P_VI_DEF) && !p_cp))
-	    set_option_default(opt_idx, OPT_FREE, p_cp);
-    didset_options();
-}
-
-#ifdef FEAT_LINEBREAK
-
-# if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
-   /* Borland C++ screws up loop optimisation here (negri) */
-#  pragma option -O-l
-# endif
-
-/*
- * fill_breakat_flags() -- called when 'breakat' changes value.
- */
-    static void
-fill_breakat_flags()
-{
-    char_u	*c;
-    int		i;
-
-    for (i = 0; i < 256; i++)
-	breakat_flags[i] = FALSE;
-
-    if (p_breakat != NULL)
-	for (c = p_breakat; *c; c++)
-	    breakat_flags[*c] = TRUE;
-}
-
-# if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
-#  pragma option -O.l
-# endif
-
-#endif
-
-/*
- * Check an option that can be a range of string values.
- *
- * Return OK for correct value, FAIL otherwise.
- * Empty is always OK.
- */
-    static int
-check_opt_strings(val, values, list)
-    char_u	*val;
-    char	**values;
-    int		list;	    /* when TRUE: accept a list of values */
-{
-    return opt_strings_flags(val, values, NULL, list);
-}
-
-/*
- * Handle an option that can be a range of string values.
- * Set a flag in "*flagp" for each string present.
- *
- * Return OK for correct value, FAIL otherwise.
- * Empty is always OK.
- */
-    static int
-opt_strings_flags(val, values, flagp, list)
-    char_u	*val;		/* new value */
-    char	**values;	/* array of valid string values */
-    unsigned	*flagp;
-    int		list;		/* when TRUE: accept a list of values */
-{
-    int		i;
-    int		len;
-    unsigned	new_flags = 0;
-
-    while (*val)
-    {
-	for (i = 0; ; ++i)
-	{
-	    if (values[i] == NULL)	/* val not found in values[] */
-		return FAIL;
-
-	    len = (int)STRLEN(values[i]);
-	    if (STRNCMP(values[i], val, len) == 0
-		    && ((list && val[len] == ',') || val[len] == NUL))
-	    {
-		val += len + (val[len] == ',');
-		new_flags |= (1 << i);
-		break;		/* check next item in val list */
-	    }
-	}
-    }
-    if (flagp != NULL)
-	*flagp = new_flags;
-
-    return OK;
-}
-
-/*
- * Read the 'wildmode' option, fill wim_flags[].
- */
-    static int
-check_opt_wim()
-{
-    char_u	new_wim_flags[4];
-    char_u	*p;
-    int		i;
-    int		idx = 0;
-
-    for (i = 0; i < 4; ++i)
-	new_wim_flags[i] = 0;
-
-    for (p = p_wim; *p; ++p)
-    {
-	for (i = 0; ASCII_ISALPHA(p[i]); ++i)
-	    ;
-	if (p[i] != NUL && p[i] != ',' && p[i] != ':')
-	    return FAIL;
-	if (i == 7 && STRNCMP(p, "longest", 7) == 0)
-	    new_wim_flags[idx] |= WIM_LONGEST;
-	else if (i == 4 && STRNCMP(p, "full", 4) == 0)
-	    new_wim_flags[idx] |= WIM_FULL;
-	else if (i == 4 && STRNCMP(p, "list", 4) == 0)
-	    new_wim_flags[idx] |= WIM_LIST;
-	else
-	    return FAIL;
-	p += i;
-	if (*p == NUL)
-	    break;
-	if (*p == ',')
-	{
-	    if (idx == 3)
-		return FAIL;
-	    ++idx;
-	}
-    }
-
-    /* fill remaining entries with last flag */
-    while (idx < 3)
-    {
-	new_wim_flags[idx + 1] = new_wim_flags[idx];
-	++idx;
-    }
-
-    /* only when there are no errors, wim_flags[] is changed */
-    for (i = 0; i < 4; ++i)
-	wim_flags[i] = new_wim_flags[i];
-    return OK;
-}
-
-/*
- * Check if backspacing over something is allowed.
- */
-    int
-can_bs(what)
-    int		what;	    /* BS_INDENT, BS_EOL or BS_START */
-{
-    switch (*p_bs)
-    {
-	case '2':	return TRUE;
-	case '1':	return (what != BS_START);
-	case '0':	return FALSE;
-    }
-    return vim_strchr(p_bs, what) != NULL;
-}
-
-/*
- * Save the current values of 'fileformat' and 'fileencoding', so that we know
- * the file must be considered changed when the value is different.
- */
-    void
-save_file_ff(buf)
-    buf_T	*buf;
-{
-    buf->b_start_ffc = *buf->b_p_ff;
-    buf->b_start_eol = buf->b_p_eol;
-#ifdef FEAT_MBYTE
-    /* Only use free/alloc when necessary, they take time. */
-    if (buf->b_start_fenc == NULL
-			     || STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0)
-    {
-	vim_free(buf->b_start_fenc);
-	buf->b_start_fenc = vim_strsave(buf->b_p_fenc);
-    }
-#endif
-}
-
-/*
- * Return TRUE if 'fileformat' and/or 'fileencoding' has a different value
- * from when editing started (save_file_ff() called).
- * Also when 'endofline' was changed and 'binary' is set.
- * Don't consider a new, empty buffer to be changed.
- */
-    int
-file_ff_differs(buf)
-    buf_T	*buf;
-{
-    if ((buf->b_flags & BF_NEW)
-	    && buf->b_ml.ml_line_count == 1
-	    && *ml_get_buf(buf, (linenr_T)1, FALSE) == NUL)
-	return FALSE;
-    if (buf->b_start_ffc != *buf->b_p_ff)
-	return TRUE;
-    if (buf->b_p_bin && buf->b_start_eol != buf->b_p_eol)
-	return TRUE;
-#ifdef FEAT_MBYTE
-    if (buf->b_start_fenc == NULL)
-	return (*buf->b_p_fenc != NUL);
-    return (STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0);
-#else
-    return FALSE;
-#endif
-}
-
-/*
- * return OK if "p" is a valid fileformat name, FAIL otherwise.
- */
-    int
-check_ff_value(p)
-    char_u	*p;
-{
-    return check_opt_strings(p, p_ff_values, FALSE);
-}
diff -Nur vim63/src/os_unix.h.orig vim63-bonobo/src/os_unix.h.orig
--- vim63/src/os_unix.h.orig	2003-11-10 10:53:44.000000000 +0100
+++ vim63-bonobo/src/os_unix.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,531 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- */
-
-/*
- * NextStep has a problem with configure, undefine a few things:
- */
-#ifdef NeXT
-# ifdef HAVE_UTIME
-#  undef HAVE_UTIME
-# endif
-# ifdef HAVE_SYS_UTSNAME_H
-#  undef HAVE_SYS_UTSNAME_H
-# endif
-#endif
-
-#include <stdio.h>
-#include <ctype.h>
-
-#ifdef VAXC
-# include <types.h>
-# include <stat.h>
-#else
-# include <sys/types.h>
-# include <sys/stat.h>
-#endif
-
-#ifdef HAVE_STDLIB_H
-# include <stdlib.h>
-#endif
-
-#ifdef __EMX__
-# define HAVE_TOTAL_MEM
-#endif
-
-#if defined(__CYGWIN__) || defined(__CYGWIN32__)
-# define WIN32UNIX	/* Compiling for Win32 using Unix files. */
-# define BINARY_FILE_IO
-#endif
-
-/* On AIX 4.2 there is a conflicting prototype for ioctl() in stropts.h and
- * unistd.h.  This hack should fix that (suggested by Jeff George).
- * But on AIX 4.3 it's alright (suggested by Jake Hamby). */
-#if defined(FEAT_GUI) && defined(_AIX) && !defined(_AIX43) && !defined(_NO_PROTO)
-# define _NO_PROTO
-#endif
-
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-
-#ifdef HAVE_LIBC_H
-# include <libc.h>		    /* for NeXT */
-#endif
-
-#ifdef HAVE_SYS_PARAM_H
-# include <sys/param.h>	    /* defines BSD, if it's a BSD system */
-#endif
-
-/*
- * Sun defines FILE on SunOS 4.x.x, Solaris has a typedef for FILE
- */
-#if defined(sun) && !defined(FILE)
-# define SOLARIS
-#endif
-
-/*
- * Using getcwd() is preferred, because it checks for a buffer overflow.
- * Don't use getcwd() on systems do use system("sh -c pwd").  There is an
- * autoconf check for this.
- * Use getcwd() anyway if getwd() isn't present.
- */
-#if defined(HAVE_GETCWD) && !(defined(BAD_GETCWD) && defined(HAVE_GETWD))
-# define USE_GETCWD
-#endif
-
-#ifndef __ARGS
-    /* The AIX VisualAge cc compiler defines __EXTENDED__ instead of __STDC__
-     * because it includes pre-ansi features. */
-# if defined(__STDC__) || defined(__GNUC__) || defined(__EXTENDED__)
-#  define __ARGS(x) x
-# else
-#  define __ARGS(x) ()
-# endif
-#endif
-
-/* always use unlink() to remove files */
-#ifndef PROTO
-# ifdef VMS
-#  define mch_remove(x) delete((char *)(x))
-#  define vim_mkdir(x, y) mkdir((char *)(x), y)
-#  ifdef VAX
-#  else
-#   define mch_rmdir(x) rmdir((char *)(x))
-#  endif
-# else
-#  define vim_mkdir(x, y) mkdir((char *)(x), y)
-#  define mch_rmdir(x) rmdir((char *)(x))
-#  define mch_remove(x) unlink((char *)(x))
-# endif
-#endif
-
-/* The number of arguments to a signal handler is configured here. */
-/* It used to be a long list of almost all systems. Any system that doesn't
- * have an argument??? */
-#define SIGHASARG
-
-/* List 3 arg systems here. I guess __sgi, please test and correct me. jw. */
-#if defined(__sgi) && defined(HAVE_SIGCONTEXT)
-# define SIGHAS3ARGS
-#endif
-
-#ifdef SIGHASARG
-# ifdef SIGHAS3ARGS
-#  define SIGPROTOARG	(int, int, struct sigcontext *)
-#  define SIGDEFARG(s)	(s, sig2, scont) int s, sig2; struct sigcontext *scont;
-#  define SIGDUMMYARG	0, 0, (struct sigcontext *)0
-# else
-#  define SIGPROTOARG	(int)
-#  define SIGDEFARG(s)	(s) int s;
-#  define SIGDUMMYARG	0
-# endif
-#else
-# define SIGPROTOARG   (void)
-# define SIGDEFARG(s)  ()
-# define SIGDUMMYARG
-#endif
-
-#ifdef HAVE_DIRENT_H
-# include <dirent.h>
-# ifndef NAMLEN
-#  define NAMLEN(dirent) strlen((dirent)->d_name)
-# endif
-#else
-# define dirent direct
-# define NAMLEN(dirent) (dirent)->d_namlen
-# if HAVE_SYS_NDIR_H
-#  include <sys/ndir.h>
-# endif
-# if HAVE_SYS_DIR_H
-#  include <sys/dir.h>
-# endif
-# if HAVE_NDIR_H
-#  include <ndir.h>
-# endif
-#endif
-
-#if !defined(HAVE_SYS_TIME_H) || defined(TIME_WITH_SYS_TIME)
-# include <time.h>	    /* on some systems time.h should not be
-			       included together with sys/time.h */
-#endif
-#ifdef HAVE_SYS_TIME_H
-# include <sys/time.h>
-#endif
-
-#include <signal.h>
-
-#if defined(DIRSIZ) && !defined(MAXNAMLEN)
-# define MAXNAMLEN DIRSIZ
-#endif
-
-#if defined(UFS_MAXNAMLEN) && !defined(MAXNAMLEN)
-# define MAXNAMLEN UFS_MAXNAMLEN    /* for dynix/ptx */
-#endif
-
-#if defined(NAME_MAX) && !defined(MAXNAMLEN)
-# define MAXNAMLEN NAME_MAX	    /* for Linux before .99p3 */
-#endif
-
-/*
- * Note: if MAXNAMLEN has the wrong value, you will get error messages
- *	 for not being able to open the swap file.
- */
-#if !defined(MAXNAMLEN)
-# define MAXNAMLEN 512		    /* for all other Unix */
-#endif
-
-#define BASENAMELEN	(MAXNAMLEN - 5)
-
-#ifdef HAVE_ERRNO_H
-# include <errno.h>
-#endif
-
-#ifdef HAVE_PWD_H
-# include <pwd.h>
-#endif
-
-#ifdef __COHERENT__
-# undef __ARGS
-#endif
-
-#if (defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_GETRLIMIT)) \
-	|| (defined(HAVE_SYS_SYSINFO_H) && defined(HAVE_SYSINFO)) \
-	|| defined(HAVE_SYSCTL) || defined(HAVE_SYSCONF)
-# define HAVE_TOTAL_MEM
-#endif
-
-#ifdef VMS
-#include <unixio.h>
-#include <unixlib.h>
-#include <signal.h>
-#include <file.h>
-#include <ssdef.h>
-#include <descrip.h>
-#include <libclidef.h>
-#include <lnmdef.h>
-#include <psldef.h>
-#include <prvdef.h>
-#include <dvidef.h>
-#include <dcdef.h>
-#include <stsdef.h>
-#include <iodef.h>
-#include <ttdef.h>
-#include <tt2def.h>
-#include <jpidef.h>
-#include <rms.h>
-#include <trmdef.h>
-#include <string.h>
-#include <starlet.h>
-#include <socket.h>
-#include <lib$routines.h>
-
-typedef struct dsc$descriptor   DESC;
-#endif
-
-/*
- * Unix system-dependent file names
- */
-#ifndef SYS_VIMRC_FILE
-# define SYS_VIMRC_FILE "$VIM/vimrc"
-#endif
-#ifndef SYS_GVIMRC_FILE
-# define SYS_GVIMRC_FILE "$VIM/gvimrc"
-#endif
-#ifndef DFLT_HELPFILE
-# define DFLT_HELPFILE	"$VIMRUNTIME/doc/help.txt"
-#endif
-#ifndef FILETYPE_FILE
-# define FILETYPE_FILE	"filetype.vim"
-#endif
-#ifndef FTPLUGIN_FILE
-# define FTPLUGIN_FILE	"ftplugin.vim"
-#endif
-#ifndef INDENT_FILE
-# define INDENT_FILE	"indent.vim"
-#endif
-#ifndef FTOFF_FILE
-# define FTOFF_FILE	"ftoff.vim"
-#endif
-#ifndef FTPLUGOF_FILE
-# define FTPLUGOF_FILE	"ftplugof.vim"
-#endif
-#ifndef INDOFF_FILE
-# define INDOFF_FILE	"indoff.vim"
-#endif
-#ifndef SYS_MENU_FILE
-# define SYS_MENU_FILE	"$VIMRUNTIME/menu.vim"
-#endif
-
-#ifndef USR_EXRC_FILE
-# ifdef VMS
-#  define USR_EXRC_FILE "sys$login:.exrc"
-# else
-#  define USR_EXRC_FILE "$HOME/.exrc"
-# endif
-#endif
-
-#if !defined(USR_EXRC_FILE2) && defined(OS2)
-# define USR_EXRC_FILE2 "$VIM/.exrc"
-#endif
-#if !defined(USR_EXRC_FILE2) && defined(VMS)
-# define USR_EXRC_FILE2 "sys$login:_exrc"
-#endif
-
-#ifndef USR_VIMRC_FILE
-# ifdef VMS
-# define USR_VIMRC_FILE  "sys$login:.vimrc"
-# else
-#  define USR_VIMRC_FILE "$HOME/.vimrc"
-# endif
-#endif
-
-#if !defined(USR_VIMRC_FILE2) && defined(OS2)
-# define USR_VIMRC_FILE2 "$VIM/.vimrc"
-#endif
-#if !defined(USR_VIMRC_FILE2) && defined(VMS)
-# define USR_VIMRC_FILE2 "sys$login:_vimrc"
-#endif
-
-#ifndef USR_GVIMRC_FILE
-# ifdef VMS
-#  define USR_GVIMRC_FILE "sys$login:.gvimrc"
-# else
-#  define USR_GVIMRC_FILE "$HOME/.gvimrc"
-# endif
-#endif
-
-#ifdef VMS
-# ifndef USR_GVIMRC_FILE2
-#  define USR_GVIMRC_FILE2  "sys$login:_gvimrc"
-# endif
-#endif
-
-#ifndef EVIM_FILE
-# define EVIM_FILE	"$VIMRUNTIME/evim.vim"
-#endif
-
-#ifdef FEAT_VIMINFO
-# ifndef VIMINFO_FILE
-#  ifdef VMS
-#   define VIMINFO_FILE  "sys$login:.viminfo"
-#  else
-#   define VIMINFO_FILE "$HOME/.viminfo"
-#  endif
-# endif
-# if !defined(VIMINFO_FILE2) && defined(OS2)
-#  define VIMINFO_FILE2 "$VIM/.viminfo"
-# endif
-# if !defined(VIMINFO_FILE2) && defined(VMS)
-#  define VIMINFO_FILE2 "sys$login:_viminfo"
-# endif
-#endif
-
-#ifndef EXRC_FILE
-# define EXRC_FILE	".exrc"
-#endif
-
-#ifndef VIMRC_FILE
-# define VIMRC_FILE	".vimrc"
-#endif
-
-#ifdef FEAT_GUI
-# ifndef GVIMRC_FILE
-#  define GVIMRC_FILE	".gvimrc"
-# endif
-#endif
-
-#ifndef SYNTAX_FNAME
-# define SYNTAX_FNAME	"$VIMRUNTIME/syntax/%s.vim"
-#endif
-
-#ifndef DFLT_BDIR
-# ifdef OS2
-#  define DFLT_BDIR     ".,c:/tmp,~/tmp,~/"
-# else
-#  ifdef VMS
-#   define DFLT_BDIR    "./,sys$login:,tmp:"
-#  else
-#   define DFLT_BDIR    ".,~/tmp,~/"    /* default for 'backupdir' */
-#  endif
-# endif
-#endif
-
-#ifndef DFLT_DIR
-# ifdef OS2
-#  define DFLT_DIR      ".,~/tmp,c:/tmp,/tmp"
-# else
-#  ifdef VMS
-#   define DFLT_DIR     "./,sys$login:,tmp:"
-#  else
-#   define DFLT_DIR     ".,~/tmp,/var/tmp,/tmp" /* default for 'directory' */
-#  endif
-# endif
-#endif
-
-#ifndef DFLT_VDIR
-# ifdef OS2
-#  define DFLT_VDIR     "$VIM/vimfiles/view"
-# else
-#  ifdef VMS
-#   define DFLT_VDIR    "sys$login:vimfiles/view"
-#  else
-#   define DFLT_VDIR    "$HOME/.vim/view"       /* default for 'viewdir' */
-#  endif
-# endif
-#endif
-
-#define DFLT_ERRORFILE		"errors.err"
-
-#ifdef OS2
-# define DFLT_RUNTIMEPATH	"$HOME/vimfiles,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/vimfiles/after"
-#else
-# ifdef VMS
-#  define DFLT_RUNTIMEPATH      "sys$login:vimfiles,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,sys$login:vimfiles/after"
-# else
-#  ifdef RUNTIME_GLOBAL
-#   define DFLT_RUNTIMEPATH	"~/.vim," RUNTIME_GLOBAL ",$VIMRUNTIME," RUNTIME_GLOBAL "/after,~/.vim/after"
-#  else
-#   define DFLT_RUNTIMEPATH	"~/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,~/.vim/after"
-#  endif
-# endif
-#endif
-
-#ifdef OS2
-/*
- * Try several directories to put the temp files.
- */
-# define TEMPDIRNAMES	"$TMP", "$TEMP", "c:\\TMP", "c:\\TEMP", ""
-# define TEMPNAMELEN	128
-#else
-# ifdef VMS
-#  ifndef VAX
-#   define VMS_TEMPNAM    /* to fix default .LIS extension */
-#  endif
-#  define TEMPNAME       "TMP:v?XXXXXX.txt"
-#  define TEMPNAMELEN    28
-# else
-#  define TEMPDIRNAMES  "$TMPDIR", "/tmp", ".", "$HOME"
-#  define TEMPNAMELEN    256
-# endif
-#endif
-
-/* Special wildcards that need to be handled by the shell */
-#define SPECIAL_WILDCHAR    "`'{"
-
-#ifndef HAVE_OPENDIR
-# define NO_EXPANDPATH
-#endif
-
-/*
- * Unix has plenty of memory, use large buffers
- */
-#define CMDBUFFSIZE 1024	/* size of the command processing buffer */
-#define MAXPATHL    1024	/* Unix has long paths and plenty of memory */
-
-#define CHECK_INODE		/* used when checking if a swap file already
-				    exists for a file */
-#ifdef VMS  /* Use less memory because of older systems  */
-# ifndef DFLT_MAXMEM
-#  define DFLT_MAXMEM (2*1024)
-# endif
-# ifndef DFLT_MAXMEMTOT
-#  define DFLT_MAXMEMTOT (5*1024)
-# endif
-#else
-# ifndef DFLT_MAXMEM
-#  define DFLT_MAXMEM	(5*1024)	 /* use up to 5 Mbyte for a buffer */
-# endif
-# ifndef DFLT_MAXMEMTOT
-#  define DFLT_MAXMEMTOT	(10*1024)    /* use up to 10 Mbyte for Vim */
-# endif
-#endif
-
-/* memmove is not present on all systems, use memmove, bcopy, memcpy or our
- * own version */
-/* Some systems have (void *) arguments, some (char *). If we use (char *) it
- * works for all */
-#ifdef USEMEMMOVE
-# define mch_memmove(to, from, len) memmove((char *)(to), (char *)(from), len)
-#else
-# ifdef USEBCOPY
-#  define mch_memmove(to, from, len) bcopy((char *)(from), (char *)(to), len)
-# else
-#  ifdef USEMEMCPY
-#   define mch_memmove(to, from, len) memcpy((char *)(to), (char *)(from), len)
-#  else
-#   define VIM_MEMMOVE	    /* found in misc2.c */
-#  endif
-# endif
-#endif
-
-#ifndef PROTO
-# ifdef HAVE_RENAME
-#  define mch_rename(src, dst) rename(src, dst)
-# else
-int mch_rename __ARGS((const char *src, const char *dest));
-# endif
-# ifdef VMS
-#  define mch_chdir(s) chdir(vms_fixfilename(s))
-# else
-#  define mch_chdir(s) chdir(s)
-# endif
-# ifndef VMS
-#  ifdef __MVS__
-  /* on OS390 Unix getenv() doesn't return a pointer to persistant
-   * storage -> use __getenv() */
-#   define mch_getenv(x) (char_u *)__getenv((char *)(x))
-#  else
-#   define mch_getenv(x) (char_u *)getenv((char *)(x))
-#  endif
-#  define mch_setenv(name, val, x) setenv(name, val, x)
-# endif
-#endif
-
-#if !defined(S_ISDIR) && defined(S_IFDIR)
-# define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
-#endif
-#if !defined(S_ISREG) && defined(S_IFREG)
-# define	S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
-#endif
-#if !defined(S_ISBLK) && defined(S_IFBLK)
-# define	S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
-#endif
-#if !defined(S_ISSOCK) && defined(S_IFSOCK)
-# define	S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
-#endif
-#if !defined(S_ISFIFO) && defined(S_IFIFO)
-# define	S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
-#endif
-
-/* Note: Some systems need both string.h and strings.h (Savage).  However,
- * some systems can't handle both, only use string.h in that case. */
-#ifdef HAVE_STRING_H
-# include <string.h>
-#endif
-#if defined(HAVE_STRINGS_H) && !defined(NO_STRINGS_WITH_STRING_H)
-# include <strings.h>
-#endif
-
-#if defined(HAVE_SETJMP_H)
-# include <setjmp.h>
-# ifdef HAVE_SIGSETJMP
-#  define JMP_BUF sigjmp_buf
-#  define SETJMP(x) sigsetjmp((x), 1)
-#  define LONGJMP siglongjmp
-# else
-#  define JMP_BUF jmp_buf
-#  define SETJMP(x) setjmp(x)
-#  define LONGJMP longjmp
-# endif
-#endif
-
-#define HAVE_DUP		/* have dup() */
-#define HAVE_ST_MODE		/* have stat.st_mode */
-
-/* We have three kinds of ACL support. */
-#define HAVE_ACL (HAVE_POSIX_ACL || HAVE_SOLARIS_ACL || HAVE_AIX_ACL)
diff -Nur vim63/src/quote vim63-bonobo/src/quote
--- vim63/src/quote	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/quote	2005-09-09 20:14:02.757581048 +0200
@@ -0,0 +1,7 @@
+function! Quote()
+normal msHmt
+%g/^GtkHTML_QUOTE_ON/.,/GtkHTML_QUOTE_OFF/s/^/> /
+%g/^> GtkHTML_QUOTE_ON/d
+%g/^> GtkHTML_QUOTE_OFF/d
+normal 'tzt's
+endfunction
diff -Nur vim63/src/screen.c.orig vim63-bonobo/src/screen.c.orig
--- vim63/src/screen.c.orig	2005-09-09 20:11:10.014841000 +0200
+++ vim63-bonobo/src/screen.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,8446 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-
-/*
- * screen.c: code for displaying on the screen
- *
- * Output to the screen (console, terminal emulator or GUI window) is minimized
- * by remembering what is already on the screen, and only updating the parts
- * that changed.
- *
- * ScreenLines[off]  Contains a copy of the whole screen, as it is currently
- *		     displayed (excluding text written by external commands).
- * ScreenAttrs[off]  Contains the associated attributes.
- * LineOffset[row]   Contains the offset into ScreenLines*[] and ScreenAttrs[]
- *		     for each line.
- * LineWraps[row]    Flag for each line whether it wraps to the next line.
- *
- * For double-byte characters, two consecutive bytes in ScreenLines[] can form
- * one character which occupies two display cells.
- * For UTF-8 a multi-byte character is converted to Unicode and stored in
- * ScreenLinesUC[].  ScreenLines[] contains the first byte only.  For an ASCII
- * character without composing chars ScreenLinesUC[] will be 0.  When the
- * character occupies two display cells the next byte in ScreenLines[] is 0.
- * ScreenLinesC1[] and ScreenLinesC2[] contain up to two composing characters
- * (drawn on top of the first character).  They are 0 when not used.
- * ScreenLines2[] is only used for euc-jp to store the second byte if the
- * first byte is 0x8e (single-width character).
- *
- * The screen_*() functions write to the screen and handle updating
- * ScreenLines[].
- *
- * update_screen() is the function that updates all windows and status lines.
- * It is called form the main loop when must_redraw is non-zero.  It may be
- * called from other places when an immediated screen update is needed.
- *
- * The part of the buffer that is displayed in a window is set with:
- * - w_topline (first buffer line in window)
- * - w_topfill (filler line above the first line)
- * - w_leftcol (leftmost window cell in window),
- * - w_skipcol (skipped window cells of first line)
- *
- * Commands that only move the cursor around in a window, do not need to take
- * action to update the display.  The main loop will check if w_topline is
- * valid and update it (scroll the window) when needed.
- *
- * Commands that scroll a window change w_topline and must call
- * check_cursor() to move the cursor into the visible part of the window, and
- * call redraw_later(VALID) to have the window displayed by update_screen()
- * later.
- *
- * Commands that change text in the buffer must call changed_bytes() or
- * changed_lines() to mark the area that changed and will require updating
- * later.  The main loop will call update_screen(), which will update each
- * window that shows the changed buffer.  This assumes text above the change
- * can remain displayed as it is.  Text after the change may need updating for
- * scrolling, folding and syntax highlighting.
- *
- * Commands that change how a window is displayed (e.g., setting 'list') or
- * invalidate the contents of a window in another way (e.g., change fold
- * settings), must call redraw_later(NOT_VALID) to have the whole window
- * redisplayed by update_screen() later.
- *
- * Commands that change how a buffer is displayed (e.g., setting 'tabstop')
- * must call redraw_curbuf_later(NOT_VALID) to have all the windows for the
- * buffer redisplayed by update_screen() later.
- *
- * Commands that move the window position must call redraw_later(NOT_VALID).
- * TODO: should minimize redrawing by scrolling when possible.
- *
- * Commands that change everything (e.g., resizing the screen) must call
- * redraw_all_later(NOT_VALID) or redraw_all_later(CLEAR).
- *
- * Things that are handled indirectly:
- * - When messages scroll the screen up, msg_scrolled will be set and
- *   update_screen() called to redraw.
- */
-
-#include "vim.h"
-
-/*
- * The attributes that are actually active for writing to the screen.
- */
-static int	screen_attr = 0;
-
-/*
- * Positioning the cursor is reduced by remembering the last position.
- * Mostly used by windgoto() and screen_char().
- */
-static int	screen_cur_row, screen_cur_col;	/* last known cursor position */
-
-#ifdef FEAT_SEARCH_EXTRA
-/*
- * Struct used for highlighting 'hlsearch' matches for the last use search
- * pattern or a ":match" item.
- * For 'hlsearch' there is one pattern for all windows.  For ":match" there is
- * a different pattern for each window.
- */
-typedef struct
-{
-    regmmatch_T	rm;	/* points to the regexp program; contains last found
-			   match (may continue in next line) */
-    buf_T	*buf;	/* the buffer to search for a match */
-    linenr_T	lnum;	/* the line to search for a match */
-    int		attr;	/* attributes to be used for a match */
-    int		attr_cur; /* attributes currently active in win_line() */
-    linenr_T	first_lnum;	/* first lnum to search for multi-line pat */
-    colnr_T	startcol; /* in win_line() points to char where HL starts */
-    colnr_T	endcol;	 /* in win_line() points to char where HL ends */
-} match_T;
-
-static match_T search_hl;	/* used for 'hlsearch' highlight matching */
-static match_T match_hl;	/* used for ":match" highlight matching */
-#endif
-
-#ifdef FEAT_FOLDING
-static foldinfo_T win_foldinfo;	/* info for 'foldcolumn' */
-#endif
-
-/*
- * Buffer for one screen line (characters and attributes).
- */
-static schar_T	*current_ScreenLine;
-
-static void win_update __ARGS((win_T *wp));
-static void win_draw_end __ARGS((win_T *wp, int c1, int c2, int row, int endrow, enum hlf_value hl));
-#ifdef FEAT_FOLDING
-static void fold_line __ARGS((win_T *wp, long fold_count, foldinfo_T *foldinfo, linenr_T lnum, int row));
-static void fill_foldcolumn __ARGS((char_u *p, win_T *wp, int closed, linenr_T lnum));
-static void copy_text_attr __ARGS((int off, char_u *buf, int len, int attr));
-#endif
-static int win_line __ARGS((win_T *, linenr_T, int, int));
-static int char_needs_redraw __ARGS((int off_from, int off_to, int cols));
-#ifdef FEAT_RIGHTLEFT
-static void screen_line __ARGS((int row, int coloff, int endcol, int clear_width, int rlflag));
-# define SCREEN_LINE(r, o, e, c, rl)    screen_line((r), (o), (e), (c), (rl))
-#else
-static void screen_line __ARGS((int row, int coloff, int endcol, int clear_width));
-# define SCREEN_LINE(r, o, e, c, rl)    screen_line((r), (o), (e), (c))
-#endif
-#ifdef FEAT_RIGHTLEFT
-static void rl_mirror __ARGS((char_u *str));
-#endif
-#ifdef FEAT_VERTSPLIT
-static void draw_vsep_win __ARGS((win_T *wp, int row));
-#endif
-#ifdef FEAT_SEARCH_EXTRA
-static void start_search_hl __ARGS((void));
-static void end_search_hl __ARGS((void));
-static void prepare_search_hl __ARGS((win_T *wp, linenr_T lnum));
-static void next_search_hl __ARGS((win_T *win, match_T *shl, linenr_T lnum, colnr_T mincol));
-#endif
-static void screen_start_highlight __ARGS((int attr));
-static void screen_char __ARGS((unsigned off, int row, int col));
-#ifdef FEAT_MBYTE
-static void screen_char_2 __ARGS((unsigned off, int row, int col));
-#endif
-static void screenclear2 __ARGS((void));
-static void lineclear __ARGS((unsigned off, int width));
-static void lineinvalid __ARGS((unsigned off, int width));
-#ifdef FEAT_VERTSPLIT
-static void linecopy __ARGS((int to, int from, win_T *wp));
-static void redraw_block __ARGS((int row, int end, win_T *wp));
-#endif
-static int win_do_lines __ARGS((win_T *wp, int row, int line_count, int mayclear, int del));
-static void win_rest_invalid __ARGS((win_T *wp));
-static int screen_ins_lines __ARGS((int, int, int, int, win_T *wp));
-static void msg_pos_mode __ARGS((void));
-#if defined(FEAT_WINDOWS) || defined(FEAT_WILDMENU) || defined(FEAT_STL_OPT)
-static int fillchar_status __ARGS((int *attr, int is_curwin));
-#endif
-#ifdef FEAT_VERTSPLIT
-static int fillchar_vsep __ARGS((int *attr));
-#endif
-#ifdef FEAT_STL_OPT
-static void win_redr_custom __ARGS((win_T *wp, int Ruler));
-#endif
-#ifdef FEAT_CMDL_INFO
-static void win_redr_ruler __ARGS((win_T *wp, int always));
-#endif
-
-#if defined(FEAT_CLIPBOARD) || defined(FEAT_VERTSPLIT)
-/* Ugly global: overrule attribute used by screen_char() */
-static int screen_char_attr = 0;
-#endif
-
-/*
- * Redraw the current window later, with update_screen(type).
- * Set must_redraw only if not already set to a higher value.
- * e.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.
- */
-    void
-redraw_later(type)
-    int		type;
-{
-    redraw_win_later(curwin, type);
-}
-
-    void
-redraw_win_later(wp, type)
-    win_T	*wp;
-    int		type;
-{
-    if (wp->w_redr_type < type)
-    {
-	wp->w_redr_type = type;
-	if (type >= NOT_VALID)
-	    wp->w_lines_valid = 0;
-	if (must_redraw < type)	/* must_redraw is the maximum of all windows */
-	    must_redraw = type;
-    }
-}
-
-/*
- * Force a complete redraw later.  Also resets the highlighting.  To be used
- * after executing a shell command that messes up the screen.
- */
-    void
-redraw_later_clear()
-{
-    redraw_all_later(CLEAR);
-    screen_attr = HL_BOLD | HL_UNDERLINE;
-}
-
-/*
- * Mark all windows to be redrawn later.
- */
-    void
-redraw_all_later(type)
-    int		type;
-{
-    win_T	*wp;
-
-    FOR_ALL_WINDOWS(wp)
-    {
-	redraw_win_later(wp, type);
-    }
-}
-
-/*
- * Mark all windows that are editing the current buffer to be udpated later.
- */
-    void
-redraw_curbuf_later(type)
-    int		type;
-{
-    redraw_buf_later(curbuf, type);
-}
-
-    void
-redraw_buf_later(buf, type)
-    buf_T	*buf;
-    int		type;
-{
-    win_T	*wp;
-
-    FOR_ALL_WINDOWS(wp)
-    {
-	if (wp->w_buffer == buf)
-	    redraw_win_later(wp, type);
-    }
-}
-
-/*
- * Changed something in the current window, at buffer line "lnum", that
- * requires that line and possibly other lines to be redrawn.
- * Used when entering/leaving Insert mode with the cursor on a folded line.
- * Used to remove the "$" from a change command.
- * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot
- * may become invalid and the whole window will have to be redrawn.
- */
-/*ARGSUSED*/
-    void
-redrawWinline(lnum, invalid)
-    linenr_T	lnum;
-    int		invalid;	/* window line height is invalid now */
-{
-#ifdef FEAT_FOLDING
-    int		i;
-#endif
-
-    if (curwin->w_redraw_top == 0 || curwin->w_redraw_top > lnum)
-	curwin->w_redraw_top = lnum;
-    if (curwin->w_redraw_bot == 0 || curwin->w_redraw_bot < lnum)
-	curwin->w_redraw_bot = lnum;
-    redraw_later(VALID);
-
-#ifdef FEAT_FOLDING
-    if (invalid)
-    {
-	/* A w_lines[] entry for this lnum has become invalid. */
-	i = find_wl_entry(curwin, lnum);
-	if (i >= 0)
-	    curwin->w_lines[i].wl_valid = FALSE;
-    }
-#endif
-}
-
-/*
- * update all windows that are editing the current buffer
- */
-    void
-update_curbuf(type)
-    int		type;
-{
-    redraw_curbuf_later(type);
-    update_screen(type);
-}
-
-/*
- * update_screen()
- *
- * Based on the current value of curwin->w_topline, transfer a screenfull
- * of stuff from Filemem to ScreenLines[], and update curwin->w_botline.
- */
-    void
-update_screen(type)
-    int		type;
-{
-    win_T	*wp;
-    static int	did_intro = FALSE;
-#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)
-    int		did_one;
-#endif
-
-    if (!screen_valid(TRUE))
-	return;
-
-    if (must_redraw)
-    {
-	if (type < must_redraw)	    /* use maximal type */
-	    type = must_redraw;
-	must_redraw = 0;
-    }
-
-    /* Need to update w_lines[]. */
-    if (curwin->w_lines_valid == 0 && type < NOT_VALID)
-	type = NOT_VALID;
-
-    if (!redrawing())
-    {
-	redraw_later(type);		/* remember type for next time */
-	must_redraw = type;
-	if (type > INVERTED_ALL)
-	    curwin->w_lines_valid = 0;	/* don't use w_lines[].wl_size now */
-	return;
-    }
-
-    updating_screen = TRUE;
-#ifdef FEAT_SYN_HL
-    ++display_tick;	    /* let syntax code know we're in a next round of
-			     * display updating */
-#endif
-
-    /*
-     * if the screen was scrolled up when displaying a message, scroll it down
-     */
-    if (msg_scrolled)
-    {
-	clear_cmdline = TRUE;
-	if (msg_scrolled > Rows - 5)	    /* clearing is faster */
-	    type = CLEAR;
-	else if (type != CLEAR)
-	{
-	    check_for_delay(FALSE);
-	    if (screen_ins_lines(0, 0, msg_scrolled, (int)Rows, NULL) == FAIL)
-		type = CLEAR;
-	    FOR_ALL_WINDOWS(wp)
-	    {
-		if (W_WINROW(wp) < msg_scrolled)
-		{
-		    if (W_WINROW(wp) + wp->w_height > msg_scrolled
-			    && wp->w_redr_type < REDRAW_TOP
-			    && wp->w_lines_valid > 0
-			    && wp->w_topline == wp->w_lines[0].wl_lnum)
-		    {
-			wp->w_upd_rows = msg_scrolled - W_WINROW(wp);
-			wp->w_redr_type = REDRAW_TOP;
-		    }
-		    else
-		    {
-			wp->w_redr_type = NOT_VALID;
-#ifdef FEAT_WINDOWS
-			if (W_WINROW(wp) + wp->w_height + W_STATUS_HEIGHT(wp)
-				<= msg_scrolled)
-			    wp->w_redr_status = TRUE;
-#endif
-		    }
-		}
-	    }
-	    redraw_cmdline = TRUE;
-	}
-	msg_scrolled = 0;
-	need_wait_return = FALSE;
-    }
-
-    /* reset cmdline_row now (may have been changed temporarily) */
-    compute_cmdrow();
-
-    /* Check for changed highlighting */
-    if (need_highlight_changed)
-	highlight_changed();
-
-    if (type == CLEAR)		/* first clear screen */
-    {
-	screenclear();		/* will reset clear_cmdline */
-	type = NOT_VALID;
-    }
-
-    if (clear_cmdline)		/* going to clear cmdline (done below) */
-	check_for_delay(FALSE);
-
-    /*
-     * Only start redrawing if there is really something to do.
-     */
-    if (type == INVERTED)
-	update_curswant();
-    if (curwin->w_redr_type < type
-	    && !((type == VALID
-		    && curwin->w_lines[0].wl_valid
-#ifdef FEAT_DIFF
-		    && curwin->w_topfill == curwin->w_old_topfill
-		    && curwin->w_botfill == curwin->w_old_botfill
-#endif
-		    && curwin->w_topline == curwin->w_lines[0].wl_lnum)
-#ifdef FEAT_VISUAL
-		|| (type == INVERTED
-		    && curwin->w_old_cursor_lnum == curwin->w_cursor.lnum
-		    && curwin->w_old_visual_mode == VIsual_mode
-		    && (curwin->w_valid & VALID_VIRTCOL)
-		    && curwin->w_old_curswant == curwin->w_curswant)
-#endif
-		))
-	curwin->w_redr_type = type;
-
-#ifdef FEAT_SYN_HL
-    /*
-     * Correct stored syntax highlighting info for changes in each displayed
-     * buffer.  Each buffer must only be done once.
-     */
-    FOR_ALL_WINDOWS(wp)
-    {
-	if (wp->w_buffer->b_mod_set)
-	{
-# ifdef FEAT_WINDOWS
-	    win_T	*wwp;
-
-	    /* Check if we already did this buffer. */
-	    for (wwp = firstwin; wwp != wp; wwp = wwp->w_next)
-		if (wwp->w_buffer == wp->w_buffer)
-		    break;
-# endif
-	    if (
-# ifdef FEAT_WINDOWS
-		    wwp == wp &&
-# endif
-		    syntax_present(wp->w_buffer))
-		syn_stack_apply_changes(wp->w_buffer);
-	}
-    }
-#endif
-
-    /*
-     * Go from top to bottom through the windows, redrawing the ones that need
-     * it.
-     */
-#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)
-    did_one = FALSE;
-#endif
-#ifdef FEAT_SEARCH_EXTRA
-    search_hl.rm.regprog = NULL;
-#endif
-    FOR_ALL_WINDOWS(wp)
-    {
-	if (wp->w_redr_type != 0)
-	{
-	    cursor_off();
-#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)
-	    if (!did_one)
-	    {
-		did_one = TRUE;
-# ifdef FEAT_SEARCH_EXTRA
-		start_search_hl();
-# endif
-# ifdef FEAT_CLIPBOARD
-		/* When Visual area changed, may have to update selection. */
-		if (clip_star.available && clip_isautosel())
-		    clip_update_selection();
-# endif
-#ifdef FEAT_GUI
-		/* Remove the cursor before starting to do anything, because
-		 * scrolling may make it difficult to redraw the text under
-		 * it. */
-		if (gui.in_use)
-		    gui_undraw_cursor();
-#endif
-	    }
-#endif
-	    win_update(wp);
-	}
-
-#ifdef FEAT_WINDOWS
-	/* redraw status line after the window to minimize cursor movement */
-	if (wp->w_redr_status)
-	{
-	    cursor_off();
-	    win_redr_status(wp);
-	}
-#endif
-    }
-#if defined(FEAT_SEARCH_EXTRA)
-    end_search_hl();
-#endif
-
-#ifdef FEAT_WINDOWS
-    /* Reset b_mod_set flags.  Going through all windows is probably faster
-     * than going through all buffers (there could be many buffers). */
-    for (wp = firstwin; wp != NULL; wp = wp->w_next)
-	wp->w_buffer->b_mod_set = FALSE;
-#else
-	curbuf->b_mod_set = FALSE;
-#endif
-
-    updating_screen = FALSE;
-#ifdef FEAT_GUI
-    gui_may_resize_shell();
-#endif
-
-    /* Clear or redraw the command line.  Done last, because scrolling may
-     * mess up the command line. */
-    if (clear_cmdline || redraw_cmdline)
-	showmode();
-
-    /* May put up an introductory message when not editing a file */
-    if (!did_intro && bufempty()
-	    && curbuf->b_fname == NULL
-#ifdef FEAT_WINDOWS
-	    && firstwin->w_next == NULL
-#endif
-	    && vim_strchr(p_shm, SHM_INTRO) == NULL)
-	intro_message(FALSE);
-    did_intro = TRUE;
-
-#ifdef FEAT_GUI
-    /* Redraw the cursor and update the scrollbars when all screen updating is
-     * done. */
-    if (gui.in_use)
-    {
-	out_flush();	/* required before updating the cursor */
-	if (did_one)
-	    gui_update_cursor(FALSE, FALSE);
-	gui_update_scrollbars(FALSE);
-    }
-#endif
-}
-
-#if defined(FEAT_SIGNS) || defined(FEAT_GUI)
-static void update_prepare __ARGS((void));
-static void update_finish __ARGS((void));
-
-/*
- * Prepare for updating one or more windows.
- */
-    static void
-update_prepare()
-{
-    cursor_off();
-    updating_screen = TRUE;
-#ifdef FEAT_GUI
-    /* Remove the cursor before starting to do anything, because scrolling may
-     * make it difficult to redraw the text under it. */
-    if (gui.in_use)
-	gui_undraw_cursor();
-#endif
-#ifdef FEAT_SEARCH_EXTRA
-    start_search_hl();
-#endif
-}
-
-/*
- * Finish updating one or more windows.
- */
-    static void
-update_finish()
-{
-    if (redraw_cmdline)
-	showmode();
-
-# ifdef FEAT_SEARCH_EXTRA
-    end_search_hl();
-# endif
-
-    updating_screen = FALSE;
-
-# ifdef FEAT_GUI
-    gui_may_resize_shell();
-
-    /* Redraw the cursor and update the scrollbars when all screen updating is
-     * done. */
-    if (gui.in_use)
-    {
-	out_flush();	/* required before updating the cursor */
-	gui_update_cursor(FALSE, FALSE);
-	gui_update_scrollbars(FALSE);
-    }
-# endif
-}
-#endif
-
-#if defined(FEAT_SIGNS) || defined(PROTO)
-    void
-update_debug_sign(buf, lnum)
-    buf_T	*buf;
-    linenr_T	lnum;
-{
-    win_T	*wp;
-    int		doit = FALSE;
-
-# ifdef FEAT_FOLDING
-    win_foldinfo.fi_level = 0;
-# endif
-
-    /* update/delete a specific mark */
-    FOR_ALL_WINDOWS(wp)
-    {
-	if (buf != NULL && lnum > 0)
-	{
-	    if (wp->w_buffer == buf && lnum >= wp->w_topline
-						      && lnum < wp->w_botline)
-	    {
-		if (wp->w_redraw_top == 0 || wp->w_redraw_top > lnum)
-		    wp->w_redraw_top = lnum;
-		if (wp->w_redraw_bot == 0 || wp->w_redraw_bot < lnum)
-		    wp->w_redraw_bot = lnum;
-		redraw_win_later(wp, VALID);
-	    }
-	}
-	else
-	    redraw_win_later(wp, VALID);
-	if (wp->w_redr_type != 0)
-	    doit = TRUE;
-    }
-
-    if (!doit)
-	return;
-
-    /* update all windows that need updating */
-    update_prepare();
-
-# ifdef FEAT_WINDOWS
-    for (wp = firstwin; wp; wp = wp->w_next)
-    {
-	if (wp->w_redr_type != 0)
-	    win_update(wp);
-	if (wp->w_redr_status)
-	    win_redr_status(wp);
-    }
-# else
-    if (curwin->w_redr_type != 0)
-	win_update(curwin);
-# endif
-
-    update_finish();
-}
-#endif
-
-
-#if defined(FEAT_GUI) || defined(PROTO)
-/*
- * Update a single window, its status line and maybe the command line msg.
- * Used for the GUI scrollbar.
- */
-    void
-updateWindow(wp)
-    win_T	*wp;
-{
-    update_prepare();
-
-#ifdef FEAT_CLIPBOARD
-    /* When Visual area changed, may have to update selection. */
-    if (clip_star.available && clip_isautosel())
-	clip_update_selection();
-#endif
-    win_update(wp);
-#ifdef FEAT_WINDOWS
-    if (wp->w_redr_status
-# ifdef FEAT_CMDL_INFO
-	    || p_ru
-# endif
-# ifdef FEAT_STL_OPT
-	    || *p_stl
-# endif
-	    )
-	win_redr_status(wp);
-#endif
-
-    update_finish();
-}
-#endif
-
-/*
- * Update a single window.
- *
- * This may cause the windows below it also to be redrawn (when clearing the
- * screen or scrolling lines).
- *
- * How the window is redrawn depends on wp->w_redr_type.  Each type also
- * implies the one below it.
- * NOT_VALID	redraw the whole window
- * REDRAW_TOP	redraw the top w_upd_rows window lines, otherwise like VALID
- * INVERTED	redraw the changed part of the Visual area
- * INVERTED_ALL	redraw the whole Visual area
- * VALID	1. scroll up/down to adjust for a changed w_topline
- *		2. update lines at the top when scrolled down
- *		3. redraw changed text:
- *		   - if wp->w_buffer->b_mod_set set, udpate lines between
- *		     b_mod_top and b_mod_bot.
- *		   - if wp->w_redraw_top non-zero, redraw lines between
- *		     wp->w_redraw_top and wp->w_redr_bot.
- *		   - continue redrawing when syntax status is invalid.
- *		4. if scrolled up, update lines at the bottom.
- * This results in three areas that may need updating:
- * top:	from first row to top_end (when scrolled down)
- * mid: from mid_start to mid_end (update inversion or changed text)
- * bot: from bot_start to last row (when scrolled up)
- */
-    static void
-win_update(wp)
-    win_T	*wp;
-{
-    buf_T	*buf = wp->w_buffer;
-    int		type;
-    int		top_end = 0;	/* Below last row of the top area that needs
-				   updating.  0 when no top area updating. */
-    int		mid_start = 999;/* first row of the mid area that needs
-				   updating.  999 when no mid area updating. */
-    int		mid_end = 0;	/* Below last row of the mid area that needs
-				   updating.  0 when no mid area updating. */
-    int		bot_start = 999;/* first row of the bot area that needs
-				   updating.  999 when no bot area updating */
-#ifdef FEAT_VISUAL
-    int		scrolled_down = FALSE;	/* TRUE when scrolled down when
-					   w_topline got smaller a bit */
-#endif
-#ifdef FEAT_SEARCH_EXTRA
-    int		top_to_mod = FALSE;    /* redraw above mod_top */
-#endif
-
-    int		row;		/* current window row to display */
-    linenr_T	lnum;		/* current buffer lnum to display */
-    int		idx;		/* current index in w_lines[] */
-    int		srow;		/* starting row of the current line */
-
-    int		eof = FALSE;	/* if TRUE, we hit the end of the file */
-    int		didline = FALSE; /* if TRUE, we finished the last line */
-    int		i;
-    long	j;
-    static int	recursive = FALSE;	/* being called recursively */
-    int		old_botline = wp->w_botline;
-#ifdef FEAT_FOLDING
-    long	fold_count;
-#endif
-#ifdef FEAT_SYN_HL
-    /* remember what happened to the previous line, to know if
-     * check_visual_highlight() can be used */
-#define DID_NONE 1	/* didn't update a line */
-#define DID_LINE 2	/* updated a normal line */
-#define DID_FOLD 3	/* updated a folded line */
-    int		did_update = DID_NONE;
-    linenr_T	syntax_last_parsed = 0;		/* last parsed text line */
-#endif
-    linenr_T	mod_top = 0;
-    linenr_T	mod_bot = 0;
-#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)
-    int		save_got_int;
-#endif
-
-    type = wp->w_redr_type;
-
-    if (type == NOT_VALID)
-    {
-#ifdef FEAT_WINDOWS
-	wp->w_redr_status = TRUE;
-#endif
-	wp->w_lines_valid = 0;
-    }
-
-    /* Window is zero-height: nothing to draw. */
-    if (wp->w_height == 0)
-    {
-	wp->w_redr_type = 0;
-	return;
-    }
-
-#ifdef FEAT_VERTSPLIT
-    /* Window is zero-width: Only need to draw the separator. */
-    if (wp->w_width == 0)
-    {
-	/* draw the vertical separator right of this window */
-	draw_vsep_win(wp, 0);
-	wp->w_redr_type = 0;
-	return;
-    }
-#endif
-
-#ifdef FEAT_SEARCH_EXTRA
-    /* Setup for ":match" highlighting.  Disable any previous match */
-    match_hl.rm = wp->w_match;
-    if (wp->w_match_id == 0)
-	match_hl.attr = 0;
-    else
-	match_hl.attr = syn_id2attr(wp->w_match_id);
-    match_hl.buf = buf;
-    match_hl.lnum = 0;
-    search_hl.buf = buf;
-    search_hl.lnum = 0;
-    search_hl.first_lnum = 0;
-#endif
-
-    if (buf->b_mod_set && buf->b_mod_xlines != 0 && wp->w_redraw_top != 0)
-    {
-	/*
-	 * When there are both inserted/deleted lines and specific lines to be
-	 * redrawn, w_redraw_top and w_redraw_bot may be invalid, just redraw
-	 * everything (only happens when redrawing is off for while).
-	 */
-	type = NOT_VALID;
-    }
-    else
-    {
-	/*
-	 * Set mod_top to the first line that needs displaying because of
-	 * changes.  Set mod_bot to the first line after the changes.
-	 */
-	mod_top = wp->w_redraw_top;
-	if (wp->w_redraw_bot != 0)
-	    mod_bot = wp->w_redraw_bot + 1;
-	else
-	    mod_bot = 0;
-	wp->w_redraw_top = 0;	/* reset for next time */
-	wp->w_redraw_bot = 0;
-	if (buf->b_mod_set)
-	{
-	    if (mod_top == 0 || mod_top > buf->b_mod_top)
-	    {
-		mod_top = buf->b_mod_top;
-#ifdef FEAT_SYN_HL
-		/* Need to redraw lines above the change that may be included
-		 * in a pattern match. */
-		if (syntax_present(buf))
-		{
-		    mod_top -= buf->b_syn_sync_linebreaks;
-		    if (mod_top < 1)
-			mod_top = 1;
-		}
-#endif
-	    }
-	    if (mod_bot == 0 || mod_bot < buf->b_mod_bot)
-		mod_bot = buf->b_mod_bot;
-
-#ifdef FEAT_SEARCH_EXTRA
-	    /* When 'hlsearch' is on and using a multi-line search pattern, a
-	     * change in one line may make the Search highlighting in a
-	     * previous line invalid.  Simple solution: redraw all visible
-	     * lines above the change.
-	     * Same for a ":match" pattern.
-	     */
-	    if ((search_hl.rm.regprog != NULL
-			&& re_multiline(search_hl.rm.regprog))
-		    || (match_hl.rm.regprog != NULL
-			&& re_multiline(match_hl.rm.regprog)))
-		top_to_mod = TRUE;
-#endif
-	}
-#ifdef FEAT_FOLDING
-	if (mod_top != 0 && hasAnyFolding(wp))
-	{
-	    linenr_T	lnumt, lnumb;
-
-	    /*
-	     * A change in a line can cause lines above it to become folded or
-	     * unfolded.  Find the top most buffer line that may be affected.
-	     * If the line was previously folded and displayed, get the first
-	     * line of that fold.  If the line is folded now, get the first
-	     * folded line.  Use the minimum of these two.
-	     */
-
-	    /* Find last valid w_lines[] entry above mod_top.  Set lnumt to
-	     * the line below it.  If there is no valid entry, use w_topline.
-	     * Find the first valid w_lines[] entry below mod_bot.  Set lnumb
-	     * to this line.  If there is no valid entry, use MAXLNUM. */
-	    lnumt = wp->w_topline;
-	    lnumb = MAXLNUM;
-	    for (i = 0; i < wp->w_lines_valid; ++i)
-		if (wp->w_lines[i].wl_valid)
-		{
-		    if (wp->w_lines[i].wl_lastlnum < mod_top)
-			lnumt = wp->w_lines[i].wl_lastlnum + 1;
-		    if (lnumb == MAXLNUM && wp->w_lines[i].wl_lnum >= mod_bot)
-		    {
-			lnumb = wp->w_lines[i].wl_lnum;
-			/* When there is a fold column it might need updating
-			 * in the next line ("J" just above an open fold). */
-			if (wp->w_p_fdc > 0)
-			    ++lnumb;
-		    }
-		}
-
-	    (void)hasFoldingWin(wp, mod_top, &mod_top, NULL, TRUE, NULL);
-	    if (mod_top > lnumt)
-		mod_top = lnumt;
-
-	    /* Now do the same for the bottom line (one above mod_bot). */
-	    --mod_bot;
-	    (void)hasFoldingWin(wp, mod_bot, NULL, &mod_bot, TRUE, NULL);
-	    ++mod_bot;
-	    if (mod_bot < lnumb)
-		mod_bot = lnumb;
-	}
-#endif
-
-	/* When a change starts above w_topline and the end is below
-	 * w_topline, start redrawing at w_topline.
-	 * If the end of the change is above w_topline: do like no change was
-	 * made, but redraw the first line to find changes in syntax. */
-	if (mod_top != 0 && mod_top < wp->w_topline)
-	{
-	    if (mod_bot > wp->w_topline)
-		mod_top = wp->w_topline;
-#ifdef FEAT_SYN_HL
-	    else if (syntax_present(buf))
-		top_end = 1;
-#endif
-	}
-
-	/* When line numbers are displayed need to redraw all lines below
-	 * inserted/deleted lines. */
-	if (mod_top != 0 && buf->b_mod_xlines != 0 && wp->w_p_nu)
-	    mod_bot = MAXLNUM;
-    }
-
-    /*
-     * When only displaying the lines at the top, set top_end.  Used when
-     * window has scrolled down for msg_scrolled.
-     */
-    if (type == REDRAW_TOP)
-    {
-	j = 0;
-	for (i = 0; i < wp->w_lines_valid; ++i)
-	{
-	    j += wp->w_lines[i].wl_size;
-	    if (j >= wp->w_upd_rows)
-	    {
-		top_end = j;
-		break;
-	    }
-	}
-	if (top_end == 0)
-	    /* not found (cannot happen?): redraw everything */
-	    type = NOT_VALID;
-	else
-	    /* top area defined, the rest is VALID */
-	    type = VALID;
-    }
-
-    /*
-     * If there are no changes on the screen that require a complete redraw,
-     * handle three cases:
-     * 1: we are off the top of the screen by a few lines: scroll down
-     * 2: wp->w_topline is below wp->w_lines[0].wl_lnum: may scroll up
-     * 3: wp->w_topline is wp->w_lines[0].wl_lnum: find first entry in
-     *    w_lines[] that needs updating.
-     */
-    if ((type == VALID || type == INVERTED || type == INVERTED_ALL)
-#ifdef FEAT_DIFF
-	    && !wp->w_botfill && !wp->w_old_botfill
-#endif
-	    )
-    {
-	if (mod_top != 0 && wp->w_topline == mod_top)
-	{
-	    /*
-	     * w_topline is the first changed line, the scrolling will be done
-	     * further down.
-	     */
-	}
-	else if (wp->w_lines[0].wl_valid
-		&& (wp->w_topline < wp->w_lines[0].wl_lnum
-#ifdef FEAT_DIFF
-		    || (wp->w_topline == wp->w_lines[0].wl_lnum
-			&& wp->w_topfill > wp->w_old_topfill)
-#endif
-		   ))
-	{
-	    /*
-	     * New topline is above old topline: May scroll down.
-	     */
-#ifdef FEAT_FOLDING
-	    if (hasAnyFolding(wp))
-	    {
-		linenr_T ln;
-
-		/* count the number of lines we are off, counting a sequence
-		 * of folded lines as one */
-		j = 0;
-		for (ln = wp->w_topline; ln < wp->w_lines[0].wl_lnum; ++ln)
-		{
-		    ++j;
-		    if (j >= wp->w_height - 2)
-			break;
-		    (void)hasFoldingWin(wp, ln, NULL, &ln, TRUE, NULL);
-		}
-	    }
-	    else
-#endif
-		j = wp->w_lines[0].wl_lnum - wp->w_topline;
-	    if (j < wp->w_height - 2)		/* not too far off */
-	    {
-		i = plines_m_win(wp, wp->w_topline, wp->w_lines[0].wl_lnum - 1);
-#ifdef FEAT_DIFF
-		/* insert extra lines for previously invisible filler lines */
-		if (wp->w_lines[0].wl_lnum != wp->w_topline)
-		    i += diff_check_fill(wp, wp->w_lines[0].wl_lnum)
-							  - wp->w_old_topfill;
-#endif
-		if (i < wp->w_height - 2)	/* less than a screen off */
-		{
-		    /*
-		     * Try to insert the correct number of lines.
-		     * If not the last window, delete the lines at the bottom.
-		     * win_ins_lines may fail when the terminal can't do it.
-		     */
-		    if (i > 0)
-			check_for_delay(FALSE);
-		    if (win_ins_lines(wp, 0, i, FALSE, wp == firstwin) == OK)
-		    {
-			if (wp->w_lines_valid != 0)
-			{
-			    /* Need to update rows that are new, stop at the
-			     * first one that scrolled down. */
-			    top_end = i;
-#ifdef FEAT_VISUAL
-			    scrolled_down = TRUE;
-#endif
-
-			    /* Move the entries that were scrolled, disable
-			     * the entries for the lines to be redrawn. */
-			    if ((wp->w_lines_valid += j) > wp->w_height)
-				wp->w_lines_valid = wp->w_height;
-			    for (idx = wp->w_lines_valid; idx - j >= 0; idx--)
-				wp->w_lines[idx] = wp->w_lines[idx - j];
-			    while (idx >= 0)
-				wp->w_lines[idx--].wl_valid = FALSE;
-			}
-		    }
-		    else
-			mid_start = 0;		/* redraw all lines */
-		}
-		else
-		    mid_start = 0;		/* redraw all lines */
-	    }
-	    else
-		mid_start = 0;		/* redraw all lines */
-	}
-	else
-	{
-	    /*
-	     * New topline is at or below old topline: May scroll up.
-	     * When topline didn't change, find first entry in w_lines[] that
-	     * needs updating.
-	     */
-
-	    /* try to find wp->w_topline in wp->w_lines[].wl_lnum */
-	    j = -1;
-	    row = 0;
-	    for (i = 0; i < wp->w_lines_valid; i++)
-	    {
-		if (wp->w_lines[i].wl_valid
-			&& wp->w_lines[i].wl_lnum == wp->w_topline)
-		{
-		    j = i;
-		    break;
-		}
-		row += wp->w_lines[i].wl_size;
-	    }
-	    if (j == -1)
-	    {
-		/* if wp->w_topline is not in wp->w_lines[].wl_lnum redraw all
-		 * lines */
-		mid_start = 0;
-	    }
-	    else
-	    {
-		/*
-		 * Try to delete the correct number of lines.
-		 * wp->w_topline is at wp->w_lines[i].wl_lnum.
-		 */
-#ifdef FEAT_DIFF
-		/* If the topline didn't change, delete old filler lines,
-		 * otherwise delete filler lines of the new topline... */
-		if (wp->w_lines[0].wl_lnum == wp->w_topline)
-		    row += wp->w_old_topfill;
-		else
-		    row += diff_check_fill(wp, wp->w_topline);
-		/* ... but don't delete new filler lines. */
-		row -= wp->w_topfill;
-#endif
-		if (row > 0)
-		{
-		    check_for_delay(FALSE);
-		    if (win_del_lines(wp, 0, row, FALSE, wp == firstwin) == OK)
-			bot_start = wp->w_height - row;
-		    else
-			mid_start = 0;		/* redraw all lines */
-		}
-		if ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0)
-		{
-		    /*
-		     * Skip the lines (below the deleted lines) that are still
-		     * valid and don't need redrawing.	Copy their info
-		     * upwards, to compensate for the deleted lines.  Set
-		     * bot_start to the first row that needs redrawing.
-		     */
-		    bot_start = 0;
-		    idx = 0;
-		    for (;;)
-		    {
-			wp->w_lines[idx] = wp->w_lines[j];
-			/* stop at line that didn't fit, unless it is still
-			 * valid (no lines deleted) */
-			if (row > 0 && bot_start + row
-				 + (int)wp->w_lines[j].wl_size > wp->w_height)
-			{
-			    wp->w_lines_valid = idx + 1;
-			    break;
-			}
-			bot_start += wp->w_lines[idx++].wl_size;
-
-			/* stop at the last valid entry in w_lines[].wl_size */
-			if (++j >= wp->w_lines_valid)
-			{
-			    wp->w_lines_valid = idx;
-			    break;
-			}
-		    }
-#ifdef FEAT_DIFF
-		    /* Correct the first entry for filler lines at the top
-		     * when it won't get updated below. */
-		    if (wp->w_p_diff && bot_start > 0)
-			wp->w_lines[0].wl_size =
-			    plines_win_nofill(wp, wp->w_topline, TRUE)
-							      + wp->w_topfill;
-#endif
-		}
-	    }
-	}
-
-	/* When starting redraw in the first line, redraw all lines.  When
-	 * there is only one window it's probably faster to clear the screen
-	 * first. */
-	if (mid_start == 0)
-	{
-	    mid_end = wp->w_height;
-	    if (lastwin == firstwin)
-		screenclear();
-	}
-    }
-    else
-    {
-	/* Not VALID or INVERTED: redraw all lines. */
-	mid_start = 0;
-	mid_end = wp->w_height;
-    }
-
-#ifdef FEAT_VISUAL
-    /* check if we are updating or removing the inverted part */
-    if ((VIsual_active && buf == curwin->w_buffer)
-	    || (wp->w_old_cursor_lnum != 0 && type != NOT_VALID))
-    {
-	linenr_T    from, to;
-
-	if (VIsual_active)
-	{
-	    if (VIsual_active
-		    && (VIsual_mode != wp->w_old_visual_mode
-			|| type == INVERTED_ALL))
-	    {
-		/*
-		 * If the type of Visual selection changed, redraw the whole
-		 * selection.  Also when the ownership of the X selection is
-		 * gained or lost.
-		 */
-		if (curwin->w_cursor.lnum < VIsual.lnum)
-		{
-		    from = curwin->w_cursor.lnum;
-		    to = VIsual.lnum;
-		}
-		else
-		{
-		    from = VIsual.lnum;
-		    to = curwin->w_cursor.lnum;
-		}
-		/* redraw more when the cursor moved as well */
-		if (wp->w_old_cursor_lnum < from)
-		    from = wp->w_old_cursor_lnum;
-		if (wp->w_old_cursor_lnum > to)
-		    to = wp->w_old_cursor_lnum;
-		if (wp->w_old_visual_lnum < from)
-		    from = wp->w_old_visual_lnum;
-		if (wp->w_old_visual_lnum > to)
-		    to = wp->w_old_visual_lnum;
-	    }
-	    else
-	    {
-		/*
-		 * Find the line numbers that need to be updated: The lines
-		 * between the old cursor position and the current cursor
-		 * position.  Also check if the Visual position changed.
-		 */
-		if (curwin->w_cursor.lnum < wp->w_old_cursor_lnum)
-		{
-		    from = curwin->w_cursor.lnum;
-		    to = wp->w_old_cursor_lnum;
-		}
-		else
-		{
-		    from = wp->w_old_cursor_lnum;
-		    to = curwin->w_cursor.lnum;
-		    if (from == 0)	/* Visual mode just started */
-			from = to;
-		}
-
-		if (VIsual.lnum != wp->w_old_visual_lnum)
-		{
-		    if (wp->w_old_visual_lnum < from
-						&& wp->w_old_visual_lnum != 0)
-			from = wp->w_old_visual_lnum;
-		    if (wp->w_old_visual_lnum > to)
-			to = wp->w_old_visual_lnum;
-		    if (VIsual.lnum < from)
-			from = VIsual.lnum;
-		    if (VIsual.lnum > to)
-			to = VIsual.lnum;
-		}
-	    }
-
-	    /*
-	     * If in block mode and changed column or curwin->w_curswant:
-	     * update all lines.
-	     * First compute the actual start and end column.
-	     */
-	    if (VIsual_mode == Ctrl_V)
-	    {
-		colnr_T	fromc, toc;
-
-		getvcols(wp, &VIsual, &curwin->w_cursor, &fromc, &toc);
-		++toc;
-		if (curwin->w_curswant == MAXCOL)
-		    toc = MAXCOL;
-
-		if (fromc != wp->w_old_cursor_fcol
-			|| toc != wp->w_old_cursor_lcol)
-		{
-		    if (from > VIsual.lnum)
-			from = VIsual.lnum;
-		    if (to < VIsual.lnum)
-			to = VIsual.lnum;
-		}
-		wp->w_old_cursor_fcol = fromc;
-		wp->w_old_cursor_lcol = toc;
-	    }
-	}
-	else
-	{
-	    /* Use the line numbers of the old Visual area. */
-	    if (wp->w_old_cursor_lnum < wp->w_old_visual_lnum)
-	    {
-		from = wp->w_old_cursor_lnum;
-		to = wp->w_old_visual_lnum;
-	    }
-	    else
-	    {
-		from = wp->w_old_visual_lnum;
-		to = wp->w_old_cursor_lnum;
-	    }
-	}
-
-	/*
-	 * There is no need to update lines above the top of the window.
-	 */
-	if (from < wp->w_topline)
-	    from = wp->w_topline;
-
-	/*
-	 * If we know the value of w_botline, use it to restrict the update to
-	 * the lines that are visible in the window.
-	 */
-	if (wp->w_valid & VALID_BOTLINE)
-	{
-	    if (from >= wp->w_botline)
-		from = wp->w_botline - 1;
-	    if (to >= wp->w_botline)
-		to = wp->w_botline - 1;
-	}
-
-	/*
-	 * Find the minimal part to be updated.
-	 * Watch out for scrolling that made entries in w_lines[] invalid.
-	 * E.g., CTRL-U makes the first half of w_lines[] invalid and sets
-	 * top_end; need to redraw from top_end to the "to" line.
-	 * A middle mouse click with a Visual selection may change the text
-	 * above the Visual area and reset wl_valid, do count these for
-	 * mid_end (in srow).
-	 */
-	if (mid_start > 0)
-	{
-	    lnum = wp->w_topline;
-	    idx = 0;
-	    srow = 0;
-	    if (scrolled_down)
-		mid_start = top_end;
-	    else
-		mid_start = 0;
-	    while (lnum < from && idx < wp->w_lines_valid)	/* find start */
-	    {
-		if (wp->w_lines[idx].wl_valid)
-		    mid_start += wp->w_lines[idx].wl_size;
-		else if (!scrolled_down)
-		    srow += wp->w_lines[idx].wl_size;
-		++idx;
-# ifdef FEAT_FOLDING
-		if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid)
-		    lnum = wp->w_lines[idx].wl_lnum;
-		else
-# endif
-		    ++lnum;
-	    }
-	    srow += mid_start;
-	    mid_end = wp->w_height;
-	    for ( ; idx < wp->w_lines_valid; ++idx)		/* find end */
-	    {
-		if (wp->w_lines[idx].wl_valid
-			&& wp->w_lines[idx].wl_lnum >= to + 1)
-		{
-		    /* Only update until first row of this line */
-		    mid_end = srow;
-		    break;
-		}
-		srow += wp->w_lines[idx].wl_size;
-	    }
-	}
-    }
-
-    if (VIsual_active && buf == curwin->w_buffer)
-    {
-	wp->w_old_visual_mode = VIsual_mode;
-	wp->w_old_cursor_lnum = curwin->w_cursor.lnum;
-	wp->w_old_visual_lnum = VIsual.lnum;
-	wp->w_old_curswant = curwin->w_curswant;
-    }
-    else
-    {
-	wp->w_old_visual_mode = 0;
-	wp->w_old_cursor_lnum = 0;
-	wp->w_old_visual_lnum = 0;
-    }
-#endif /* FEAT_VISUAL */
-
-#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)
-    /* reset got_int, otherwise regexp won't work */
-    save_got_int = got_int;
-    got_int = 0;
-#endif
-#ifdef FEAT_FOLDING
-    win_foldinfo.fi_level = 0;
-#endif
-
-    /*
-     * Update all the window rows.
-     */
-    idx = 0;		/* first entry in w_lines[].wl_size */
-    row = 0;
-    srow = 0;
-    lnum = wp->w_topline;	/* first line shown in window */
-    for (;;)
-    {
-	/* stop updating when reached the end of the window (check for _past_
-	 * the end of the window is at the end of the loop) */
-	if (row == wp->w_height)
-	{
-	    didline = TRUE;
-	    break;
-	}
-
-	/* stop updating when hit the end of the file */
-	if (lnum > buf->b_ml.ml_line_count)
-	{
-	    eof = TRUE;
-	    break;
-	}
-
-	/* Remember the starting row of the line that is going to be dealt
-	 * with.  It is used further down when the line doesn't fit. */
-	srow = row;
-
-	/*
-	 * Update a line when it is in an area that needs updating, when it
-	 * has changes or w_lines[idx] is invalid.
-	 * bot_start may be halfway a wrapped line after using
-	 * win_del_lines(), check if the current line includes it.
-	 * When syntax folding is being used, the saved syntax states will
-	 * already have been updated, we can't see where the syntax state is
-	 * the same again, just update until the end of the window.
-	 */
-	if (row < top_end
-		|| (row >= mid_start && row < mid_end)
-#ifdef FEAT_SEARCH_EXTRA
-		|| top_to_mod
-#endif
-		|| idx >= wp->w_lines_valid
-		|| (row + wp->w_lines[idx].wl_size > bot_start)
-		|| (mod_top != 0
-		    && (lnum == mod_top
-			|| (lnum >= mod_top
-			    && (lnum < mod_bot
-#ifdef FEAT_SYN_HL
-				|| did_update == DID_FOLD
-				|| (did_update == DID_LINE
-				    && syntax_present(buf)
-				    && (
-# ifdef FEAT_FOLDING
-					(foldmethodIsSyntax(wp)
-						      && hasAnyFolding(wp)) ||
-# endif
-					syntax_check_changed(lnum)))
-#endif
-				)))))
-	{
-#ifdef FEAT_SEARCH_EXTRA
-	    if (lnum == mod_top)
-		top_to_mod = FALSE;
-#endif
-
-	    /*
-	     * When at start of changed lines: May scroll following lines
-	     * up or down to minimize redrawing.
-	     * Don't do this when the change continues until the end.
-	     * Don't scroll when dollar_vcol is non-zero, keep the "$".
-	     */
-	    if (lnum == mod_top
-		    && mod_bot != MAXLNUM
-		    && !(dollar_vcol != 0 && mod_bot == mod_top + 1))
-	    {
-		int		old_rows = 0;
-		int		new_rows = 0;
-		int		xtra_rows;
-		linenr_T	l;
-
-		/* Count the old number of window rows, using w_lines[], which
-		 * should still contain the sizes for the lines as they are
-		 * currently displayed. */
-		for (i = idx; i < wp->w_lines_valid; ++i)
-		{
-		    /* Only valid lines have a meaningful wl_lnum.  Invalid
-		     * lines are part of the changed area. */
-		    if (wp->w_lines[i].wl_valid
-			    && wp->w_lines[i].wl_lnum == mod_bot)
-			break;
-		    old_rows += wp->w_lines[i].wl_size;
-#ifdef FEAT_FOLDING
-		    if (wp->w_lines[i].wl_valid
-			    && wp->w_lines[i].wl_lastlnum + 1 == mod_bot)
-		    {
-			/* Must have found the last valid entry above mod_bot.
-			 * Add following invalid entries. */
-			++i;
-			while (i < wp->w_lines_valid
-						  && !wp->w_lines[i].wl_valid)
-			    old_rows += wp->w_lines[i++].wl_size;
-			break;
-		    }
-#endif
-		}
-
-		if (i >= wp->w_lines_valid)
-		{
-		    /* We can't find a valid line below the changed lines,
-		     * need to redraw until the end of the window.
-		     * Inserting/deleting lines has no use. */
-		    bot_start = 0;
-		}
-		else
-		{
-		    /* Able to count old number of rows: Count new window
-		     * rows, and may insert/delete lines */
-		    j = idx;
-		    for (l = lnum; l < mod_bot; ++l)
-		    {
-#ifdef FEAT_FOLDING
-			if (hasFoldingWin(wp, l, NULL, &l, TRUE, NULL))
-			    ++new_rows;
-			else
-#endif
-#ifdef FEAT_DIFF
-			    if (l == wp->w_topline)
-			    new_rows += plines_win_nofill(wp, l, TRUE)
-							      + wp->w_topfill;
-			else
-#endif
-			    new_rows += plines_win(wp, l, TRUE);
-			++j;
-			if (new_rows > wp->w_height - row - 2)
-			{
-			    /* it's getting too much, must redraw the rest */
-			    new_rows = 9999;
-			    break;
-			}
-		    }
-		    xtra_rows = new_rows - old_rows;
-		    if (xtra_rows < 0)
-		    {
-			/* May scroll text up.  If there is not enough
-			 * remaining text or scrolling fails, must redraw the
-			 * rest.  If scrolling works, must redraw the text
-			 * below the scrolled text. */
-			if (row - xtra_rows >= wp->w_height - 2)
-			    mod_bot = MAXLNUM;
-			else
-			{
-			    check_for_delay(FALSE);
-			    if (win_del_lines(wp, row,
-					    -xtra_rows, FALSE, FALSE) == FAIL)
-				mod_bot = MAXLNUM;
-			    else
-				bot_start = wp->w_height + xtra_rows;
-			}
-		    }
-		    else if (xtra_rows > 0)
-		    {
-			/* May scroll text down.  If there is not enough
-			 * remaining text of scrolling fails, must redraw the
-			 * rest. */
-			if (row + xtra_rows >= wp->w_height - 2)
-			    mod_bot = MAXLNUM;
-			else
-			{
-			    check_for_delay(FALSE);
-			    if (win_ins_lines(wp, row + old_rows,
-					     xtra_rows, FALSE, FALSE) == FAIL)
-				mod_bot = MAXLNUM;
-			    else if (top_end > row + old_rows)
-				/* Scrolled the part at the top that requires
-				 * updating down. */
-				top_end += xtra_rows;
-			}
-		    }
-
-		    /* When not updating the rest, may need to move w_lines[]
-		     * entries. */
-		    if (mod_bot != MAXLNUM && i != j)
-		    {
-			if (j < i)
-			{
-			    int x = row + new_rows;
-
-			    /* move entries in w_lines[] upwards */
-			    for (;;)
-			    {
-				/* stop at last valid entry in w_lines[] */
-				if (i >= wp->w_lines_valid)
-				{
-				    wp->w_lines_valid = j;
-				    break;
-				}
-				wp->w_lines[j] = wp->w_lines[i];
-				/* stop at a line that won't fit */
-				if (x + (int)wp->w_lines[j].wl_size
-							   > wp->w_height)
-				{
-				    wp->w_lines_valid = j + 1;
-				    break;
-				}
-				x += wp->w_lines[j++].wl_size;
-				++i;
-			    }
-			    if (bot_start > x)
-				bot_start = x;
-			}
-			else /* j > i */
-			{
-			    /* move entries in w_lines[] downwards */
-			    j -= i;
-			    wp->w_lines_valid += j;
-			    if (wp->w_lines_valid > wp->w_height)
-				wp->w_lines_valid = wp->w_height;
-			    for (i = wp->w_lines_valid; i - j >= idx; --i)
-				wp->w_lines[i] = wp->w_lines[i - j];
-
-			    /* The w_lines[] entries for inserted lines are
-			     * now invalid, but wl_size may be used above.
-			     * Reset to zero. */
-			    while (i >= idx)
-			    {
-				wp->w_lines[i].wl_size = 0;
-				wp->w_lines[i--].wl_valid = FALSE;
-			    }
-			}
-		    }
-		}
-	    }
-
-#ifdef FEAT_FOLDING
-	    /*
-	     * When lines are folded, display one line for all of them.
-	     * Otherwise, display normally (can be several display lines when
-	     * 'wrap' is on).
-	     */
-	    fold_count = foldedCount(wp, lnum, &win_foldinfo);
-	    if (fold_count != 0)
-	    {
-		fold_line(wp, fold_count, &win_foldinfo, lnum, row);
-		++row;
-		--fold_count;
-		wp->w_lines[idx].wl_folded = TRUE;
-		wp->w_lines[idx].wl_lastlnum = lnum + fold_count;
-# ifdef FEAT_SYN_HL
-		did_update = DID_FOLD;
-# endif
-	    }
-	    else
-#endif
-	    if (idx < wp->w_lines_valid
-		    && wp->w_lines[idx].wl_valid
-		    && wp->w_lines[idx].wl_lnum == lnum
-		    && lnum > wp->w_topline
-		    && !(dy_flags & DY_LASTLINE)
-		    && srow + wp->w_lines[idx].wl_size > wp->w_height
-#ifdef FEAT_DIFF
-		    && diff_check_fill(wp, lnum) == 0
-#endif
-		    )
-	    {
-		/* This line is not going to fit.  Don't draw anything here,
-		 * will draw "@  " lines below. */
-		row = wp->w_height + 1;
-	    }
-	    else
-	    {
-#ifdef FEAT_SEARCH_EXTRA
-		prepare_search_hl(wp, lnum);
-#endif
-#ifdef FEAT_SYN_HL
-		/* Let the syntax stuff know we skipped a few lines. */
-		if (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum
-						       && syntax_present(buf))
-		    syntax_end_parsing(syntax_last_parsed + 1);
-#endif
-
-		/*
-		 * Display one line.
-		 */
-		row = win_line(wp, lnum, srow, wp->w_height);
-
-#ifdef FEAT_FOLDING
-		wp->w_lines[idx].wl_folded = FALSE;
-		wp->w_lines[idx].wl_lastlnum = lnum;
-#endif
-#ifdef FEAT_SYN_HL
-		did_update = DID_LINE;
-		syntax_last_parsed = lnum;
-#endif
-	    }
-
-	    wp->w_lines[idx].wl_lnum = lnum;
-	    wp->w_lines[idx].wl_valid = TRUE;
-	    if (row > wp->w_height)	/* past end of screen */
-	    {
-		/* we may need the size of that too long line later on */
-		if (dollar_vcol == 0)
-		    wp->w_lines[idx].wl_size = plines_win(wp, lnum, TRUE);
-		++idx;
-		break;
-	    }
-	    if (dollar_vcol == 0)
-		wp->w_lines[idx].wl_size = row - srow;
-	    ++idx;
-#ifdef FEAT_FOLDING
-	    lnum += fold_count + 1;
-#else
-	    ++lnum;
-#endif
-	}
-	else
-	{
-	    /* This line does not need updating, advance to the next one */
-	    row += wp->w_lines[idx++].wl_size;
-	    if (row > wp->w_height)	/* past end of screen */
-		break;
-#ifdef FEAT_FOLDING
-	    lnum = wp->w_lines[idx - 1].wl_lastlnum + 1;
-#else
-	    ++lnum;
-#endif
-#ifdef FEAT_SYN_HL
-	    did_update = DID_NONE;
-#endif
-	}
-
-	if (lnum > buf->b_ml.ml_line_count)
-	{
-	    eof = TRUE;
-	    break;
-	}
-    }
-    /*
-     * End of loop over all window lines.
-     */
-
-
-    if (idx > wp->w_lines_valid)
-	wp->w_lines_valid = idx;
-
-#ifdef FEAT_SYN_HL
-    /*
-     * Let the syntax stuff know we stop parsing here.
-     */
-    if (syntax_last_parsed != 0 && syntax_present(buf))
-	syntax_end_parsing(syntax_last_parsed + 1);
-#endif
-
-    /*
-     * If we didn't hit the end of the file, and we didn't finish the last
-     * line we were working on, then the line didn't fit.
-     */
-    wp->w_empty_rows = 0;
-#ifdef FEAT_DIFF
-    wp->w_filler_rows = 0;
-#endif
-    if (!eof && !didline)
-    {
-	if (lnum == wp->w_topline)
-	{
-	    /*
-	     * Single line that does not fit!
-	     * Don't overwrite it, it can be edited.
-	     */
-	    wp->w_botline = lnum + 1;
-	}
-#ifdef FEAT_DIFF
-	else if (diff_check_fill(wp, lnum) >= wp->w_height - srow)
-	{
-	    /* Window ends in filler lines. */
-	    wp->w_botline = lnum;
-	    wp->w_filler_rows = wp->w_height - srow;
-	}
-#endif
-	else if (dy_flags & DY_LASTLINE)	/* 'display' has "lastline" */
-	{
-	    /*
-	     * Last line isn't finished: Display "@@@" at the end.
-	     */
-	    screen_fill(W_WINROW(wp) + wp->w_height - 1,
-		    W_WINROW(wp) + wp->w_height,
-		    (int)W_ENDCOL(wp) - 3, (int)W_ENDCOL(wp),
-		    '@', '@', hl_attr(HLF_AT));
-	    set_empty_rows(wp, srow);
-	    wp->w_botline = lnum;
-	}
-	else
-	{
-	    win_draw_end(wp, '@', ' ', srow, wp->w_height, HLF_AT);
-	    wp->w_botline = lnum;
-	}
-    }
-    else
-    {
-#ifdef FEAT_VERTSPLIT
-	draw_vsep_win(wp, row);
-#endif
-	if (eof)		/* we hit the end of the file */
-	{
-	    wp->w_botline = buf->b_ml.ml_line_count + 1;
-#ifdef FEAT_DIFF
-	    j = diff_check_fill(wp, wp->w_botline);
-	    if (j > 0 && !wp->w_botfill)
-	    {
-		/*
-		 * Display filler lines at the end of the file
-		 */
-		if (char2cells(fill_diff) > 1)
-		    i = '-';
-		else
-		    i = fill_diff;
-		if (row + j > wp->w_height)
-		    j = wp->w_height - row;
-		win_draw_end(wp, i, i, row, row + (int)j, HLF_DED);
-		row += j;
-	    }
-#endif
-	}
-	else if (dollar_vcol == 0)
-	    wp->w_botline = lnum;
-
-	/* make sure the rest of the screen is blank */
-	/* put '~'s on rows that aren't part of the file. */
-	win_draw_end(wp, '~', ' ', row, wp->w_height, HLF_AT);
-    }
-
-    /* Reset the type of redrawing required, the window has been updated. */
-    wp->w_redr_type = 0;
-#ifdef FEAT_DIFF
-    wp->w_old_topfill = wp->w_topfill;
-    wp->w_old_botfill = wp->w_botfill;
-#endif
-
-    if (dollar_vcol == 0)
-    {
-	/*
-	 * There is a trick with w_botline.  If we invalidate it on each
-	 * change that might modify it, this will cause a lot of expensive
-	 * calls to plines() in update_topline() each time.  Therefore the
-	 * value of w_botline is often approximated, and this value is used to
-	 * compute the value of w_topline.  If the value of w_botline was
-	 * wrong, check that the value of w_topline is correct (cursor is on
-	 * the visible part of the text).  If it's not, we need to redraw
-	 * again.  Mostly this just means scrolling up a few lines, so it
-	 * doesn't look too bad.  Only do this for the current window (where
-	 * changes are relevant).
-	 */
-	wp->w_valid |= VALID_BOTLINE;
-	if (wp == curwin && wp->w_botline != old_botline && !recursive)
-	{
-	    recursive = TRUE;
-	    curwin->w_valid &= ~VALID_TOPLINE;
-	    update_topline();	/* may invalidate w_botline again */
-	    if (must_redraw != 0)
-	    {
-		/* Don't update for changes in buffer again. */
-		i = curbuf->b_mod_set;
-		curbuf->b_mod_set = FALSE;
-		win_update(curwin);
-		must_redraw = 0;
-		curbuf->b_mod_set = i;
-	    }
-	    recursive = FALSE;
-	}
-    }
-
-#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)
-    /* restore got_int, unless CTRL-C was hit while redrawing */
-    if (!got_int)
-	got_int = save_got_int;
-#endif
-}
-
-#ifdef FEAT_SIGNS
-static int draw_signcolumn __ARGS((win_T *wp));
-
-/*
- * Return TRUE when window "wp" has a column to draw signs in.
- */
-    static int
-draw_signcolumn(wp)
-    win_T *wp;
-{
-    return (wp->w_buffer->b_signlist != NULL
-# ifdef FEAT_NETBEANS_INTG
-			    || usingNetbeans
-# endif
-		    );
-}
-#endif
-
-/*
- * Clear the rest of the window and mark the unused lines with "c1".  use "c2"
- * as the filler character.
- */
-    static void
-win_draw_end(wp, c1, c2, row, endrow, hl)
-    win_T	*wp;
-    int		c1;
-    int		c2;
-    int		row;
-    int		endrow;
-    enum hlf_value hl;
-{
-#if defined(FEAT_FOLDING) || defined(FEAT_SIGNS) || defined(FEAT_CMDWIN)
-    int		n = 0;
-# define FDC_OFF n
-#else
-# define FDC_OFF 0
-#endif
-
-#ifdef FEAT_RIGHTLEFT
-    if (wp->w_p_rl)
-    {
-	/* No check for cmdline window: should never be right-left. */
-# ifdef FEAT_FOLDING
-	n = wp->w_p_fdc;
-
-	if (n > 0)
-	{
-	    /* draw the fold column at the right */
-	    if (n > W_WIDTH(wp))
-		n = W_WIDTH(wp);
-	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
-		    W_ENDCOL(wp) - n, (int)W_ENDCOL(wp),
-		    ' ', ' ', hl_attr(HLF_FC));
-	}
-# endif
-# ifdef FEAT_SIGNS
-	if (draw_signcolumn(wp))
-	{
-	    int nn = n + 2;
-
-	    /* draw the sign column left of the fold column */
-	    if (nn > W_WIDTH(wp))
-		nn = W_WIDTH(wp);
-	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
-		    W_ENDCOL(wp) - nn, (int)W_ENDCOL(wp) - n,
-		    ' ', ' ', hl_attr(HLF_SC));
-	    n = nn;
-	}
-# endif
-	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
-		W_WINCOL(wp), W_ENDCOL(wp) - 1 - FDC_OFF,
-		c2, c2, hl_attr(hl));
-	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
-		W_ENDCOL(wp) - 1 - FDC_OFF, W_ENDCOL(wp) - FDC_OFF,
-		c1, c2, hl_attr(hl));
-    }
-    else
-#endif
-    {
-#ifdef FEAT_CMDWIN
-	if (cmdwin_type != 0 && wp == curwin)
-	{
-	    /* draw the cmdline character in the leftmost column */
-	    n = 1;
-	    if (n > wp->w_width)
-		n = wp->w_width;
-	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
-		    W_WINCOL(wp), (int)W_WINCOL(wp) + n,
-		    cmdwin_type, ' ', hl_attr(HLF_AT));
-	}
-#endif
-#ifdef FEAT_FOLDING
-	if (wp->w_p_fdc > 0)
-	{
-	    int	    nn = n + wp->w_p_fdc;
-
-	    /* draw the fold column at the left */
-	    if (nn > W_WIDTH(wp))
-		nn = W_WIDTH(wp);
-	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
-		    W_WINCOL(wp) + n, (int)W_WINCOL(wp) + nn,
-		    ' ', ' ', hl_attr(HLF_FC));
-	    n = nn;
-	}
-#endif
-#ifdef FEAT_SIGNS
-	if (draw_signcolumn(wp))
-	{
-	    int	    nn = n + 2;
-
-	    /* draw the sign column after the fold column */
-	    if (nn > W_WIDTH(wp))
-		nn = W_WIDTH(wp);
-	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
-		    W_WINCOL(wp) + n, (int)W_WINCOL(wp) + nn,
-		    ' ', ' ', hl_attr(HLF_SC));
-	    n = nn;
-	}
-#endif
-	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
-		W_WINCOL(wp) + FDC_OFF, (int)W_ENDCOL(wp),
-		c1, c2, hl_attr(hl));
-    }
-    set_empty_rows(wp, row);
-}
-
-#ifdef FEAT_FOLDING
-/*
- * Display one folded line.
- */
-    static void
-fold_line(wp, fold_count, foldinfo, lnum, row)
-    win_T	*wp;
-    long	fold_count;
-    foldinfo_T	*foldinfo;
-    linenr_T	lnum;
-    int		row;
-{
-    char_u	buf[51];
-    pos_T	*top, *bot;
-    linenr_T	lnume = lnum + fold_count - 1;
-    int		len;
-    char_u	*p;
-    char_u	*text = NULL;
-    int		fdc;
-    int		level;
-    int		col;
-    int		txtcol;
-    int		off = (int)(current_ScreenLine - ScreenLines);
-
-    /* Build the fold line:
-     * 1. Add the cmdwin_type for the command-line window
-     * 2. Add the 'foldcolumn'
-     * 3. Add the 'number' column
-     * 4. Compose the text
-     * 5. Add the text
-     * 6. set highlighting for the Visual area an other text
-     */
-    col = 0;
-
-    /*
-     * 1. Add the cmdwin_type for the command-line window
-     * Ignores 'rightleft', this window is never right-left.
-     */
-#ifdef FEAT_CMDWIN
-    if (cmdwin_type != 0 && wp == curwin)
-    {
-	ScreenLines[off] = cmdwin_type;
-	ScreenAttrs[off] = hl_attr(HLF_AT);
-#ifdef FEAT_MBYTE
-	if (enc_utf8)
-	    ScreenLinesUC[off] = 0;
-#endif
-	++col;
-    }
-#endif
-
-    /*
-     * 2. Add the 'foldcolumn'
-     */
-    fdc = wp->w_p_fdc;
-    if (fdc > W_WIDTH(wp) - col)
-	fdc = W_WIDTH(wp) - col;
-    if (fdc > 0)
-    {
-	fill_foldcolumn(buf, wp, TRUE, lnum);
-#ifdef FEAT_RIGHTLEFT
-	if (wp->w_p_rl)
-	{
-	    int		i;
-
-	    copy_text_attr(off + W_WIDTH(wp) - fdc - col, buf, fdc,
-							     hl_attr(HLF_FC));
-	    /* reverse the fold column */
-	    for (i = 0; i < fdc; ++i)
-		ScreenLines[off + W_WIDTH(wp) - i - 1 - col] = buf[i];
-	}
-	else
-#endif
-	    copy_text_attr(off + col, buf, fdc, hl_attr(HLF_FC));
-	col += fdc;
-    }
-
-#ifdef FEAT_RIGHTLEFT
-# define RL_MEMSET(p, v, l) vim_memset(ScreenAttrs + off + (wp->w_p_rl ? (W_WIDTH(wp) - (p) - (l)) : (p)), v, l)
-#else
-# define RL_MEMSET(p, v, l) vim_memset(ScreenAttrs + off + p, v, l)
-#endif
-
-    /* Set all attributes of the 'number' column and the text */
-    RL_MEMSET(col, hl_attr(HLF_FL), (size_t)(W_WIDTH(wp) - col));
-
-#ifdef FEAT_SIGNS
-    /* If signs are being displayed, add two spaces. */
-    if (draw_signcolumn(wp))
-    {
-	len = W_WIDTH(wp) - col;
-	if (len > 0)
-	{
-	    if (len > 2)
-		len = 2;
-# ifdef FEAT_RIGHTLEFT
-	    if (wp->w_p_rl)
-		/* the line number isn't reversed */
-		copy_text_attr(off + W_WIDTH(wp) - len - col,
-					(char_u *)"  ", len, hl_attr(HLF_FL));
-	    else
-# endif
-		copy_text_attr(off + col, (char_u *)"  ", len, hl_attr(HLF_FL));
-	    col += len;
-	}
-    }
-#endif
-
-    /*
-     * 3. Add the 'number' column
-     */
-    if (wp->w_p_nu)
-    {
-	len = W_WIDTH(wp) - col;
-	if (len > 0)
-	{
-	    if (len > 8)
-		len = 8;
-	    sprintf((char *)buf, "%7ld ", (long)lnum);
-#ifdef FEAT_RIGHTLEFT
-	    if (wp->w_p_rl)
-		/* the line number isn't reversed */
-		copy_text_attr(off + W_WIDTH(wp) - len - col, buf, len,
-							     hl_attr(HLF_FL));
-	    else
-#endif
-		copy_text_attr(off + col, buf, len, hl_attr(HLF_FL));
-	    col += len;
-	}
-    }
-
-    /*
-     * 4. Compose the folded-line string with 'foldtext', if set.
-     */
-#ifdef FEAT_EVAL
-    if (*wp->w_p_fdt != NUL)
-    {
-	char_u	dashes[51];
-	win_T	*save_curwin;
-
-	/* Set "v:foldstart" and "v:foldend". */
-	set_vim_var_nr(VV_FOLDSTART, lnum);
-	set_vim_var_nr(VV_FOLDEND, lnume);
-
-	/* Set "v:folddashes" to a string of "level" dashes. */
-	/* Set "v:foldlevel" to "level". */
-	level = foldinfo->fi_level;
-	if (level > 50)
-	    level = 50;
-	vim_memset(dashes, '-', (size_t)level);
-	dashes[level] = NUL;
-	set_vim_var_string(VV_FOLDDASHES, dashes, -1);
-	set_vim_var_nr(VV_FOLDLEVEL, (long)level);
-	save_curwin = curwin;
-	curwin = wp;
-	curbuf = wp->w_buffer;
-
-	++emsg_off;
-	text = eval_to_string_safe(wp->w_p_fdt, NULL);
-	--emsg_off;
-
-	curwin = save_curwin;
-	curbuf = curwin->w_buffer;
-	set_vim_var_string(VV_FOLDDASHES, NULL, -1);
-
-	if (text != NULL)
-	{
-	    /* Replace unprintable characters, if there are any.  But
-	     * replace a TAB with a space. */
-	    for (p = text; *p != NUL; ++p)
-	    {
-#ifdef FEAT_MBYTE
-		if (has_mbyte && (len = (*mb_ptr2len_check)(p)) > 1)
-		{
-		    if (!vim_isprintc((*mb_ptr2char)(p)))
-			break;
-		    p += len - 1;
-		}
-		else
-#endif
-		    if (*p == TAB)
-			*p = ' ';
-		    else if (ptr2cells(p) > 1)
-			break;
-	    }
-	    if (*p != NUL)
-	    {
-		p = transstr(text);
-		vim_free(text);
-		text = p;
-	    }
-	}
-    }
-    if (text == NULL)
-#endif
-    {
-	sprintf((char *)buf, _("+--%3ld lines folded "), fold_count);
-	text = buf;
-    }
-
-    txtcol = col;	/* remember where text starts */
-
-    /*
-     * 5. move the text to current_ScreenLine.  Fill up with "fill_fold".
-     *    Right-left text is put in columns 0 - number-col, normal text is put
-     *    in columns number-col - window-width.
-     */
-#ifdef FEAT_MBYTE
-    if (has_mbyte)
-    {
-	int	cells;
-	int	u8c, u8c_c1, u8c_c2;
-	int	idx;
-	int	c_len;
-# ifdef FEAT_ARABIC
-	int	prev_c = 0;		/* previous Arabic character */
-	int	prev_c1 = 0;		/* first composing char for prev_c */
-# endif
-
-# ifdef FEAT_RIGHTLEFT
-	if (wp->w_p_rl)
-	    idx = off;
-	else
-# endif
-	    idx = off + col;
-
-	/* Store multibyte characters in ScreenLines[] et al. correctly. */
-	for (p = text; *p != NUL; )
-	{
-	    cells = (*mb_ptr2cells)(p);
-	    c_len = (*mb_ptr2len_check)(p);
-	    if (col + cells > W_WIDTH(wp)
-# ifdef FEAT_RIGHTLEFT
-		    - (wp->w_p_rl ? col : 0)
-# endif
-		    )
-		break;
-	    ScreenLines[idx] = *p;
-	    if (enc_utf8)
-	    {
-		u8c = utfc_ptr2char(p, &u8c_c1, &u8c_c2);
-		if (*p < 0x80 && u8c_c1 == 0 && u8c_c2 == 0)
-		{
-		    ScreenLinesUC[idx] = 0;
-#ifdef FEAT_ARABIC
-		    prev_c = u8c;
-#endif
-		}
-		else
-		{
-#ifdef FEAT_ARABIC
-		    if (p_arshape && !p_tbidi && ARABIC_CHAR(u8c))
-		    {
-			/* Do Arabic shaping. */
-			int	pc, pc1, nc, dummy;
-			int	firstbyte = *p;
-
-			/* The idea of what is the previous and next
-			 * character depends on 'rightleft'. */
-			if (wp->w_p_rl)
-			{
-			    pc = prev_c;
-			    pc1 = prev_c1;
-			    nc = utf_ptr2char(p + c_len);
-			    prev_c1 = u8c_c1;
-			}
-			else
-			{
-			    pc = utfc_ptr2char(p + c_len, &pc1, &dummy);
-			    nc = prev_c;
-			}
-			prev_c = u8c;
-
-			u8c = arabic_shape(u8c, &firstbyte, &u8c_c1,
-								 pc, pc1, nc);
-			ScreenLines[idx] = firstbyte;
-		    }
-		    else
-			prev_c = u8c;
-#endif
-		    /* Non-BMP character: display as ? or fullwidth ?. */
-		    if (u8c >= 0x10000)
-			ScreenLinesUC[idx] = (cells == 2) ? 0xff1f : (int)'?';
-		    else
-			ScreenLinesUC[idx] = u8c;
-		    ScreenLinesC1[idx] = u8c_c1;
-		    ScreenLinesC2[idx] = u8c_c2;
-		}
-		if (cells > 1)
-		    ScreenLines[idx + 1] = 0;
-	    }
-	    else if (cells > 1)	    /* double-byte character */
-	    {
-		if (enc_dbcs == DBCS_JPNU && *p == 0x8e)
-		    ScreenLines2[idx] = p[1];
-		else
-		    ScreenLines[idx + 1] = p[1];
-	    }
-	    col += cells;
-	    idx += cells;
-	    p += c_len;
-	}
-    }
-    else
-#endif
-    {
-	len = (int)STRLEN(text);
-	if (len > W_WIDTH(wp) - col)
-	    len = W_WIDTH(wp) - col;
-	if (len > 0)
-	{
-#ifdef FEAT_RIGHTLEFT
-	    if (wp->w_p_rl)
-		STRNCPY(current_ScreenLine, text, len);
-	    else
-#endif
-		STRNCPY(current_ScreenLine + col, text, len);
-	    col += len;
-	}
-    }
-
-    /* Fill the rest of the line with the fold filler */
-#ifdef FEAT_RIGHTLEFT
-    if (wp->w_p_rl)
-	col -= txtcol;
-#endif
-    while (col < W_WIDTH(wp)
-#ifdef FEAT_RIGHTLEFT
-		    - (wp->w_p_rl ? txtcol : 0)
-#endif
-	    )
-    {
-#ifdef FEAT_MBYTE
-	if (enc_utf8)
-	{
-	    if (fill_fold >= 0x80)
-	    {
-		ScreenLinesUC[off + col] = fill_fold;
-		ScreenLinesC1[off + col] = 0;
-		ScreenLinesC2[off + col] = 0;
-	    }
-	    else
-		ScreenLinesUC[off + col] = 0;
-	}
-#endif
-	ScreenLines[off + col++] = fill_fold;
-    }
-
-    if (text != buf)
-	vim_free(text);
-
-    /*
-     * 6. set highlighting for the Visual area an other text.
-     * If all folded lines are in the Visual area, highlight the line.
-     */
-#ifdef FEAT_VISUAL
-    if (VIsual_active && wp->w_buffer == curwin->w_buffer)
-    {
-	if (ltoreq(curwin->w_cursor, VIsual))
-	{
-	    /* Visual is after curwin->w_cursor */
-	    top = &curwin->w_cursor;
-	    bot = &VIsual;
-	}
-	else
-	{
-	    /* Visual is before curwin->w_cursor */
-	    top = &VIsual;
-	    bot = &curwin->w_cursor;
-	}
-	if (lnum >= top->lnum
-		&& lnume <= bot->lnum
-		&& (VIsual_mode != 'v'
-		    || ((lnum > top->lnum
-			    || (lnum == top->lnum
-				&& top->col == 0))
-			&& (lnume < bot->lnum
-			    || (lnume == bot->lnum
-				&& (bot->col - (*p_sel == 'e'))
-		>= STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
-	{
-	    if (VIsual_mode == Ctrl_V)
-	    {
-		/* Visual block mode: highlight the chars part of the block */
-		if (wp->w_old_cursor_fcol + txtcol < (colnr_T)W_WIDTH(wp))
-		{
-		    if (wp->w_old_cursor_lcol + txtcol < (colnr_T)W_WIDTH(wp))
-			len = wp->w_old_cursor_lcol;
-		    else
-			len = W_WIDTH(wp) - txtcol;
-		    RL_MEMSET(wp->w_old_cursor_fcol + txtcol, hl_attr(HLF_V),
-				       (size_t)(len - wp->w_old_cursor_fcol));
-		}
-	    }
-	    else
-		/* Set all attributes of the text */
-		RL_MEMSET(txtcol, hl_attr(HLF_V),
-					      (size_t)(W_WIDTH(wp) - txtcol));
-	}
-    }
-#endif
-
-
-    SCREEN_LINE(row + W_WINROW(wp), W_WINCOL(wp), (int)W_WIDTH(wp),
-						     (int)W_WIDTH(wp), FALSE);
-
-    /*
-     * Update w_cline_height and w_cline_folded if the cursor line was
-     * updated (saves a call to plines() later).
-     */
-    if (wp == curwin
-	    && lnum <= curwin->w_cursor.lnum
-	    && lnume >= curwin->w_cursor.lnum)
-    {
-	curwin->w_cline_row = row;
-	curwin->w_cline_height = 1;
-	curwin->w_cline_folded = TRUE;
-	curwin->w_valid |= (VALID_CHEIGHT|VALID_CROW);
-    }
-}
-
-/*
- * Copy "buf[len]" to ScreenLines["off"] and set attributes to "attr".
- */
-    static void
-copy_text_attr(off, buf, len, attr)
-    int		off;
-    char_u	*buf;
-    int		len;
-    int		attr;
-{
-    mch_memmove(ScreenLines + off, buf, (size_t)len);
-# ifdef FEAT_MBYTE
-    if (enc_utf8)
-	vim_memset(ScreenLinesUC + off, 0, sizeof(u8char_T) * (size_t)len);
-# endif
-    vim_memset(ScreenAttrs + off, attr, (size_t)len);
-}
-
-/*
- * Fill the foldcolumn at "p" for window "wp".
- */
-    static void
-fill_foldcolumn(p, wp, closed, lnum)
-    char_u	*p;
-    win_T	*wp;
-    int		closed;		/* TRUE of FALSE */
-    linenr_T	lnum;		/* current line number */
-{
-    int		i = 0;
-    int		level;
-    int		first_level;
-
-    /* Init to all spaces. */
-    copy_spaces(p, (size_t)wp->w_p_fdc);
-
-    level = win_foldinfo.fi_level;
-    if (level > 0)
-    {
-	/* If the column is too narrow, we start at the lowest level that
-	 * fits and use numbers to indicated the depth. */
-	first_level = level - wp->w_p_fdc - closed + 2;
-	if (first_level < 1)
-	    first_level = 1;
-
-	for (i = 0; i + 1 < wp->w_p_fdc; ++i)
-	{
-	    if (win_foldinfo.fi_lnum == lnum
-			      && first_level + i >= win_foldinfo.fi_low_level)
-		p[i] = '-';
-	    else if (first_level == 1)
-		p[i] = '|';
-	    else if (first_level + i <= 9)
-		p[i] = '0' + first_level + i;
-	    else
-		p[i] = '>';
-	    if (first_level + i == level)
-		break;
-	}
-    }
-    if (closed)
-	p[i] = '+';
-}
-#endif /* FEAT_FOLDING */
-
-/*
- * Display line "lnum" of window 'wp' on the screen.
- * Start at row "startrow", stop when "endrow" is reached.
- * wp->w_virtcol needs to be valid.
- *
- * Return the number of last row the line occupies.
- */
-    static int
-win_line(wp, lnum, startrow, endrow)
-    win_T	*wp;
-    linenr_T	lnum;
-    int		startrow;
-    int		endrow;
-{
-    int		col;			/* visual column on screen */
-    unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
-    int		c = 0;			/* init for GCC */
-    long	vcol = 0;		/* virtual column (for tabs) */
-    long	vcol_prev = -1;		/* "vcol" of previous character */
-    char_u	*line;			/* current line */
-    char_u	*ptr;			/* current position in "line" */
-    int		row;			/* row in the window, excl w_winrow */
-    int		screen_row;		/* row on the screen, incl w_winrow */
-
-    char_u	extra[18];		/* "%ld" and 'fdc' must fit in here */
-    int		n_extra = 0;		/* number of extra chars */
-    char_u	*p_extra = NULL;	/* string of extra chars */
-    int		c_extra = NUL;		/* extra chars, all the same */
-    int		extra_attr = 0;		/* attributes when n_extra != 0 */
-    static char_u *at_end_str = (char_u *)""; /* used for p_extra when
-					   displaying lcs_eol at end-of-line */
-    int		lcs_eol_one = lcs_eol;	/* lcs_eol until it's been used */
-    int		lcs_prec_todo = lcs_prec;   /* lcs_prec until it's been used */
-
-    /* saved "extra" items for when draw_state becomes WL_LINE (again) */
-    int		saved_n_extra = 0;
-    char_u	*saved_p_extra = NULL;
-    int		saved_c_extra = 0;
-    int		saved_char_attr = 0;
-
-    int		n_attr = 0;		/* chars with special attr */
-    int		saved_attr2 = 0;	/* char_attr saved for n_attr */
-    int		n_attr3 = 0;		/* chars with overruling special attr */
-    int		saved_attr3 = 0;	/* char_attr saved for n_attr3 */
-
-    int		n_skip = 0;		/* nr of chars to skip for 'nowrap' */
-
-    int		fromcol, tocol;		/* start/end of inverting */
-    int		fromcol_prev = -2;	/* start of inverting after cursor */
-    int		noinvcur = FALSE;	/* don't invert the cursor */
-#ifdef FEAT_VISUAL
-    pos_T	*top, *bot;
-#endif
-    pos_T	pos;
-    long	v;
-
-    int		char_attr = 0;		/* attributes for next character */
-    int		area_highlighting = FALSE; /* Visual or incsearch highlighting
-					      in this line */
-    int		attr = 0;		/* attributes for area highlighting */
-    int		area_attr = 0;		/* attributes desired by highlighting */
-    int		search_attr = 0;	/* attributes desired by 'hlsearch' */
-#ifdef FEAT_SYN_HL
-    int		syntax_attr = 0;	/* attributes desired by syntax */
-    int		has_syntax = FALSE;	/* this buffer has syntax highl. */
-    int		save_did_emsg;
-#endif
-    int		extra_check;		/* has syntax or linebreak */
-#ifdef FEAT_MBYTE
-    int		multi_attr = 0;		/* attributes desired by multibyte */
-    int		mb_l = 1;		/* multi-byte byte length */
-    int		mb_c = 0;		/* decoded multi-byte character */
-    int		mb_utf8 = FALSE;	/* screen char is UTF-8 char */
-    int		u8c_c1 = 0;		/* first composing UTF-8 char */
-    int		u8c_c2 = 0;		/* second composing UTF-8 char */
-#endif
-#ifdef FEAT_DIFF
-    int		filler_lines;		/* nr of filler lines to be drawn */
-    int		filler_todo;		/* nr of filler lines still to do + 1 */
-    enum hlf_value diff_hlf = (enum hlf_value)0; /* type of diff highlighting */
-    int		change_start = MAXCOL;	/* first col of changed area */
-    int		change_end = -1;	/* last col of changed area */
-#endif
-    colnr_T	trailcol = MAXCOL;	/* start of trailing spaces */
-#ifdef FEAT_LINEBREAK
-    int		need_showbreak = FALSE;
-#endif
-#if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS))
-# define LINE_ATTR
-    int		line_attr = 0;		/* atrribute for the whole line */
-#endif
-#ifdef FEAT_SEARCH_EXTRA
-    match_T	*shl;			/* points to search_hl or match_hl */
-#endif
-#ifdef FEAT_ARABIC
-    int		prev_c = 0;		/* previous Arabic character */
-    int		prev_c1 = 0;		/* first composing char for prev_c */
-#endif
-
-    /* draw_state: items that are drawn in sequence: */
-#define WL_START	0		/* nothing done yet */
-#ifdef FEAT_CMDWIN
-# define WL_CMDLINE	WL_START + 1	/* cmdline window column */
-#else
-# define WL_CMDLINE	WL_START
-#endif
-#ifdef FEAT_FOLDING
-# define WL_FOLD	WL_CMDLINE + 1	/* 'foldcolumn' */
-#else
-# define WL_FOLD	WL_CMDLINE
-#endif
-#ifdef FEAT_SIGNS
-# define WL_SIGN	WL_FOLD + 1	/* column for signs */
-#else
-# define WL_SIGN	WL_FOLD		/* column for signs */
-#endif
-#define WL_NR		WL_SIGN + 1	/* line number */
-#if defined(FEAT_LINEBREAK) || defined(FEAT_DIFF)
-# define WL_SBR		WL_NR + 1	/* 'showbreak' or 'diff' */
-#else
-# define WL_SBR		WL_NR
-#endif
-#define WL_LINE		WL_SBR + 1	/* text in the line */
-    int		draw_state = WL_START;	/* what to draw next */
-#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
-    int		feedback_col = 0;
-    int		feedback_old_attr = -1;
-#endif
-
-
-    if (startrow > endrow)		/* past the end already! */
-	return startrow;
-
-    row = startrow;
-    screen_row = row + W_WINROW(wp);
-
-    /*
-     * To speed up the loop below, set extra_check when there is linebreak,
-     * trailing white space and/or syntax processing to be done.
-     */
-#ifdef FEAT_LINEBREAK
-    extra_check = wp->w_p_lbr;
-#else
-    extra_check = 0;
-#endif
-#ifdef FEAT_SYN_HL
-    if (syntax_present(wp->w_buffer))
-    {
-	/* Prepare for syntax highlighting in this line.  When there is an
-	 * error, stop syntax highlighting. */
-	save_did_emsg = did_emsg;
-	did_emsg = FALSE;
-	syntax_start(wp, lnum);
-	if (did_emsg)
-	    syntax_clear(wp->w_buffer);
-	else
-	{
-	    did_emsg = save_did_emsg;
-	    has_syntax = TRUE;
-	    extra_check = TRUE;
-	}
-    }
-#endif
-
-    /*
-     * handle visual active in this window
-     */
-    fromcol = -10;
-    tocol = MAXCOL;
-#ifdef FEAT_VISUAL
-    if (VIsual_active && wp->w_buffer == curwin->w_buffer)
-    {
-					/* Visual is after curwin->w_cursor */
-	if (ltoreq(curwin->w_cursor, VIsual))
-	{
-	    top = &curwin->w_cursor;
-	    bot = &VIsual;
-	}
-	else				/* Visual is before curwin->w_cursor */
-	{
-	    top = &VIsual;
-	    bot = &curwin->w_cursor;
-	}
-	if (VIsual_mode == Ctrl_V)	/* block mode */
-	{
-	    if (lnum >= top->lnum && lnum <= bot->lnum)
-	    {
-		fromcol = wp->w_old_cursor_fcol;
-		tocol = wp->w_old_cursor_lcol;
-	    }
-	}
-	else				/* non-block mode */
-	{
-	    if (lnum > top->lnum && lnum <= bot->lnum)
-		fromcol = 0;
-	    else if (lnum == top->lnum)
-	    {
-		if (VIsual_mode == 'V')	/* linewise */
-		    fromcol = 0;
-		else
-		{
-		    getvvcol(wp, top, (colnr_T *)&fromcol, NULL, NULL);
-		    if (gchar_pos(top) == NUL)
-			tocol = fromcol + 1;
-		}
-	    }
-	    if (VIsual_mode != 'V' && lnum == bot->lnum)
-	    {
-		if (*p_sel == 'e' && bot->col == 0
-#ifdef FEAT_VIRTUALEDIT
-			&& bot->coladd == 0
-#endif
-		   )
-		{
-		    fromcol = -10;
-		    tocol = MAXCOL;
-		}
-		else
-		{
-		    pos = *bot;
-		    if (*p_sel == 'e')
-			getvvcol(wp, &pos, (colnr_T *)&tocol, NULL, NULL);
-		    else
-		    {
-			getvvcol(wp, &pos, NULL, NULL, (colnr_T *)&tocol);
-			++tocol;
-		    }
-		}
-	    }
-	}
-
-#ifndef MSDOS
-	/* Check if the character under the cursor should not be inverted */
-	if (!highlight_match && lnum == curwin->w_cursor.lnum && wp == curwin
-# ifdef FEAT_GUI
-		&& !gui.in_use
-# endif
-		)
-	    noinvcur = TRUE;
-#endif
-
-	/* if inverting in this line set area_highlighting */
-	if (fromcol >= 0)
-	{
-	    area_highlighting = TRUE;
-	    attr = hl_attr(HLF_V);
-#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
-	    if (clip_star.available && !clip_star.owned && clip_isautosel())
-		attr = hl_attr(HLF_VNC);
-#endif
-	}
-    }
-
-    /*
-     * handle 'insearch' and ":s///c" highlighting
-     */
-    else
-#endif /* FEAT_VISUAL */
-	if (highlight_match
-	    && wp == curwin
-	    && lnum >= curwin->w_cursor.lnum
-	    && lnum <= curwin->w_cursor.lnum + search_match_lines)
-    {
-	if (lnum == curwin->w_cursor.lnum)
-	    getvcol(curwin, &(curwin->w_cursor),
-					     (colnr_T *)&fromcol, NULL, NULL);
-	else
-	    fromcol = 0;
-	if (lnum == curwin->w_cursor.lnum + search_match_lines)
-	{
-	    pos.lnum = lnum;
-	    pos.col = search_match_endcol;
-	    getvcol(curwin, &pos, (colnr_T *)&tocol, NULL, NULL);
-	}
-	else
-	    tocol = MAXCOL;
-	if (fromcol == tocol)		/* do at least one character */
-	    tocol = fromcol + 1;	/* happens when past end of line */
-	area_highlighting = TRUE;
-	attr = hl_attr(HLF_I);
-    }
-
-#ifdef FEAT_DIFF
-    filler_lines = diff_check(wp, lnum);
-    if (filler_lines < 0)
-    {
-	if (filler_lines == -1)
-	{
-	    if (diff_find_change(wp, lnum, &change_start, &change_end))
-		diff_hlf = HLF_ADD;	/* added line */
-	    else if (change_start == 0)
-		diff_hlf = HLF_TXD;	/* changed text */
-	    else
-		diff_hlf = HLF_CHD;	/* changed line */
-	}
-	else
-	    diff_hlf = HLF_ADD;		/* added line */
-	filler_lines = 0;
-	area_highlighting = TRUE;
-    }
-    if (lnum == wp->w_topline)
-	filler_lines = wp->w_topfill;
-    filler_todo = filler_lines;
-#endif
-
-#ifdef LINE_ATTR
-# ifdef FEAT_SIGNS
-    /* If this line has a sign with line highlighting set line_attr. */
-    v = buf_getsigntype(wp->w_buffer, lnum, SIGN_LINEHL);
-    if (v != 0)
-	line_attr = sign_get_attr((int)v, TRUE);
-# endif
-# if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
-    /* Highlight the current line in the quickfix window. */
-    if (bt_quickfix(wp->w_buffer) && qf_current_entry() == lnum)
-	line_attr = hl_attr(HLF_L);
-# endif
-    if (line_attr != 0)
-	area_highlighting = TRUE;
-#endif
-
-    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
-    ptr = line;
-
-    /* find start of trailing whitespace */
-    if (wp->w_p_list && lcs_trail)
-    {
-	trailcol = (colnr_T)STRLEN(ptr);
-	while (trailcol > (colnr_T)0 && vim_iswhite(ptr[trailcol - 1]))
-	    --trailcol;
-	trailcol += (colnr_T) (ptr - line);
-	extra_check = TRUE;
-    }
-
-    /*
-     * 'nowrap' or 'wrap' and a single line that doesn't fit: Advance to the
-     * first character to be displayed.
-     */
-    if (wp->w_p_wrap)
-	v = wp->w_skipcol;
-    else
-	v = wp->w_leftcol;
-    if (v > 0)
-    {
-#ifdef FEAT_MBYTE
-	char_u	*prev_ptr = ptr;
-#endif
-	while (vcol < v && *ptr != NUL)
-	{
-	    c = win_lbr_chartabsize(wp, ptr, (colnr_T)vcol, NULL);
-	    vcol += c;
-#ifdef FEAT_MBYTE
-	    prev_ptr = ptr;
-	    if (has_mbyte)
-		ptr += (*mb_ptr2len_check)(ptr);
-	    else
-#endif
-		++ptr;
-	}
-
-#ifdef FEAT_VIRTUALEDIT
-	/* When 'virtualedit' is set the end of the line may be before the
-	 * start of the displayed part. */
-	if (vcol < v && *ptr == NUL && virtual_active())
-	    vcol = v;
-#endif
-
-	/* Handle a character that's not completely on the screen: Put ptr at
-	 * that character but skip the first few screen characters. */
-	if (vcol > v)
-	{
-	    vcol -= c;
-#ifdef FEAT_MBYTE
-	    ptr = prev_ptr;
-#else
-	    --ptr;
-#endif
-	    n_skip = v - vcol;
-	}
-
-	/*
-	 * Adjust for when the inverted text is before the screen,
-	 * and when the start of the inverted text is before the screen.
-	 */
-	if (tocol <= vcol)
-	    fromcol = 0;
-	else if (fromcol >= 0 && fromcol < vcol)
-	    fromcol = vcol;
-
-#ifdef FEAT_LINEBREAK
-	/* When w_skipcol is non-zero, first line needs 'showbreak' */
-	if (wp->w_p_wrap)
-	    need_showbreak = TRUE;
-#endif
-    }
-
-    /*
-     * Correct highlighting for cursor that can't be disabled.
-     * Avoids having to check this for each character.
-     */
-    if (fromcol >= 0)
-    {
-	if (noinvcur)
-	{
-	    if ((colnr_T)fromcol == wp->w_virtcol)
-	    {
-		/* highlighting starts at cursor, let it start just after the
-		 * cursor */
-		fromcol_prev = fromcol;
-		fromcol = -1;
-	    }
-	    else if ((colnr_T)fromcol < wp->w_virtcol)
-		/* restart highlighting after the cursor */
-		fromcol_prev = wp->w_virtcol;
-	}
-	if (fromcol >= tocol)
-	    fromcol = -1;
-    }
-
-#ifdef FEAT_SEARCH_EXTRA
-    /*
-     * Handle highlighting the last used search pattern.
-     * Do this for both search_hl and match_hl.
-     */
-    shl = &search_hl;
-    for (;;)
-    {
-	shl->startcol = MAXCOL;
-	shl->endcol = MAXCOL;
-	shl->attr_cur = 0;
-	if (shl->rm.regprog != NULL)
-	{
-	    v = (long)(ptr - line);
-	    next_search_hl(wp, shl, lnum, (colnr_T)v);
-
-	    /* Need to get the line again, a multi-line regexp may have made it
-	     * invalid. */
-	    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
-	    ptr = line + v;
-
-	    if (shl->lnum != 0 && shl->lnum <= lnum)
-	    {
-		if (shl->lnum == lnum)
-		    shl->startcol = shl->rm.startpos[0].col;
-		else
-		    shl->startcol = 0;
-		if (lnum == shl->lnum + shl->rm.endpos[0].lnum
-						  - shl->rm.startpos[0].lnum)
-		    shl->endcol = shl->rm.endpos[0].col;
-		else
-		    shl->endcol = MAXCOL;
-		/* Highlight one character for an empty match. */
-		if (shl->startcol == shl->endcol)
-		{
-#ifdef FEAT_MBYTE
-		    if (has_mbyte && line[shl->endcol] != NUL)
-			shl->endcol += (*mb_ptr2len_check)(line + shl->endcol);
-		    else
-#endif
-			++shl->endcol;
-		}
-		if ((long)shl->startcol < v)  /* match at leftcol */
-		{
-		    shl->attr_cur = shl->attr;
-		    search_attr = shl->attr;
-		}
-		area_highlighting = TRUE;
-	    }
-	}
-	if (shl == &match_hl)
-	    break;
-	shl = &match_hl;
-    }
-#endif
-
-    off = (unsigned) (current_ScreenLine - ScreenLines);
-    col = 0;
-#ifdef FEAT_RIGHTLEFT
-    if (wp->w_p_rl)
-    {
-	/* Rightleft window: process the text in the normal direction, but put
-	 * it in current_ScreenLine[] from right to left.  Start at the
-	 * rightmost column of the window. */
-	col = W_WIDTH(wp) - 1;
-	off += col;
-    }
-#endif
-
-    /*
-     * Repeat for the whole displayed line.
-     */
-    for (;;)
-    {
-	/* Skip this quickly when working on the text. */
-	if (draw_state != WL_LINE)
-	{
-#ifdef FEAT_CMDWIN
-	    if (draw_state == WL_CMDLINE - 1 && n_extra == 0)
-	    {
-		draw_state = WL_CMDLINE;
-		if (cmdwin_type != 0 && wp == curwin)
-		{
-		    /* Draw the cmdline character. */
-		    *extra = cmdwin_type;
-		    n_extra = 1;
-		    p_extra = extra;
-		    c_extra = NUL;
-		    char_attr = hl_attr(HLF_AT);
-		}
-	    }
-#endif
-
-#ifdef FEAT_FOLDING
-	    if (draw_state == WL_FOLD - 1 && n_extra == 0)
-	    {
-		draw_state = WL_FOLD;
-		if (wp->w_p_fdc > 0)
-		{
-		    /* Draw the 'foldcolumn'. */
-		    fill_foldcolumn(extra, wp, FALSE, lnum);
-		    n_extra = wp->w_p_fdc;
-		    p_extra = extra;
-		    c_extra = NUL;
-		    char_attr = hl_attr(HLF_FC);
-		}
-	    }
-#endif
-
-#ifdef FEAT_SIGNS
-	    if (draw_state == WL_SIGN - 1 && n_extra == 0)
-	    {
-		draw_state = WL_SIGN;
-		/* Show the sign column when there are any signs in this
-		 * buffer or when using Netbeans. */
-		if (draw_signcolumn(wp)
-# ifdef FEAT_DIFF
-			&& filler_todo <= 0
-# endif
-		   )
-		{
-		    int_u	text_sign;
-# ifdef FEAT_SIGN_ICONS
-		    int_u	icon_sign;
-# endif
-
-		    /* Draw two cells with the sign value or blank. */
-		    c_extra = ' ';
-		    char_attr = hl_attr(HLF_SC);
-		    n_extra = 2;
-
-		    if (row == startrow)
-		    {
-			text_sign = buf_getsigntype(wp->w_buffer, lnum,
-								   SIGN_TEXT);
-# ifdef FEAT_SIGN_ICONS
-			icon_sign = buf_getsigntype(wp->w_buffer, lnum,
-								   SIGN_ICON);
-			if (gui.in_use && icon_sign != 0)
-			{
-			    /* Use the image in this position. */
-			    c_extra = SIGN_BYTE;
-#  ifdef FEAT_NETBEANS_INTG
-			    if (buf_signcount(wp->w_buffer, lnum) > 1)
-				c_extra = MULTISIGN_BYTE;
-#  endif
-			    char_attr = icon_sign;
-			}
-			else
-# endif
-			    if (text_sign != 0)
-			{
-			    p_extra = sign_get_text(text_sign);
-			    if (p_extra != NULL)
-			    {
-				c_extra = NUL;
-				n_extra = STRLEN(p_extra);
-			    }
-			    char_attr = sign_get_attr(text_sign, FALSE);
-			}
-		    }
-		}
-	    }
-#endif
-
-	    if (draw_state == WL_NR - 1 && n_extra == 0)
-	    {
-		draw_state = WL_NR;
-		/* Display the line number.  After the first fill with blanks
-		 * when the 'n' flag isn't in 'cpo' */
-		if (wp->w_p_nu
-			&& (row == startrow
-#ifdef FEAT_DIFF
-			    + filler_lines
-#endif
-			    || vim_strchr(p_cpo, CPO_NUMCOL) == NULL))
-		{
-		    /* Draw the line number (empty space after wrapping). */
-		    if (row == startrow
-#ifdef FEAT_DIFF
-			    + filler_lines
-#endif
-			    )
-		    {
-			sprintf((char *)extra, "%7ld ", (long)lnum);
-			if (wp->w_skipcol > 0)
-			    for (p_extra = extra; *p_extra == ' '; ++p_extra)
-				*p_extra = '-';
-#ifdef FEAT_RIGHTLEFT
-			if (wp->w_p_rl)		    /* reverse line numbers */
-			    rl_mirror(extra);
-#endif
-			p_extra = extra;
-			c_extra = NUL;
-		    }
-		    else
-			c_extra = ' ';
-		    n_extra = 8;
-		    char_attr = hl_attr(HLF_N);
-		}
-	    }
-
-#if defined(FEAT_LINEBREAK) || defined(FEAT_DIFF)
-	    if (draw_state == WL_SBR - 1 && n_extra == 0)
-	    {
-		draw_state = WL_SBR;
-# ifdef FEAT_DIFF
-		if (filler_todo > 0)
-		{
-		    /* Draw "deleted" diff line(s). */
-		    if (char2cells(fill_diff) > 1)
-			c_extra = '-';
-		    else
-			c_extra = fill_diff;
-#  ifdef FEAT_RIGHTLEFT
-		    if (wp->w_p_rl)
-			n_extra = col + 1;
-		    else
-#  endif
-			n_extra = W_WIDTH(wp) - col;
-		    char_attr = hl_attr(HLF_DED);
-		}
-# endif
-# ifdef FEAT_LINEBREAK
-		if (*p_sbr != NUL && need_showbreak)
-		{
-		    /* Draw 'showbreak' at the start of each broken line. */
-		    p_extra = p_sbr;
-		    c_extra = NUL;
-		    n_extra = (int)STRLEN(p_sbr);
-		    char_attr = hl_attr(HLF_AT);
-		    need_showbreak = FALSE;
-		    /* Correct end of highlighted area for 'showbreak',
-		     * required when 'linebreak' is also set. */
-		    if (tocol == vcol)
-			tocol += n_extra;
-		}
-# endif
-	    }
-#endif
-
-	    if (draw_state == WL_LINE - 1 && n_extra == 0)
-	    {
-		draw_state = WL_LINE;
-		if (saved_n_extra)
-		{
-		    /* Continue item from end of wrapped line. */
-		    n_extra = saved_n_extra;
-		    c_extra = saved_c_extra;
-		    p_extra = saved_p_extra;
-		    char_attr = saved_char_attr;
-		}
-		else
-		    char_attr = 0;
-	    }
-	}
-
-	/* When still displaying '$' of change command, stop at cursor */
-	if (dollar_vcol != 0 && wp == curwin && vcol >= (long)wp->w_virtcol
-#ifdef FEAT_DIFF
-				   && filler_todo <= 0
-#endif
-		)
-	{
-	    SCREEN_LINE(screen_row, W_WINCOL(wp), col, -(int)W_WIDTH(wp),
-								  wp->w_p_rl);
-	    /* Pretend we have finished updating the window. */
-	    row = wp->w_height;
-	    break;
-	}
-
-	if (draw_state == WL_LINE && area_highlighting)
-	{
-	    /* handle Visual or match highlighting in this line */
-	    if (vcol == fromcol
-#ifdef FEAT_MBYTE
-		    || (has_mbyte && vcol + 1 == fromcol && n_extra == 0
-			&& (*mb_ptr2cells)(ptr) > 1)
-#endif
-		    || ((int)vcol_prev == fromcol_prev
-			&& vcol < tocol))
-		area_attr = attr;		/* start highlighting */
-	    else if (area_attr != 0
-		    && (vcol == tocol
-			|| (noinvcur && (colnr_T)vcol == wp->w_virtcol)))
-#ifdef LINE_ATTR
-		area_attr = line_attr;		/* stop highlighting */
-	    else if (line_attr && ((fromcol == -10 && tocol == MAXCOL)
-					 || (vcol < fromcol || vcol > tocol)))
-		area_attr = line_attr;
-#else
-		area_attr = 0;			/* stop highlighting */
-#endif
-
-#ifdef FEAT_SEARCH_EXTRA
-	    if (!n_extra)
-	    {
-		/*
-		 * Check for start/end of search pattern match.
-		 * After end, check for start/end of next match.
-		 * When another match, have to check for start again.
-		 * Watch out for matching an empty string!
-		 * Do this first for search_hl, then for match_hl, so that
-		 * ":match" overrules 'hlsearch'.
-		 */
-		v = (long)(ptr - line);
-		shl = &search_hl;
-		for (;;)
-		{
-		    while (shl->rm.regprog != NULL)
-		    {
-			if (shl->startcol != MAXCOL
-				&& v >= (long)shl->startcol
-				&& v < (long)shl->endcol)
-			{
-			    shl->attr_cur = shl->attr;
-			}
-			else if (v == (long)shl->endcol)
-			{
-			    shl->attr_cur = 0;
-
-			    next_search_hl(wp, shl, lnum, (colnr_T)v);
-
-			    /* Need to get the line again, a multi-line regexp
-			     * may have made it invalid. */
-			    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
-			    ptr = line + v;
-
-			    if (shl->lnum == lnum)
-			    {
-				shl->startcol = shl->rm.startpos[0].col;
-				if (shl->rm.endpos[0].lnum == 0)
-				    shl->endcol = shl->rm.endpos[0].col;
-				else
-				    shl->endcol = MAXCOL;
-
-				if (shl->startcol == shl->endcol)
-				{
-				    /* highlight empty match, try again after
-				     * it */
-#ifdef FEAT_MBYTE
-				    if (has_mbyte)
-					shl->endcol += (*mb_ptr2len_check)(line
-							       + shl->endcol);
-				    else
-#endif
-					++shl->endcol;
-				}
-
-				/* Loop to check if the match starts at the
-				 * current position */
-				continue;
-			    }
-			}
-			break;
-		    }
-		    if (shl == &match_hl)
-			break;
-		    shl = &match_hl;
-		}
-		/* ":match" highlighting overrules 'hlsearch' */
-		if (match_hl.attr_cur != 0)
-		    search_attr = match_hl.attr_cur;
-		else
-		    search_attr = search_hl.attr_cur;
-	    }
-#endif
-
-	    if (area_attr != 0)
-		char_attr = area_attr;
-#ifdef FEAT_SYN_HL
-	    else if (search_attr == 0 && has_syntax)
-		char_attr = syntax_attr;
-#endif
-	    else
-		char_attr = search_attr;
-
-#ifdef FEAT_DIFF
-	    if (diff_hlf != (enum hlf_value)0 && n_extra == 0)
-	    {
-		if (diff_hlf == HLF_CHD && ptr - line >= change_start)
-		    diff_hlf = HLF_TXD;		/* changed text */
-		if (diff_hlf == HLF_TXD && ptr - line > change_end)
-		    diff_hlf = HLF_CHD;		/* changed line */
-		if (attr == 0 || area_attr != attr)
-		    area_attr = hl_attr(diff_hlf);
-		if (attr == 0 || char_attr != attr)
-		{
-		    if (search_attr != 0)
-			char_attr = search_attr;
-		    else
-			char_attr = hl_attr(diff_hlf);
-		}
-	    }
-#endif
-	}
-
-	/*
-	 * Get the next character to put on the screen.
-	 */
-	/*
-	 * The 'extra' array contains the extra stuff that is inserted to
-	 * represent special characters (non-printable stuff).  When all
-	 * characters are the same, c_extra is used.
-	 * For the '$' of the 'list' option, n_extra == 1, p_extra == "".
-	 */
-	if (n_extra > 0)
-	{
-	    if (c_extra != NUL)
-	    {
-		c = c_extra;
-#ifdef FEAT_MBYTE
-		mb_c = c;	/* doesn't handle non-utf-8 multi-byte! */
-		if (enc_utf8 && (*mb_char2len)(c) > 1)
-		{
-		    mb_utf8 = TRUE;
-		    u8c_c1 = u8c_c2 = 0;
-		}
-		else
-		    mb_utf8 = FALSE;
-#endif
-	    }
-	    else
-	    {
-		c = *p_extra;
-#ifdef FEAT_MBYTE
-		if (has_mbyte)
-		{
-		    mb_c = c;
-		    if (enc_utf8)
-		    {
-			/* If the UTF-8 character is more than one byte:
-			 * Decode it into "mb_c". */
-			mb_l = (*mb_ptr2len_check)(p_extra);
-			mb_utf8 = FALSE;
-			if (mb_l > n_extra)
-			    mb_l = 1;
-			else if (mb_l > 1)
-			{
-			    mb_c = utfc_ptr2char(p_extra, &u8c_c1, &u8c_c2);
-			    mb_utf8 = TRUE;
-			}
-		    }
-		    else
-		    {
-			/* if this is a DBCS character, put it in "mb_c" */
-			mb_l = MB_BYTE2LEN(c);
-			if (mb_l >= n_extra)
-			    mb_l = 1;
-			else if (mb_l > 1)
-			    mb_c = (c << 8) + p_extra[1];
-		    }
-		    /* If a double-width char doesn't fit display a '>' in the
-		     * last column. */
-		    if (
-# ifdef FEAT_RIGHTLEFT
-			    wp->w_p_rl ? (col <= 0) :
-# endif
-				    (col >= W_WIDTH(wp) - 1)
-			    && (*mb_char2cells)(mb_c) == 2)
-		    {
-			c = '>';
-			mb_c = c;
-			mb_l = 1;
-			mb_utf8 = FALSE;
-			multi_attr = hl_attr(HLF_AT);
-			/* put the pointer back to output the double-width
-			 * character at the start of the next line. */
-			++n_extra;
-			--p_extra;
-		    }
-		    else
-		    {
-			n_extra -= mb_l - 1;
-			p_extra += mb_l - 1;
-		    }
-		}
-#endif
-		++p_extra;
-	    }
-	    --n_extra;
-	}
-	else
-	{
-	    /*
-	     * Get a character from the line itself.
-	     */
-	    c = *ptr;
-#ifdef FEAT_MBYTE
-	    if (has_mbyte)
-	    {
-		mb_c = c;
-		if (enc_utf8)
-		{
-		    /* If the UTF-8 character is more than one byte: Decode it
-		     * into "mb_c". */
-		    mb_l = (*mb_ptr2len_check)(ptr);
-		    mb_utf8 = FALSE;
-		    if (mb_l > 1)
-		    {
-			mb_c = utfc_ptr2char(ptr, &u8c_c1, &u8c_c2);
-			/* Overlong encoded ASCII or ASCII with composing char
-			 * is displayed normally, except a NUL. */
-			if (mb_c < 0x80)
-			    c = mb_c;
-			mb_utf8 = TRUE;
-		    }
-
-		    if ((mb_l == 1 && c >= 0x80)
-			    || (mb_l >= 1 && mb_c == 0)
-			    || (mb_l > 1 && (!vim_isprintc(mb_c)
-							 || mb_c >= 0x10000)))
-		    {
-			/*
-			 * Illegal UTF-8 byte: display as <xx>.
-			 * Non-BMP character : display as ? or fullwidth ?.
-			 */
-			if (mb_c < 0x10000)
-			{
-			    transchar_hex(extra, mb_c);
-#ifdef FEAT_RIGHTLEFT
-			    if (wp->w_p_rl)		/* reverse */
-				rl_mirror(extra);
-#endif
-			}
-			else if (utf_char2cells(mb_c) != 2)
-			    STRCPY(extra, "?");
-			else
-			    /* 0xff1f in UTF-8: full-width '?' */
-			    STRCPY(extra, "\357\274\237");
-
-			p_extra = extra;
-			c = *p_extra;
-			mb_c = mb_ptr2char_adv(&p_extra);
-			mb_utf8 = (c >= 0x80);
-			n_extra = (int)STRLEN(p_extra);
-			c_extra = NUL;
-			if (area_attr == 0 && search_attr == 0)
-			{
-			    n_attr = n_extra + 1;
-			    extra_attr = hl_attr(HLF_8);
-			    saved_attr2 = char_attr; /* save current attr */
-			}
-		    }
-		    else if (mb_l == 0)  /* at the NUL at end-of-line */
-			mb_l = 1;
-#ifdef FEAT_ARABIC
-		    else if (p_arshape && !p_tbidi && ARABIC_CHAR(mb_c))
-		    {
-			/* Do Arabic shaping. */
-			int	pc, pc1, nc, dummy;
-
-			/* The idea of what is the previous and next
-			 * character depends on 'rightleft'. */
-			if (wp->w_p_rl)
-			{
-			    pc = prev_c;
-			    pc1 = prev_c1;
-			    nc = utf_ptr2char(ptr + mb_l);
-			    prev_c1 = u8c_c1;
-			}
-			else
-			{
-			    pc = utfc_ptr2char(ptr + mb_l, &pc1, &dummy);
-			    nc = prev_c;
-			}
-			prev_c = mb_c;
-
-			mb_c = arabic_shape(mb_c, &c, &u8c_c1, pc, pc1, nc);
-		    }
-		    else
-			prev_c = mb_c;
-#endif
-		}
-		else	/* enc_dbcs */
-		{
-		    mb_l = MB_BYTE2LEN(c);
-		    if (mb_l == 0)  /* at the NUL at end-of-line */
-			mb_l = 1;
-		    else if (mb_l > 1)
-		    {
-			/* We assume a second byte below 32 is illegal.
-			 * Hopefully this is OK for all double-byte encodings!
-			 */
-			if (ptr[1] >= 32)
-			    mb_c = (c << 8) + ptr[1];
-			else
-			{
-			    if (ptr[1] == NUL)
-			    {
-				/* head byte at end of line */
-				mb_l = 1;
-				transchar_nonprint(extra, c);
-			    }
-			    else
-			    {
-				/* illegal tail byte */
-				mb_l = 2;
-				STRCPY(extra, "XX");
-			    }
-			    p_extra = extra;
-			    n_extra = (int)STRLEN(extra) - 1;
-			    c_extra = NUL;
-			    c = *p_extra++;
-			    if (area_attr == 0 && search_attr == 0)
-			    {
-				n_attr = n_extra + 1;
-				extra_attr = hl_attr(HLF_8);
-				saved_attr2 = char_attr; /* save current attr */
-			    }
-			    mb_c = c;
-			}
-		    }
-		}
-		/* If a double-width char doesn't fit display a '>' in the
-		 * last column; the character is displayed at the start of the
-		 * next line. */
-		if ((
-# ifdef FEAT_RIGHTLEFT
-			    wp->w_p_rl ? (col <= 0) :
-# endif
-				(col >= W_WIDTH(wp) - 1))
-			&& (*mb_char2cells)(mb_c) == 2)
-		{
-		    c = '>';
-		    mb_c = c;
-		    mb_utf8 = FALSE;
-		    mb_l = 1;
-		    multi_attr = hl_attr(HLF_AT);
-		    /* Put pointer back so that the character will be
-		     * displayed at the start of the next line. */
-		    --ptr;
-		}
-		else if (*ptr != NUL)
-		    ptr += mb_l - 1;
-
-		/* If a double-width char doesn't fit at the left side display
-		 * a '<' in the first column. */
-		if (n_skip > 0 && mb_l > 1)
-		{
-		    extra[0] = '<';
-		    p_extra = extra;
-		    n_extra = 1;
-		    c_extra = NUL;
-		    c = ' ';
-		    if (area_attr == 0 && search_attr == 0)
-		    {
-			n_attr = n_extra + 1;
-			extra_attr = hl_attr(HLF_AT);
-			saved_attr2 = char_attr; /* save current attr */
-		    }
-		    mb_c = c;
-		    mb_utf8 = FALSE;
-		    mb_l = 1;
-		}
-
-	    }
-#endif
-	    ++ptr;
-
-	    if (extra_check)
-	    {
-#ifdef FEAT_SYN_HL
-		/* Get syntax attribute, unless still at the start of the line
-		 * (double-wide char that doesn't fit). */
-		if (has_syntax && (v = (long)(ptr - line)) > 0)
-		{
-		    /* Get the syntax attribute for the character.  If there
-		     * is an error, disable syntax highlighting. */
-		    save_did_emsg = did_emsg;
-		    did_emsg = FALSE;
-
-		    syntax_attr = get_syntax_attr((colnr_T)v - 1);
-
-		    if (did_emsg)
-			syntax_clear(wp->w_buffer);
-		    else
-			did_emsg = save_did_emsg;
-
-		    /* Need to get the line again, a multi-line regexp may
-		     * have made it invalid. */
-		    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
-		    ptr = line + v;
-
-		    if (area_attr == 0 && search_attr == 0)
-			char_attr = syntax_attr;
-		}
-#endif
-#ifdef FEAT_LINEBREAK
-		/*
-		 * Found last space before word: check for line break
-		 */
-		if (wp->w_p_lbr && vim_isbreak(c) && !vim_isbreak(*ptr)
-						      && !wp->w_p_list)
-		{
-		    n_extra = win_lbr_chartabsize(wp, ptr - (
-# ifdef FEAT_MBYTE
-				has_mbyte ? mb_l :
-# endif
-				1), (colnr_T)vcol, NULL) - 1;
-		    c_extra = ' ';
-		    if (vim_iswhite(c))
-			c = ' ';
-		}
-#endif
-
-		if (trailcol != MAXCOL && ptr > line + trailcol && c == ' ')
-		{
-		    c = lcs_trail;
-		    if (area_attr == 0 && search_attr == 0)
-		    {
-			n_attr = 1;
-			extra_attr = hl_attr(HLF_8);
-			saved_attr2 = char_attr; /* save current attr */
-		    }
-#ifdef FEAT_MBYTE
-		    mb_c = c;
-		    if (enc_utf8 && (*mb_char2len)(c) > 1)
-		    {
-			mb_utf8 = TRUE;
-			u8c_c1 = u8c_c2 = 0;
-		    }
-		    else
-			mb_utf8 = FALSE;
-#endif
-		}
-	    }
-
-	    /*
-	     * Handling of non-printable characters.
-	     */
-	    if (!(chartab[c] & CT_PRINT_CHAR))
-	    {
-		/*
-		 * when getting a character from the file, we may have to
-		 * turn it into something else on the way to putting it
-		 * into "ScreenLines".
-		 */
-		if (c == TAB && (!wp->w_p_list || lcs_tab1))
-		{
-		    /* tab amount depends on current column */
-		    n_extra = (int)wp->w_buffer->b_p_ts
-				   - vcol % (int)wp->w_buffer->b_p_ts - 1;
-#ifdef FEAT_MBYTE
-		    mb_utf8 = FALSE;	/* don't draw as UTF-8 */
-#endif
-		    if (wp->w_p_list)
-		    {
-			c = lcs_tab1;
-			c_extra = lcs_tab2;
-			n_attr = n_extra + 1;
-			extra_attr = hl_attr(HLF_8);
-			saved_attr2 = char_attr; /* save current attr */
-#ifdef FEAT_MBYTE
-			mb_c = c;
-			if (enc_utf8 && (*mb_char2len)(c) > 1)
-			{
-			    mb_utf8 = TRUE;
-			    u8c_c1 = u8c_c2 = 0;
-			}
-#endif
-		    }
-		    else
-		    {
-			c_extra = ' ';
-			c = ' ';
-		    }
-		}
-		else if (c == NUL && wp->w_p_list && lcs_eol_one > 0)
-		{
-#if defined(FEAT_DIFF) || defined(LINE_ATTR)
-		    /* For a diff line the highlighting continues after the
-		     * "$". */
-		    if (
-# ifdef FEAT_DIFF
-			    diff_hlf == (enum hlf_value)0
-#  ifdef LINE_ATTR
-			    &&
-#  endif
-# endif
-# ifdef LINE_ATTR
-			    line_attr == 0
-# endif
-		       )
-#endif
-		    {
-#ifdef FEAT_VIRTUALEDIT
-			/* In virtualedit, visual selections may extend
-			 * beyond end of line. */
-			if (area_highlighting && virtual_active()
-				&& tocol != MAXCOL && vcol < tocol)
-			    n_extra = 0;
-			else
-#endif
-			{
-			    p_extra = at_end_str;
-			    n_extra = 1;
-			    c_extra = NUL;
-			}
-		    }
-		    c = lcs_eol;
-		    lcs_eol_one = -1;
-		    --ptr;	    /* put it back at the NUL */
-		    if (area_attr == 0 && search_attr == 0)
-		    {
-			extra_attr = hl_attr(HLF_AT);
-			n_attr = 1;
-		    }
-#ifdef FEAT_MBYTE
-		    mb_c = c;
-		    if (enc_utf8 && (*mb_char2len)(c) > 1)
-		    {
-			mb_utf8 = TRUE;
-			u8c_c1 = u8c_c2 = 0;
-		    }
-		    else
-			mb_utf8 = FALSE;	/* don't draw as UTF-8 */
-#endif
-		}
-		else if (c != NUL)
-		{
-		    p_extra = transchar(c);
-#ifdef FEAT_RIGHTLEFT
-		    if ((dy_flags & DY_UHEX) && wp->w_p_rl)
-			rl_mirror(p_extra);	/* reverse "<12>" */
-#endif
-		    n_extra = byte2cells(c) - 1;
-		    c_extra = NUL;
-		    c = *p_extra++;
-		    if (area_attr == 0 && search_attr == 0)
-		    {
-			n_attr = n_extra + 1;
-			extra_attr = hl_attr(HLF_8);
-			saved_attr2 = char_attr; /* save current attr */
-		    }
-#ifdef FEAT_MBYTE
-		    mb_utf8 = FALSE;	/* don't draw as UTF-8 */
-#endif
-		}
-#ifdef FEAT_VIRTUALEDIT
-		else if (VIsual_active
-			 && (VIsual_mode == Ctrl_V
-			     || VIsual_mode == 'v')
-			 && virtual_active()
-			 && tocol != MAXCOL
-			 && vcol < tocol
-			 && (
-# ifdef FEAT_RIGHTLEFT
-			    wp->w_p_rl ? (col >= 0) :
-# endif
-			    (col < W_WIDTH(wp))))
-		{
-		    c = ' ';
-		    --ptr;	    /* put it back at the NUL */
-		}
-#endif
-#if defined(FEAT_DIFF) || defined(LINE_ATTR)
-		else if ((
-# ifdef FEAT_DIFF
-			    diff_hlf != (enum hlf_value)0
-#  ifdef LINE_ATTR
-			    ||
-#  endif
-# endif
-# ifdef LINE_ATTR
-			    line_attr != 0
-# endif
-			) && (
-# ifdef FEAT_RIGHTLEFT
-			    wp->w_p_rl ? (col >= 0) :
-# endif
-			    (col < W_WIDTH(wp))))
-		{
-		    /* Highlight until the right side of the window */
-		    c = ' ';
-		    --ptr;	    /* put it back at the NUL */
-# ifdef FEAT_DIFF
-		    if (diff_hlf == HLF_TXD)
-		    {
-			diff_hlf = HLF_CHD;
-			if (attr == 0 || char_attr != attr)
-			    char_attr = hl_attr(diff_hlf);
-		    }
-# endif
-		}
-#endif
-	    }
-	}
-
-	/* Don't override visual selection highlighting. */
-	if (n_attr > 0
-		&& draw_state == WL_LINE
-		&& (area_attr == 0 || char_attr != area_attr)
-		&& (search_attr == 0 || char_attr != search_attr))
-	    char_attr = extra_attr;
-
-#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
-	/* XIM don't send preedit_start and preedit_end, but they send
-	 * preedit_changed and commit.  Thus Vim can't set "im_is_active", use
-	 * im_is_preediting() here. */
-	if (xic != NULL
-		&& lnum == curwin->w_cursor.lnum
-		&& (State & INSERT)
-		&& !p_imdisable
-		&& im_is_preediting()
-		&& draw_state == WL_LINE)
-	{
-	    colnr_T tcol;
-
-	    if (preedit_end_col == MAXCOL)
-		getvcol(curwin, &(curwin->w_cursor), &tcol, NULL, NULL);
-	    else
-		tcol = preedit_end_col;
-	    if ((long)preedit_start_col <= vcol && vcol < (long)tcol)
-	    {
-		if (feedback_old_attr < 0)
-		{
-		    feedback_col = 0;
-		    feedback_old_attr = char_attr;
-		}
-		char_attr = im_get_feedback_attr(feedback_col);
-		if (char_attr < 0)
-		    char_attr = feedback_old_attr;
-		feedback_col++;
-	    }
-	    else if (feedback_old_attr >= 0)
-	    {
-		char_attr = feedback_old_attr;
-		feedback_old_attr = -1;
-		feedback_col = 0;
-	    }
-	}
-#endif
-	/*
-	 * Handle the case where we are in column 0 but not on the first
-	 * character of the line and the user wants us to show us a
-	 * special character (via 'listchars' option "precedes:<char>".
-	 */
-	if (lcs_prec_todo != NUL
-		&& (wp->w_p_wrap ? wp->w_skipcol > 0 : wp->w_leftcol > 0)
-#ifdef FEAT_DIFF
-		&& filler_todo <= 0
-#endif
-		&& draw_state > WL_NR
-		&& c != NUL)
-	{
-	    c = lcs_prec;
-	    lcs_prec_todo = NUL;
-#ifdef FEAT_MBYTE
-	    mb_c = c;
-	    if (enc_utf8 && (*mb_char2len)(c) > 1)
-	    {
-		mb_utf8 = TRUE;
-		u8c_c1 = u8c_c2 = 0;
-	    }
-	    else
-		mb_utf8 = FALSE;	/* don't draw as UTF-8 */
-#endif
-	    if ((area_attr == 0 || char_attr != area_attr)
-		    && (search_attr == 0 || char_attr != search_attr))
-	    {
-		saved_attr3 = char_attr; /* save current attr */
-		char_attr = hl_attr(HLF_AT); /* later copied to char_attr */
-		n_attr3 = 1;
-	    }
-	}
-
-	/*
-	 * At end of the text line.
-	 */
-	if (c == NUL)
-	{
-	    /* invert at least one char, used for Visual and empty line or
-	     * highlight match at end of line. If it's beyond the last
-	     * char on the screen, just overwrite that one (tricky!)  Not
-	     * needed when a '$' was displayed for 'list'. */
-	    if (lcs_eol == lcs_eol_one
-		    && ((area_attr != 0 && vcol == fromcol)
-#ifdef FEAT_SEARCH_EXTRA
-			/* highlight 'hlsearch' match at end of line */
-			|| (ptr - line) - 1 == (long)search_hl.startcol
-			|| (ptr - line) - 1 == (long)match_hl.startcol
-#endif
-		       ))
-	    {
-		int n = 0;
-
-#ifdef FEAT_RIGHTLEFT
-		if (wp->w_p_rl)
-		{
-		    if (col < 0)
-			n = 1;
-		}
-		else
-#endif
-		{
-		    if (col >= W_WIDTH(wp))
-			n = -1;
-		}
-		if (n != 0)
-		{
-		    /* At the window boundary, highlight the last character
-		     * instead (better than nothing). */
-		    off += n;
-		    col += n;
-		}
-		else
-		{
-		    /* Add a blank character to highlight. */
-		    ScreenLines[off] = ' ';
-#ifdef FEAT_MBYTE
-		    if (enc_utf8)
-			ScreenLinesUC[off] = 0;
-#endif
-		}
-#ifdef FEAT_SEARCH_EXTRA
-		if (area_attr == 0)
-		{
-		    if ((ptr - line) - 1 == (long)match_hl.startcol)
-			char_attr = match_hl.attr;
-		    else
-			char_attr = search_hl.attr;
-		}
-#endif
-		ScreenAttrs[off] = char_attr;
-#ifdef FEAT_RIGHTLEFT
-		if (wp->w_p_rl)
-		    --col;
-		else
-#endif
-		    ++col;
-	    }
-
-	    SCREEN_LINE(screen_row, W_WINCOL(wp), col, (int)W_WIDTH(wp),
-								  wp->w_p_rl);
-	    row++;
-
-	    /*
-	     * Update w_cline_height and w_cline_folded if the cursor line was
-	     * updated (saves a call to plines() later).
-	     */
-	    if (wp == curwin && lnum == curwin->w_cursor.lnum)
-	    {
-		curwin->w_cline_row = startrow;
-		curwin->w_cline_height = row - startrow;
-#ifdef FEAT_FOLDING
-		curwin->w_cline_folded = FALSE;
-#endif
-		curwin->w_valid |= (VALID_CHEIGHT|VALID_CROW);
-	    }
-
-	    break;
-	}
-
-	/* line continues beyond line end */
-	if (lcs_ext
-		&& !wp->w_p_wrap
-#ifdef FEAT_DIFF
-		&& filler_todo <= 0
-#endif
-		&& (
-#ifdef FEAT_RIGHTLEFT
-		    wp->w_p_rl ? col == 0 :
-#endif
-		    col == W_WIDTH(wp) - 1)
-		&& (*ptr != NUL
-		    || (wp->w_p_list && lcs_eol != NUL && p_extra != at_end_str)
-		    || (n_extra && (c_extra != NUL || *p_extra != NUL))))
-	{
-	    c = lcs_ext;
-	    char_attr = hl_attr(HLF_AT);
-#ifdef FEAT_MBYTE
-	    mb_c = c;
-	    if (enc_utf8 && (*mb_char2len)(c) > 1)
-	    {
-		mb_utf8 = TRUE;
-		u8c_c1 = u8c_c2 = 0;
-	    }
-	    else
-		mb_utf8 = FALSE;
-#endif
-	}
-
-	/*
-	 * Store character to be displayed.
-	 * Skip characters that are left of the screen for 'nowrap'.
-	 */
-	vcol_prev = vcol;
-	if (draw_state < WL_LINE || n_skip <= 0)
-	{
-	    /*
-	     * Store the character.
-	     */
-#if defined(FEAT_RIGHTLEFT) && defined(FEAT_MBYTE)
-	    if (has_mbyte && wp->w_p_rl && (*mb_char2cells)(mb_c) > 1)
-	    {
-		/* A double-wide character is: put first halve in left cell. */
-		--off;
-		--col;
-	    }
-#endif
-	    ScreenLines[off] = c;
-#ifdef FEAT_MBYTE
-	    if (enc_dbcs == DBCS_JPNU)
-		ScreenLines2[off] = mb_c & 0xff;
-	    else if (enc_utf8)
-	    {
-		if (mb_utf8)
-		{
-		    ScreenLinesUC[off] = mb_c;
-		    ScreenLinesC1[off] = u8c_c1;
-		    ScreenLinesC2[off] = u8c_c2;
-		}
-		else
-		    ScreenLinesUC[off] = 0;
-	    }
-	    if (multi_attr)
-	    {
-		ScreenAttrs[off] = multi_attr;
-		multi_attr = 0;
-	    }
-	    else
-#endif
-		ScreenAttrs[off] = char_attr;
-
-#ifdef FEAT_MBYTE
-	    if (has_mbyte && (*mb_char2cells)(mb_c) > 1)
-	    {
-		/* Need to fill two screen columns. */
-		++off;
-		++col;
-		if (enc_utf8)
-		    /* UTF-8: Put a 0 in the second screen char. */
-		    ScreenLines[off] = 0;
-		else
-		    /* DBCS: Put second byte in the second screen char. */
-		    ScreenLines[off] = mb_c & 0xff;
-		++vcol;
-		/* When "tocol" is halfway a character, set it to the end of
-		 * the character, otherwise highlighting won't stop. */
-		if (tocol == vcol)
-		    ++tocol;
-#ifdef FEAT_RIGHTLEFT
-		if (wp->w_p_rl)
-		{
-		    /* now it's time to backup one cell */
-		    --off;
-		    --col;
-		}
-#endif
-	    }
-#endif
-#ifdef FEAT_RIGHTLEFT
-	    if (wp->w_p_rl)
-	    {
-		--off;
-		--col;
-	    }
-	    else
-#endif
-	    {
-		++off;
-		++col;
-	    }
-	}
-	else
-	    --n_skip;
-
-	/* Only advance the "vcol" when after the 'number' column. */
-	if (draw_state >= WL_SBR
-#ifdef FEAT_DIFF
-		&& filler_todo <= 0
-#endif
-		)
-	    ++vcol;
-
-	/* restore attributes after "predeces" in 'listchars' */
-	if (draw_state > WL_NR && n_attr3 > 0 && --n_attr3 == 0)
-	    char_attr = saved_attr3;
-
-	/* restore attributes after last 'listchars' or 'number' char */
-	if (n_attr > 0 && draw_state == WL_LINE && --n_attr == 0)
-	    char_attr = saved_attr2;
-
-	/*
-	 * At end of screen line and there is more to come: Display the line
-	 * so far.  If there is no more to display it is catched above.
-	 */
-	if ((
-#ifdef FEAT_RIGHTLEFT
-	    wp->w_p_rl ? (col < 0) :
-#endif
-				    (col >= W_WIDTH(wp)))
-		&& (*ptr != NUL
-#ifdef FEAT_DIFF
-		    || filler_todo > 0
-#endif
-		    || (wp->w_p_list && lcs_eol != NUL && p_extra != at_end_str)
-		    || (n_extra != 0 && (c_extra != NUL || *p_extra != NUL)))
-		)
-	{
-	    SCREEN_LINE(screen_row, W_WINCOL(wp), col, (int)W_WIDTH(wp),
-								  wp->w_p_rl);
-	    ++row;
-	    ++screen_row;
-
-	    /* When not wrapping and finished diff lines, or when displayed
-	     * '$' and highlighting until last column, break here. */
-	    if ((!wp->w_p_wrap
-#ifdef FEAT_DIFF
-		    && filler_todo <= 0
-#endif
-		    ) || lcs_eol_one == -1)
-		break;
-
-	    /* When the window is too narrow draw all "@" lines. */
-	    if (draw_state != WL_LINE
-#ifdef FEAT_DIFF
-		    && filler_todo <= 0
-#endif
-		    )
-	    {
-		win_draw_end(wp, '@', ' ', row, wp->w_height, HLF_AT);
-#ifdef FEAT_VERTSPLIT
-		draw_vsep_win(wp, row);
-#endif
-		row = endrow;
-	    }
-
-	    /* When line got too long for screen break here. */
-	    if (row == endrow)
-	    {
-		++row;
-		break;
-	    }
-
-	    if (screen_cur_row == screen_row - 1
-#ifdef FEAT_DIFF
-		     && filler_todo <= 0
-#endif
-		     && W_WIDTH(wp) == Columns)
-	    {
-		/* Remember that the line wraps, used for modeless copy. */
-		LineWraps[screen_row - 1] = TRUE;
-
-		/*
-		 * Special trick to make copy/paste of wrapped lines work with
-		 * xterm/screen: write an extra character beyond the end of
-		 * the line. This will work with all terminal types
-		 * (regardless of the xn,am settings).
-		 * Only do this on a fast tty.
-		 * Only do this if the cursor is on the current line
-		 * (something has been written in it).
-		 * Don't do this for the GUI.
-		 * Don't do this for double-width characters.
-		 * Don't do this for a window not at the right screen border.
-		 */
-		if (p_tf
-#ifdef FEAT_GUI
-			 && !gui.in_use
-#endif
-#ifdef FEAT_MBYTE
-			 && !(has_mbyte
-			     && ((*mb_off2cells)(LineOffset[screen_row]) == 2
-				 || (*mb_off2cells)(LineOffset[screen_row - 1]
-							+ (int)Columns - 2) == 2))
-#endif
-		   )
-		{
-		    /* First make sure we are at the end of the screen line,
-		     * then output the same character again to let the
-		     * terminal know about the wrap.  If the terminal doesn't
-		     * auto-wrap, we overwrite the character. */
-		    if (screen_cur_col != W_WIDTH(wp))
-			screen_char(LineOffset[screen_row - 1]
-						      + (unsigned)Columns - 1,
-					  screen_row - 1, (int)(Columns - 1));
-
-#ifdef FEAT_MBYTE
-		    /* When there is a multi-byte character, just output a
-		     * space to keep it simple. */
-		    if (has_mbyte && MB_BYTE2LEN(ScreenLines[LineOffset[
-					screen_row - 1] + (Columns - 1)]) > 1)
-			out_char(' ');
-		    else
-#endif
-			out_char(ScreenLines[LineOffset[screen_row - 1]
-							    + (Columns - 1)]);
-		    /* force a redraw of the first char on the next line */
-		    ScreenAttrs[LineOffset[screen_row]] = (sattr_T)-1;
-		    screen_start();	/* don't know where cursor is now */
-		}
-	    }
-
-	    col = 0;
-	    off = (unsigned)(current_ScreenLine - ScreenLines);
-#ifdef FEAT_RIGHTLEFT
-	    if (wp->w_p_rl)
-	    {
-		col = W_WIDTH(wp) - 1;	/* col is not used if breaking! */
-		off += col;
-	    }
-#endif
-
-	    /* reset the drawing state for the start of a wrapped line */
-	    draw_state = WL_START;
-	    saved_n_extra = n_extra;
-	    saved_p_extra = p_extra;
-	    saved_c_extra = c_extra;
-	    saved_char_attr = char_attr;
-	    n_extra = 0;
-	    lcs_prec_todo = lcs_prec;
-#ifdef FEAT_LINEBREAK
-# ifdef FEAT_DIFF
-	    if (filler_todo <= 0)
-# endif
-		need_showbreak = TRUE;
-#endif
-#ifdef FEAT_DIFF
-	    --filler_todo;
-	    /* When the filler lines are actually below the last line of the
-	     * file, don't draw the line itself, break here. */
-	    if (filler_todo == 0 && wp->w_botfill)
-		break;
-#endif
-	}
-
-    }	/* for every character in the line */
-
-    return row;
-}
-
-/*
- * Check whether the given character needs redrawing:
- * - the (first byte of the) character is different
- * - the attributes are different
- * - the character is multi-byte and the next byte is different
- */
-    static int
-char_needs_redraw(off_from, off_to, cols)
-    int		off_from;
-    int		off_to;
-    int		cols;
-{
-    if (cols > 0
-	    && ((ScreenLines[off_from] != ScreenLines[off_to]
-		    || ScreenAttrs[off_from] != ScreenAttrs[off_to])
-
-#ifdef FEAT_MBYTE
-		|| (enc_dbcs != 0
-		    && MB_BYTE2LEN(ScreenLines[off_from]) > 1
-		    && (enc_dbcs == DBCS_JPNU && ScreenLines[off_from] == 0x8e
-			? ScreenLines2[off_from] != ScreenLines2[off_to]
-			: (cols > 1 && ScreenLines[off_from + 1]
-						 != ScreenLines[off_to + 1])))
-		|| (enc_utf8
-		    && (ScreenLinesUC[off_from] != ScreenLinesUC[off_to]
-			|| (ScreenLinesUC[off_from] != 0
-			    && (ScreenLinesC1[off_from]
-						      != ScreenLinesC1[off_to]
-				|| ScreenLinesC2[off_from]
-						  != ScreenLinesC2[off_to]))))
-#endif
-	       ))
-	return TRUE;
-    return FALSE;
-}
-
-/*
- * Move one "cooked" screen line to the screen, but only the characters that
- * have actually changed.  Handle insert/delete character.
- * "coloff" gives the first column on the screen for this line.
- * "endcol" gives the columns where valid characters are.
- * "clear_width" is the width of the window.  It's > 0 if the rest of the line
- * needs to be cleared, negative otherwise.
- * "rlflag" is TRUE in a rightleft window:
- *    When TRUE and "clear_width" > 0, clear columns 0 to "endcol"
- *    When FALSE and "clear_width" > 0, clear columns "endcol" to "clear_width"
- */
-    static void
-screen_line(row, coloff, endcol, clear_width
-#ifdef FEAT_RIGHTLEFT
-				    , rlflag
-#endif
-						)
-    int	    row;
-    int	    coloff;
-    int	    endcol;
-    int	    clear_width;
-#ifdef FEAT_RIGHTLEFT
-    int	    rlflag;
-#endif
-{
-    unsigned	    off_from;
-    unsigned	    off_to;
-    int		    col = 0;
-#if defined(FEAT_GUI) || defined(UNIX) || defined(FEAT_VERTSPLIT)
-    int		    hl;
-#endif
-    int		    force = FALSE;	/* force update rest of the line */
-    int		    redraw_this		/* bool: does character need redraw? */
-#ifdef FEAT_GUI
-				= TRUE	/* For GUI when while-loop empty */
-#endif
-				;
-    int		    redraw_next;	/* redraw_this for next character */
-#ifdef FEAT_MBYTE
-    int		    clear_next = FALSE;
-    int		    char_cells;		/* 1: normal char */
-					/* 2: occupies two display cells */
-# define CHAR_CELLS char_cells
-#else
-# define CHAR_CELLS 1
-#endif
-
-# ifdef FEAT_CLIPBOARD
-    clip_may_clear_selection(row, row);
-# endif
-
-    off_from = (unsigned)(current_ScreenLine - ScreenLines);
-    off_to = LineOffset[row] + coloff;
-
-#ifdef FEAT_RIGHTLEFT
-    if (rlflag)
-    {
-	/* Clear rest first, because it's left of the text. */
-	if (clear_width > 0)
-	{
-	    while (col <= endcol && ScreenLines[off_to] == ' '
-		    && ScreenAttrs[off_to] == 0
-# ifdef FEAT_MBYTE
-				  && (!enc_utf8 || ScreenLinesUC[off_to] == 0)
-# endif
-						  )
-	    {
-		++off_to;
-		++col;
-	    }
-	    if (col <= endcol)
-		screen_fill(row, row + 1, col + coloff,
-					    endcol + coloff + 1, ' ', ' ', 0);
-	}
-	col = endcol + 1;
-	off_to = LineOffset[row] + col + coloff;
-	off_from += col;
-	endcol = (clear_width > 0 ? clear_width : -clear_width);
-    }
-#endif /* FEAT_RIGHTLEFT */
-
-    redraw_next = char_needs_redraw(off_from, off_to, endcol - col);
-
-    while (col < endcol)
-    {
-#ifdef FEAT_MBYTE
-	if (has_mbyte && (col + 1 < endcol))
-	    char_cells = (*mb_off2cells)(off_from);
-	else
-	    char_cells = 1;
-#endif
-
-	redraw_this = redraw_next;
-	redraw_next = force || char_needs_redraw(off_from + CHAR_CELLS,
-			      off_to + CHAR_CELLS, endcol - col - CHAR_CELLS);
-
-#ifdef FEAT_GUI
-	/* If the next character was bold, then redraw the current character to
-	 * remove any pixels that might have spilt over into us.  This only
-	 * happens in the GUI.
-	 */
-	if (redraw_next && gui.in_use)
-	{
-	    hl = ScreenAttrs[off_to + CHAR_CELLS];
-	    if (hl > HL_ALL || (hl & HL_BOLD))
-		redraw_this = TRUE;
-	}
-#endif
-
-	if (redraw_this)
-	{
-	    /*
-	     * Special handling when 'xs' termcap flag set (hpterm):
-	     * Attributes for characters are stored at the position where the
-	     * cursor is when writing the highlighting code.  The
-	     * start-highlighting code must be written with the cursor on the
-	     * first highlighted character.  The stop-highlighting code must
-	     * be written with the cursor just after the last highlighted
-	     * character.
-	     * Overwriting a character doesn't remove it's highlighting.  Need
-	     * to clear the rest of the line, and force redrawing it
-	     * completely.
-	     */
-	    if (       p_wiv
-		    && !force
-#ifdef FEAT_GUI
-		    && !gui.in_use
-#endif
-		    && ScreenAttrs[off_to] != 0
-		    && ScreenAttrs[off_from] != ScreenAttrs[off_to])
-	    {
-		/*
-		 * Need to remove highlighting attributes here.
-		 */
-		windgoto(row, col + coloff);
-		out_str(T_CE);		/* clear rest of this screen line */
-		screen_start();		/* don't know where cursor is now */
-		force = TRUE;		/* force redraw of rest of the line */
-		redraw_next = TRUE;	/* or else next char would miss out */
-
-		/*
-		 * If the previous character was highlighted, need to stop
-		 * highlighting at this character.
-		 */
-		if (col + coloff > 0 && ScreenAttrs[off_to - 1] != 0)
-		{
-		    screen_attr = ScreenAttrs[off_to - 1];
-		    term_windgoto(row, col + coloff);
-		    screen_stop_highlight();
-		}
-		else
-		    screen_attr = 0;	    /* highlighting has stopped */
-	    }
-#ifdef FEAT_MBYTE
-	    if (enc_dbcs != 0)
-	    {
-		/* Check if overwriting a double-byte with a single-byte or
-		 * the other way around requires another character to be
-		 * redrawn.  For UTF-8 this isn't needed, because comparing
-		 * ScreenLinesUC[] is sufficient. */
-		if (char_cells == 1
-			&& col + 1 < endcol
-			&& (*mb_off2cells)(off_to) > 1)
-		{
-		    /* Writing a single-cell character over a double-cell
-		     * character: need to redraw the next cell. */
-		    ScreenLines[off_to + 1] = 0;
-		    redraw_next = TRUE;
-		}
-		else if (char_cells == 2
-			&& col + 2 < endcol
-			&& (*mb_off2cells)(off_to) == 1
-			&& (*mb_off2cells)(off_to + 1) > 1)
-		{
-		    /* Writing the second half of a double-cell character over
-		     * a double-cell character: need to redraw the second
-		     * cell. */
-		    ScreenLines[off_to + 2] = 0;
-		    redraw_next = TRUE;
-		}
-
-		if (enc_dbcs == DBCS_JPNU)
-		    ScreenLines2[off_to] = ScreenLines2[off_from];
-	    }
-	    /* When writing a single-width character over a double-width
-	     * character and at the end of the redrawn text, need to clear out
-	     * the right halve of the old character.
-	     * Also required when writing the right halve of a double-width
-	     * char over the left halve of an existing one. */
-	    if (has_mbyte && col + char_cells == endcol
-		    && ((char_cells == 1
-			    && (*mb_off2cells)(off_to) > 1)
-			|| (char_cells == 2
-			    && (*mb_off2cells)(off_to) == 1
-			    && (*mb_off2cells)(off_to + 1) > 1)))
-		clear_next = TRUE;
-#endif
-
-	    ScreenLines[off_to] = ScreenLines[off_from];
-#ifdef FEAT_MBYTE
-	    if (enc_utf8)
-	    {
-		ScreenLinesUC[off_to] = ScreenLinesUC[off_from];
-		if (ScreenLinesUC[off_from] != 0)
-		{
-		    ScreenLinesC1[off_to] = ScreenLinesC1[off_from];
-		    ScreenLinesC2[off_to] = ScreenLinesC2[off_from];
-		}
-	    }
-	    if (char_cells == 2)
-		ScreenLines[off_to + 1] = ScreenLines[off_from + 1];
-#endif
-
-#if defined(FEAT_GUI) || defined(UNIX)
-	    /* The bold trick makes a single row of pixels appear in the next
-	     * character.  When a bold character is removed, the next
-	     * character should be redrawn too.  This happens for our own GUI
-	     * and for some xterms. */
-	    if (
-# ifdef FEAT_GUI
-		    gui.in_use
-# endif
-# if defined(FEAT_GUI) && defined(UNIX)
-		    ||
-# endif
-# ifdef UNIX
-		    term_is_xterm
-# endif
-		    )
-	    {
-		hl = ScreenAttrs[off_to];
-		if (hl > HL_ALL || (hl & HL_BOLD))
-		    redraw_next = TRUE;
-	    }
-#endif
-	    ScreenAttrs[off_to] = ScreenAttrs[off_from];
-#ifdef FEAT_MBYTE
-	    if (enc_dbcs != 0 && char_cells == 2)
-	    {
-		/* just a hack: It makes two bytes of DBCS have same attr */
-		ScreenAttrs[off_to + 1] = ScreenAttrs[off_from];
-		screen_char_2(off_to, row, col + coloff);
-	    }
-	    else
-#endif
-		screen_char(off_to, row, col + coloff);
-	}
-	else if (  p_wiv
-#ifdef FEAT_GUI
-		&& !gui.in_use
-#endif
-		&& col + coloff > 0)
-	{
-	    if (ScreenAttrs[off_to] == ScreenAttrs[off_to - 1])
-	    {
-		/*
-		 * Don't output stop-highlight when moving the cursor, it will
-		 * stop the highlighting when it should continue.
-		 */
-		screen_attr = 0;
-	    }
-	    else if (screen_attr != 0)
-		screen_stop_highlight();
-	}
-
-	off_to += CHAR_CELLS;
-	off_from += CHAR_CELLS;
-	col += CHAR_CELLS;
-    }
-
-#ifdef FEAT_MBYTE
-    if (clear_next)
-    {
-	/* Clear the second half of a double-wide character of which the left
-	 * half was overwritten with a single-wide character. */
-	ScreenLines[off_to] = ' ';
-	if (enc_utf8)
-	    ScreenLinesUC[off_to] = 0;
-	screen_char(off_to, row, col + coloff);
-    }
-#endif
-
-    if (clear_width > 0
-#ifdef FEAT_RIGHTLEFT
-		    && !rlflag
-#endif
-				   )
-    {
-#ifdef FEAT_GUI
-	int startCol = col;
-#endif
-
-	/* blank out the rest of the line */
-	while (col < clear_width && ScreenLines[off_to] == ' '
-						  && ScreenAttrs[off_to] == 0
-#ifdef FEAT_MBYTE
-				  && (!enc_utf8 || ScreenLinesUC[off_to] == 0)
-#endif
-						  )
-	{
-	    ++off_to;
-	    ++col;
-	}
-	if (col < clear_width)
-	{
-#ifdef FEAT_GUI
-	    /*
-	     * In the GUI, clearing the rest of the line may leave pixels
-	     * behind if the first character cleared was bold.  Some bold
-	     * fonts spill over the left.  In this case we redraw the previous
-	     * character too.  If we didn't skip any blanks above, then we
-	     * only redraw if the character wasn't already redrawn anyway.
-	     */
-	    if (gui.in_use && (col > startCol || !redraw_this)
-# ifdef FEAT_MBYTE
-		    && enc_dbcs == 0
-# endif
-	       )
-	    {
-		hl = ScreenAttrs[off_to];
-		if (hl > HL_ALL || (hl & HL_BOLD))
-		    screen_char(off_to - 1, row, col + coloff - 1);
-	    }
-#endif
-	    screen_fill(row, row + 1, col + coloff, clear_width + coloff,
-								 ' ', ' ', 0);
-#ifdef FEAT_VERTSPLIT
-	    off_to += clear_width - col;
-	    col = clear_width;
-#endif
-	}
-    }
-
-    if (clear_width > 0)
-    {
-#ifdef FEAT_VERTSPLIT
-	/* For a window that's left of another, draw the separator char. */
-	if (col + coloff < Columns)
-	{
-	    int c;
-
-	    c = fillchar_vsep(&hl);
-	    if (ScreenLines[off_to] != c
-# ifdef FEAT_MBYTE
-		    || (enc_utf8
-			      && ScreenLinesUC[off_to] != (c >= 0x80 ? c : 0))
-# endif
-		    || ScreenAttrs[off_to] != hl)
-	    {
-		ScreenLines[off_to] = c;
-		ScreenAttrs[off_to] = hl;
-# ifdef FEAT_MBYTE
-		if (enc_utf8)
-		{
-		    if (c >= 0x80)
-		    {
-			ScreenLinesUC[off_to] = c;
-			ScreenLinesC1[off_to] = 0;
-			ScreenLinesC2[off_to] = 0;
-		    }
-		    else
-			ScreenLinesUC[off_to] = 0;
-		}
-# endif
-		screen_char(off_to, row, col + coloff);
-	    }
-	}
-	else
-#endif
-	    LineWraps[row] = FALSE;
-    }
-}
-
-#ifdef FEAT_RIGHTLEFT
-/*
- * Mirror text "str" for right-lieft displaying.
- */
-    static void
-rl_mirror(str)
-    char_u	*str;
-{
-    char_u	*p1, *p2;
-    int		t;
-
-    for (p1 = str, p2 = str + STRLEN(str) - 1; p1 < p2; ++p1, --p2)
-    {
-	t = *p1;
-	*p1 = *p2;
-	*p2 = t;
-    }
-}
-#endif
-
-#if defined(FEAT_WINDOWS) || defined(PROTO)
-/*
- * mark all status lines for redraw; used after first :cd
- */
-    void
-status_redraw_all()
-{
-    win_T	*wp;
-
-    for (wp = firstwin; wp; wp = wp->w_next)
-	if (wp->w_status_height)
-	{
-	    wp->w_redr_status = TRUE;
-	    redraw_later(VALID);
-	}
-}
-
-/*
- * mark all status lines of the current buffer for redraw
- */
-    void
-status_redraw_curbuf()
-{
-    win_T	*wp;
-
-    for (wp = firstwin; wp; wp = wp->w_next)
-	if (wp->w_status_height != 0 && wp->w_buffer == curbuf)
-	{
-	    wp->w_redr_status = TRUE;
-	    redraw_later(VALID);
-	}
-}
-
-/*
- * Redraw all status lines that need to be redrawn.
- */
-    void
-redraw_statuslines()
-{
-    win_T	*wp;
-
-    for (wp = firstwin; wp; wp = wp->w_next)
-	if (wp->w_redr_status)
-	    win_redr_status(wp);
-}
-#endif
-
-#if (defined(FEAT_WILDMENU) && defined(FEAT_VERTSPLIT)) || defined(PROTO)
-/*
- * Redraw all status lines at the bottom of frame "frp".
- */
-    void
-win_redraw_last_status(frp)
-    frame_T	*frp;
-{
-    if (frp->fr_layout == FR_LEAF)
-	frp->fr_win->w_redr_status = TRUE;
-    else if (frp->fr_layout == FR_ROW)
-    {
-	for (frp = frp->fr_child; frp != NULL; frp = frp->fr_next)
-	    win_redraw_last_status(frp);
-    }
-    else /* frp->fr_layout == FR_COL */
-    {
-	frp = frp->fr_child;
-	while (frp->fr_next != NULL)
-	    frp = frp->fr_next;
-	win_redraw_last_status(frp);
-    }
-}
-#endif
-
-#ifdef FEAT_VERTSPLIT
-/*
- * Draw the verticap separator right of window "wp" starting with line "row".
- */
-    static void
-draw_vsep_win(wp, row)
-    win_T	*wp;
-    int		row;
-{
-    int		hl;
-    int		c;
-
-    if (wp->w_vsep_width)
-    {
-	/* draw the vertical separator right of this window */
-	c = fillchar_vsep(&hl);
-	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + wp->w_height,
-		W_ENDCOL(wp), W_ENDCOL(wp) + 1,
-		c, ' ', hl);
-    }
-}
-#endif
-
-#ifdef FEAT_WILDMENU
-static int status_match_len __ARGS((expand_T *xp, char_u *s));
-
-/*
- * Get the lenght of an item as it will be shown in the status line.
- */
-    static int
-status_match_len(xp, s)
-    expand_T	*xp;
-    char_u	*s;
-{
-    int	len = 0;
-
-#ifdef FEAT_MENU
-    int emenu = (xp->xp_context == EXPAND_MENUS
-	    || xp->xp_context == EXPAND_MENUNAMES);
-
-    /* Check for menu separators - replace with '|'. */
-    if (emenu && menu_is_separator(s))
-	return 1;
-#endif
-
-    while (*s != NUL)
-    {
-	/* Don't display backslashes used for escaping, they look ugly. */
-	if (rem_backslash(s)
-#ifdef FEAT_MENU
-		|| (emenu && (s[0] == '\\' && s[1] != NUL))
-#endif
-		)
-	    ++s;
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	{
-	    len += ptr2cells(s);
-	    s += (*mb_ptr2len_check)(s);
-	}
-	else
-#endif
-	    len += ptr2cells(s++);
-
-    }
-
-    return len;
-}
-
-/*
- * Show wildchar matches in the status line.
- * Show at least the "match" item.
- * We start at item 'first_match' in the list and show all matches that fit.
- *
- * If inversion is possible we use it. Else '=' characters are used.
- */
-    void
-win_redr_status_matches(xp, num_matches, matches, match, showtail)
-    expand_T	*xp;
-    int		num_matches;
-    char_u	**matches;	/* list of matches */
-    int		match;
-    int		showtail;
-{
-#define L_MATCH(m) (showtail ? sm_gettail(matches[m]) : matches[m])
-    int		row;
-    char_u	*buf;
-    int		len;
-    int		clen;		/* lenght in screen cells */
-    int		fillchar;
-    int		attr;
-    int		i;
-    int		highlight = TRUE;
-    char_u	*selstart = NULL;
-    int		selstart_col = 0;
-    char_u	*selend = NULL;
-    static int	first_match = 0;
-    int		add_left = FALSE;
-    char_u	*s;
-#ifdef FEAT_MENU
-    int		emenu;
-#endif
-#if defined(FEAT_MBYTE) || defined(FEAT_MENU)
-    int		l;
-#endif
-
-    if (matches == NULL)	/* interrupted completion? */
-	return;
-
-#ifdef FEAT_MBYTE
-    if (has_mbyte)
-	buf = alloc((unsigned)Columns * MB_MAXBYTES + 1);
-    else
-#endif
-	buf = alloc((unsigned)Columns + 1);
-    if (buf == NULL)
-	return;
-
-    if (match == -1)	/* don't show match but original text */
-    {
-	match = 0;
-	highlight = FALSE;
-    }
-    /* count 1 for the ending ">" */
-    clen = status_match_len(xp, L_MATCH(match)) + 3;
-    if (match == 0)
-	first_match = 0;
-    else if (match < first_match)
-    {
-	/* jumping left, as far as we can go */
-	first_match = match;
-	add_left = TRUE;
-    }
-    else
-    {
-	/* check if match fits on the screen */
-	for (i = first_match; i < match; ++i)
-	    clen += status_match_len(xp, L_MATCH(i)) + 2;
-	if (first_match > 0)
-	    clen += 2;
-	/* jumping right, put match at the left */
-	if ((long)clen > Columns)
-	{
-	    first_match = match;
-	    /* if showing the last match, we can add some on the left */
-	    clen = 2;
-	    for (i = match; i < num_matches; ++i)
-	    {
-		clen += status_match_len(xp, L_MATCH(i)) + 2;
-		if ((long)clen >= Columns)
-		    break;
-	    }
-	    if (i == num_matches)
-		add_left = TRUE;
-	}
-    }
-    if (add_left)
-	while (first_match > 0)
-	{
-	    clen += status_match_len(xp, L_MATCH(first_match - 1)) + 2;
-	    if ((long)clen >= Columns)
-		break;
-	    --first_match;
-	}
-
-    fillchar = fillchar_status(&attr, TRUE);
-
-    if (first_match == 0)
-    {
-	*buf = NUL;
-	len = 0;
-    }
-    else
-    {
-	STRCPY(buf, "< ");
-	len = 2;
-    }
-    clen = len;
-
-    i = first_match;
-    while ((long)(clen + status_match_len(xp, L_MATCH(i)) + 2) < Columns)
-    {
-	if (i == match)
-	{
-	    selstart = buf + len;
-	    selstart_col = clen;
-	}
-
-	s = L_MATCH(i);
-	/* Check for menu separators - replace with '|' */
-#ifdef FEAT_MENU
-	emenu = (xp->xp_context == EXPAND_MENUS
-		|| xp->xp_context == EXPAND_MENUNAMES);
-	if (emenu && menu_is_separator(s))
-	{
-	    STRCPY(buf + len, transchar('|'));
-	    l = (int)STRLEN(buf + len);
-	    len += l;
-	    clen += l;
-	}
-	else
-#endif
-	    for ( ; *s != NUL; ++s)
-	{
-	    /* Don't display backslashes used for escaping, they look ugly. */
-	    if (rem_backslash(s)
-#ifdef FEAT_MENU
-		    || (emenu
-			  && (s[0] == '\t' || (s[0] == '\\' && s[1] != NUL)))
-#endif
-		    )
-		++s;
-	    clen += ptr2cells(s);
-#ifdef FEAT_MBYTE
-	    if (has_mbyte && (l = (*mb_ptr2len_check)(s)) > 1)
-	    {
-		STRNCPY(buf + len, s, l);
-		s += l - 1;
-		len += l;
-	    }
-	    else
-#endif
-	    {
-		STRCPY(buf + len, transchar_byte(*s));
-		len += (int)STRLEN(buf + len);
-	    }
-	}
-	if (i == match)
-	    selend = buf + len;
-
-	*(buf + len++) = ' ';
-	*(buf + len++) = ' ';
-	clen += 2;
-	if (++i == num_matches)
-		break;
-    }
-
-    if (i != num_matches)
-    {
-	*(buf + len++) = '>';
-	++clen;
-    }
-
-    buf[len] = NUL;
-
-    row = cmdline_row - 1;
-    if (row >= 0)
-    {
-	if (wild_menu_showing == 0)
-	{
-	    if (msg_scrolled > 0)
-	    {
-		/* Put the wildmenu just above the command line.  If there is
-		 * no room, scroll the screen one line up. */
-		if (cmdline_row == Rows - 1)
-		{
-		    screen_del_lines(0, 0, 1, (int)Rows, TRUE, NULL);
-		    ++msg_scrolled;
-		}
-		else
-		{
-		    ++cmdline_row;
-		    ++row;
-		}
-		wild_menu_showing = WM_SCROLLED;
-	    }
-	    else
-	    {
-		/* Create status line if needed by setting 'laststatus' to 2.
-		 * Set 'winminheight' to zero to avoid that the window is
-		 * resized. */
-		if (lastwin->w_status_height == 0)
-		{
-		    save_p_ls = p_ls;
-		    save_p_wmh = p_wmh;
-		    p_ls = 2;
-		    p_wmh = 0;
-		    last_status(FALSE);
-		}
-		wild_menu_showing = WM_SHOWN;
-	    }
-	}
-
-	screen_puts(buf, row, 0, attr);
-	if (selstart != NULL && highlight)
-	{
-	    *selend = NUL;
-	    screen_puts(selstart, row, selstart_col, hl_attr(HLF_WM));
-	}
-
-	screen_fill(row, row + 1, clen, (int)Columns, fillchar, fillchar, attr);
-    }
-
-#ifdef FEAT_VERTSPLIT
-    win_redraw_last_status(topframe);
-#else
-    lastwin->w_redr_status = TRUE;
-#endif
-    vim_free(buf);
-}
-#endif
-
-#if defined(FEAT_WINDOWS) || defined(PROTO)
-/*
- * Redraw the status line of window wp.
- *
- * If inversion is possible we use it. Else '=' characters are used.
- */
-    void
-win_redr_status(wp)
-    win_T	*wp;
-{
-    int		row;
-    char_u	*p;
-    int		len;
-    int		fillchar;
-    int		attr;
-    int		this_ru_col;
-
-    wp->w_redr_status = FALSE;
-    if (wp->w_status_height == 0)
-    {
-	/* no status line, can only be last window */
-	redraw_cmdline = TRUE;
-    }
-    else if (!redrawing())
-    {
-	/* Don't redraw right now, do it later. */
-	wp->w_redr_status = TRUE;
-    }
-#ifdef FEAT_STL_OPT
-    else if (*p_stl)
-    {
-	/* redraw custom status line */
-	win_redr_custom(wp, FALSE);
-    }
-#endif
-    else
-    {
-	fillchar = fillchar_status(&attr, wp == curwin);
-
-	if (buf_spname(wp->w_buffer) != NULL)
-	    STRCPY(NameBuff, buf_spname(wp->w_buffer));
-	else
-	    home_replace(wp->w_buffer, wp->w_buffer->b_fname, NameBuff,
-							      MAXPATHL, TRUE);
-	trans_characters(NameBuff, MAXPATHL);
-	p = NameBuff;
-	len = (int)STRLEN(p);
-
-	if (wp->w_buffer->b_help
-#ifdef FEAT_QUICKFIX
-		|| wp->w_p_pvw
-#endif
-		|| bufIsChanged(wp->w_buffer)
-		|| wp->w_buffer->b_p_ro)
-	    *(p + len++) = ' ';
-	if (wp->w_buffer->b_help)
-	{
-	    STRCPY(p + len, _("[help]"));
-	    len += (int)STRLEN(p + len);
-	}
-#ifdef FEAT_QUICKFIX
-	if (wp->w_p_pvw)
-	{
-	    STRCPY(p + len, _("[Preview]"));
-	    len += (int)STRLEN(p + len);
-	}
-#endif
-	if (bufIsChanged(wp->w_buffer))
-	{
-	    STRCPY(p + len, "[+]");
-	    len += 3;
-	}
-	if (wp->w_buffer->b_p_ro)
-	{
-	    STRCPY(p + len, "[RO]");
-	    len += 4;
-	}
-
-#ifndef FEAT_VERTSPLIT
-	this_ru_col = ru_col;
-	if (this_ru_col < (Columns + 1) / 2)
-	    this_ru_col = (Columns + 1) / 2;
-#else
-	this_ru_col = ru_col - (Columns - W_WIDTH(wp));
-	if (this_ru_col < (W_WIDTH(wp) + 1) / 2)
-	    this_ru_col = (W_WIDTH(wp) + 1) / 2;
-	if (this_ru_col <= 1)
-	{
-	    p = (char_u *)"<";		/* No room for file name! */
-	    len = 1;
-	}
-	else
-#endif
-#ifdef FEAT_MBYTE
-	    if (has_mbyte)
-	    {
-		int	clen = 0, i;
-
-		/* Count total number of display cells. */
-		for (i = 0; p[i] != NUL; i += (*mb_ptr2len_check)(p + i))
-		    clen += (*mb_ptr2cells)(p + i);
-		/* Find first character that will fit.
-		 * Going from start to end is much faster for DBCS. */
-		for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;
-					      i += (*mb_ptr2len_check)(p + i))
-		    clen -= (*mb_ptr2cells)(p + i);
-		len = clen;
-		if (i > 0)
-		{
-		    p = p + i - 1;
-		    *p = '<';
-		    ++len;
-		}
-
-	    }
-	    else
-#endif
-	    if (len > this_ru_col - 1)
-	    {
-		p += len - (this_ru_col - 1);
-		*p = '<';
-		len = this_ru_col - 1;
-	    }
-
-	row = W_WINROW(wp) + wp->w_height;
-	screen_puts(p, row, W_WINCOL(wp), attr);
-	screen_fill(row, row + 1, len + W_WINCOL(wp),
-			this_ru_col + W_WINCOL(wp), fillchar, fillchar, attr);
-
-	if (get_keymap_str(wp, NameBuff, MAXPATHL)
-		&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))
-	    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)
-						   - 1 + W_WINCOL(wp)), attr);
-
-#ifdef FEAT_CMDL_INFO
-	win_redr_ruler(wp, TRUE);
-#endif
-    }
-
-#ifdef FEAT_VERTSPLIT
-    /*
-     * May need to draw the character below the vertical separator.
-     */
-    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())
-    {
-	if (stl_connected(wp))
-	    fillchar = fillchar_status(&attr, wp == curwin);
-	else
-	    fillchar = fillchar_vsep(&attr);
-	screen_putchar(fillchar, W_WINROW(wp) + wp->w_height, W_ENDCOL(wp),
-									attr);
-    }
-#endif
-}
-
-# ifdef FEAT_VERTSPLIT
-/*
- * Return TRUE if the status line of window "wp" is connected to the status
- * line of the window right of it.  If not, then it's a vertical separator.
- * Only call if (wp->w_vsep_width != 0).
- */
-    int
-stl_connected(wp)
-    win_T	*wp;
-{
-    frame_T	*fr;
-
-    fr = wp->w_frame;
-    while (fr->fr_parent != NULL)
-    {
-	if (fr->fr_parent->fr_layout == FR_COL)
-	{
-	    if (fr->fr_next != NULL)
-		break;
-	}
-	else
-	{
-	    if (fr->fr_next != NULL)
-		return TRUE;
-	}
-	fr = fr->fr_parent;
-    }
-    return FALSE;
-}
-# endif
-
-#endif /* FEAT_WINDOWS */
-
-#if defined(FEAT_WINDOWS) || defined(FEAT_STL_OPT) || defined(PROTO)
-/*
- * Get the value to show for the language mappings, active 'keymap'.
- */
-    int
-get_keymap_str(wp, buf, len)
-    win_T	*wp;
-    char_u	*buf;	    /* buffer for the result */
-    int		len;	    /* length of buffer */
-{
-    char_u	*p;
-
-    if (wp->w_buffer->b_p_iminsert != B_IMODE_LMAP)
-	return FALSE;
-
-    {
-#ifdef FEAT_EVAL
-	buf_T	*old_curbuf = curbuf;
-	win_T	*old_curwin = curwin;
-	char_u	*s;
-
-	curbuf = wp->w_buffer;
-	curwin = wp;
-	STRCPY(buf, "b:keymap_name");	/* must be writable */
-	++emsg_skip;
-	s = p = eval_to_string(buf, NULL);
-	--emsg_skip;
-	curbuf = old_curbuf;
-	curwin = old_curwin;
-	if (p == NULL || *p == NUL)
-#endif
-	{
-#ifdef FEAT_KEYMAP
-	    if (wp->w_buffer->b_kmap_state & KEYMAP_LOADED)
-		p = wp->w_buffer->b_p_keymap;
-	    else
-#endif
-		p = (char_u *)"lang";
-	}
-	if ((int)(STRLEN(p) + 3) < len)
-	    sprintf((char *)buf, "<%s>", p);
-	else
-	    buf[0] = NUL;
-#ifdef FEAT_EVAL
-	vim_free(s);
-#endif
-    }
-    return buf[0] != NUL;
-}
-#endif
-
-#if defined(FEAT_STL_OPT) || defined(PROTO)
-/*
- * Redraw the status line or ruler of window wp.
- */
-    static void
-win_redr_custom(wp, Ruler)
-    win_T	*wp;
-    int		Ruler;
-{
-    int		attr;
-    int		curattr;
-    int		row;
-    int		col = 0;
-    int		maxwidth;
-    int		width;
-    int		n;
-    int		len;
-    int		fillchar;
-    char_u	buf[MAXPATHL];
-    char_u	*p;
-    struct	stl_hlrec hl[STL_MAX_ITEM];
-
-    /* setup environment for the task at hand */
-    row = W_WINROW(wp) + wp->w_height;
-    fillchar = fillchar_status(&attr, wp == curwin);
-    maxwidth = W_WIDTH(wp);
-    p = p_stl;
-    if (Ruler)
-    {
-	p = p_ruf;
-	/* advance past any leading group spec - implicit in ru_col */
-	if (*p == '%')
-	{
-	    if (*++p == '-')
-		p++;
-	    if (atoi((char *) p))
-		while (VIM_ISDIGIT(*p))
-		    p++;
-	    if (*p++ != '(')
-		p = p_ruf;
-	}
-#ifdef FEAT_VERTSPLIT
-	col = ru_col - (Columns - W_WIDTH(wp));
-	if (col < (W_WIDTH(wp) + 1) / 2)
-	    col = (W_WIDTH(wp) + 1) / 2;
-#else
-	col = ru_col;
-	if (col > (Columns + 1) / 2)
-	    col = (Columns + 1) / 2;
-#endif
-	maxwidth = W_WIDTH(wp) - col;
-#ifdef FEAT_WINDOWS
-	if (!wp->w_status_height)
-#endif
-	{
-	    row = Rows - 1;
-	    --maxwidth;	/* writing in last column may cause scrolling */
-	    fillchar = ' ';
-	    attr = 0;
-	}
-    }
-    if (maxwidth <= 0)
-	return;
-#ifdef FEAT_VERTSPLIT
-    col += W_WINCOL(wp);
-#endif
-
-    width = build_stl_str_hl(wp, buf, sizeof(buf), p, fillchar, maxwidth, hl);
-    len = STRLEN(buf);
-
-    while (width < maxwidth && len < sizeof(buf) - 1)
-    {
-#ifdef FEAT_MBYTE
-	len += (*mb_char2bytes)(fillchar, buf + len);
-#else
-	buf[len++] = fillchar;
-#endif
-	++width;
-    }
-    buf[len] = NUL;
-
-    curattr = attr;
-    p = buf;
-    for (n = 0; hl[n].start != NULL; n++)
-    {
-	len = (int)(hl[n].start - p);
-	screen_puts_len(p, len, row, col, curattr);
-	col += vim_strnsize(p, len);
-	p = hl[n].start;
-
-	if (hl[n].userhl == 0)
-	    curattr = attr;
-#ifdef FEAT_WINDOWS
-	else if (wp != curwin && wp->w_status_height != 0)
-	    curattr = highlight_stlnc[hl[n].userhl - 1];
-#endif
-	else
-	    curattr = highlight_user[hl[n].userhl - 1];
-    }
-    screen_puts(p, row, col, curattr);
-}
-
-#endif /* FEAT_STL_OPT */
-
-/*
- * Output a single character directly to the screen and update ScreenLines.
- */
-    void
-screen_putchar(c, row, col, attr)
-    int	    c;
-    int	    row, col;
-    int	    attr;
-{
-#ifdef FEAT_MBYTE
-    char_u	buf[MB_MAXBYTES + 1];
-
-    buf[(*mb_char2bytes)(c, buf)] = NUL;
-#else
-    char_u	buf[2];
-
-    buf[0] = c;
-    buf[1] = NUL;
-#endif
-    screen_puts(buf, row, col, attr);
-}
-
-/*
- * Get a single character directly from ScreenLines into "bytes[]".
- * Also return its attribute in *attrp;
- */
-    void
-screen_getbytes(row, col, bytes, attrp)
-    int	    row, col;
-    char_u  *bytes;
-    int	    *attrp;
-{
-    unsigned off;
-
-    /* safety check */
-    if (ScreenLines != NULL && row < screen_Rows && col < screen_Columns)
-    {
-	off = LineOffset[row] + col;
-	*attrp = ScreenAttrs[off];
-	bytes[0] = ScreenLines[off];
-	bytes[1] = NUL;
-
-#ifdef FEAT_MBYTE
-	if (enc_utf8 && ScreenLinesUC[off] != 0)
-	    bytes[utfc_char2bytes(off, bytes)] = NUL;
-	else if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
-	{
-	    bytes[0] = ScreenLines[off];
-	    bytes[1] = ScreenLines2[off];
-	    bytes[2] = NUL;
-	}
-	else if (enc_dbcs && MB_BYTE2LEN(bytes[0]) > 1)
-	{
-	    bytes[1] = ScreenLines[off + 1];
-	    bytes[2] = NUL;
-	}
-#endif
-    }
-}
-
-/*
- * Put string '*text' on the screen at position 'row' and 'col', with
- * attributes 'attr', and update ScreenLines[] and ScreenAttrs[].
- * Note: only outputs within one row, message is truncated at screen boundary!
- * Note: if ScreenLines[], row and/or col is invalid, nothing is done.
- */
-    void
-screen_puts(text, row, col, attr)
-    char_u	*text;
-    int		row;
-    int		col;
-    int		attr;
-{
-    screen_puts_len(text, -1, row, col, attr);
-}
-
-/*
- * Like screen_puts(), but output "text[len]".  When "len" is -1 output up to
- * a NUL.
- */
-    void
-screen_puts_len(text, len, row, col, attr)
-    char_u	*text;
-    int		len;
-    int		row;
-    int		col;
-    int		attr;
-{
-    unsigned	off;
-    char_u	*ptr = text;
-    int		c;
-#ifdef FEAT_MBYTE
-    int		mbyte_blen = 1;
-    int		mbyte_cells = 1;
-    int		u8c = 0;
-    int		u8c_c1 = 0;
-    int		u8c_c2 = 0;
-    int		clear_next_cell = FALSE;
-# ifdef FEAT_ARABIC
-    int		prev_c = 0;		/* previous Arabic character */
-    int		pc, nc, nc1, dummy;
-# endif
-#endif
-
-    if (ScreenLines == NULL || row >= screen_Rows)	/* safety check */
-	return;
-
-    off = LineOffset[row] + col;
-    while (*ptr != NUL && col < screen_Columns
-				      && (len < 0 || (int)(ptr - text) < len))
-    {
-	c = *ptr;
-#ifdef FEAT_MBYTE
-	/* check if this is the first byte of a multibyte */
-	if (has_mbyte)
-	{
-	    if (enc_utf8 && len > 0)
-		mbyte_blen = utfc_ptr2len_check_len(ptr,
-						   (int)((text + len) - ptr));
-	    else
-		mbyte_blen = (*mb_ptr2len_check)(ptr);
-	    if (enc_dbcs == DBCS_JPNU && c == 0x8e)
-		mbyte_cells = 1;
-	    else if (enc_dbcs != 0)
-		mbyte_cells = mbyte_blen;
-	    else	/* enc_utf8 */
-	    {
-		if (len >= 0)
-		    u8c = utfc_ptr2char_len(ptr, &u8c_c1, &u8c_c2,
-						   (int)((text + len) - ptr));
-		else
-		    u8c = utfc_ptr2char(ptr, &u8c_c1, &u8c_c2);
-		mbyte_cells = utf_char2cells(u8c);
-		/* Non-BMP character: display as ? or fullwidth ?. */
-		if (u8c >= 0x10000)
-		{
-		    u8c = (mbyte_cells == 2) ? 0xff1f : (int)'?';
-		    if (attr == 0)
-			attr = hl_attr(HLF_8);
-		}
-# ifdef FEAT_ARABIC
-		if (p_arshape && !p_tbidi && ARABIC_CHAR(u8c))
-		{
-		    /* Do Arabic shaping. */
-		    if (len >= 0 && (int)(ptr - text) + mbyte_blen >= len)
-		    {
-			/* Past end of string to be displayed. */
-			nc = NUL;
-			nc1 = NUL;
-		    }
-		    else
-			nc = utfc_ptr2char(ptr + mbyte_blen, &nc1, &dummy);
-		    pc = prev_c;
-		    prev_c = u8c;
-		    u8c = arabic_shape(u8c, &c, &u8c_c1, nc, nc1, pc);
-		}
-		else
-		    prev_c = u8c;
-# endif
-	    }
-	}
-#endif
-
-	if (ScreenLines[off] != c
-#ifdef FEAT_MBYTE
-		|| (mbyte_cells == 2
-		    && ScreenLines[off + 1] != (enc_dbcs ? ptr[1] : 0))
-		|| (enc_dbcs == DBCS_JPNU
-		    && c == 0x8e
-		    && ScreenLines2[off] != ptr[1])
-		|| (enc_utf8
-		    && mbyte_blen > 1
-		    && (ScreenLinesUC[off] != u8c
-			|| ScreenLinesC1[off] != u8c_c1
-			|| ScreenLinesC2[off] != u8c_c2))
-#endif
-		|| ScreenAttrs[off] != attr
-		|| exmode_active
-		)
-	{
-#if defined(FEAT_GUI) || defined(UNIX)
-	    /* The bold trick makes a single row of pixels appear in the next
-	     * character.  When a bold character is removed, the next
-	     * character should be redrawn too.  This happens for our own GUI
-	     * and for some xterms.
-	     * Force the redraw by setting the attribute to a different value
-	     * than "attr", the contents of ScreenLines[] may be needed by
-	     * mb_off2cells() further on.
-	     * Don't do this for the last drawn character, because the next
-	     * character may not be redrawn. */
-	    if (
-# ifdef FEAT_GUI
-		    gui.in_use
-# endif
-# if defined(FEAT_GUI) && defined(UNIX)
-		    ||
-# endif
-# ifdef UNIX
-		    term_is_xterm
-# endif
-	       )
-	    {
-		int		n;
-
-		n = ScreenAttrs[off];
-# ifdef FEAT_MBYTE
-		if (col + mbyte_cells < screen_Columns
-			&& (n > HL_ALL || (n & HL_BOLD))
-			&& (len < 0 ? ptr[mbyte_blen] != NUL
-					     : ptr + mbyte_blen < text + len))
-		    ScreenAttrs[off + mbyte_cells] = attr + 1;
-# else
-		if (col + 1 < screen_Columns
-			&& (n > HL_ALL || (n & HL_BOLD))
-			&& (len < 0 ? ptr[1] != NUL : ptr + 1 < text + len))
-		    ScreenLines[off + 1] = 0;
-# endif
-	    }
-#endif
-#ifdef FEAT_MBYTE
-	    /* When at the end of the text and overwriting a two-cell
-	     * character with a one-cell character, need to clear the next
-	     * cell.  Also when overwriting the left halve of a two-cell char
-	     * with the right halve of a two-cell char.  Do this only once
-	     * (mb_off2cells() may return 2 on the right halve). */
-	    if (clear_next_cell)
-		clear_next_cell = FALSE;
-	    else if (has_mbyte
-		    && (len < 0 ? ptr[mbyte_blen] == NUL
-					     : ptr + mbyte_blen >= text + len)
-		    && ((mbyte_cells == 1 && (*mb_off2cells)(off) > 1)
-			|| (mbyte_cells == 2
-			    && (*mb_off2cells)(off) == 1
-			    && (*mb_off2cells)(off + 1) > 1)))
-		clear_next_cell = TRUE;
-
-	    /* Make sure we never leave a second byte of a double-byte behind,
-	     * it confuses mb_off2cells(). */
-	    if (enc_dbcs
-		    && ((mbyte_cells == 1 && (*mb_off2cells)(off) > 1)
-			|| (mbyte_cells == 2
-			    && (*mb_off2cells)(off) == 1
-			    && (*mb_off2cells)(off + 1) > 1)))
-		ScreenLines[off + mbyte_blen] = 0;
-#endif
-	    ScreenLines[off] = c;
-	    ScreenAttrs[off] = attr;
-#ifdef FEAT_MBYTE
-	    if (enc_utf8)
-	    {
-		if (c < 0x80 && u8c_c1 == 0 && u8c_c2 == 0)
-		    ScreenLinesUC[off] = 0;
-		else
-		{
-		    ScreenLinesUC[off] = u8c;
-		    ScreenLinesC1[off] = u8c_c1;
-		    ScreenLinesC2[off] = u8c_c2;
-		}
-		if (mbyte_cells == 2)
-		{
-		    ScreenLines[off + 1] = 0;
-		    ScreenAttrs[off + 1] = attr;
-		}
-		screen_char(off, row, col);
-	    }
-	    else if (mbyte_cells == 2)
-	    {
-		ScreenLines[off + 1] = ptr[1];
-		ScreenAttrs[off + 1] = attr;
-		screen_char_2(off, row, col);
-	    }
-	    else if (enc_dbcs == DBCS_JPNU && c == 0x8e)
-	    {
-		ScreenLines2[off] = ptr[1];
-		screen_char(off, row, col);
-	    }
-	    else
-#endif
-		screen_char(off, row, col);
-	}
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	{
-	    off += mbyte_cells;
-	    col += mbyte_cells;
-	    ptr += mbyte_blen;
-	    if (clear_next_cell)
-		ptr = (char_u *)" ";
-	}
-	else
-#endif
-	{
-	    ++off;
-	    ++col;
-	    ++ptr;
-	}
-    }
-}
-
-#ifdef FEAT_SEARCH_EXTRA
-/*
- * Prepare for 'searchhl' highlighting.
- */
-    static void
-start_search_hl()
-{
-    if (p_hls && !no_hlsearch)
-    {
-	last_pat_prog(&search_hl.rm);
-	search_hl.attr = hl_attr(HLF_L);
-    }
-}
-
-/*
- * Clean up for 'searchhl' highlighting.
- */
-    static void
-end_search_hl()
-{
-    if (search_hl.rm.regprog != NULL)
-    {
-	vim_free(search_hl.rm.regprog);
-	search_hl.rm.regprog = NULL;
-    }
-}
-
-/*
- * Advance to the match in window "wp" line "lnum" or past it.
- */
-    static void
-prepare_search_hl(wp, lnum)
-    win_T	*wp;
-    linenr_T	lnum;
-{
-    match_T	*shl;		/* points to search_hl or match_hl */
-    int		n;
-
-    /*
-     * When using a multi-line pattern, start searching at the top
-     * of the window or just after a closed fold.
-     * Do this both for search_hl and match_hl.
-     */
-    shl = &search_hl;
-    for (;;)
-    {
-	if (shl->rm.regprog != NULL
-		&& shl->lnum == 0
-		&& re_multiline(shl->rm.regprog))
-	{
-	    if (shl->first_lnum == 0)
-	    {
-# ifdef FEAT_FOLDING
-		for (shl->first_lnum = lnum;
-			   shl->first_lnum > wp->w_topline; --shl->first_lnum)
-		    if (hasFoldingWin(wp, shl->first_lnum - 1,
-						      NULL, NULL, TRUE, NULL))
-			break;
-# else
-		shl->first_lnum = wp->w_topline;
-# endif
-	    }
-	    n = 0;
-	    while (shl->first_lnum < lnum && shl->rm.regprog != NULL)
-	    {
-		next_search_hl(wp, shl, shl->first_lnum, (colnr_T)n);
-		if (shl->lnum != 0)
-		{
-		    shl->first_lnum = shl->lnum
-				    + shl->rm.endpos[0].lnum
-				    - shl->rm.startpos[0].lnum;
-		    n = shl->rm.endpos[0].col;
-		}
-		else
-		{
-		    ++shl->first_lnum;
-		    n = 0;
-		}
-	    }
-	}
-	if (shl == &match_hl)
-	    break;
-	shl = &match_hl;
-    }
-}
-
-/*
- * Search for a next 'searchl' or ":match" match.
- * Uses shl->buf.
- * Sets shl->lnum and shl->rm contents.
- * Note: Assumes a previous match is always before "lnum", unless
- * shl->lnum is zero.
- * Careful: Any pointers for buffer lines will become invalid.
- */
-    static void
-next_search_hl(win, shl, lnum, mincol)
-    win_T	*win;
-    match_T	*shl;		/* points to search_hl or match_hl */
-    linenr_T	lnum;
-    colnr_T	mincol;		/* minimal column for a match */
-{
-    linenr_T	l;
-    colnr_T	matchcol;
-    long	nmatched;
-
-    if (shl->lnum != 0)
-    {
-	/* Check for three situations:
-	 * 1. If the "lnum" is below a previous match, start a new search.
-	 * 2. If the previous match includes "mincol", use it.
-	 * 3. Continue after the previous match.
-	 */
-	l = shl->lnum + shl->rm.endpos[0].lnum - shl->rm.startpos[0].lnum;
-	if (lnum > l)
-	    shl->lnum = 0;
-	else if (lnum < l || shl->rm.endpos[0].col > mincol)
-	    return;
-    }
-
-    /*
-     * Repeat searching for a match until one is found that includes "mincol"
-     * or none is found in this line.
-     */
-    called_emsg = FALSE;
-    for (;;)
-    {
-	/* Three situations:
-	 * 1. No useful previous match: search from start of line.
-	 * 2. Not Vi compatible or empty match: continue at next character.
-	 *    Break the loop if this is beyond the end of the line.
-	 * 3. Vi compatible searching: continue at end of previous match.
-	 */
-	if (shl->lnum == 0)
-	    matchcol = 0;
-	else if (vim_strchr(p_cpo, CPO_SEARCH) == NULL
-		|| (shl->rm.endpos[0].lnum == 0
-		    && shl->rm.endpos[0].col == shl->rm.startpos[0].col))
-	{
-	    matchcol = shl->rm.startpos[0].col + 1;
-	    if (ml_get_buf(shl->buf, lnum, FALSE)[matchcol - 1] == NUL)
-	    {
-		shl->lnum = 0;
-		break;
-	    }
-	}
-	else
-	    matchcol = shl->rm.endpos[0].col;
-
-	shl->lnum = lnum;
-	nmatched = vim_regexec_multi(&shl->rm, win, shl->buf, lnum, matchcol);
-	if (called_emsg)
-	{
-	    /* Error while handling regexp: stop using this regexp. */
-	    vim_free(shl->rm.regprog);
-	    shl->rm.regprog = NULL;
-	    no_hlsearch = TRUE;
-	    break;
-	}
-	if (nmatched == 0)
-	{
-	    shl->lnum = 0;		/* no match found */
-	    break;
-	}
-	if (shl->rm.startpos[0].lnum > 0
-		|| shl->rm.startpos[0].col >= mincol
-		|| nmatched > 1
-		|| shl->rm.endpos[0].col > mincol)
-	{
-	    shl->lnum += shl->rm.startpos[0].lnum;
-	    break;			/* useful match found */
-	}
-    }
-}
-#endif
-
-      static void
-screen_start_highlight(attr)
-      int	attr;
-{
-    attrentry_T *aep = NULL;
-
-    screen_attr = attr;
-    if (full_screen
-#ifdef WIN3264
-		    && termcap_active
-#endif
-				       )
-    {
-#ifdef FEAT_GUI
-	if (gui.in_use)
-	{
-	    char	buf[20];
-
-	    sprintf(buf, IF_EB("\033|%dh", ESC_STR "|%dh"), attr);		/* internal GUI code */
-	    OUT_STR(buf);
-	}
-	else
-#endif
-	{
-	    if (attr > HL_ALL)				/* special HL attr. */
-	    {
-		if (t_colors > 1)
-		    aep = syn_cterm_attr2entry(attr);
-		else
-		    aep = syn_term_attr2entry(attr);
-		if (aep == NULL)	    /* did ":syntax clear" */
-		    attr = 0;
-		else
-		    attr = aep->ae_attr;
-	    }
-	    if ((attr & HL_BOLD) && T_MD != NULL)	/* bold */
-		out_str(T_MD);
-	    if ((attr & HL_STANDOUT) && T_SO != NULL)	/* standout */
-		out_str(T_SO);
-	    if ((attr & HL_UNDERLINE) && T_US != NULL)	/* underline */
-		out_str(T_US);
-	    if ((attr & HL_ITALIC) && T_CZH != NULL)	/* italic */
-		out_str(T_CZH);
-	    if ((attr & HL_INVERSE) && T_MR != NULL)	/* inverse (reverse) */
-		out_str(T_MR);
-
-	    /*
-	     * Output the color or start string after bold etc., in case the
-	     * bold etc. override the color setting.
-	     */
-	    if (aep != NULL)
-	    {
-		if (t_colors > 1)
-		{
-		    if (aep->ae_u.cterm.fg_color)
-			term_fg_color(aep->ae_u.cterm.fg_color - 1);
-		    if (aep->ae_u.cterm.bg_color)
-			term_bg_color(aep->ae_u.cterm.bg_color - 1);
-		}
-		else
-		{
-		    if (aep->ae_u.term.start != NULL)
-			out_str(aep->ae_u.term.start);
-		}
-	    }
-	}
-    }
-}
-
-      void
-screen_stop_highlight()
-{
-    int	    do_ME = FALSE;	    /* output T_ME code */
-
-    if (screen_attr != 0
-#ifdef WIN3264
-			&& termcap_active
-#endif
-					   )
-    {
-#ifdef FEAT_GUI
-	if (gui.in_use)
-	{
-	    char	buf[20];
-
-	    /* use internal GUI code */
-	    sprintf(buf, IF_EB("\033|%dH", ESC_STR "|%dH"), screen_attr);
-	    OUT_STR(buf);
-	}
-	else
-#endif
-	{
-	    if (screen_attr > HL_ALL)			/* special HL attr. */
-	    {
-		attrentry_T *aep;
-
-		if (t_colors > 1)
-		{
-		    /*
-		     * Assume that t_me restores the original colors!
-		     */
-		    aep = syn_cterm_attr2entry(screen_attr);
-		    if (aep != NULL && (aep->ae_u.cterm.fg_color
-						 || aep->ae_u.cterm.bg_color))
-			do_ME = TRUE;
-		}
-		else
-		{
-		    aep = syn_term_attr2entry(screen_attr);
-		    if (aep != NULL && aep->ae_u.term.stop != NULL)
-		    {
-			if (STRCMP(aep->ae_u.term.stop, T_ME) == 0)
-			    do_ME = TRUE;
-			else
-			    out_str(aep->ae_u.term.stop);
-		    }
-		}
-		if (aep == NULL)	    /* did ":syntax clear" */
-		    screen_attr = 0;
-		else
-		    screen_attr = aep->ae_attr;
-	    }
-
-	    /*
-	     * Often all ending-codes are equal to T_ME.  Avoid outputting the
-	     * same sequence several times.
-	     */
-	    if (screen_attr & HL_STANDOUT)
-	    {
-		if (STRCMP(T_SE, T_ME) == 0)
-		    do_ME = TRUE;
-		else
-		    out_str(T_SE);
-	    }
-	    if (screen_attr & HL_UNDERLINE)
-	    {
-		if (STRCMP(T_UE, T_ME) == 0)
-		    do_ME = TRUE;
-		else
-		    out_str(T_UE);
-	    }
-	    if (screen_attr & HL_ITALIC)
-	    {
-		if (STRCMP(T_CZR, T_ME) == 0)
-		    do_ME = TRUE;
-		else
-		    out_str(T_CZR);
-	    }
-	    if (do_ME || (screen_attr & (HL_BOLD | HL_INVERSE)))
-		out_str(T_ME);
-
-	    if (t_colors > 1)
-	    {
-		/* set Normal cterm colors */
-		if (cterm_normal_fg_color != 0)
-		    term_fg_color(cterm_normal_fg_color - 1);
-		if (cterm_normal_bg_color != 0)
-		    term_bg_color(cterm_normal_bg_color - 1);
-		if (cterm_normal_fg_bold)
-		    out_str(T_MD);
-	    }
-	}
-    }
-    screen_attr = 0;
-}
-
-/*
- * Reset the colors for a cterm.  Used when leaving Vim.
- * The machine specific code may override this again.
- */
-    void
-reset_cterm_colors()
-{
-    if (t_colors > 1)
-    {
-	/* set Normal cterm colors */
-	if (cterm_normal_fg_color > 0 || cterm_normal_bg_color > 0)
-	{
-	    out_str(T_OP);
-	    screen_attr = -1;
-	}
-	if (cterm_normal_fg_bold)
-	{
-	    out_str(T_ME);
-	    screen_attr = -1;
-	}
-    }
-}
-
-/*
- * Put character ScreenLines["off"] on the screen at position "row" and "col",
- * using the attributes from ScreenAttrs["off"].
- */
-    static void
-screen_char(off, row, col)
-    unsigned	off;
-    int		row;
-    int		col;
-{
-    int		attr;
-
-    /* Check for illegal values, just in case (could happen just after
-     * resizing). */
-    if (row >= screen_Rows || col >= screen_Columns)
-	return;
-
-    /* Outputting the last character on the screen may scrollup the screen.
-     * Don't to it!  Mark the character invalid (update it when scrolled up) */
-    if (row == screen_Rows - 1 && col == screen_Columns - 1
-#ifdef FEAT_RIGHTLEFT
-	    /* account for first command-line character in rightleft mode */
-	    && !cmdmsg_rl
-#endif
-       )
-    {
-	ScreenAttrs[off] = (sattr_T)-1;
-	return;
-    }
-
-    /*
-     * Stop highlighting first, so it's easier to move the cursor.
-     */
-#if defined(FEAT_CLIPBOARD) || defined(FEAT_VERTSPLIT)
-    if (screen_char_attr != 0)
-	attr = screen_char_attr;
-    else
-#endif
-	attr = ScreenAttrs[off];
-    if (screen_attr != attr)
-	screen_stop_highlight();
-
-    windgoto(row, col);
-
-    if (screen_attr != attr)
-	screen_start_highlight(attr);
-
-#ifdef FEAT_MBYTE
-    if (enc_utf8 && ScreenLinesUC[off] != 0)
-    {
-	char_u	    buf[MB_MAXBYTES + 1];
-
-	/* Convert UTF-8 character to bytes and write it. */
-
-	buf[utfc_char2bytes(off, buf)] = NUL;
-
-	out_str(buf);
-	if (utf_char2cells(ScreenLinesUC[off]) > 1)
-	    ++screen_cur_col;
-    }
-    else
-#endif
-    {
-#ifdef FEAT_MBYTE
-	out_flush_check();
-#endif
-	out_char(ScreenLines[off]);
-#ifdef FEAT_MBYTE
-	/* double-byte character in single-width cell */
-	if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
-	    out_char(ScreenLines2[off]);
-#endif
-    }
-
-    screen_cur_col++;
-}
-
-#ifdef FEAT_MBYTE
-
-/*
- * Used for enc_dbcs only: Put one double-wide character at ScreenLines["off"]
- * on the screen at position 'row' and 'col'.
- * The attributes of the first byte is used for all.  This is required to
- * output the two bytes of a double-byte character with nothing in between.
- */
-    static void
-screen_char_2(off, row, col)
-    unsigned	off;
-    int		row;
-    int		col;
-{
-    /* Check for illegal values (could be wrong when screen was resized). */
-    if (off + 1 >= (unsigned)(screen_Rows * screen_Columns))
-	return;
-
-    /* Outputting the last character on the screen may scrollup the screen.
-     * Don't to it!  Mark the character invalid (update it when scrolled up) */
-    if (row == screen_Rows - 1 && col >= screen_Columns - 2)
-    {
-	ScreenAttrs[off] = (sattr_T)-1;
-	return;
-    }
-
-    /* Output the first byte normally (positions the cursor), then write the
-     * second byte directly. */
-    screen_char(off, row, col);
-    out_char(ScreenLines[off + 1]);
-    ++screen_cur_col;
-}
-#endif
-
-#if defined(FEAT_CLIPBOARD) || defined(FEAT_VERTSPLIT) || defined(PROTO)
-/*
- * Draw a rectangle of the screen, inverted when "invert" is TRUE.
- * This uses the contents of ScreenLines[] and doesn't change it.
- */
-    void
-screen_draw_rectangle(row, col, height, width, invert)
-    int		row;
-    int		col;
-    int		height;
-    int		width;
-    int		invert;
-{
-    int		r, c;
-    int		off;
-
-    if (invert)
-	screen_char_attr = HL_INVERSE;
-    for (r = row; r < row + height; ++r)
-    {
-	off = LineOffset[r];
-	for (c = col; c < col + width; ++c)
-	{
-#ifdef FEAT_MBYTE
-	    if (enc_dbcs != 0 && dbcs_off2cells(off + c) > 1)
-	    {
-		screen_char_2(off + c, r, c);
-		++c;
-	    }
-	    else
-#endif
-	    {
-		screen_char(off + c, r, c);
-#ifdef FEAT_MBYTE
-		if (utf_off2cells(off + c) > 1)
-		    ++c;
-#endif
-	    }
-	}
-    }
-    screen_char_attr = 0;
-}
-#endif
-
-#ifdef FEAT_VERTSPLIT
-/*
- * Redraw the characters for a vertically split window.
- */
-    static void
-redraw_block(row, end, wp)
-    int		row;
-    int		end;
-    win_T	*wp;
-{
-    int		col;
-    int		width;
-
-# ifdef FEAT_CLIPBOARD
-    clip_may_clear_selection(row, end - 1);
-# endif
-
-    if (wp == NULL)
-    {
-	col = 0;
-	width = Columns;
-    }
-    else
-    {
-	col = wp->w_wincol;
-	width = wp->w_width;
-    }
-    screen_draw_rectangle(row, col, end - row, width, FALSE);
-}
-#endif
-
-/*
- * Fill the screen from 'start_row' to 'end_row', from 'start_col' to 'end_col'
- * with character 'c1' in first column followed by 'c2' in the other columns.
- * Use attributes 'attr'.
- */
-    void
-screen_fill(start_row, end_row, start_col, end_col, c1, c2, attr)
-    int	    start_row, end_row;
-    int	    start_col, end_col;
-    int	    c1, c2;
-    int	    attr;
-{
-    int		    row;
-    int		    col;
-    int		    off;
-    int		    end_off;
-    int		    did_delete;
-    int		    c;
-    int		    norm_term;
-#if defined(FEAT_GUI) || defined(UNIX)
-    int		    force_next = FALSE;
-#endif
-
-    if (end_row > screen_Rows)		/* safety check */
-	end_row = screen_Rows;
-    if (end_col > screen_Columns)	/* safety check */
-	end_col = screen_Columns;
-    if (ScreenLines == NULL
-	    || start_row >= end_row
-	    || start_col >= end_col)	/* nothing to do */
-	return;
-
-    /* it's a "normal" terminal when not in a GUI or cterm */
-    norm_term = (
-#ifdef FEAT_GUI
-	    !gui.in_use &&
-#endif
-			    t_colors <= 1);
-    for (row = start_row; row < end_row; ++row)
-    {
-	/*
-	 * Try to use delete-line termcap code, when no attributes or in a
-	 * "normal" terminal, where a bold/italic space is just a
-	 * space.
-	 */
-	did_delete = FALSE;
-	if (c2 == ' '
-		&& end_col == Columns
-		&& can_clear(T_CE)
-		&& (attr == 0
-		    || (norm_term
-			&& attr <= HL_ALL
-			&& ((attr & ~(HL_BOLD | HL_ITALIC)) == 0))))
-	{
-	    /*
-	     * check if we really need to clear something
-	     */
-	    col = start_col;
-	    if (c1 != ' ')			/* don't clear first char */
-		++col;
-
-	    off = LineOffset[row] + col;
-	    end_off = LineOffset[row] + end_col;
-
-	    /* skip blanks (used often, keep it fast!) */
-#ifdef FEAT_MBYTE
-	    if (enc_utf8)
-		while (off < end_off && ScreenLines[off] == ' '
-			  && ScreenAttrs[off] == 0 && ScreenLinesUC[off] == 0)
-		    ++off;
-	    else
-#endif
-		while (off < end_off && ScreenLines[off] == ' '
-						     && ScreenAttrs[off] == 0)
-		    ++off;
-	    if (off < end_off)		/* something to be cleared */
-	    {
-		col = off - LineOffset[row];
-		screen_stop_highlight();
-		term_windgoto(row, col);/* clear rest of this screen line */
-		out_str(T_CE);
-		screen_start();		/* don't know where cursor is now */
-		col = end_col - col;
-		while (col--)		/* clear chars in ScreenLines */
-		{
-		    ScreenLines[off] = ' ';
-#ifdef FEAT_MBYTE
-		    if (enc_utf8)
-			ScreenLinesUC[off] = 0;
-#endif
-		    ScreenAttrs[off] = 0;
-		    ++off;
-		}
-	    }
-	    did_delete = TRUE;		/* the chars are cleared now */
-	}
-
-	off = LineOffset[row] + start_col;
-	c = c1;
-	for (col = start_col; col < end_col; ++col)
-	{
-	    if (ScreenLines[off] != c
-#ifdef FEAT_MBYTE
-		    || (enc_utf8 && ScreenLinesUC[off] != (c >= 0x80 ? c : 0))
-#endif
-		    || ScreenAttrs[off] != attr
-#if defined(FEAT_GUI) || defined(UNIX)
-		    || force_next
-#endif
-		    )
-	    {
-#if defined(FEAT_GUI) || defined(UNIX)
-		/* The bold trick may make a single row of pixels appear in
-		 * the next character.  When a bold character is removed, the
-		 * next character should be redrawn too.  This happens for our
-		 * own GUI and for some xterms.  */
-		if (
-# ifdef FEAT_GUI
-			gui.in_use
-# endif
-# if defined(FEAT_GUI) && defined(UNIX)
-			||
-# endif
-# ifdef UNIX
-			term_is_xterm
-# endif
-		   )
-		{
-		    if (ScreenLines[off] != ' '
-			    && (ScreenAttrs[off] > HL_ALL
-				|| ScreenAttrs[off] & HL_BOLD))
-			force_next = TRUE;
-		    else
-			force_next = FALSE;
-		}
-#endif
-		ScreenLines[off] = c;
-#ifdef FEAT_MBYTE
-		if (enc_utf8)
-		{
-		    if (c >= 0x80)
-		    {
-			ScreenLinesUC[off] = c;
-			ScreenLinesC1[off] = 0;
-			ScreenLinesC2[off] = 0;
-		    }
-		    else
-			ScreenLinesUC[off] = 0;
-		}
-#endif
-		ScreenAttrs[off] = attr;
-		if (!did_delete || c != ' ')
-		    screen_char(off, row, col);
-	    }
-	    ++off;
-	    if (col == start_col)
-	    {
-		if (did_delete)
-		    break;
-		c = c2;
-	    }
-	}
-	if (end_col == Columns)
-	    LineWraps[row] = FALSE;
-	if (row == Rows - 1)		/* overwritten the command line */
-	{
-	    redraw_cmdline = TRUE;
-	    if (c1 == ' ' && c2 == ' ')
-		clear_cmdline = FALSE;	/* command line has been cleared */
-	}
-    }
-}
-
-/*
- * Check if there should be a delay.  Used before clearing or redrawing the
- * screen or the command line.
- */
-    void
-check_for_delay(check_msg_scroll)
-    int	    check_msg_scroll;
-{
-    if ((emsg_on_display || (check_msg_scroll && msg_scroll))
-	    && !did_wait_return
-	    && emsg_silent == 0)
-    {
-	out_flush();
-	ui_delay(1000L, TRUE);
-	emsg_on_display = FALSE;
-	if (check_msg_scroll)
-	    msg_scroll = FALSE;
-    }
-}
-
-/*
- * screen_valid -  allocate screen buffers if size changed
- *   If "clear" is TRUE: clear screen if it has been resized.
- *	Returns TRUE if there is a valid screen to write to.
- *	Returns FALSE when starting up and screen not initialized yet.
- */
-    int
-screen_valid(clear)
-    int	    clear;
-{
-    screenalloc(clear);	    /* allocate screen buffers if size changed */
-    return (ScreenLines != NULL);
-}
-
-/*
- * Resize the shell to Rows and Columns.
- * Allocate ScreenLines[] and associated items.
- *
- * There may be some time between setting Rows and Columns and (re)allocating
- * ScreenLines[].  This happens when starting up and when (manually) changing
- * the shell size.  Always use screen_Rows and screen_Columns to access items
- * in ScreenLines[].  Use Rows and Columns for positioning text etc. where the
- * final size of the shell is needed.
- */
-    void
-screenalloc(clear)
-    int	    clear;
-{
-    int		    new_row, old_row;
-#ifdef FEAT_GUI
-    int		    old_Rows;
-#endif
-    win_T	    *wp;
-    int		    outofmem = FALSE;
-    int		    len;
-    schar_T	    *new_ScreenLines;
-#ifdef FEAT_MBYTE
-    u8char_T	    *new_ScreenLinesUC = NULL;
-    u8char_T	    *new_ScreenLinesC1 = NULL;
-    u8char_T	    *new_ScreenLinesC2 = NULL;
-    schar_T	    *new_ScreenLines2 = NULL;
-#endif
-    sattr_T	    *new_ScreenAttrs;
-    unsigned	    *new_LineOffset;
-    char_u	    *new_LineWraps;
-    static int	    entered = FALSE;		/* avoid recursiveness */
-
-    /*
-     * Allocation of the screen buffers is done only when the size changes and
-     * when Rows and Columns have been set and we have started doing full
-     * screen stuff.
-     */
-    if ((ScreenLines != NULL
-		&& Rows == screen_Rows
-		&& Columns == screen_Columns
-#ifdef FEAT_MBYTE
-		&& enc_utf8 == (ScreenLinesUC != NULL)
-		&& (enc_dbcs == DBCS_JPNU) == (ScreenLines2 != NULL)
-#endif
-		)
-	    || Rows == 0
-	    || Columns == 0
-	    || (!full_screen && ScreenLines == NULL))
-	return;
-
-    /*
-     * It's possible that we produce an out-of-memory message below, which
-     * will cause this function to be called again.  To break the loop, just
-     * return here.
-     */
-    if (entered)
-	return;
-    entered = TRUE;
-
-    win_new_shellsize();    /* fit the windows in the new sized shell */
-
-#ifdef FEAT_GUI_BEOS
-    vim_lock_screen();  /* be safe, put it here */
-#endif
-
-    comp_col();		/* recompute columns for shown command and ruler */
-
-    /*
-     * We're changing the size of the screen.
-     * - Allocate new arrays for ScreenLines and ScreenAttrs.
-     * - Move lines from the old arrays into the new arrays, clear extra
-     *	 lines (unless the screen is going to be cleared).
-     * - Free the old arrays.
-     *
-     * If anything fails, make ScreenLines NULL, so we don't do anything!
-     * Continuing with the old ScreenLines may result in a crash, because the
-     * size is wrong.
-     */
-#ifdef FEAT_WINDOWS
-    for (wp = firstwin; wp; wp = wp->w_next)
-	win_free_lsize(wp);
-#else
-	win_free_lsize(curwin);
-#endif
-
-    new_ScreenLines = (schar_T *)lalloc((long_u)(
-			      (Rows + 1) * Columns * sizeof(schar_T)), FALSE);
-#ifdef FEAT_MBYTE
-    if (enc_utf8)
-    {
-	new_ScreenLinesUC = (u8char_T *)lalloc((long_u)(
-			     (Rows + 1) * Columns * sizeof(u8char_T)), FALSE);
-	new_ScreenLinesC1 = (u8char_T *)lalloc((long_u)(
-			     (Rows + 1) * Columns * sizeof(u8char_T)), FALSE);
-	new_ScreenLinesC2 = (u8char_T *)lalloc((long_u)(
-			     (Rows + 1) * Columns * sizeof(u8char_T)), FALSE);
-    }
-    if (enc_dbcs == DBCS_JPNU)
-	new_ScreenLines2 = (schar_T *)lalloc((long_u)(
-			     (Rows + 1) * Columns * sizeof(schar_T)), FALSE);
-#endif
-    new_ScreenAttrs = (sattr_T *)lalloc((long_u)(
-			      (Rows + 1) * Columns * sizeof(sattr_T)), FALSE);
-    new_LineOffset = (unsigned *)lalloc((long_u)(
-					 Rows * sizeof(unsigned)), FALSE);
-    new_LineWraps = (char_u *)lalloc((long_u)(Rows * sizeof(char_u)), FALSE);
-
-    FOR_ALL_WINDOWS(wp)
-    {
-	if (win_alloc_lines(wp) == FAIL)
-	{
-	    outofmem = TRUE;
-#ifdef FEAT_WINDOWS
-	    break;
-#endif
-	}
-    }
-
-    if (new_ScreenLines == NULL
-#ifdef FEAT_MBYTE
-	    || (enc_utf8 && (new_ScreenLinesUC == NULL
-		   || new_ScreenLinesC1 == NULL || new_ScreenLinesC2 == NULL))
-	    || (enc_dbcs == DBCS_JPNU && new_ScreenLines2 == NULL)
-#endif
-	    || new_ScreenAttrs == NULL
-	    || new_LineOffset == NULL
-	    || new_LineWraps == NULL
-	    || outofmem)
-    {
-	do_outofmem_msg((long_u)((Rows + 1) * Columns));    /* guess the size */
-	vim_free(new_ScreenLines);
-	new_ScreenLines = NULL;
-#ifdef FEAT_MBYTE
-	vim_free(new_ScreenLinesUC);
-	new_ScreenLinesUC = NULL;
-	vim_free(new_ScreenLinesC1);
-	new_ScreenLinesC1 = NULL;
-	vim_free(new_ScreenLinesC2);
-	new_ScreenLinesC2 = NULL;
-	vim_free(new_ScreenLines2);
-	new_ScreenLines2 = NULL;
-#endif
-	vim_free(new_ScreenAttrs);
-	new_ScreenAttrs = NULL;
-	vim_free(new_LineOffset);
-	new_LineOffset = NULL;
-	vim_free(new_LineWraps);
-	new_LineWraps = NULL;
-    }
-    else
-    {
-	for (new_row = 0; new_row < Rows; ++new_row)
-	{
-	    new_LineOffset[new_row] = new_row * Columns;
-	    new_LineWraps[new_row] = FALSE;
-
-	    /*
-	     * If the screen is not going to be cleared, copy as much as
-	     * possible from the old screen to the new one and clear the rest
-	     * (used when resizing the window at the "--more--" prompt or when
-	     * executing an external command, for the GUI).
-	     */
-	    if (!clear)
-	    {
-		(void)vim_memset(new_ScreenLines + new_row * Columns,
-				      ' ', (size_t)Columns * sizeof(schar_T));
-#ifdef FEAT_MBYTE
-		if (enc_utf8)
-		{
-		    (void)vim_memset(new_ScreenLinesUC + new_row * Columns,
-				       0, (size_t)Columns * sizeof(u8char_T));
-		    (void)vim_memset(new_ScreenLinesC1 + new_row * Columns,
-				       0, (size_t)Columns * sizeof(u8char_T));
-		    (void)vim_memset(new_ScreenLinesC2 + new_row * Columns,
-				       0, (size_t)Columns * sizeof(u8char_T));
-		}
-		if (enc_dbcs == DBCS_JPNU)
-		    (void)vim_memset(new_ScreenLines2 + new_row * Columns,
-				       0, (size_t)Columns * sizeof(schar_T));
-#endif
-		(void)vim_memset(new_ScreenAttrs + new_row * Columns,
-					0, (size_t)Columns * sizeof(sattr_T));
-		old_row = new_row + (screen_Rows - Rows);
-		if (old_row >= 0)
-		{
-		    if (screen_Columns < Columns)
-			len = screen_Columns;
-		    else
-			len = Columns;
-#ifdef FEAT_MBYTE
-		    /* When switching to utf-8 don't copy characters, they
-		     * may be invalid now. */
-		    if (!(enc_utf8 && ScreenLinesUC == NULL))
-#endif
-			mch_memmove(new_ScreenLines + new_LineOffset[new_row],
-				ScreenLines + LineOffset[old_row],
-				(size_t)len * sizeof(schar_T));
-#ifdef FEAT_MBYTE
-		    if (enc_utf8 && ScreenLinesUC != NULL)
-		    {
-			mch_memmove(new_ScreenLinesUC + new_LineOffset[new_row],
-				ScreenLinesUC + LineOffset[old_row],
-				(size_t)len * sizeof(u8char_T));
-			mch_memmove(new_ScreenLinesC1 + new_LineOffset[new_row],
-				ScreenLinesC1 + LineOffset[old_row],
-				(size_t)len * sizeof(u8char_T));
-			mch_memmove(new_ScreenLinesC2 + new_LineOffset[new_row],
-				ScreenLinesC2 + LineOffset[old_row],
-				(size_t)len * sizeof(u8char_T));
-		    }
-		    if (enc_dbcs == DBCS_JPNU && ScreenLines2 != NULL)
-			mch_memmove(new_ScreenLines2 + new_LineOffset[new_row],
-				ScreenLines2 + LineOffset[old_row],
-				(size_t)len * sizeof(schar_T));
-#endif
-		    mch_memmove(new_ScreenAttrs + new_LineOffset[new_row],
-			    ScreenAttrs + LineOffset[old_row],
-			    (size_t)len * sizeof(sattr_T));
-		}
-	    }
-	}
-	/* Use the last line of the screen for the current line. */
-	current_ScreenLine = new_ScreenLines + Rows * Columns;
-    }
-
-    vim_free(ScreenLines);
-#ifdef FEAT_MBYTE
-    vim_free(ScreenLinesUC);
-    vim_free(ScreenLinesC1);
-    vim_free(ScreenLinesC2);
-    vim_free(ScreenLines2);
-#endif
-    vim_free(ScreenAttrs);
-    vim_free(LineOffset);
-    vim_free(LineWraps);
-    ScreenLines = new_ScreenLines;
-#ifdef FEAT_MBYTE
-    ScreenLinesUC = new_ScreenLinesUC;
-    ScreenLinesC1 = new_ScreenLinesC1;
-    ScreenLinesC2 = new_ScreenLinesC2;
-    ScreenLines2 = new_ScreenLines2;
-#endif
-    ScreenAttrs = new_ScreenAttrs;
-    LineOffset = new_LineOffset;
-    LineWraps = new_LineWraps;
-
-    /* It's important that screen_Rows and screen_Columns reflect the actual
-     * size of ScreenLines[].  Set them before calling anything. */
-#ifdef FEAT_GUI
-    old_Rows = screen_Rows;
-#endif
-    screen_Rows = Rows;
-    screen_Columns = Columns;
-
-    must_redraw = CLEAR;	/* need to clear the screen later */
-    if (clear)
-	screenclear2();
-
-#ifdef FEAT_GUI
-    else if (gui.in_use
-	    && !gui.starting
-	    && ScreenLines != NULL
-	    && old_Rows != Rows)
-    {
-	(void)gui_redraw_block(0, 0, (int)Rows - 1, (int)Columns - 1, 0);
-	/*
-	 * Adjust the position of the cursor, for when executing an external
-	 * command.
-	 */
-	if (msg_row >= Rows)		/* Rows got smaller */
-	    msg_row = Rows - 1;		/* put cursor at last row */
-	else if (Rows > old_Rows)	/* Rows got bigger */
-	    msg_row += Rows - old_Rows; /* put cursor in same place */
-	if (msg_col >= Columns)		/* Columns got smaller */
-	    msg_col = Columns - 1;	/* put cursor at last column */
-    }
-#endif
-
-#ifdef FEAT_GUI_BEOS
-    vim_unlock_screen();
-#endif
-    entered = FALSE;
-}
-
-    void
-screenclear()
-{
-    check_for_delay(FALSE);
-    screenalloc(FALSE);	    /* allocate screen buffers if size changed */
-    screenclear2();	    /* clear the screen */
-}
-
-    static void
-screenclear2()
-{
-    int	    i;
-
-    if (starting == NO_SCREEN || ScreenLines == NULL
-#ifdef FEAT_GUI
-	    || (gui.in_use && gui.starting)
-#endif
-	    )
-	return;
-
-#ifdef FEAT_GUI
-    if (!gui.in_use)
-#endif
-	screen_attr = -1;	/* force setting the Normal colors */
-    screen_stop_highlight();	/* don't want highlighting here */
-
-#ifdef FEAT_CLIPBOARD
-    /* disable selection without redrawing it */
-    clip_scroll_selection(9999);
-#endif
-
-    /* blank out ScreenLines */
-    for (i = 0; i < Rows; ++i)
-    {
-	lineclear(LineOffset[i], (int)Columns);
-	LineWraps[i] = FALSE;
-    }
-
-    if (can_clear(T_CL))
-    {
-	out_str(T_CL);		/* clear the display */
-	clear_cmdline = FALSE;
-    }
-    else
-    {
-	/* can't clear the screen, mark all chars with invalid attributes */
-	for (i = 0; i < Rows; ++i)
-	    lineinvalid(LineOffset[i], (int)Columns);
-	clear_cmdline = TRUE;
-    }
-
-    screen_cleared = TRUE;	/* can use contents of ScreenLines now */
-
-    win_rest_invalid(firstwin);
-    redraw_cmdline = TRUE;
-    if (must_redraw == CLEAR)	/* no need to clear again */
-	must_redraw = NOT_VALID;
-    compute_cmdrow();
-    msg_row = cmdline_row;	/* put cursor on last line for messages */
-    msg_col = 0;
-    screen_start();		/* don't know where cursor is now */
-    msg_scrolled = 0;		/* can't scroll back */
-    msg_didany = FALSE;
-    msg_didout = FALSE;
-}
-
-/*
- * Clear one line in ScreenLines.
- */
-    static void
-lineclear(off, width)
-    unsigned	off;
-    int		width;
-{
-    (void)vim_memset(ScreenLines + off, ' ', (size_t)width * sizeof(schar_T));
-#ifdef FEAT_MBYTE
-    if (enc_utf8)
-	(void)vim_memset(ScreenLinesUC + off, 0,
-					  (size_t)width * sizeof(u8char_T));
-#endif
-    (void)vim_memset(ScreenAttrs + off, 0, (size_t)width * sizeof(sattr_T));
-}
-
-/*
- * Mark one line in ScreenLines invalid by setting the attributes to an
- * invalid value.
- */
-    static void
-lineinvalid(off, width)
-    unsigned	off;
-    int		width;
-{
-    (void)vim_memset(ScreenAttrs + off, -1, (size_t)width * sizeof(sattr_T));
-}
-
-#ifdef FEAT_VERTSPLIT
-/*
- * Copy part of a Screenline for vertically split window "wp".
- */
-    static void
-linecopy(to, from, wp)
-    int		to;
-    int		from;
-    win_T	*wp;
-{
-    unsigned	off_to = LineOffset[to] + wp->w_wincol;
-    unsigned	off_from = LineOffset[from] + wp->w_wincol;
-
-    mch_memmove(ScreenLines + off_to, ScreenLines + off_from,
-	    wp->w_width * sizeof(schar_T));
-# ifdef FEAT_MBYTE
-    if (enc_utf8)
-    {
-	mch_memmove(ScreenLinesUC + off_to, ScreenLinesUC + off_from,
-		wp->w_width * sizeof(u8char_T));
-	mch_memmove(ScreenLinesC1 + off_to, ScreenLinesC1 + off_from,
-		wp->w_width * sizeof(u8char_T));
-	mch_memmove(ScreenLinesC2 + off_to, ScreenLinesC2 + off_from,
-		wp->w_width * sizeof(u8char_T));
-    }
-    if (enc_dbcs == DBCS_JPNU)
-	mch_memmove(ScreenLines2 + off_to, ScreenLines2 + off_from,
-		wp->w_width * sizeof(schar_T));
-# endif
-    mch_memmove(ScreenAttrs + off_to, ScreenAttrs + off_from,
-	    wp->w_width * sizeof(sattr_T));
-}
-#endif
-
-/*
- * Return TRUE if clearing with term string "p" would work.
- * It can't work when the string is empty or it won't set the right background.
- */
-    int
-can_clear(p)
-    char_u	*p;
-{
-    return (*p != NUL && (t_colors <= 1
-#ifdef FEAT_GUI
-		|| gui.in_use
-#endif
-		|| cterm_normal_bg_color == 0 || *T_UT != NUL));
-}
-
-/*
- * Reset cursor position. Use whenever cursor was moved because of outputting
- * something directly to the screen (shell commands) or a terminal control
- * code.
- */
-    void
-screen_start()
-{
-    screen_cur_row = screen_cur_col = 9999;
-}
-
-/*
- * Note that the cursor has gone down to the next line, column 0.
- * Used for Ex mode.
- */
-    void
-screen_down()
-{
-    screen_cur_col = 0;
-    if (screen_cur_row < Rows - 1)
-	++screen_cur_row;
-}
-
-/*
- * Move the cursor to position "row","col" in the screen.
- * This tries to find the most efficient way to move, minimizing the number of
- * characters sent to the terminal.
- */
-    void
-windgoto(row, col)
-    int	    row;
-    int	    col;
-{
-    char_u	    *p;
-    int		    i;
-    int		    plan;
-    int		    cost;
-    int		    wouldbe_col;
-    int		    noinvcurs;
-    char_u	    *bs;
-    int		    goto_cost;
-    int		    attr;
-
-#define GOTO_COST   7	/* asssume a term_windgoto() takes about 7 chars */
-#define HIGHL_COST  5	/* assume unhighlight takes 5 chars */
-
-#define PLAN_LE	    1
-#define PLAN_CR	    2
-#define PLAN_NL	    3
-#define PLAN_WRITE  4
-    /* Can't use ScreenLines unless initialized */
-    if (ScreenLines == NULL)
-	return;
-
-    if (col != screen_cur_col || row != screen_cur_row)
-    {
-	/* Check for valid position. */
-	if (row < 0)	/* window without text lines? */
-	    row = 0;
-	if (row >= screen_Rows)
-	    row = screen_Rows - 1;
-	if (col >= screen_Columns)
-	    col = screen_Columns - 1;
-
-	/* check if no cursor movement is allowed in highlight mode */
-	if (screen_attr && *T_MS == NUL)
-	    noinvcurs = HIGHL_COST;
-	else
-	    noinvcurs = 0;
-	goto_cost = GOTO_COST + noinvcurs;
-
-	/*
-	 * Plan how to do the positioning:
-	 * 1. Use CR to move it to column 0, same row.
-	 * 2. Use T_LE to move it a few columns to the left.
-	 * 3. Use NL to move a few lines down, column 0.
-	 * 4. Move a few columns to the right with T_ND or by writing chars.
-	 *
-	 * Don't do this if the cursor went beyond the last column, the cursor
-	 * position is unknown then (some terminals wrap, some don't )
-	 *
-	 * First check if the highlighting attibutes allow us to write
-	 * characters to move the cursor to the right.
-	 */
-	if (row >= screen_cur_row && screen_cur_col < Columns)
-	{
-	    /*
-	     * If the cursor is in the same row, bigger col, we can use CR
-	     * or T_LE.
-	     */
-	    bs = NULL;			    /* init for GCC */
-	    attr = screen_attr;
-	    if (row == screen_cur_row && col < screen_cur_col)
-	    {
-		/* "le" is preferred over "bc", because "bc" is obsolete */
-		if (*T_LE)
-		    bs = T_LE;		    /* "cursor left" */
-		else
-		    bs = T_BC;		    /* "backspace character (old) */
-		if (*bs)
-		    cost = (screen_cur_col - col) * (int)STRLEN(bs);
-		else
-		    cost = 999;
-		if (col + 1 < cost)	    /* using CR is less characters */
-		{
-		    plan = PLAN_CR;
-		    wouldbe_col = 0;
-		    cost = 1;		    /* CR is just one character */
-		}
-		else
-		{
-		    plan = PLAN_LE;
-		    wouldbe_col = col;
-		}
-		if (noinvcurs)		    /* will stop highlighting */
-		{
-		    cost += noinvcurs;
-		    attr = 0;
-		}
-	    }
-
-	    /*
-	     * If the cursor is above where we want to be, we can use CR LF.
-	     */
-	    else if (row > screen_cur_row)
-	    {
-		plan = PLAN_NL;
-		wouldbe_col = 0;
-		cost = (row - screen_cur_row) * 2;  /* CR LF */
-		if (noinvcurs)		    /* will stop highlighting */
-		{
-		    cost += noinvcurs;
-		    attr = 0;
-		}
-	    }
-
-	    /*
-	     * If the cursor is in the same row, smaller col, just use write.
-	     */
-	    else
-	    {
-		plan = PLAN_WRITE;
-		wouldbe_col = screen_cur_col;
-		cost = 0;
-	    }
-
-	    /*
-	     * Check if any characters that need to be written have the
-	     * correct attributes.  Also avoid UTF-8 characters.
-	     */
-	    i = col - wouldbe_col;
-	    if (i > 0)
-		cost += i;
-	    if (cost < goto_cost && i > 0)
-	    {
-		/*
-		 * Check if the attributes are correct without additionally
-		 * stopping highlighting.
-		 */
-		p = ScreenAttrs + LineOffset[row] + wouldbe_col;
-		while (i && *p++ == attr)
-		    --i;
-		if (i != 0)
-		{
-		    /*
-		     * Try if it works when highlighting is stopped here.
-		     */
-		    if (*--p == 0)
-		    {
-			cost += noinvcurs;
-			while (i && *p++ == 0)
-			    --i;
-		    }
-		    if (i != 0)
-			cost = 999;	/* different attributes, don't do it */
-		}
-#ifdef FEAT_MBYTE
-		if (enc_utf8)
-		{
-		    /* Don't use an UTF-8 char for positioning, it's slow. */
-		    for (i = wouldbe_col; i < col; ++i)
-			if (ScreenLinesUC[LineOffset[row] + i] != 0)
-			{
-			    cost = 999;
-			    break;
-			}
-		}
-#endif
-	    }
-
-	    /*
-	     * We can do it without term_windgoto()!
-	     */
-	    if (cost < goto_cost)
-	    {
-		if (plan == PLAN_LE)
-		{
-		    if (noinvcurs)
-			screen_stop_highlight();
-		    while (screen_cur_col > col)
-		    {
-			out_str(bs);
-			--screen_cur_col;
-		    }
-		}
-		else if (plan == PLAN_CR)
-		{
-		    if (noinvcurs)
-			screen_stop_highlight();
-		    out_char('\r');
-		    screen_cur_col = 0;
-		}
-		else if (plan == PLAN_NL)
-		{
-		    if (noinvcurs)
-			screen_stop_highlight();
-		    while (screen_cur_row < row)
-		    {
-			out_char('\n');
-			++screen_cur_row;
-		    }
-		    screen_cur_col = 0;
-		}
-
-		i = col - screen_cur_col;
-		if (i > 0)
-		{
-		    /*
-		     * Use cursor-right if it's one character only.  Avoids
-		     * removing a line of pixels from the last bold char, when
-		     * using the bold trick in the GUI.
-		     */
-		    if (T_ND[0] != NUL && T_ND[1] == NUL)
-		    {
-			while (i-- > 0)
-			    out_char(*T_ND);
-		    }
-		    else
-		    {
-			int	off;
-
-			off = LineOffset[row] + screen_cur_col;
-			while (i-- > 0)
-			{
-			    if (ScreenAttrs[off] != screen_attr)
-				screen_stop_highlight();
-#ifdef FEAT_MBYTE
-			    out_flush_check();
-#endif
-			    out_char(ScreenLines[off]);
-#ifdef FEAT_MBYTE
-			    if (enc_dbcs == DBCS_JPNU
-						  && ScreenLines[off] == 0x8e)
-				out_char(ScreenLines2[off]);
-#endif
-			    ++off;
-			}
-		    }
-		}
-	    }
-	}
-	else
-	    cost = 999;
-
-	if (cost >= goto_cost)
-	{
-	    if (noinvcurs)
-		screen_stop_highlight();
-	    if (row == screen_cur_row && (col > screen_cur_col) &&
-								*T_CRI != NUL)
-		term_cursor_right(col - screen_cur_col);
-	    else
-		term_windgoto(row, col);
-	}
-	screen_cur_row = row;
-	screen_cur_col = col;
-    }
-}
-
-/*
- * Set cursor to its position in the current window.
- */
-    void
-setcursor()
-{
-    if (redrawing())
-    {
-	validate_cursor();
-	windgoto(W_WINROW(curwin) + curwin->w_wrow,
-		W_WINCOL(curwin) + (
-#ifdef FEAT_RIGHTLEFT
-		curwin->w_p_rl ? ((int)W_WIDTH(curwin) - curwin->w_wcol - (
-# ifdef FEAT_MBYTE
-			has_mbyte ? (*mb_ptr2cells)(ml_get_cursor()) :
-# endif
-			1)) :
-#endif
-							    curwin->w_wcol));
-    }
-}
-
-
-/*
- * insert 'line_count' lines at 'row' in window 'wp'
- * if 'invalid' is TRUE the wp->w_lines[].wl_lnum is invalidated.
- * if 'mayclear' is TRUE the screen will be cleared if it is faster than
- * scrolling.
- * Returns FAIL if the lines are not inserted, OK for success.
- */
-    int
-win_ins_lines(wp, row, line_count, invalid, mayclear)
-    win_T	*wp;
-    int		row;
-    int		line_count;
-    int		invalid;
-    int		mayclear;
-{
-    int		did_delete;
-    int		nextrow;
-    int		lastrow;
-    int		retval;
-
-    if (invalid)
-	wp->w_lines_valid = 0;
-
-    if (wp->w_height < 5)
-	return FAIL;
-
-    if (line_count > wp->w_height - row)
-	line_count = wp->w_height - row;
-
-    retval = win_do_lines(wp, row, line_count, mayclear, FALSE);
-    if (retval != MAYBE)
-	return retval;
-
-    /*
-     * If there is a next window or a status line, we first try to delete the
-     * lines at the bottom to avoid messing what is after the window.
-     * If this fails and there are following windows, don't do anything to avoid
-     * messing up those windows, better just redraw.
-     */
-    did_delete = FALSE;
-#ifdef FEAT_WINDOWS
-    if (wp->w_next != NULL || wp->w_status_height)
-    {
-	if (screen_del_lines(0, W_WINROW(wp) + wp->w_height - line_count,
-				    line_count, (int)Rows, FALSE, NULL) == OK)
-	    did_delete = TRUE;
-	else if (wp->w_next)
-	    return FAIL;
-    }
-#endif
-    /*
-     * if no lines deleted, blank the lines that will end up below the window
-     */
-    if (!did_delete)
-    {
-#ifdef FEAT_WINDOWS
-	wp->w_redr_status = TRUE;
-#endif
-	redraw_cmdline = TRUE;
-	nextrow = W_WINROW(wp) + wp->w_height + W_STATUS_HEIGHT(wp);
-	lastrow = nextrow + line_count;
-	if (lastrow > Rows)
-	    lastrow = Rows;
-	screen_fill(nextrow - line_count, lastrow - line_count,
-		  W_WINCOL(wp), (int)W_ENDCOL(wp),
-		  ' ', ' ', 0);
-    }
-
-    if (screen_ins_lines(0, W_WINROW(wp) + row, line_count, (int)Rows, NULL)
-								      == FAIL)
-    {
-	    /* deletion will have messed up other windows */
-	if (did_delete)
-	{
-#ifdef FEAT_WINDOWS
-	    wp->w_redr_status = TRUE;
-#endif
-	    win_rest_invalid(W_NEXT(wp));
-	}
-	return FAIL;
-    }
-
-    return OK;
-}
-
-/*
- * delete "line_count" window lines at "row" in window "wp"
- * If "invalid" is TRUE curwin->w_lines[] is invalidated.
- * If "mayclear" is TRUE the screen will be cleared if it is faster than
- * scrolling
- * Return OK for success, FAIL if the lines are not deleted.
- */
-    int
-win_del_lines(wp, row, line_count, invalid, mayclear)
-    win_T	*wp;
-    int		row;
-    int		line_count;
-    int		invalid;
-    int		mayclear;
-{
-    int		retval;
-
-    if (invalid)
-	wp->w_lines_valid = 0;
-
-    if (line_count > wp->w_height - row)
-	line_count = wp->w_height - row;
-
-    retval = win_do_lines(wp, row, line_count, mayclear, TRUE);
-    if (retval != MAYBE)
-	return retval;
-
-    if (screen_del_lines(0, W_WINROW(wp) + row, line_count,
-					      (int)Rows, FALSE, NULL) == FAIL)
-	return FAIL;
-
-#ifdef FEAT_WINDOWS
-    /*
-     * If there are windows or status lines below, try to put them at the
-     * correct place. If we can't do that, they have to be redrawn.
-     */
-    if (wp->w_next || wp->w_status_height || cmdline_row < Rows - 1)
-    {
-	if (screen_ins_lines(0, W_WINROW(wp) + wp->w_height - line_count,
-					 line_count, (int)Rows, NULL) == FAIL)
-	{
-	    wp->w_redr_status = TRUE;
-	    win_rest_invalid(wp->w_next);
-	}
-    }
-    /*
-     * If this is the last window and there is no status line, redraw the
-     * command line later.
-     */
-    else
-#endif
-	redraw_cmdline = TRUE;
-    return OK;
-}
-
-/*
- * Common code for win_ins_lines() and win_del_lines().
- * Returns OK or FAIL when the work has been done.
- * Returns MAYBE when not finished yet.
- */
-    static int
-win_do_lines(wp, row, line_count, mayclear, del)
-    win_T	*wp;
-    int		row;
-    int		line_count;
-    int		mayclear;
-    int		del;
-{
-    int		retval;
-
-    if (!redrawing() || line_count <= 0)
-	return FAIL;
-
-    /* only a few lines left: redraw is faster */
-    if (mayclear && Rows - line_count < 5
-#ifdef FEAT_VERTSPLIT
-	    && wp->w_width == Columns
-#endif
-	    )
-    {
-	screenclear();	    /* will set wp->w_lines_valid to 0 */
-	return FAIL;
-    }
-
-    /*
-     * Delete all remaining lines
-     */
-    if (row + line_count >= wp->w_height)
-    {
-	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + wp->w_height,
-		W_WINCOL(wp), (int)W_ENDCOL(wp),
-		' ', ' ', 0);
-	return OK;
-    }
-
-    /*
-     * when scrolling, the message on the command line should be cleared,
-     * otherwise it will stay there forever.
-     */
-    clear_cmdline = TRUE;
-
-    /*
-     * If the terminal can set a scroll region, use that.
-     * Always do this in a vertically split window.  This will redraw from
-     * ScreenLines[] when t_CV isn't defined.  That's faster than using
-     * win_line().
-     * Don't use a scroll region when we are going to redraw the text, writing
-     * a character in the lower right corner of the scroll region causes a
-     * scroll-up in the DJGPP version.
-     */
-    if (scroll_region
-#ifdef FEAT_VERTSPLIT
-	    || W_WIDTH(wp) != Columns
-#endif
-	    )
-    {
-#ifdef FEAT_VERTSPLIT
-	if (scroll_region && (wp->w_width == Columns || *T_CSV != NUL))
-#endif
-	    scroll_region_set(wp, row);
-	if (del)
-	    retval = screen_del_lines(W_WINROW(wp) + row, 0, line_count,
-					       wp->w_height - row, FALSE, wp);
-	else
-	    retval = screen_ins_lines(W_WINROW(wp) + row, 0, line_count,
-						      wp->w_height - row, wp);
-#ifdef FEAT_VERTSPLIT
-	if (scroll_region && (wp->w_width == Columns || *T_CSV != NUL))
-#endif
-	    scroll_region_reset();
-	return retval;
-    }
-
-#ifdef FEAT_WINDOWS
-    if (wp->w_next != NULL && p_tf) /* don't delete/insert on fast terminal */
-	return FAIL;
-#endif
-
-    return MAYBE;
-}
-
-/*
- * window 'wp' and everything after it is messed up, mark it for redraw
- */
-    static void
-win_rest_invalid(wp)
-    win_T	*wp;
-{
-#ifdef FEAT_WINDOWS
-    while (wp != NULL)
-#else
-    if (wp != NULL)
-#endif
-    {
-	redraw_win_later(wp, NOT_VALID);
-#ifdef FEAT_WINDOWS
-	wp->w_redr_status = TRUE;
-	wp = wp->w_next;
-#endif
-    }
-    redraw_cmdline = TRUE;
-}
-
-/*
- * The rest of the routines in this file perform screen manipulations. The
- * given operation is performed physically on the screen. The corresponding
- * change is also made to the internal screen image. In this way, the editor
- * anticipates the effect of editing changes on the appearance of the screen.
- * That way, when we call screenupdate a complete redraw isn't usually
- * necessary. Another advantage is that we can keep adding code to anticipate
- * screen changes, and in the meantime, everything still works.
- */
-
-/*
- * types for inserting or deleting lines
- */
-#define USE_T_CAL   1
-#define USE_T_CDL   2
-#define USE_T_AL    3
-#define USE_T_CE    4
-#define USE_T_DL    5
-#define USE_T_SR    6
-#define USE_NL	    7
-#define USE_T_CD    8
-#define USE_REDRAW  9
-
-/*
- * insert lines on the screen and update ScreenLines[]
- * 'end' is the line after the scrolled part. Normally it is Rows.
- * When scrolling region used 'off' is the offset from the top for the region.
- * 'row' and 'end' are relative to the start of the region.
- *
- * return FAIL for failure, OK for success.
- */
-    static int
-screen_ins_lines(off, row, line_count, end, wp)
-    int		off;
-    int		row;
-    int		line_count;
-    int		end;
-    win_T	*wp;	    /* NULL or window to use width from */
-{
-    int		i;
-    int		j;
-    unsigned	temp;
-    int		cursor_row;
-    int		type;
-    int		result_empty;
-    int		can_ce = can_clear(T_CE);
-
-    /*
-     * FAIL if
-     * - there is no valid screen
-     * - the screen has to be redrawn completely
-     * - the line count is less than one
-     * - the line count is more than 'ttyscroll'
-     */
-    if (!screen_valid(TRUE) || line_count <= 0 || line_count > p_ttyscroll)
-	return FAIL;
-
-    /*
-     * There are seven ways to insert lines:
-     * 0. When in a vertically split window and t_CV isn't set, redraw the
-     *    characters from ScreenLines[].
-     * 1. Use T_CD (clear to end of display) if it exists and the result of
-     *	  the insert is just empty lines
-     * 2. Use T_CAL (insert multiple lines) if it exists and T_AL is not
-     *	  present or line_count > 1. It looks better if we do all the inserts
-     *	  at once.
-     * 3. Use T_CDL (delete multiple lines) if it exists and the result of the
-     *	  insert is just empty lines and T_CE is not present or line_count >
-     *	  1.
-     * 4. Use T_AL (insert line) if it exists.
-     * 5. Use T_CE (erase line) if it exists and the result of the insert is
-     *	  just empty lines.
-     * 6. Use T_DL (delete line) if it exists and the result of the insert is
-     *	  just empty lines.
-     * 7. Use T_SR (scroll reverse) if it exists and inserting at row 0 and
-     *	  the 'da' flag is not set or we have clear line capability.
-     * 8. redraw the characters from ScreenLines[].
-     *
-     * Careful: In a hpterm scroll reverse doesn't work as expected, it moves
-     * the scrollbar for the window. It does have insert line, use that if it
-     * exists.
-     */
-    result_empty = (row + line_count >= end);
-#ifdef FEAT_VERTSPLIT
-    if (wp != NULL && wp->w_width != Columns && *T_CSV == NUL)
-	type = USE_REDRAW;
-    else
-#endif
-    if (can_clear(T_CD) && result_empty)
-	type = USE_T_CD;
-    else if (*T_CAL != NUL && (line_count > 1 || *T_AL == NUL))
-	type = USE_T_CAL;
-    else if (*T_CDL != NUL && result_empty && (line_count > 1 || !can_ce))
-	type = USE_T_CDL;
-    else if (*T_AL != NUL)
-	type = USE_T_AL;
-    else if (can_ce && result_empty)
-	type = USE_T_CE;
-    else if (*T_DL != NUL && result_empty)
-	type = USE_T_DL;
-    else if (*T_SR != NUL && row == 0 && (*T_DA == NUL || can_ce))
-	type = USE_T_SR;
-    else
-	return FAIL;
-
-    /*
-     * For clearing the lines screen_del_lines() is used. This will also take
-     * care of t_db if necessary.
-     */
-    if (type == USE_T_CD || type == USE_T_CDL ||
-					 type == USE_T_CE || type == USE_T_DL)
-	return screen_del_lines(off, row, line_count, end, FALSE, wp);
-
-    /*
-     * If text is retained below the screen, first clear or delete as many
-     * lines at the bottom of the window as are about to be inserted so that
-     * the deleted lines won't later surface during a screen_del_lines.
-     */
-    if (*T_DB)
-	screen_del_lines(off, end - line_count, line_count, end, FALSE, wp);
-
-#ifdef FEAT_CLIPBOARD
-    /* Remove a modeless selection when inserting lines halfway the screen
-     * or not the full width of the screen. */
-    if (off + row > 0
-# ifdef FEAT_VERTSPLIT
-	    || (wp != NULL && wp->w_width != Columns)
-# endif
-       )
-	clip_clear_selection();
-    else
-	clip_scroll_selection(-line_count);
-#endif
-
-#ifdef FEAT_GUI_BEOS
-    vim_lock_screen();
-#endif
-#ifdef FEAT_GUI
-    /* Don't update the GUI cursor here, ScreenLines[] is invalid until the
-     * scrolling is actually carried out. */
-    gui_dont_update_cursor();
-#endif
-
-    if (*T_CCS != NUL)	   /* cursor relative to region */
-	cursor_row = row;
-    else
-	cursor_row = row + off;
-
-    /*
-     * Shift LineOffset[] line_count down to reflect the inserted lines.
-     * Clear the inserted lines in ScreenLines[].
-     */
-    row += off;
-    end += off;
-    for (i = 0; i < line_count; ++i)
-    {
-#ifdef FEAT_VERTSPLIT
-	if (wp != NULL && wp->w_width != Columns)
-	{
-	    /* need to copy part of a line */
-	    j = end - 1 - i;
-	    while ((j -= line_count) >= row)
-		linecopy(j + line_count, j, wp);
-	    j += line_count;
-	    if (can_clear((char_u *)" "))
-		lineclear(LineOffset[j] + wp->w_wincol, wp->w_width);
-	    else
-		lineinvalid(LineOffset[j] + wp->w_wincol, wp->w_width);
-	    LineWraps[j] = FALSE;
-	}
-	else
-#endif
-	{
-	    j = end - 1 - i;
-	    temp = LineOffset[j];
-	    while ((j -= line_count) >= row)
-	    {
-		LineOffset[j + line_count] = LineOffset[j];
-		LineWraps[j + line_count] = LineWraps[j];
-	    }
-	    LineOffset[j + line_count] = temp;
-	    LineWraps[j + line_count] = FALSE;
-	    if (can_clear((char_u *)" "))
-		lineclear(temp, (int)Columns);
-	    else
-		lineinvalid(temp, (int)Columns);
-	}
-    }
-#ifdef FEAT_GUI_BEOS
-    vim_unlock_screen();
-#endif
-
-    screen_stop_highlight();
-    windgoto(cursor_row, 0);
-
-#ifdef FEAT_VERTSPLIT
-    /* redraw the characters */
-    if (type == USE_REDRAW)
-	redraw_block(row, end, wp);
-    else
-#endif
-	if (type == USE_T_CAL)
-    {
-	term_append_lines(line_count);
-	screen_start();		/* don't know where cursor is now */
-    }
-    else
-    {
-	for (i = 0; i < line_count; i++)
-	{
-	    if (type == USE_T_AL)
-	    {
-		if (i && cursor_row != 0)
-		    windgoto(cursor_row, 0);
-		out_str(T_AL);
-	    }
-	    else  /* type == USE_T_SR */
-		out_str(T_SR);
-	    screen_start();	    /* don't know where cursor is now */
-	}
-    }
-
-    /*
-     * With scroll-reverse and 'da' flag set we need to clear the lines that
-     * have been scrolled down into the region.
-     */
-    if (type == USE_T_SR && *T_DA)
-    {
-	for (i = 0; i < line_count; ++i)
-	{
-	    windgoto(off + i, 0);
-	    out_str(T_CE);
-	    screen_start();	    /* don't know where cursor is now */
-	}
-    }
-
-#ifdef FEAT_GUI
-    gui_can_update_cursor();
-    if (gui.in_use)
-	out_flush();	/* always flush after a scroll */
-#endif
-    return OK;
-}
-
-/*
- * delete lines on the screen and update ScreenLines[]
- * 'end' is the line after the scrolled part. Normally it is Rows.
- * When scrolling region used 'off' is the offset from the top for the region.
- * 'row' and 'end' are relative to the start of the region.
- *
- * Return OK for success, FAIL if the lines are not deleted.
- */
-/*ARGSUSED*/
-    int
-screen_del_lines(off, row, line_count, end, force, wp)
-    int		off;
-    int		row;
-    int		line_count;
-    int		end;
-    int		force;		/* even when line_count > p_ttyscroll */
-    win_T	*wp;		/* NULL or window to use width from */
-{
-    int		j;
-    int		i;
-    unsigned	temp;
-    int		cursor_row;
-    int		cursor_end;
-    int		result_empty;	/* result is empty until end of region */
-    int		can_delete;	/* deleting line codes can be used */
-    int		type;
-
-    /*
-     * FAIL if
-     * - there is no valid screen
-     * - the screen has to be redrawn completely
-     * - the line count is less than one
-     * - the line count is more than 'ttyscroll'
-     */
-    if (!screen_valid(TRUE) || line_count <= 0 ||
-					 (!force && line_count > p_ttyscroll))
-	return FAIL;
-
-    /*
-     * Check if the rest of the current region will become empty.
-     */
-    result_empty = row + line_count >= end;
-
-    /*
-     * We can delete lines only when 'db' flag not set or when 'ce' option
-     * available.
-     */
-    can_delete = (*T_DB == NUL || can_clear(T_CE));
-
-    /*
-     * There are six ways to delete lines:
-     * 0. When in a vertically split window and t_CV isn't set, redraw the
-     *    characters from ScreenLines[].
-     * 1. Use T_CD if it exists and the result is empty.
-     * 2. Use newlines if row == 0 and count == 1 or T_CDL does not exist.
-     * 3. Use T_CDL (delete multiple lines) if it exists and line_count > 1 or
-     *	  none of the other ways work.
-     * 4. Use T_CE (erase line) if the result is empty.
-     * 5. Use T_DL (delete line) if it exists.
-     * 6. redraw the characters from ScreenLines[].
-     */
-#ifdef FEAT_VERTSPLIT
-    if (wp != NULL && wp->w_width != Columns && *T_CSV == NUL)
-	type = USE_REDRAW;
-    else
-#endif
-    if (can_clear(T_CD) && result_empty)
-	type = USE_T_CD;
-#if defined(__BEOS__) && defined(BEOS_DR8)
-    /*
-     * USE_NL does not seem to work in Terminal of DR8 so we set T_DB="" in
-     * its internal termcap... this works okay for tests which test *T_DB !=
-     * NUL.  It has the disadvantage that the user cannot use any :set t_*
-     * command to get T_DB (back) to empty_option, only :set term=... will do
-     * the trick...
-     * Anyway, this hack will hopefully go away with the next OS release.
-     * (Olaf Seibert)
-     */
-    else if (row == 0 && T_DB == empty_option
-					&& (line_count == 1 || *T_CDL == NUL))
-#else
-    else if (row == 0 && (
-#ifndef AMIGA
-	/* On the Amiga, somehow '\n' on the last line doesn't always scroll
-	 * up, so use delete-line command */
-			    line_count == 1 ||
-#endif
-						*T_CDL == NUL))
-#endif
-	type = USE_NL;
-    else if (*T_CDL != NUL && line_count > 1 && can_delete)
-	type = USE_T_CDL;
-    else if (can_clear(T_CE) && result_empty
-#ifdef FEAT_VERTSPLIT
-	    && (wp == NULL || wp->w_width == Columns)
-#endif
-	    )
-	type = USE_T_CE;
-    else if (*T_DL != NUL && can_delete)
-	type = USE_T_DL;
-    else if (*T_CDL != NUL && can_delete)
-	type = USE_T_CDL;
-    else
-	return FAIL;
-
-#ifdef FEAT_CLIPBOARD
-    /* Remove a modeless selection when deleting lines halfway the screen or
-     * not the full width of the screen. */
-    if (off + row > 0
-# ifdef FEAT_VERTSPLIT
-	    || (wp != NULL && wp->w_width != Columns)
-# endif
-       )
-	clip_clear_selection();
-    else
-	clip_scroll_selection(line_count);
-#endif
-
-#ifdef FEAT_GUI_BEOS
-    vim_lock_screen();
-#endif
-#ifdef FEAT_GUI
-    /* Don't update the GUI cursor here, ScreenLines[] is invalid until the
-     * scrolling is actually carried out. */
-    gui_dont_update_cursor();
-#endif
-
-    if (*T_CCS != NUL)	    /* cursor relative to region */
-    {
-	cursor_row = row;
-	cursor_end = end;
-    }
-    else
-    {
-	cursor_row = row + off;
-	cursor_end = end + off;
-    }
-
-    /*
-     * Now shift LineOffset[] line_count up to reflect the deleted lines.
-     * Clear the inserted lines in ScreenLines[].
-     */
-    row += off;
-    end += off;
-    for (i = 0; i < line_count; ++i)
-    {
-#ifdef FEAT_VERTSPLIT
-	if (wp != NULL && wp->w_width != Columns)
-	{
-	    /* need to copy part of a line */
-	    j = row + i;
-	    while ((j += line_count) <= end - 1)
-		linecopy(j - line_count, j, wp);
-	    j -= line_count;
-	    if (can_clear((char_u *)" "))
-		lineclear(LineOffset[j] + wp->w_wincol, wp->w_width);
-	    else
-		lineinvalid(LineOffset[j] + wp->w_wincol, wp->w_width);
-	    LineWraps[j] = FALSE;
-	}
-	else
-#endif
-	{
-	    /* whole width, moving the line pointers is faster */
-	    j = row + i;
-	    temp = LineOffset[j];
-	    while ((j += line_count) <= end - 1)
-	    {
-		LineOffset[j - line_count] = LineOffset[j];
-		LineWraps[j - line_count] = LineWraps[j];
-	    }
-	    LineOffset[j - line_count] = temp;
-	    LineWraps[j - line_count] = FALSE;
-	    if (can_clear((char_u *)" "))
-		lineclear(temp, (int)Columns);
-	    else
-		lineinvalid(temp, (int)Columns);
-	}
-    }
-#ifdef FEAT_GUI_BEOS
-    vim_unlock_screen();
-#endif
-
-    screen_stop_highlight();
-
-#ifdef FEAT_VERTSPLIT
-    /* redraw the characters */
-    if (type == USE_REDRAW)
-	redraw_block(row, end, wp);
-    else
-#endif
-	if (type == USE_T_CD)	/* delete the lines */
-    {
-	windgoto(cursor_row, 0);
-	out_str(T_CD);
-	screen_start();			/* don't know where cursor is now */
-    }
-    else if (type == USE_T_CDL)
-    {
-	windgoto(cursor_row, 0);
-	term_delete_lines(line_count);
-	screen_start();			/* don't know where cursor is now */
-    }
-    /*
-     * Deleting lines at top of the screen or scroll region: Just scroll
-     * the whole screen (scroll region) up by outputting newlines on the
-     * last line.
-     */
-    else if (type == USE_NL)
-    {
-	windgoto(cursor_end - 1, 0);
-	for (i = line_count; --i >= 0; )
-	    out_char('\n');		/* cursor will remain on same line */
-    }
-    else
-    {
-	for (i = line_count; --i >= 0; )
-	{
-	    if (type == USE_T_DL)
-	    {
-		windgoto(cursor_row, 0);
-		out_str(T_DL);		/* delete a line */
-	    }
-	    else /* type == USE_T_CE */
-	    {
-		windgoto(cursor_row + i, 0);
-		out_str(T_CE);		/* erase a line */
-	    }
-	    screen_start();		/* don't know where cursor is now */
-	}
-    }
-
-    /*
-     * If the 'db' flag is set, we need to clear the lines that have been
-     * scrolled up at the bottom of the region.
-     */
-    if (*T_DB && (type == USE_T_DL || type == USE_T_CDL))
-    {
-	for (i = line_count; i > 0; --i)
-	{
-	    windgoto(cursor_end - i, 0);
-	    out_str(T_CE);		/* erase a line */
-	    screen_start();		/* don't know where cursor is now */
-	}
-    }
-
-#ifdef FEAT_GUI
-    gui_can_update_cursor();
-    if (gui.in_use)
-	out_flush();	/* always flush after a scroll */
-#endif
-
-    return OK;
-}
-
-/*
- * show the current mode and ruler
- *
- * If clear_cmdline is TRUE, clear the rest of the cmdline.
- * If clear_cmdline is FALSE there may be a message there that needs to be
- * cleared only if a mode is shown.
- * Return the length of the message (0 if no message).
- */
-    int
-showmode()
-{
-    int		need_clear;
-    int		length = 0;
-    int		do_mode;
-    int		attr;
-    int		nwr_save;
-#ifdef FEAT_INS_EXPAND
-    int		sub_attr;
-#endif
-
-    do_mode = (p_smd && ((State & INSERT) || restart_edit
-#ifdef FEAT_VISUAL
-		|| VIsual_active
-#endif
-		));
-    if (do_mode || Recording)
-    {
-	/*
-	 * Don't show mode right now, when not redrawing or inside a mapping.
-	 * Call char_avail() only when we are going to show something, because
-	 * it takes a bit of time.
-	 */
-	if (!redrawing() || (char_avail() && !KeyTyped) || msg_silent != 0)
-	{
-	    redraw_cmdline = TRUE;		/* show mode later */
-	    return 0;
-	}
-
-	nwr_save = need_wait_return;
-
-	/* wait a bit before overwriting an important message */
-	check_for_delay(FALSE);
-
-	/* if the cmdline is more than one line high, erase top lines */
-	need_clear = clear_cmdline;
-	if (clear_cmdline && cmdline_row < Rows - 1)
-	    msg_clr_cmdline();			/* will reset clear_cmdline */
-
-	/* Position on the last line in the window, column 0 */
-	msg_pos_mode();
-	cursor_off();
-	attr = hl_attr(HLF_CM);			/* Highlight mode */
-	if (do_mode)
-	{
-	    MSG_PUTS_ATTR("--", attr);
-#if defined(FEAT_XIM)
-	    if (xic != NULL && im_get_status() && !p_imdisable
-					&& curbuf->b_p_iminsert == B_IMODE_IM)
-# ifdef HAVE_GTK2 /* most of the time, it's not XIM being used */
-		MSG_PUTS_ATTR(" IM", attr);
-# else
-		MSG_PUTS_ATTR(" XIM", attr);
-# endif
-#endif
-#if defined(FEAT_HANGULIN) && defined(FEAT_GUI)
-	    if (gui.in_use)
-	    {
-		if (hangul_input_state_get())
-		    MSG_PUTS_ATTR(" ѱ", attr);   /* HANGUL */
-	    }
-#endif
-#ifdef FEAT_INS_EXPAND
-	    if (edit_submode != NULL)		/* CTRL-X in Insert mode */
-	    {
-		/* These messages can get long, avoid a wrap in a narrow
-		 * window.  Prefer showing edit_submode_extra. */
-		length = (Rows - msg_row) * Columns - 3;
-		if (edit_submode_extra != NULL)
-		    length -= vim_strsize(edit_submode_extra);
-		if (length > 0)
-		{
-		    if (edit_submode_pre != NULL)
-			length -= vim_strsize(edit_submode_pre);
-		    if (length - vim_strsize(edit_submode) > 0)
-		    {
-			if (edit_submode_pre != NULL)
-			    msg_puts_attr(edit_submode_pre, attr);
-			msg_puts_attr(edit_submode, attr);
-		    }
-		    if (edit_submode_extra != NULL)
-		    {
-			MSG_PUTS_ATTR(" ", attr);  /* add a space in between */
-			if ((int)edit_submode_highl < (int)HLF_COUNT)
-			    sub_attr = hl_attr(edit_submode_highl);
-			else
-			    sub_attr = attr;
-			msg_puts_attr(edit_submode_extra, sub_attr);
-		    }
-		}
-		length = 0;
-	    }
-	    else
-#endif
-	    {
-#ifdef FEAT_VREPLACE
-		if (State & VREPLACE_FLAG)
-		    MSG_PUTS_ATTR(_(" VREPLACE"), attr);
-		else
-#endif
-		    if (State & REPLACE_FLAG)
-		    MSG_PUTS_ATTR(_(" REPLACE"), attr);
-		else if (State & INSERT)
-		{
-#ifdef FEAT_RIGHTLEFT
-		    if (p_ri)
-			MSG_PUTS_ATTR(_(" REVERSE"), attr);
-#endif
-		    MSG_PUTS_ATTR(_(" INSERT"), attr);
-		}
-		else if (restart_edit == 'I')
-		    MSG_PUTS_ATTR(_(" (insert)"), attr);
-		else if (restart_edit == 'R')
-		    MSG_PUTS_ATTR(_(" (replace)"), attr);
-		else if (restart_edit == 'V')
-		    MSG_PUTS_ATTR(_(" (vreplace)"), attr);
-#ifdef FEAT_RIGHTLEFT
-		if (p_hkmap)
-		    MSG_PUTS_ATTR(_(" Hebrew"), attr);
-# ifdef FEAT_FKMAP
-		if (p_fkmap)
-		    MSG_PUTS_ATTR(farsi_text_5, attr);
-# endif
-#endif
-#ifdef FEAT_KEYMAP
-		if (State & LANGMAP)
-		{
-# ifdef FEAT_ARABIC
-		    if (curwin->w_p_arab)
-			MSG_PUTS_ATTR(_(" Arabic"), attr);
-		    else
-# endif
-			MSG_PUTS_ATTR(_(" (lang)"), attr);
-		}
-#endif
-		if ((State & INSERT) && p_paste)
-		    MSG_PUTS_ATTR(_(" (paste)"), attr);
-
-#ifdef FEAT_VISUAL
-		if (VIsual_active)
-		{
-		    char *p;
-
-		    /* Don't concatenate separate words to avoid translation
-		     * problems. */
-		    switch ((VIsual_select ? 4 : 0)
-			    + (VIsual_mode == Ctrl_V) * 2
-			    + (VIsual_mode == 'V'))
-		    {
-			case 0:	p = N_(" VISUAL"); break;
-			case 1: p = N_(" VISUAL LINE"); break;
-			case 2: p = N_(" VISUAL BLOCK"); break;
-			case 4: p = N_(" SELECT"); break;
-			case 5: p = N_(" SELECT LINE"); break;
-			default: p = N_(" SELECT BLOCK"); break;
-		    }
-		    MSG_PUTS_ATTR(_(p), attr);
-		}
-#endif
-		MSG_PUTS_ATTR(" --", attr);
-	    }
-	    need_clear = TRUE;
-	}
-	if (Recording
-#ifdef FEAT_INS_EXPAND
-		&& edit_submode == NULL	    /* otherwise it gets too long */
-#endif
-		)
-	{
-	    MSG_PUTS_ATTR(_("recording"), attr);
-	    need_clear = TRUE;
-	}
-	if (need_clear || clear_cmdline)
-	    msg_clr_eos();
-	msg_didout = FALSE;		/* overwrite this message */
-	length = msg_col;
-	msg_col = 0;
-	need_wait_return = nwr_save;	/* never ask for hit-return for this */
-    }
-    else if (clear_cmdline && msg_silent == 0)
-	/* Clear the whole command line.  Will reset "clear_cmdline". */
-	msg_clr_cmdline();
-
-#ifdef FEAT_CMDL_INFO
-# ifdef FEAT_VISUAL
-    /* In Visual mode the size of the selected area must be redrawn. */
-    if (VIsual_active)
-	clear_showcmd();
-# endif
-
-    /* If the last window has no status line, the ruler is after the mode
-     * message and must be redrawn */
-    if (redrawing()
-# ifdef FEAT_WINDOWS
-	    && lastwin->w_status_height == 0
-# endif
-       )
-	win_redr_ruler(lastwin, TRUE);
-#endif
-    redraw_cmdline = FALSE;
-    clear_cmdline = FALSE;
-
-    return length;
-}
-
-/*
- * Position for a mode message.
- */
-    static void
-msg_pos_mode()
-{
-    msg_col = 0;
-    msg_row = Rows - 1;
-}
-
-/*
- * Delete mode message.  Used when ESC is typed which is expected to end
- * Insert mode (but Insert mode didn't end yet!).
- */
-    void
-unshowmode(force)
-    int	    force;
-{
-    /*
-     * Don't delete it right now, when not redrawing or insided a mapping.
-     */
-    if (!redrawing() || (!force && char_avail() && !KeyTyped))
-	redraw_cmdline = TRUE;		/* delete mode later */
-    else
-    {
-	msg_pos_mode();
-	if (Recording)
-	    MSG_PUTS_ATTR(_("recording"), hl_attr(HLF_CM));
-	msg_clr_eos();
-    }
-}
-
-#if defined(FEAT_WINDOWS) || defined(FEAT_WILDMENU) || defined(FEAT_STL_OPT)
-/*
- * Get the character to use in a status line.  Get its attributes in "*attr".
- */
-    static int
-fillchar_status(attr, is_curwin)
-    int		*attr;
-    int		is_curwin;
-{
-    int fill;
-    if (is_curwin)
-    {
-	*attr = hl_attr(HLF_S);
-	fill = fill_stl;
-    }
-    else
-    {
-	*attr = hl_attr(HLF_SNC);
-	fill = fill_stlnc;
-    }
-    /* Use fill when there is highlighting, and highlighting of current
-     * window differs, or the fillchars differ, or this is not the
-     * current window */
-    if (*attr != 0 && ((hl_attr(HLF_S) != hl_attr(HLF_SNC)
-			|| !is_curwin || firstwin == lastwin)
-		    || (fill_stl != fill_stlnc)))
-	return fill;
-    if (is_curwin)
-	return '^';
-    return '=';
-}
-#endif
-
-#ifdef FEAT_VERTSPLIT
-/*
- * Get the character to use in a separator between vertically split windows.
- * Get its attributes in "*attr".
- */
-    static int
-fillchar_vsep(attr)
-    int	    *attr;
-{
-    *attr = hl_attr(HLF_C);
-    if (*attr == 0 && fill_vert == ' ')
-	return '|';
-    else
-	return fill_vert;
-}
-#endif
-
-/*
- * Return TRUE if redrawing should currently be done.
- */
-    int
-redrawing()
-{
-    return (!RedrawingDisabled
-		       && !(p_lz && char_avail() && !KeyTyped && !do_redraw));
-}
-
-/*
- * Return TRUE if printing messages should currently be done.
- */
-    int
-messaging()
-{
-    return (!(p_lz && char_avail() && !KeyTyped));
-}
-
-/*
- * Show current status info in ruler and various other places
- * If always is FALSE, only show ruler if position has changed.
- */
-    void
-showruler(always)
-    int	    always;
-{
-    if (!always && !redrawing())
-	return;
-#if defined(FEAT_STL_OPT) && defined(FEAT_WINDOWS)
-    if (*p_stl && curwin->w_status_height)
-	win_redr_custom(curwin, FALSE);
-    else
-#endif
-#ifdef FEAT_CMDL_INFO
-	win_redr_ruler(curwin, always);
-#endif
-
-#ifdef FEAT_TITLE
-    if (need_maketitle
-# ifdef FEAT_STL_OPT
-	    || (p_icon && (stl_syntax & STL_IN_ICON))
-	    || (p_title && (stl_syntax & STL_IN_TITLE))
-# endif
-       )
-	maketitle();
-#endif
-}
-
-#ifdef FEAT_CMDL_INFO
-    static void
-win_redr_ruler(wp, always)
-    win_T	*wp;
-    int		always;
-{
-    char_u	buffer[70];
-    int		row;
-    int		fillchar;
-    int		attr;
-    int		empty_line = FALSE;
-    colnr_T	virtcol;
-    int		i;
-    int		o;
-#ifdef FEAT_VERTSPLIT
-    int		this_ru_col;
-    int		off = 0;
-    int		width = Columns;
-# define WITH_OFF(x) x
-# define WITH_WIDTH(x) x
-#else
-# define WITH_OFF(x) 0
-# define WITH_WIDTH(x) Columns
-# define this_ru_col ru_col
-#endif
-
-    /* If 'ruler' off or redrawing disabled, don't do anything */
-    if (!p_ru)
-	return;
-
-    /*
-     * Check if cursor.lnum is valid, since win_redr_ruler() may be called
-     * after deleting lines, before cursor.lnum is corrected.
-     */
-    if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count)
-	return;
-
-#ifdef FEAT_INS_EXPAND
-    /* Don't draw the ruler while doing insert-completion, it might overwrite
-     * the (long) mode message. */
-# ifdef FEAT_WINDOWS
-    if (wp == lastwin && lastwin->w_status_height == 0)
-# endif
-	if (edit_submode != NULL)
-	    return;
-#endif
-
-#ifdef FEAT_STL_OPT
-    if (*p_ruf)
-    {
-	win_redr_custom(wp, TRUE);
-	return;
-    }
-#endif
-
-    /*
-     * Check if not in Insert mode and the line is empty (will show "0-1").
-     */
-    if (!(State & INSERT)
-		&& *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)
-	empty_line = TRUE;
-
-    /*
-     * Only draw the ruler when something changed.
-     */
-    validate_virtcol_win(wp);
-    if (       redraw_cmdline
-	    || always
-	    || wp->w_cursor.lnum != wp->w_ru_cursor.lnum
-	    || wp->w_cursor.col != wp->w_ru_cursor.col
-	    || wp->w_virtcol != wp->w_ru_virtcol
-#ifdef FEAT_VIRTUALEDIT
-	    || wp->w_cursor.coladd != wp->w_ru_cursor.coladd
-#endif
-	    || wp->w_topline != wp->w_ru_topline
-	    || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count
-#ifdef FEAT_DIFF
-	    || wp->w_topfill != wp->w_ru_topfill
-#endif
-	    || empty_line != wp->w_ru_empty)
-    {
-	cursor_off();
-#ifdef FEAT_WINDOWS
-	if (wp->w_status_height)
-	{
-	    row = W_WINROW(wp) + wp->w_height;
-	    fillchar = fillchar_status(&attr, wp == curwin);
-# ifdef FEAT_VERTSPLIT
-	    off = W_WINCOL(wp);
-	    width = W_WIDTH(wp);
-# endif
-	}
-	else
-#endif
-	{
-	    row = Rows - 1;
-	    fillchar = ' ';
-	    attr = 0;
-#ifdef FEAT_VERTSPLIT
-	    width = Columns;
-	    off = 0;
-#endif
-	}
-
-	/* In list mode virtcol needs to be recomputed */
-	virtcol = wp->w_virtcol;
-	if (wp->w_p_list && lcs_tab1 == NUL)
-	{
-	    wp->w_p_list = FALSE;
-	    getvvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);
-	    wp->w_p_list = TRUE;
-	}
-
-	/*
-	 * Some sprintfs return the length, some return a pointer.
-	 * To avoid portability problems we use strlen() here.
-	 */
-	sprintf((char *)buffer, "%ld,",
-		(wp->w_buffer->b_ml.ml_flags & ML_EMPTY)
-		    ? 0L
-		    : (long)(wp->w_cursor.lnum));
-	col_print(buffer + STRLEN(buffer),
-			empty_line ? 0 : (int)wp->w_cursor.col + 1,
-			(int)virtcol + 1);
-
-	/*
-	 * Add a "50%" if there is room for it.
-	 * On the last line, don't print in the last column (scrolls the
-	 * screen up on some terminals).
-	 */
-	i = (int)STRLEN(buffer);
-	get_rel_pos(wp, buffer + i + 1);
-	o = i + vim_strsize(buffer + i + 1);
-#ifdef FEAT_WINDOWS
-	if (wp->w_status_height == 0)	/* can't use last char of screen */
-#endif
-	    ++o;
-#ifdef FEAT_VERTSPLIT
-	this_ru_col = ru_col - (Columns - width);
-	if (this_ru_col < 0)
-	    this_ru_col = 0;
-#endif
-	/* Never use more than half the window/screen width, leave the other
-	 * half for the filename. */
-	if (this_ru_col < (WITH_WIDTH(width) + 1) / 2)
-	    this_ru_col = (WITH_WIDTH(width) + 1) / 2;
-	if (this_ru_col + o < WITH_WIDTH(width))
-	{
-	    while (this_ru_col + o < WITH_WIDTH(width))
-	    {
-#ifdef FEAT_MBYTE
-		if (has_mbyte)
-		    i += (*mb_char2bytes)(fillchar, buffer + i);
-		else
-#endif
-		    buffer[i++] = fillchar;
-		++o;
-	    }
-	    get_rel_pos(wp, buffer + i);
-	}
-	/* Truncate at window boundary. */
-#ifdef FEAT_MBYTE
-	if (has_mbyte)
-	{
-	    o = 0;
-	    for (i = 0; buffer[i] != NUL; i += (*mb_ptr2len_check)(buffer + i))
-	    {
-		o += (*mb_ptr2cells)(buffer + i);
-		if (this_ru_col + o > WITH_WIDTH(width))
-		{
-		    buffer[i] = NUL;
-		    break;
-		}
-	    }
-	}
-	else
-#endif
-	if (this_ru_col + (int)STRLEN(buffer) > WITH_WIDTH(width))
-	    buffer[WITH_WIDTH(width) - this_ru_col] = NUL;
-
-	screen_puts(buffer, row, this_ru_col + WITH_OFF(off), attr);
-	i = redraw_cmdline;
-	screen_fill(row, row + 1,
-		this_ru_col + WITH_OFF(off) + (int)STRLEN(buffer),
-		(int)(WITH_OFF(off) + WITH_WIDTH(width)),
-		fillchar, fillchar, attr);
-	/* don't redraw the cmdline because of showing the ruler */
-	redraw_cmdline = i;
-	wp->w_ru_cursor = wp->w_cursor;
-	wp->w_ru_virtcol = wp->w_virtcol;
-	wp->w_ru_empty = empty_line;
-	wp->w_ru_topline = wp->w_topline;
-	wp->w_ru_line_count = wp->w_buffer->b_ml.ml_line_count;
-#ifdef FEAT_DIFF
-	wp->w_ru_topfill = wp->w_topfill;
-#endif
-    }
-}
-#endif
diff -Nur vim63/src/structs.h vim63-bonobo/src/structs.h
--- vim63/src/structs.h	2005-09-09 20:11:10.607751000 +0200
+++ vim63-bonobo/src/structs.h	2005-09-09 20:14:02.759580744 +0200
@@ -1084,6 +1084,10 @@
     char_u	*b_p_bh;	/* 'bufhidden' */
     char_u	*b_p_bt;	/* 'buftype' */
 #endif
+#if defined(FEAT_GUI_COMPONENT)
+    int         emb_buffer;     /* this buffer is associated with the container application,
+                                   and cannot be removed */
+#endif
     int		b_p_bl;		/* 'buflisted' */
 #ifdef FEAT_CINDENT
     int		b_p_cin;	/* 'cindent' */
@@ -1281,6 +1285,9 @@
     int		b_was_netbeans_file;/* TRUE if b_netbeans_file was once set */
 #endif
 
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+    pos_T	b_saved_cursor_pos;	/* start pos of last VIsual */
+#endif
 };
 
 /*
@@ -1773,8 +1780,11 @@
     GtkWidget	*tearoff_handle;
     GtkWidget   *label;		    /* Used by "set wak=" code. */
 #endif
-#ifdef FEAT_GUI_MOTIF
+#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_COMPONENT)
     int		sensitive;	    /* turn button on/off */
+#if defined(FEAT_GUI_COMPONENT)
+    int         dirty;              /* menu item has been updated; container needs to know */
+#endif
 #endif
 #if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MOTIF)
     Pixmap	image;		    /* Toolbar image */
diff -Nur vim63/src/structs.h.orig vim63-bonobo/src/structs.h.orig
--- vim63/src/structs.h.orig	2005-09-09 20:11:09.681892000 +0200
+++ vim63-bonobo/src/structs.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1900 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- */
-
-/*
- * This file contains various definitions of structures that are used by Vim
- */
-
-/*
- * There is something wrong in the SAS compiler that makes typedefs not
- * valid in include files.  Has been fixed in version 6.58.
- */
-#if defined(SASC) && SASC < 658
-typedef long		linenr_T;
-typedef unsigned	colnr_T;
-typedef unsigned short	short_u;
-#endif
-
-/*
- * position in file or buffer
- */
-typedef struct
-{
-    linenr_T	lnum;	/* line number */
-    colnr_T	col;	/* column number */
-#ifdef FEAT_VIRTUALEDIT
-    colnr_T	coladd;
-#endif
-} pos_T;
-
-#ifdef FEAT_VIRTUALEDIT
-# define INIT_POS_T {0, 0, 0}
-#else
-# define INIT_POS_T {0, 0}
-#endif
-
-/*
- * Same, but without coladd.
- */
-typedef struct
-{
-    linenr_T	lnum;	/* line number */
-    colnr_T	col;	/* column number */
-} lpos_T;
-
-/*
- * Structure used for growing arrays.
- * This is used to store information that only grows, is deleted all at
- * once, and needs to be accessed by index.  See ga_clear() and ga_grow().
- */
-typedef struct growarray
-{
-    int	    ga_len;		    /* current number of items used */
-    int	    ga_room;		    /* number of unused items at the end */
-    int	    ga_itemsize;	    /* sizeof one item */
-    int	    ga_growsize;	    /* number of items to grow each time */
-    void    *ga_data;		    /* pointer to the first item */
-} garray_T;
-
-#define GA_EMPTY    {0, 0, 0, 0, NULL}
-
-/*
- * This is here because regexp.h needs pos_T and below regprog_T is used.
- */
-#include "regexp.h"
-
-typedef struct window	win_T;
-typedef struct wininfo	wininfo_T;
-typedef struct frame	frame_T;
-typedef int		scid_T;		/* script ID */
-
-/*
- * This is here because gui.h needs the pos_T and win_T, and win_T needs gui.h
- * for scrollbar_T.
- */
-#ifdef FEAT_GUI
-# include "gui.h"
-#else
-# ifdef FEAT_XCLIPBOARD
-#  include <X11/Intrinsic.h>
-# endif
-# define guicolor_T int		/* avoid error in prototypes */
-#endif
-
-/*
- * marks: positions in a file
- * (a normal mark is a lnum/col pair, the same as a file position)
- */
-
-/* (Note: for EBCDIC there are more than 26, because there are gaps in the
- * alphabet coding.  To minimize changes to the code, I decided to just
- * increase the number of possible marks. */
-#define NMARKS		('z' - 'a' + 1)	/* max. # of named marks */
-#define JUMPLISTSIZE	100		/* max. # of marks in jump list */
-#define TAGSTACKSIZE	20		/* max. # of tags in tag stack */
-
-typedef struct filemark
-{
-    pos_T	mark;		/* cursor position */
-    int		fnum;		/* file number */
-} fmark_T;
-
-/* Xtended file mark: also has a file name */
-typedef struct xfilemark
-{
-    fmark_T	fmark;
-    char_u	*fname;		/* file name, used when fnum == 0 */
-} xfmark_T;
-
-/*
- * The taggy struct is used to store the information about a :tag command.
- */
-typedef struct taggy
-{
-    char_u	*tagname;	/* tag name */
-    fmark_T	fmark;		/* cursor position BEFORE ":tag" */
-    int		cur_match;	/* match number */
-    int		cur_fnum;	/* buffer number used for cur_match */
-} taggy_T;
-
-/*
- * Structure that contains all options that are local to a window.
- * Used twice in a window: for the current buffer and for all buffers.
- * Also used in wininfo_T.
- */
-typedef struct
-{
-#ifdef FEAT_ARABIC
-    int		wo_arab;
-# define w_p_arab w_onebuf_opt.wo_arab	/* 'arabic' */
-#endif
-#ifdef FEAT_DIFF
-    int		wo_diff;
-# define w_p_diff w_onebuf_opt.wo_diff	/* 'diff' */
-#endif
-#ifdef FEAT_FOLDING
-    long	wo_fdc;
-# define w_p_fdc w_onebuf_opt.wo_fdc	/* 'foldcolumn' */
-    int		wo_fen;
-# define w_p_fen w_onebuf_opt.wo_fen	/* 'foldenable' */
-    char_u	*wo_fdi;
-# define w_p_fdi w_onebuf_opt.wo_fdi	/* 'foldignore' */
-    long	wo_fdl;
-# define w_p_fdl w_onebuf_opt.wo_fdl	/* 'foldlevel' */
-    char_u	*wo_fdm;
-# define w_p_fdm w_onebuf_opt.wo_fdm	/* 'foldmethod' */
-    long	wo_fml;
-# define w_p_fml w_onebuf_opt.wo_fml	/* 'foldminlines' */
-    long	wo_fdn;
-# define w_p_fdn w_onebuf_opt.wo_fdn	/* 'foldnextmax' */
-# ifdef FEAT_EVAL
-    char_u	*wo_fde;
-# define w_p_fde w_onebuf_opt.wo_fde	/* 'foldexpr' */
-    char_u	*wo_fdt;
-#  define w_p_fdt w_onebuf_opt.wo_fdt	/* 'foldtext' */
-# endif
-    char_u	*wo_fmr;
-# define w_p_fmr w_onebuf_opt.wo_fmr	/* 'foldmarker' */
-#endif
-#ifdef FEAT_LINEBREAK
-    int		wo_lbr;
-# define w_p_lbr w_onebuf_opt.wo_lbr	/* 'linebreak' */
-#endif
-    int		wo_list;
-#define w_p_list w_onebuf_opt.wo_list	/* 'list' */
-    int		wo_nu;
-#define w_p_nu w_onebuf_opt.wo_nu	/* 'number' */
-#if defined(FEAT_WINDOWS)
-    int		wo_wfh;
-# define w_p_wfh w_onebuf_opt.wo_wfh	/* 'winfixheight' */
-#endif
-#if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-    int		wo_pvw;
-# define w_p_pvw w_onebuf_opt.wo_pvw	/* 'previewwindow' */
-#endif
-#ifdef FEAT_RIGHTLEFT
-    int		wo_rl;
-# define w_p_rl w_onebuf_opt.wo_rl	/* 'rightleft' */
-    char_u	*wo_rlc;
-# define w_p_rlc w_onebuf_opt.wo_rlc	/* 'rightleftcmd' */
-#endif
-    long	wo_scr;
-#define w_p_scr w_onebuf_opt.wo_scr	/* 'scroll' */
-#ifdef FEAT_SCROLLBIND
-    int		wo_scb;
-# define w_p_scb w_onebuf_opt.wo_scb	/* 'scrollbind' */
-#endif
-    int		wo_wrap;
-#define w_p_wrap w_onebuf_opt.wo_wrap	/* 'wrap' */
-} winopt_T;
-
-/*
- * Window info stored with a buffer.
- *
- * Two types of info are kept for a buffer which are associated with a
- * specific window:
- * 1. Each window can have a different line number associated with a buffer.
- * 2. The window-local options for a buffer work in a similar way.
- * The window-info is kept in a list at b_wininfo.  It is kept in
- * most-recently-used order.
- */
-struct wininfo
-{
-    wininfo_T	*wi_next;	/* next entry or NULL for last entry */
-    wininfo_T	*wi_prev;	/* previous entry or NULL for first entry */
-    win_T	*wi_win;	/* pointer to window that did set wi_lnum */
-    pos_T	wi_fpos;	/* last cursor position in the file */
-    int		wi_optset;	/* TRUE when wi_opt has useful values */
-    winopt_T	wi_opt;		/* local window options */
-#ifdef FEAT_FOLDING
-    int		wi_fold_manual;	/* copy of w_fold_manual */
-    garray_T	wi_folds;	/* clone of w_folds */
-#endif
-};
-
-/*
- * Info used to pass info about a fold from the fold-detection code to the
- * code that displays the foldcolumn.
- */
-typedef struct foldinfo
-{
-    int		fi_level;	/* level of the fold; when this is zero the
-				   other fields are invalid */
-    int		fi_lnum;	/* line number where fold starts */
-    int		fi_low_level;	/* lowest fold level that starts in the same
-				   line */
-} foldinfo_T;
-
-/*
- * stuctures used for undo
- */
-
-typedef struct u_entry u_entry_T;
-typedef struct u_header u_header_T;
-struct u_entry
-{
-    u_entry_T	*ue_next;	/* pointer to next entry in list */
-    linenr_T	ue_top;		/* number of line above undo block */
-    linenr_T	ue_bot;		/* number of line below undo block */
-    linenr_T	ue_lcount;	/* linecount when u_save called */
-    char_u	**ue_array;	/* array of lines in undo block */
-    long	ue_size;	/* number of lines in ue_array */
-};
-
-struct u_header
-{
-    u_header_T	*uh_next;	/* pointer to next header in list */
-    u_header_T	*uh_prev;	/* pointer to previous header in list */
-    u_entry_T	*uh_entry;	/* pointer to first entry */
-    u_entry_T	*uh_getbot_entry; /* pointer to where ue_bot must be set */
-    pos_T	uh_cursor;	/* cursor position before saving */
-#ifdef FEAT_VIRTUALEDIT
-    long	uh_cursor_vcol;
-#endif
-    int		uh_flags;	/* see below */
-    pos_T	uh_namedm[NMARKS];	/* marks before undo/after redo */
-};
-
-/* values for uh_flags */
-#define UH_CHANGED  0x01	/* b_changed flag before undo/after redo */
-#define UH_EMPTYBUF 0x02	/* buffer was empty */
-
-/*
- * stuctures used in undo.c
- */
-#if SIZEOF_INT > 2
-# define ALIGN_LONG	/* longword alignment and use filler byte */
-# define ALIGN_SIZE (sizeof(long))
-#else
-# define ALIGN_SIZE (sizeof(short))
-#endif
-
-#define ALIGN_MASK (ALIGN_SIZE - 1)
-
-typedef struct m_info minfo_T;
-
-/*
- * stucture used to link chunks in one of the free chunk lists.
- */
-struct m_info
-{
-#ifdef ALIGN_LONG
-    long_u	m_size;		/* size of the chunk (including m_info) */
-#else
-    short_u	m_size;		/* size of the chunk (including m_info) */
-#endif
-    minfo_T	*m_next;	/* pointer to next free chunk in the list */
-};
-
-/*
- * structure used to link blocks in the list of allocated blocks.
- */
-typedef struct m_block mblock_T;
-struct m_block
-{
-    mblock_T	*mb_next;	/* pointer to next allocated block */
-    size_t	mb_size;	/* total size of all chunks in this block */
-    minfo_T	mb_info;	/* head of free chuck list for this block */
-};
-
-/*
- * things used in memfile.c
- */
-
-typedef struct block_hdr    bhdr_T;
-typedef struct memfile	    memfile_T;
-typedef long		    blocknr_T;
-
-/*
- * for each (previously) used block in the memfile there is one block header.
- *
- * The block may be linked in the used list OR in the free list.
- * The used blocks are also kept in hash lists.
- *
- * The used list is a doubly linked list, most recently used block first.
- *	The blocks in the used list have a block of memory allocated.
- *	mf_used_count is the number of pages in the used list.
- * The hash lists are used to quickly find a block in the used list.
- * The free list is a single linked list, not sorted.
- *	The blocks in the free list have no block of memory allocated and
- *	the contents of the block in the file (if any) is irrelevant.
- */
-
-struct block_hdr
-{
-    bhdr_T	*bh_next;	    /* next block_hdr in free or used list */
-    bhdr_T	*bh_prev;	    /* previous block_hdr in used list */
-    bhdr_T	*bh_hash_next;	    /* next block_hdr in hash list */
-    bhdr_T	*bh_hash_prev;	    /* previous block_hdr in hash list */
-    blocknr_T	bh_bnum;		/* block number */
-    char_u	*bh_data;	    /* pointer to memory (for used block) */
-    int		bh_page_count;	    /* number of pages in this block */
-
-#define BH_DIRTY    1
-#define BH_LOCKED   2
-    char	bh_flags;	    /* BH_DIRTY or BH_LOCKED */
-};
-
-/*
- * when a block with a negative number is flushed to the file, it gets
- * a positive number. Because the reference to the block is still the negative
- * number, we remember the translation to the new positive number in the
- * double linked trans lists. The structure is the same as the hash lists.
- */
-typedef struct nr_trans NR_TRANS;
-
-struct nr_trans
-{
-    NR_TRANS	*nt_next;		/* next nr_trans in hash list */
-    NR_TRANS	*nt_prev;		/* previous nr_trans in hash list */
-    blocknr_T	nt_old_bnum;		/* old, negative, number */
-    blocknr_T	nt_new_bnum;		/* new, positive, number */
-};
-
-/*
- * structure used to store one block of the stuff/redo/recording buffers
- */
-struct buffblock
-{
-    struct buffblock	*b_next;	/* pointer to next buffblock */
-    char_u		b_str[1];	/* contents (actually longer) */
-};
-
-/*
- * header used for the stuff buffer and the redo buffer
- */
-struct buffheader
-{
-    struct buffblock	bh_first;	/* first (dummy) block of list */
-    struct buffblock	*bh_curr;	/* buffblock for appending */
-    int			bh_index;	/* index for reading */
-    int			bh_space;	/* space in bh_curr for appending */
-};
-
-/*
- * used for completion on the command line
- */
-typedef struct expand
-{
-    int		xp_context;		/* type of expansion */
-    char_u	*xp_pattern;		/* start of item to expand */
-#if defined(FEAT_USR_CMDS) && defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
-    char_u	*xp_arg;		/* completion function */
-    int		xp_scriptID;		/* SID for completion function */
-#endif
-    int		xp_backslash;		/* one of the XP_BS_ values */
-    int		xp_numfiles;		/* number of files found by
-						    file name completion */
-    char_u	**xp_files;		/* list of files */
-} expand_T;
-
-/* values for xp_backslash */
-#define XP_BS_NONE	0	/* nothing special for backslashes */
-#define XP_BS_ONE	1	/* uses one backslash before a space */
-#define XP_BS_THREE	2	/* uses three backslashes before a space */
-
-/*
- * Command modifiers ":vertical", ":browse", ":confirm" and ":hide" set a flag.
- * This needs to be saved for recursive commands, put them in a structure for
- * easy manipulation.
- */
-typedef struct
-{
-    int		hide;			/* TRUE when ":hide" was used */
-# ifdef FEAT_BROWSE
-    int		browse;			/* TRUE to invoke file dialog */
-# endif
-# ifdef FEAT_WINDOWS
-    int		split;			/* flags for win_split() */
-# endif
-# if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
-    int		confirm;		/* TRUE to invoke yes/no dialog */
-# endif
-    int		keepmarks;		/* TRUE when ":keepmarks" was used */
-    int		keepjumps;		/* TRUE when ":keepjumps" was used */
-    int		lockmarks;		/* TRUE when ":lockmarks" was used */
-} cmdmod_T;
-
-/*
- * Simplistic hashing scheme to quickly locate the blocks in the used list.
- * 64 blocks are found directly (64 * 4K = 256K, most files are smaller).
- */
-#define MEMHASHSIZE	64
-#define MEMHASH(nr)	((nr) & (MEMHASHSIZE - 1))
-
-struct memfile
-{
-    char_u	*mf_fname;		/* name of the file */
-    char_u	*mf_ffname;		/* idem, full path */
-    int		mf_fd;			/* file descriptor */
-    bhdr_T	*mf_free_first;		/* first block_hdr in free list */
-    bhdr_T	*mf_used_first;		/* mru block_hdr in used list */
-    bhdr_T	*mf_used_last;		/* lru block_hdr in used list */
-    unsigned	mf_used_count;		/* number of pages in used list */
-    unsigned	mf_used_count_max;	/* maximum number of pages in memory */
-    bhdr_T	*mf_hash[MEMHASHSIZE];	/* array of hash lists */
-    NR_TRANS	*mf_trans[MEMHASHSIZE];	/* array of trans lists */
-    blocknr_T	mf_blocknr_max;		/* highest positive block number + 1*/
-    blocknr_T	mf_blocknr_min;		/* lowest negative block number - 1 */
-    blocknr_T	mf_neg_count;		/* number of negative blocks numbers */
-    blocknr_T	mf_infile_count;	/* number of pages in the file */
-    unsigned	mf_page_size;		/* number of bytes in a page */
-    int		mf_dirty;		/* TRUE if there are dirty blocks */
-};
-
-/*
- * things used in memline.c
- */
-/*
- * When searching for a specific line, we remember what blocks in the tree
- * are the branches leading to that block. This is stored in ml_stack.  Each
- * entry is a pointer to info in a block (may be data block or pointer block)
- */
-typedef struct info_pointer
-{
-    blocknr_T	ip_bnum;	/* block number */
-    linenr_T	ip_low;		/* lowest lnum in this block */
-    linenr_T	ip_high;	/* highest lnum in this block */
-    int		ip_index;	/* index for block with current lnum */
-} infoptr_T;	/* block/index pair */
-
-#ifdef FEAT_BYTEOFF
-typedef struct ml_chunksize
-{
-    int		mlcs_numlines;
-    long	mlcs_totalsize;
-} chunksize_T;
-
- /* Flags when calling ml_updatechunk() */
-
-#define ML_CHNK_ADDLINE 1
-#define ML_CHNK_DELLINE 2
-#define ML_CHNK_UPDLINE 3
-#endif
-
-/*
- * the memline structure holds all the information about a memline
- */
-typedef struct memline
-{
-    linenr_T	ml_line_count;	/* number of lines in the buffer */
-
-    memfile_T	*ml_mfp;	/* pointer to associated memfile */
-
-#define ML_EMPTY	1	/* empty buffer */
-#define ML_LINE_DIRTY	2	/* cached line was changed and allocated */
-#define ML_LOCKED_DIRTY	4	/* ml_locked was changed */
-#define ML_LOCKED_POS	8	/* ml_locked needs positive block number */
-    int		ml_flags;
-
-    infoptr_T	*ml_stack;	/* stack of pointer blocks (array of IPTRs) */
-    int		ml_stack_top;	/* current top if ml_stack */
-    int		ml_stack_size;	/* total number of entries in ml_stack */
-
-    linenr_T	ml_line_lnum;	/* line number of cached line, 0 if not valid */
-    char_u	*ml_line_ptr;	/* pointer to cached line */
-
-    bhdr_T	*ml_locked;	/* block used by last ml_get */
-    linenr_T	ml_locked_low;	/* first line in ml_locked */
-    linenr_T	ml_locked_high;	/* last line in ml_locked */
-    int		ml_locked_lineadd;  /* number of lines inserted in ml_locked */
-#ifdef FEAT_BYTEOFF
-    chunksize_T *ml_chunksize;
-    int		ml_numchunks;
-    int		ml_usedchunks;
-#endif
-} memline_T;
-
-#if defined(FEAT_SIGNS) || defined(PROTO)
-typedef struct signlist signlist_T;
-
-struct signlist
-{
-    int		id;		/* unique identifier for each placed sign */
-    linenr_T	lnum;		/* line number which has this sign */
-    int		typenr;		/* typenr of sign */
-    signlist_T	*next;		/* next signlist entry */
-# ifdef FEAT_NETBEANS_INTG
-    signlist_T  *prev;		/* previous entry -- for easy reordering */
-# endif
-};
-
-/* type argument for buf_getsigntype() */
-#define SIGN_ANY	0
-#define SIGN_LINEHL	1
-#define SIGN_ICON	2
-#define SIGN_TEXT	3
-#endif
-
-/*
- * Argument list: Array of file names.
- * Used for the global argument list and the argument lists local to a window.
- */
-typedef struct arglist
-{
-    garray_T	al_ga;		/* growarray with the array of file names */
-    int		al_refcount;	/* number of windows using this arglist */
-} alist_T;
-
-/*
- * For each argument remember the file name as it was given, and the buffer
- * number that contains the expanded file name (required for when ":cd" is
- * used.
- */
-typedef struct argentry
-{
-    char_u	*ae_fname;	/* file name as specified */
-    int		ae_fnum;	/* buffer number with expanded file name */
-} aentry_T;
-
-#ifdef FEAT_WINDOWS
-# define ALIST(win) (win)->w_alist
-#else
-# define ALIST(win) (&global_alist)
-#endif
-#define GARGLIST	((aentry_T *)global_alist.al_ga.ga_data)
-#define ARGLIST		((aentry_T *)ALIST(curwin)->al_ga.ga_data)
-#define WARGLIST(wp)	((aentry_T *)ALIST(wp)->al_ga.ga_data)
-#define AARGLIST(al)	((aentry_T *)((al)->al_ga.ga_data))
-#define GARGCOUNT	(global_alist.al_ga.ga_len)
-#define ARGCOUNT	(ALIST(curwin)->al_ga.ga_len)
-#define WARGCOUNT(wp)	(ALIST(wp)->al_ga.ga_len)
-
-/*
- * A list used for saving values of "emsg_silent".  Used by ex_try() to save the
- * value of "emsg_silent" if it was non-zero.  When this is done, the CSF_SILENT
- * flag below is set.
- */
-
-typedef struct eslist_elem eslist_T;
-struct eslist_elem
-{
-    int		saved_emsg_silent;	/* saved value of "emsg_silent" */
-    eslist_T	*next;			/* next element on the list */
-};
-
-/*
- * For conditional commands a stack is kept of nested conditionals.
- * When cs_idx < 0, there is no conditional command.
- */
-#define CSTACK_LEN	50
-
-struct condstack
-{
-    char	cs_flags[CSTACK_LEN];	/* CSF_ flags */
-    char	cs_pending[CSTACK_LEN];	/* CSTP_: what's pending in ":finally"*/
-    union {
-	void   *cs_pend_rv[CSTACK_LEN];	/* returnval for pending return */
-	void   *cs_pend_ex[CSTACK_LEN];	/* exception for pending throw */
-    }		cs_pend;
-    int		cs_line[CSTACK_LEN];	/* line number of ":while" line */
-    int		cs_idx;			/* current entry, or -1 if none */
-    int		cs_whilelevel;		/* number of nested ":while"s */
-    int		cs_trylevel;		/* number of nested ":try"s */
-    eslist_T	*cs_emsg_silent_list;	/* saved values of "emsg_silent" */
-    char	cs_had_while;		/* just found ":while" */
-    char	cs_had_continue;	/* just found ":continue" */
-    char	cs_had_endwhile;	/* just found ":endwhile" */
-    char	cs_had_finally;		/* just found ":finally" */
-};
-# define cs_retvar	cs_pend.cs_pend_rv
-# define cs_exception	cs_pend.cs_pend_ex
-
-# define CSF_TRUE	1	/* condition was TRUE */
-# define CSF_ACTIVE	2	/* current state is active */
-# define CSF_ELSE	4	/* ":else" has been passed */
-# define CSF_WHILE	8	/* is a ":while" */
-# define CSF_TRY	16	/* is a ":try" */
-# define CSF_FINALLY	32	/* ":finally" has been passed */
-# define CSF_THROWN	64	/* exception thrown to this try conditional */
-# define CSF_CAUGHT	128	/* exception caught by this try conditional */
-# define CSF_SILENT	4	/* "emsg_silent" reset by ":try" */
-/* Note that CSF_ELSE is only used when CSF_TRY and CSF_WHILE are unset
- * (an ":if"), and CSF_SILENT is only used when CSF_TRY is set. */
-
-/*
- * What's pending for being reactivated at the ":endtry" of this try
- * conditional:
- */
-# define CSTP_NONE	0	/* nothing pending in ":finally" clause */
-# define CSTP_ERROR	1	/* an error is pending */
-# define CSTP_INTERRUPT	2	/* an interrupt is pending */
-# define CSTP_THROW	4	/* a throw is pending */
-# define CSTP_BREAK	8	/* ":break" is pending */
-# define CSTP_CONTINUE	16	/* ":continue" is pending */
-# define CSTP_RETURN	24	/* ":return" is pending */
-# define CSTP_FINISH	32	/* ":finish" is pending */
-
-/*
- * A list of error messages that can be converted to an exception.  "throw_msg"
- * is only set in the first element of the list.  Usually, it points to the
- * original message stored in that element, but sometimes it points to a later
- * message in the list.  See cause_errthrow() below.
- */
-struct msglist
-{
-    char_u		*msg;		/* original message */
-    char_u		*throw_msg;	/* msg to throw: usually original one */
-    struct msglist	*next;		/* next of several messages in a row */
-};
-
-/*
- * Structure describing an exception.
- * (don't use "struct exception", it's used by the math library).
- */
-typedef struct vim_exception except_T;
-struct vim_exception
-{
-    int			type;		/* exception type */
-    char_u		*value;		/* exception value */
-    struct msglist	*messages;	/* message(s) causing error exception */
-    char_u		*throw_name;	/* name of the throw point */
-    linenr_T		throw_lnum;	/* line number of the throw point */
-    except_T		*caught;	/* next exception on the caught stack */
-};
-
-/*
- * The exception types.
- */
-#define ET_USER		0	/* exception caused by ":throw" command */
-#define ET_ERROR	1	/* error exception */
-#define ET_INTERRUPT	2	/* interrupt exception triggered by Ctrl-C */
-
-/*
- * Structure to save the error/interrupt/exception state between calls to
- * enter_cleanup() and leave_cleanup().  Must be allocated as an automatic
- * variable by the (common) caller of these functions.
- */
-typedef struct cleanup_stuff cleanup_T;
-struct cleanup_stuff
-{
-    int pending;		/* error/interrupt/exception state */
-    except_T *exception;	/* exception value */
-};
-
-#ifdef FEAT_SYN_HL
-/* struct passed to in_id_list() */
-struct sp_syn
-{
-    int		inc_tag;	/* ":syn include" unique tag */
-    short	id;		/* highlight group ID of item */
-    short	*cont_in_list;	/* cont.in group IDs, if non-zero */
-};
-
-/*
- * Each keyword has one keyentry, which is linked in a hash list.
- */
-typedef struct keyentry keyentry_T;
-
-struct keyentry
-{
-    keyentry_T	*next;		/* next keyword in the hash list */
-    struct sp_syn k_syn;	/* struct passed to in_id_list() */
-    short	*next_list;	/* ID list for next match (if non-zero) */
-    short	flags;		/* see syntax.c */
-    char_u	keyword[1];	/* actually longer */
-};
-
-/*
- * Struct used to store one state of the state stack.
- */
-typedef struct buf_state
-{
-    int		    bs_idx;	 /* index of pattern */
-    long	    bs_flags;	 /* flags for pattern */
-    reg_extmatch_T *bs_extmatch; /* external matches from start pattern */
-} bufstate_T;
-
-/*
- * syn_state contains the syntax state stack for the start of one line.
- * Used by b_sst_array[].
- */
-typedef struct syn_state synstate_T;
-
-struct syn_state
-{
-    synstate_T	*sst_next;	/* next entry in used or free list */
-    linenr_T	sst_lnum;	/* line number for this state */
-    union
-    {
-	bufstate_T	sst_stack[SST_FIX_STATES]; /* short state stack */
-	garray_T	sst_ga;	/* growarray for long state stack */
-    } sst_union;
-    int		sst_next_flags;	/* flags for sst_next_list */
-    short	*sst_next_list;	/* "nextgroup" list in this state
-				 * (this is a copy, don't free it! */
-    short	sst_stacksize;	/* number of states on the stack */
-    disptick_T	sst_tick;	/* tick when last displayed */
-    linenr_T	sst_change_lnum;/* when non-zero, change in this line
-				 * may have made the state invalid */
-};
-#endif /* FEAT_SYN_HL */
-
-/*
- * Structure shared between syntax.c, screen.c and gui_x11.c.
- */
-typedef struct attr_entry
-{
-    short	    ae_attr;		/* HL_BOLD, etc. */
-    union
-    {
-	struct
-	{
-	    char_u	    *start;	/* start escape sequence */
-	    char_u	    *stop;	/* stop escape sequence */
-	} term;
-	struct
-	{
-	    char_u	    fg_color;	/* foreground color number */
-	    char_u	    bg_color;	/* background color number */
-	} cterm;
-# ifdef FEAT_GUI
-	struct
-	{
-	    guicolor_T	    fg_color;	/* foreground color handle */
-	    guicolor_T	    bg_color;	/* background color handle */
-	    GuiFont	    font;	/* font handle */
-#  ifdef FEAT_XFONTSET
-	    GuiFontset	    fontset;	/* fontset handle */
-#  endif
-	} gui;
-# endif
-    } ae_u;
-} attrentry_T;
-
-#ifdef USE_ICONV
-# ifdef HAVE_ICONV_H
-#  include <iconv.h>
-# else
-#  if defined(MACOS_X)
-#   include <sys/errno.h>
-#   define EILSEQ ENOENT /* MacOS X does not have EILSEQ */
-typedef struct _iconv_t *iconv_t;
-#  else
-#   if defined(MACOS_CLASSIC)
-typedef struct _iconv_t *iconv_t;
-#    define EINVAL	22
-#    define E2BIG	7
-#    define ENOENT	2
-#    define EFAULT	14
-#    define EILSEQ	123
-#   else
-#    include <errno.h>
-#   endif
-#  endif
-typedef void *iconv_t;
-# endif
-#endif
-
-/*
- * Used for the typeahead buffer: typebuf.
- */
-typedef struct
-{
-    char_u	*tb_buf;	/* buffer for typed characters */
-    char_u	*tb_noremap;	/* mapping flags for characters in tb_buf[] */
-    int		tb_buflen;	/* size of tb_buf[] */
-    int		tb_off;		/* current position in tb_buf[] */
-    int		tb_len;		/* number of valid bytes in tb_buf[] */
-    int		tb_maplen;	/* nr of mapped bytes in tb_buf[] */
-    int		tb_silent;	/* nr of silently mapped bytes in tb_buf[] */
-    int		tb_no_abbr_cnt; /* nr of bytes without abbrev. in tb_buf[] */
-    int		tb_change_cnt;	/* nr of time tb_buf was changed; never zero */
-} typebuf_T;
-
-/* Struct to hold the saved typeahead for save_typeahead(). */
-typedef struct
-{
-    typebuf_T		save_typebuf;
-    int			typebuf_valid;	    /* TRUE when save_typebuf valid */
-    struct buffheader	save_stuffbuff;
-#ifdef USE_INPUT_BUF
-    char_u		*save_inputbuf;
-#endif
-} tasave_T;
-
-/*
- * Used for conversion of terminal I/O and script files.
- */
-typedef struct
-{
-    int		vc_type;	/* zero or one of the CONV_ values */
-    int		vc_factor;	/* max. expansion factor */
-# ifdef WIN3264
-    int		vc_cpfrom;	/* codepage to convert from (CONV_CODEPAGE) */
-    int		vc_cpto;	/* codepage to convert to (CONV_CODEPAGE) */
-# endif
-# ifdef USE_ICONV
-    iconv_t	vc_fd;		/* for CONV_ICONV */
-# endif
-    int		vc_fail;	/* fail for invalid char, don't use '?' */
-} vimconv_T;
-
-/*
- * Structure used for reading from the viminfo file.
- */
-typedef struct
-{
-    char_u	*vir_line;	/* text of the current line */
-    FILE	*vir_fd;	/* file descriptor */
-#ifdef FEAT_MBYTE
-    vimconv_T	vir_conv;	/* encoding conversion */
-#endif
-} vir_T;
-
-#define CONV_NONE		0
-#define CONV_TO_UTF8		1
-#define CONV_TO_LATIN1		2
-#define CONV_ICONV		3
-#ifdef WIN3264
-# define CONV_CODEPAGE		4	/* codepage -> codepage */
-#endif
-#ifdef MACOS_X
-# define CONV_MAC_LATIN1	5
-# define CONV_LATIN1_MAC	6
-# define CONV_MAC_UTF8		7
-# define CONV_UTF8_MAC		8
-#endif
-
-/*
- * Structure used for mappings and abbreviations.
- */
-typedef struct mapblock mapblock_T;
-struct mapblock
-{
-    mapblock_T	*m_next;	/* next mapblock in list */
-    char_u	*m_keys;	/* mapped from */
-    int		m_keylen;	/* strlen(m_keys) */
-    char_u	*m_str;		/* mapped to */
-    int		m_mode;		/* valid mode */
-    int		m_noremap;	/* if non-zero no re-mapping for m_str */
-    char	m_silent;	/* <silent> used, don't echo commands */
-#if 0  /* Not used yet */
-    scid_T	m_script_ID;	/* ID of script where map was defined,
-				   used for s: variables and functions */
-#endif
-};
-
-/*
- * Used for highlighting in the status line.
- */
-struct stl_hlrec
-{
-    char_u	*start;
-    int		userhl;
-};
-
-/*
- * buffer: structure that holds information about one file
- *
- * Several windows can share a single Buffer
- * A buffer is unallocated if there is no memfile for it.
- * A buffer is new if the associated file has never been loaded yet.
- */
-
-typedef struct file_buffer buf_T;
-
-struct file_buffer
-{
-    memline_T	b_ml;		/* associated memline (also contains line
-				   count) */
-
-    buf_T	*b_next;	/* links in list of buffers */
-    buf_T	*b_prev;
-
-    int		b_nwindows;	/* nr of windows open on this buffer */
-
-    int		b_flags;	/* various BF_ flags */
-
-    /*
-     * b_ffname has the full path of the file (NULL for no name).
-     * b_sfname is the name as the user typed it (or NULL).
-     * b_fname is the same as b_sfname, unless ":cd" has been done,
-     *		then it is the same as b_ffname (NULL for no name).
-     */
-    char_u	*b_ffname;	/* full path file name */
-    char_u	*b_sfname;	/* short file name */
-    char_u	*b_fname;	/* current file name */
-
-#ifdef UNIX
-    int		b_dev;		/* device number (-1 if not set) */
-    ino_t	b_ino;		/* inode number */
-#endif
-#ifdef FEAT_CW_EDITOR
-    FSSpec	b_FSSpec;	/* MacOS File Identification */
-#endif
-#ifdef VMS
-    char	 b_fab_rfm;	/* Record format    */
-    char	 b_fab_rat;	/* Record attribute */
-    unsigned int b_fab_mrs;	/* Max record size  */
-#endif
-#ifdef FEAT_SNIFF
-    int		b_sniff;	/* file was loaded through Sniff */
-#endif
-
-    int		b_fnum;		/* buffer number for this file. */
-
-    int		b_changed;	/* 'modified': Set to TRUE if something in the
-				   file has been changed and not written out. */
-    int		b_changedtick;	/* incremented for each change, also for undo */
-
-    int		b_saving;	/* Set to TRUE if we are in the middle of
-				   saving the buffer. */
-
-    /*
-     * Changes to a buffer require updating of the display.  To minimize the
-     * work, remember changes made and update everything at once.
-     */
-    int		b_mod_set;	/* TRUE when there are changes since the last
-				   time the display was updated */
-    linenr_T	b_mod_top;	/* topmost lnum that was changed */
-    linenr_T	b_mod_bot;	/* lnum below last changed line, AFTER the
-				   change */
-    long	b_mod_xlines;	/* number of extra buffer lines inserted;
-				   negative when lines were deleted */
-
-    wininfo_T	*b_wininfo;	/* list of last used info for each window */
-
-    long	b_mtime;	/* last change time of original file */
-    long	b_mtime_read;	/* last change time when reading */
-    size_t	b_orig_size;	/* size of original file in bytes */
-    int		b_orig_mode;	/* mode of original file */
-
-    pos_T	b_namedm[NMARKS]; /* current named marks (mark.c) */
-
-#ifdef FEAT_VISUAL
-    /* These variables are set when VIsual_active becomes FALSE */
-    pos_T	b_visual_start;	/* start pos of last VIsual */
-    pos_T	b_visual_end;	/* end position of last VIsual */
-    int		b_visual_mode;	/* VIsual_mode of last VIsual */
-# ifdef FEAT_EVAL
-    int		b_visual_mode_eval;  /* b_visual_mode for visualmode() */
-# endif
-    colnr_T	b_visual_curswant;   /* MAXCOL from w_curswant */
-#endif
-
-    pos_T	b_last_cursor;	/* cursor position when last unloading this
-				   buffer */
-    pos_T	b_last_insert;	/* where Insert mode was left */
-    pos_T	b_last_change;	/* position of last change: '. mark */
-
-#ifdef FEAT_JUMPLIST
-    /*
-     * the changelist contains old change positions
-     */
-    pos_T	b_changelist[JUMPLISTSIZE];
-    int		b_changelistlen;	/* number of active entries */
-    int		b_new_change;		/* set by u_savecommon() */
-#endif
-
-    /*
-     * Character table, only used in charset.c for 'iskeyword'
-     * 32 bytes of 8 bits: 1 bit per character 0-255.
-     */
-    char_u	b_chartab[32];
-
-#ifdef FEAT_LOCALMAP
-    /* Table used for mappings local to a buffer. */
-    mapblock_T	*(b_maphash[256]);
-
-    /* First abbreviation local to a buffer. */
-    mapblock_T	*b_first_abbr;
-#endif
-#ifdef FEAT_USR_CMDS
-    /* User commands local to the buffer. */
-    garray_T	b_ucmds;
-#endif
-    /*
-     * start and end of an operator, also used for '[ and ']
-     */
-    pos_T	b_op_start;
-    pos_T	b_op_end;
-
-#ifdef FEAT_VIMINFO
-    int		b_marks_read;	/* Have we read viminfo marks yet? */
-#endif
-
-    /*
-     * The following only used in undo.c.
-     */
-    u_header_T	*b_u_oldhead;	/* pointer to oldest header */
-    u_header_T	*b_u_newhead;	/* pointer to newest header */
-    u_header_T	*b_u_curhead;	/* pointer to current header */
-    int		b_u_numhead;	/* current number of headers */
-    int		b_u_synced;	/* entry lists are synced */
-
-    /*
-     * variables for "U" command in undo.c
-     */
-    char_u	*b_u_line_ptr;	/* saved line for "U" command */
-    linenr_T	b_u_line_lnum;	/* line number of line in u_line */
-    colnr_T	b_u_line_colnr;	/* optional column number */
-
-    /*
-     * The following only used in undo.c
-     */
-    mblock_T	b_block_head;	/* head of allocated memory block list */
-    minfo_T	*b_m_search;	/* pointer to chunk before previously
-				   allocated/freed chunk */
-    mblock_T	*b_mb_current;	/* block where m_search points in */
-#ifdef FEAT_INS_EXPAND
-    int		b_scanned;	/* ^N/^P have scanned this buffer */
-#endif
-
-    /* flags for use of ":lmap" and IM control */
-    long	b_p_iminsert;	/* input mode for insert */
-    long	b_p_imsearch;	/* input mode for search */
-#define B_IMODE_USE_INSERT -1	/*	Use b_p_iminsert value for search */
-#define B_IMODE_NONE 0		/*	Input via none */
-#define B_IMODE_LMAP 1		/*	Input via langmap */
-#ifndef USE_IM_CONTROL
-# define B_IMODE_LAST 1
-#else
-# define B_IMODE_IM 2		/*	Input via input method */
-# define B_IMODE_LAST 2
-#endif
-
-#ifdef FEAT_KEYMAP
-    short	b_kmap_state;	/* using "lmap" mappings */
-# define KEYMAP_INIT	1	/* 'keymap' was set, call keymap_init() */
-# define KEYMAP_LOADED	2	/* 'keymap' mappings have been loaded */
-    garray_T	b_kmap_ga;	/* the keymap table */
-#endif
-
-    /*
-     * Options local to a buffer.
-     * They are here because their value depends on the type of file
-     * or contents of the file being edited.
-     */
-    int		b_p_initialized;	/* set when options initialized */
-
-    int		b_p_ai;		/* 'autoindent' */
-    int		b_p_ai_nopaste;	/* b_p_ai saved for paste mode */
-    int		b_p_ci;		/* 'copyindent' */
-    int		b_p_bin;	/* 'binary' */
-#ifdef FEAT_MBYTE
-    int		b_p_bomb;	/* 'bomb' */
-#endif
-#if defined(FEAT_QUICKFIX)
-    char_u	*b_p_bh;	/* 'bufhidden' */
-    char_u	*b_p_bt;	/* 'buftype' */
-#endif
-    int		b_p_bl;		/* 'buflisted' */
-#ifdef FEAT_CINDENT
-    int		b_p_cin;	/* 'cindent' */
-    char_u	*b_p_cino;	/* 'cinoptions' */
-    char_u	*b_p_cink;	/* 'cinkeys' */
-#endif
-#if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)
-    char_u	*b_p_cinw;	/* 'cinwords' */
-#endif
-#ifdef FEAT_COMMENTS
-    char_u	*b_p_com;	/* 'comments' */
-#endif
-#ifdef FEAT_FOLDING
-    char_u	*b_p_cms;	/* 'commentstring' */
-#endif
-#ifdef FEAT_INS_EXPAND
-    char_u	*b_p_cpt;	/* 'complete' */
-#endif
-    int		b_p_eol;	/* 'endofline' */
-    int		b_p_et;		/* 'expandtab' */
-    int		b_p_et_nobin;	/* b_p_et saved for binary mode */
-#ifdef FEAT_MBYTE
-    char_u	*b_p_fenc;	/* 'fileencoding' */
-#endif
-    char_u	*b_p_ff;	/* 'fileformat' */
-#ifdef FEAT_AUTOCMD
-    char_u	*b_p_ft;	/* 'filetype' */
-#endif
-    char_u	*b_p_fo;	/* 'formatoptions' */
-    int		b_p_inf;	/* 'infercase' */
-    char_u	*b_p_isk;	/* 'iskeyword' */
-#ifdef FEAT_FIND_ID
-    char_u	*b_p_def;	/* 'define' local value */
-    char_u	*b_p_inc;	/* 'include' */
-# ifdef FEAT_EVAL
-    char_u	*b_p_inex;	/* 'includeexpr' */
-# endif
-#endif
-#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
-    char_u	*b_p_inde;	/* 'indentexpr' */
-    char_u	*b_p_indk;	/* 'indentkeys' */
-#endif
-#ifdef FEAT_CRYPT
-    char_u	*b_p_key;	/* 'key' */
-#endif
-    char_u	*b_p_kp;	/* 'keywordprg' */
-#ifdef FEAT_LISP
-    int		b_p_lisp;	/* 'lisp' */
-#endif
-    char_u	*b_p_mps;	/* 'matchpairs' */
-    int		b_p_ml;		/* 'modeline' */
-    int		b_p_ml_nobin;	/* b_p_ml saved for binary mode */
-    int		b_p_ma;		/* 'modifiable' */
-    char_u	*b_p_nf;	/* 'nrformats' */
-#ifdef FEAT_OSFILETYPE
-    char_u	*b_p_oft;	/* 'osfiletype' */
-#endif
-    int		b_p_pi;		/* 'preserveindent' */
-    int		b_p_ro;		/* 'readonly' */
-    long	b_p_sw;		/* 'shiftwidth' */
-#ifndef SHORT_FNAME
-    int		b_p_sn;		/* 'shortname' */
-#endif
-#ifdef FEAT_SMARTINDENT
-    int		b_p_si;		/* 'smartindent' */
-#endif
-    long	b_p_sts;	/* 'softtabstop' */
-    long	b_p_sts_nopaste; /* b_p_sts saved for paste mode */
-#ifdef FEAT_SEARCHPATH
-    char_u	*b_p_sua;	/* 'suffixesadd' */
-#endif
-    int		b_p_swf;	/* 'swapfile' */
-#ifdef FEAT_SYN_HL
-    char_u	*b_p_syn;	/* 'syntax' */
-#endif
-    long	b_p_ts;		/* 'tabstop' */
-    int		b_p_tx;		/* 'textmode' */
-    long	b_p_tw;		/* 'textwidth' */
-    long	b_p_tw_nobin;	/* b_p_tw saved for binary mode */
-    long	b_p_tw_nopaste;	/* b_p_tw saved for paste mode */
-    long	b_p_wm;		/* 'wrapmargin' */
-    long	b_p_wm_nobin;	/* b_p_wm saved for binary mode */
-    long	b_p_wm_nopaste;	/* b_p_wm saved for paste mode */
-#ifdef FEAT_KEYMAP
-    char_u	*b_p_keymap;	/* 'keymap' */
-#endif
-
-    /* local values for options which are normally global */
-#ifdef FEAT_QUICKFIX
-    char_u	*b_p_gp;	/* 'grepprg' local value */
-    char_u	*b_p_mp;	/* 'makeprg' local value */
-    char_u	*b_p_efm;	/* 'errorformat' local value */
-#endif
-    char_u	*b_p_ep;	/* 'equalprg' local value */
-    char_u	*b_p_path;	/* 'path' local value */
-    int		b_p_ar;		/* 'autoread' local value */
-    char_u	*b_p_tags;	/* 'tags' local value */
-#ifdef FEAT_INS_EXPAND
-    char_u	*b_p_dict;	/* 'dictionary' local value */
-    char_u	*b_p_tsr;	/* 'thesaurus' local value */
-#endif
-
-    /* end of buffer options */
-
-    int		b_start_eol;	/* last line had eol when it was read */
-    int		b_start_ffc;	/* first char of 'ff' when edit started */
-#ifdef FEAT_MBYTE
-    char_u	*b_start_fenc;	/* 'fileencoding' when edit started or NULL */
-#endif
-
-#ifdef FEAT_EVAL
-    garray_T	b_vars;		/* internal variables, local to buffer */
-#endif
-
-    /* When a buffer is created, it starts without a swap file.  b_may_swap is
-     * then set to indicate that a swap file may be opened later.  It is reset
-     * if a swap file could not be opened.
-     */
-    int		b_may_swap;
-    int		b_did_warn;	/* Set to 1 if user has been warned on first
-				   change of a read-only file */
-    int		b_help;		/* buffer for help file (when set b_p_bt is
-				   "help") */
-
-#ifndef SHORT_FNAME
-    int		b_shortname;	/* this file has an 8.3 file name */
-#endif
-
-#ifdef FEAT_PERL
-    void	*perl_private;
-#endif
-
-#ifdef FEAT_PYTHON
-    void	*python_ref;	/* The Python value referring to this buffer */
-#endif
-
-#ifdef FEAT_TCL
-    void	*tcl_ref;
-#endif
-
-#ifdef FEAT_RUBY
-    void	*ruby_ref;
-#endif
-
-#ifdef FEAT_SYN_HL
-    keyentry_T	**b_keywtab;		/* syntax keywords hash table */
-    keyentry_T	**b_keywtab_ic;		/* idem, ignore case */
-    int		b_syn_ic;		/* ignore case for :syn cmds */
-    garray_T	b_syn_patterns;		/* table for syntax patterns */
-    garray_T	b_syn_clusters;		/* table for syntax clusters */
-    int		b_syn_containedin;	/* TRUE when there is an item with a
-					   "containedin" argument */
-    int		b_syn_sync_flags;	/* flags about how to sync */
-    short	b_syn_sync_id;		/* group to sync on */
-    long	b_syn_sync_minlines;	/* minimal sync lines offset */
-    long	b_syn_sync_maxlines;	/* maximal sync lines offset */
-    long	b_syn_sync_linebreaks;	/* offset for multi-line pattern */
-    char_u	*b_syn_linecont_pat;	/* line continuation pattern */
-    regprog_T	*b_syn_linecont_prog;	/* line continuation program */
-    int		b_syn_linecont_ic;	/* ignore-case flag for above */
-    int		b_syn_topgrp;		/* for ":syntax include" */
-# ifdef FEAT_FOLDING
-    int		b_syn_folditems;	/* number of patterns with the HL_FOLD
-					   flag set */
-# endif
-/*
- * b_sst_array[] contains the state stack for a number of lines, for the start
- * of that line (col == 0).  This avoids having to recompute the syntax state
- * too often.
- * b_sst_array[] is allocated to hold the state for all displayed lines, and
- * states for 1 out of about 20 other lines.
- * b_sst_array		pointer to an array of synstate_T
- * b_sst_len		number of entries in b_sst_array[]
- * b_sst_first		pointer to first used entry in b_sst_array[] or NULL
- * b_sst_firstfree	pointer to first free entry in b_sst_array[] or NULL
- * b_sst_freecount	number of free entries in b_sst_array[]
- * b_sst_check_lnum	entries after this lnum need to be checked for
- *			validity (MAXLNUM means no check needed)
- */
-    synstate_T	*b_sst_array;
-    int		b_sst_len;
-    synstate_T	*b_sst_first;
-    synstate_T	*b_sst_firstfree;
-    int		b_sst_freecount;
-    linenr_T	b_sst_check_lnum;
-    short_u	b_sst_lasttick;	/* last display tick */
-#endif /* FEAT_SYN_HL */
-
-#ifdef FEAT_SIGNS
-    signlist_T	*b_signlist;	/* list of signs to draw */
-#endif
-
-#ifdef FEAT_NETBEANS_INTG
-    int		b_netbeans_file;    /* TRUE when buffer is owned by NetBeans */
-    int		b_was_netbeans_file;/* TRUE if b_netbeans_file was once set */
-#endif
-
-};
-
-/*
- * Structure to cache info for displayed lines in w_lines[].
- * Each logical line has one entry.
- * The entry tells how the logical line is currently displayed in the window.
- * This is updated when displaying the window.
- * When the display is changed (e.g., when clearing the screen) w_lines_valid
- * is changed to exclude invalid entries.
- * When making changes to the buffer, wl_valid is reset to indicate wl_size
- * may not reflect what is actually in the buffer.  When wl_valid is FALSE,
- * the entries can only be used to count the number of displayed lines used.
- * wl_lnum and wl_lastlnum are invalid too.
- */
-typedef struct w_line
-{
-    linenr_T	wl_lnum;	/* buffer line number for logical line */
-    short_u	wl_size;	/* height in screen lines */
-    char	wl_valid;	/* TRUE values are valid for text in buffer */
-#ifdef FEAT_FOLDING
-    char	wl_folded;	/* TRUE when this is a range of folded lines */
-    linenr_T	wl_lastlnum;	/* last buffer line number for logical line */
-#endif
-} wline_T;
-
-/*
- * Windows are kept in a tree of frames.  Each frame has a column (FR_COL)
- * or row (FR_ROW) layout or is a leaf, which has a window.
- */
-struct frame
-{
-    char	fr_layout;	/* FR_LEAF, FR_COL or FR_ROW */
-#ifdef FEAT_VERTSPLIT
-    int		fr_width;
-#endif
-    int		fr_height;
-    int		fr_newheight;	/* new height used in win_equal_rec() */
-    frame_T	*fr_parent;	/* containing frame or NULL */
-    frame_T	*fr_next;	/* frame right or below in same parent, NULL
-				   for first */
-    frame_T	*fr_prev;	/* frame left or above in same parent, NULL
-				   for last */
-    /* fr_child and fr_win are mutually exclusive */
-    frame_T	*fr_child;	/* first contained frame */
-    win_T	*fr_win;	/* window that fills this frame */
-};
-
-#define FR_LEAF	0	/* frame is a leaf */
-#define FR_ROW	1	/* frame with a row of windows */
-#define FR_COL	2	/* frame with a column of windows */
-
-/*
- * Structure which contains all information that belongs to a window
- *
- * All row numbers are relative to the start of the window, except w_winrow.
- */
-struct window
-{
-    buf_T	*w_buffer;	    /* buffer we are a window into (used
-				       often, keep it the first item!) */
-
-#ifdef FEAT_WINDOWS
-    win_T	*w_prev;	    /* link to previous window */
-    win_T	*w_next;	    /* link to next window */
-#endif
-
-    frame_T	*w_frame;	    /* frame containing this window */
-
-    pos_T	w_cursor;	    /* cursor position in buffer */
-
-    colnr_T	w_curswant;	    /* The column we'd like to be at.  This is
-				       used to try to stay in the same column
-				       for up/down cursor motions. */
-
-    int		w_set_curswant;	    /* If set, then update w_curswant the next
-				       time through cursupdate() to the
-				       current virtual column */
-
-#ifdef FEAT_VISUAL
-    /*
-     * the next six are used to update the visual part
-     */
-    char	w_old_visual_mode;  /* last known VIsual_mode */
-    linenr_T	w_old_cursor_lnum;  /* last known end of visual part */
-    colnr_T	w_old_cursor_fcol;  /* first column for block visual part */
-    colnr_T	w_old_cursor_lcol;  /* last column for block visual part */
-    linenr_T	w_old_visual_lnum;  /* last known start of visual part */
-    colnr_T	w_old_curswant;	    /* last known value of Curswant */
-#endif
-
-    /*
-     * The next three specify the offsets for displaying the buffer:
-     */
-    linenr_T	w_topline;	    /* buffer line number of the line at the
-				       top of the window */
-#ifdef FEAT_DIFF
-    int		w_topfill;	    /* number of filler lines above w_topline */
-    int		w_old_topfill;	    /* w_topfill at last redraw */
-    int		w_botfill;	    /* TRUE when filler lines are actually
-				       below w_topline (at end of file) */
-    int		w_old_botfill;	    /* w_botfill at last redraw */
-#endif
-    colnr_T	w_leftcol;	    /* window column number of the left most
-				       character in the window; used when
-				       'wrap' is off */
-    colnr_T	w_skipcol;	    /* starting column when a single line
-				       doesn't fit in the window */
-
-    /*
-     * Layout of the window in the screen.
-     * May need to add "msg_scrolled" to "w_winrow" in rare situations.
-     */
-#ifdef FEAT_WINDOWS
-    int		w_winrow;	    /* first row of window in screen */
-#endif
-    int		w_height;	    /* number of rows in window, excluding
-				       status/command line(s) */
-#ifdef FEAT_WINDOWS
-    int		w_status_height;    /* number of status lines (0 or 1) */
-#endif
-#ifdef FEAT_VERTSPLIT
-    int		w_wincol;	    /* Leftmost column of window in screen.
-				       use W_WINCOL() */
-    int		w_width;	    /* Width of window, excluding separation.
-				       use W_WIDTH() */
-    int		w_vsep_width;	    /* Number of separator columns (0 or 1).
-				       use W_VSEP_WIDTH() */
-#endif
-
-    /*
-     * === start of cached values ====
-     */
-    /*
-     * Recomputing is minimized by storing the result of computations.
-     * Use functions in screen.c to check if they are valid and to update.
-     * w_valid is a bitfield of flags, which indicate if specific values are
-     * valid or need to be recomputed.	See screen.c for values.
-     */
-    int		w_valid;
-    pos_T	w_valid_cursor;	    /* last known position of w_cursor, used
-				       to adjust w_valid */
-    colnr_T	w_valid_leftcol;    /* last known w_leftcol */
-
-    /*
-     * w_cline_height is the number of physical lines taken by the buffer line
-     * that the cursor is on.  We use this to avoid extra calls to plines().
-     */
-    int		w_cline_height;	    /* current size of cursor line */
-#ifdef FEAT_FOLDING
-    int		w_cline_folded;	    /* cursor line is folded */
-#endif
-
-    int		w_cline_row;	    /* starting row of the cursor line */
-
-    colnr_T	w_virtcol;	    /* column number of the cursor in the
-				       buffer line, as opposed to the column
-				       number we're at on the screen.  This
-				       makes a difference on lines which span
-				       more than one screen line or when
-				       w_leftcol is non-zero */
-
-    /*
-     * w_wrow and w_wcol specify the cursor position in the window.
-     * This is related to positions in the window, not in the display or
-     * buffer, thus w_wrow is relative to w_winrow.
-     */
-    int		w_wrow, w_wcol;	    /* cursor position in window */
-
-    linenr_T	w_botline;	    /* number of the line below the bottom of
-				       the screen */
-    int		w_empty_rows;	    /* number of ~ rows in window */
-#ifdef FEAT_DIFF
-    int		w_filler_rows;	    /* number of filler rows at the end of the
-				       window */
-#endif
-
-    /*
-     * Info about the lines currently in the window is remembered to avoid
-     * recomputing it every time.  The allocated size of w_lines[] is Rows.
-     * Only the w_lines_valid entries are actually valid.
-     * When the display is up-to-date w_lines[0].wl_lnum is equal to w_topline
-     * and w_lines[w_lines_valid - 1].wl_lnum is equal to w_botline.
-     * Between changing text and updating the display w_lines[] represents
-     * what is currently displayed.  wl_valid is reset to indicated this.
-     * This is used for efficient redrawing.
-     */
-    int		w_lines_valid;	    /* number of valid entries */
-    wline_T	*w_lines;
-
-#ifdef FEAT_FOLDING
-    garray_T	w_folds;	    /* array of nested folds */
-    char	w_fold_manual;	    /* when TRUE: some folds are opened/closed
-				       manually */
-    char	w_foldinvalid;	    /* when TRUE: folding needs to be
-				       recomputed */
-#endif
-
-    /*
-     * === end of cached values ===
-     */
-
-    int		w_redr_type;	    /* type of redraw to be performed on win */
-    int		w_upd_rows;	    /* number of window lines to update when
-				       w_redr_type is REDRAW_TOP */
-    linenr_T	w_redraw_top;	    /* when != 0: first line needing redraw */
-    linenr_T	w_redraw_bot;	    /* when != 0: last line needing redraw */
-#ifdef FEAT_WINDOWS
-    int		w_redr_status;	    /* if TRUE status line must be redrawn */
-#endif
-
-#ifdef FEAT_CMDL_INFO
-    /* remember what is shown in the ruler for this window (if 'ruler' set) */
-    pos_T	w_ru_cursor;	    /* cursor position shown in ruler */
-    colnr_T	w_ru_virtcol;	    /* virtcol shown in ruler */
-    linenr_T	w_ru_topline;	    /* topline shown in ruler */
-    linenr_T	w_ru_line_count;    /* line count used for ruler */
-# ifdef FEAT_DIFF
-    int		w_ru_topfill;	    /* topfill shown in ruler */
-# endif
-    char	w_ru_empty;	    /* TRUE if ruler shows 0-1 (empty line) */
-#endif
-
-    int		w_alt_fnum;	    /* alternate file (for # and CTRL-^) */
-
-#ifdef FEAT_WINDOWS
-    alist_T	*w_alist;	    /* pointer to arglist for this window */
-#endif
-    int		w_arg_idx;	    /* current index in argument list (can be
-				       out of range!) */
-    int		w_arg_idx_invalid;  /* editing another file than w_arg_idx */
-
-    char_u	*w_localdir;	    /* absolute path of local directory or
-				       NULL */
-    /*
-     * Options local to a window.
-     * They are local because they influence the layout of the window or
-     * depend on the window layout.
-     * There are two values: w_onebuf_opt is local to the buffer currently in
-     * this window, w_allbuf_opt is for all buffers in this window.
-     */
-    winopt_T	w_onebuf_opt;
-    winopt_T	w_allbuf_opt;
-
-    /* transform a pointer to a "onebuf" option into a "allbuf" option */
-#define GLOBAL_WO(p)	((char *)p + sizeof(winopt_T))
-
-#ifdef FEAT_SCROLLBIND
-    long	w_scbind_pos;
-#endif
-
-#ifdef FEAT_EVAL
-    garray_T	w_vars;		/* internal variables, local to window */
-#endif
-
-#if defined(FEAT_RIGHTLEFT) && defined(FEAT_FKMAP)
-    int		w_farsi;	/* for the window dependent Farsi functions */
-#endif
-
-    /*
-     * The w_prev_pcmark field is used to check whether we really did jump to
-     * a new line after setting the w_pcmark.  If not, then we revert to
-     * using the previous w_pcmark.
-     */
-    pos_T	w_pcmark;	/* previous context mark */
-    pos_T	w_prev_pcmark;	/* previous w_pcmark */
-
-#ifdef FEAT_JUMPLIST
-    /*
-     * the jumplist contains old cursor positions
-     */
-    xfmark_T	w_jumplist[JUMPLISTSIZE];
-    int		w_jumplistlen;		/* number of active entries */
-    int		w_jumplistidx;		/* current position */
-
-    int		w_changelistidx;	/* current position in b_changelist */
-#endif
-
-#ifdef FEAT_SEARCH_EXTRA
-    regmmatch_T	w_match;	/* regexp program for ":match" */
-    int		w_match_id;	/* highlight ID for ":match" */
-#endif
-
-    /*
-     * the tagstack grows from 0 upwards:
-     * entry 0: older
-     * entry 1: newer
-     * entry 2: newest
-     */
-    taggy_T	w_tagstack[TAGSTACKSIZE];	/* the tag stack */
-    int		w_tagstackidx;		/* idx just below activ entry */
-    int		w_tagstacklen;		/* number of tags on stack */
-
-    /*
-     * w_fraction is the fractional row of the cursor within the window, from
-     * 0 at the top row to FRACTION_MULT at the last row.
-     * w_prev_fraction_row was the actual cursor row when w_fraction was last
-     * calculated.
-     */
-    int		w_fraction;
-    int		w_prev_fraction_row;
-
-#ifdef FEAT_GUI
-    scrollbar_T	w_scrollbars[2];	/* vert. Scrollbars for this window */
-#endif
-
-#ifdef FEAT_PERL
-    void	*perl_private;
-#endif
-
-#ifdef FEAT_PYTHON
-    void	*python_ref;	/* The Python value referring to this
-					   window */
-#endif
-
-#ifdef FEAT_TCL
-    void	*tcl_ref;
-#endif
-
-#ifdef FEAT_RUBY
-    void	*ruby_ref;
-#endif
-};
-
-/*
- * Arguments for operators.
- */
-typedef struct oparg
-{
-    int		op_type;	/* current pending operator type */
-    int		regname;	/* register to use for the operator */
-    int		motion_type;	/* type of the current cursor motion */
-    int		motion_force;	/* force motion type: 'v', 'V' or CTRL-V */
-    int		use_reg_one;	/* TRUE if delete uses reg 1 even when not
-				   linewise */
-    int		inclusive;	/* TRUE if char motion is inclusive (only
-				   valid when motion_type is MCHAR */
-    int		end_adjusted;	/* backuped b_op_end one char (only used by
-				   do_format()) */
-    pos_T	start;		/* start of the operator */
-    pos_T	end;		/* end of the operator */
-    pos_T	cursor_start;	/* cursor position before motion for "gw" */
-
-    long	line_count;	/* number of lines from op_start to op_end
-				   (inclusive) */
-    int		empty;		/* op_start and op_end the same (only used by
-				   do_change()) */
-#ifdef FEAT_VISUAL
-    int		is_VIsual;	/* operator on Visual area */
-    int		block_mode;	/* current operator is Visual block mode */
-#endif
-    colnr_T	start_vcol;	/* start col for block mode operator */
-    colnr_T	end_vcol;	/* end col for block mode operator */
-} oparg_T;
-
-/*
- * Arguments for Normal mode commands.
- */
-typedef struct cmdarg
-{
-    oparg_T	*oap;		/* Operator arguments */
-    int		prechar;	/* prefix character (optional, always 'g') */
-    int		cmdchar;	/* command character */
-    int		nchar;		/* next command character (optional) */
-#ifdef FEAT_MBYTE
-    int		ncharC1;	/* first composing character (optional) */
-    int		ncharC2;	/* second composing character (optional) */
-#endif
-    int		extra_char;	/* yet another character (optional) */
-    long	opcount;	/* count before an operator */
-    long	count0;		/* count before command, default 0 */
-    long	count1;		/* count before command, default 1 */
-    int		arg;		/* extra argument from nv_cmds[] */
-    int		retval;		/* return: CA_* values */
-    char_u	*searchbuf;	/* return: pointer to search pattern or NULL */
-} cmdarg_T;
-
-/* values for retval: */
-#define CA_COMMAND_BUSY	    1	/* skip restarting edit() once */
-#define CA_NO_ADJ_OP_END    2	/* don't adjust operator end */
-
-#ifdef CURSOR_SHAPE
-/*
- * struct to store values from 'guicursor' and 'mouseshape'
- */
-/* Indexes in shape_table[] */
-#define SHAPE_IDX_N	0	/* Normal mode */
-#define SHAPE_IDX_V	1	/* Visual mode */
-#define SHAPE_IDX_I	2	/* Insert mode */
-#define SHAPE_IDX_R	3	/* Replace mode */
-#define SHAPE_IDX_C	4	/* Command line Normal mode */
-#define SHAPE_IDX_CI	5	/* Command line Insert mode */
-#define SHAPE_IDX_CR	6	/* Command line Replace mode */
-#define SHAPE_IDX_O	7	/* Operator-pending mode */
-#define SHAPE_IDX_VE	8	/* Visual mode with 'seleciton' exclusive */
-#define SHAPE_IDX_CLINE	9	/* On command line */
-#define SHAPE_IDX_STATUS 10	/* A status line */
-#define SHAPE_IDX_SDRAG 11	/* dragging a status line */
-#define SHAPE_IDX_VSEP	12	/* A vertical separator line */
-#define SHAPE_IDX_VDRAG 13	/* dragging a vertical separator line */
-#define SHAPE_IDX_MORE	14	/* Hit-return or More */
-#define SHAPE_IDX_MOREL	15	/* Hit-return or More in last line */
-#define SHAPE_IDX_SM	16	/* showing matching paren */
-#define SHAPE_IDX_COUNT	17
-
-#define SHAPE_BLOCK	0	/* block cursor */
-#define SHAPE_HOR	1	/* horizontal bar cursor */
-#define SHAPE_VER	2	/* vertical bar cursor */
-
-#define MSHAPE_NUMBERED	1000	/* offset for shapes identified by number */
-#define MSHAPE_HIDE	1	/* hide mouse pointer */
-
-#define SHAPE_MOUSE	1	/* used for mouse pointer shape */
-#define SHAPE_CURSOR	2	/* used for text cursor shape */
-
-typedef struct cursor_entry
-{
-    int		shape;		/* one of the SHAPE_ defines */
-    int		mshape;		/* one of the MSHAPE defines */
-    int		percentage;	/* percentage of cell for bar */
-    long	blinkwait;	/* blinking, wait time before blinking starts */
-    long	blinkon;	/* blinking, on time */
-    long	blinkoff;	/* blinking, off time */
-    int		id;		/* highlight group ID */
-    int		id_lm;		/* highlight group ID for :lmap mode */
-    char	*name;		/* mode name (fixed) */
-    char	used_for;	/* SHAPE_MOUSE and/or SHAPE_CURSOR */
-} cursorentry_T;
-#endif /* CURSOR_SHAPE */
-
-#ifdef FEAT_MENU
-
-/* Indices into vimmenu_T->strings[] and vimmenu_T->noremap[] for each mode */
-#define MENU_INDEX_INVALID	-1
-#define MENU_INDEX_NORMAL	0
-#define MENU_INDEX_VISUAL	1
-#define MENU_INDEX_OP_PENDING	2
-#define MENU_INDEX_INSERT	3
-#define MENU_INDEX_CMDLINE	4
-#define MENU_INDEX_TIP		5
-#define MENU_MODES		6
-
-/* Menu modes */
-#define MENU_NORMAL_MODE	(1 << MENU_INDEX_NORMAL)
-#define MENU_VISUAL_MODE	(1 << MENU_INDEX_VISUAL)
-#define MENU_OP_PENDING_MODE	(1 << MENU_INDEX_OP_PENDING)
-#define MENU_INSERT_MODE	(1 << MENU_INDEX_INSERT)
-#define MENU_CMDLINE_MODE	(1 << MENU_INDEX_CMDLINE)
-#define MENU_TIP_MODE		(1 << MENU_INDEX_TIP)
-#define MENU_ALL_MODES		((1 << MENU_INDEX_TIP) - 1)
-/*note MENU_INDEX_TIP is not a 'real' mode*/
-
-/* Start a menu name with this to not include it on the main menu bar */
-#define MNU_HIDDEN_CHAR		']'
-
-typedef struct VimMenu vimmenu_T;
-
-struct VimMenu
-{
-    int		modes;		    /* Which modes is this menu visible for? */
-    int		enabled;	    /* for which modes the menu is enabled */
-    char_u	*name;		    /* Name of menu */
-    char_u	*dname;		    /* Displayed Name (without '&') */
-    int		mnemonic;	    /* mnemonic key (after '&') */
-    char_u	*actext;	    /* accelerator text (after TAB) */
-    int		priority;	    /* Menu order priority */
-#ifdef FEAT_GUI
-    void	(*cb)();	    /* Call-back routine */
-#endif
-#ifdef FEAT_TOOLBAR
-    char_u	*iconfile;	    /* name of file for icon or NULL */
-    int		iconidx;	    /* icon index (-1 if not set) */
-    int		icon_builtin;	    /* icon names is BuiltIn{nr} */
-#endif
-    char_u	*strings[MENU_MODES]; /* Mapped string for each mode */
-    int		noremap[MENU_MODES]; /* A REMAP_ flag for each mode */
-    char	silent[MENU_MODES]; /* A silent flag for each mode */
-    vimmenu_T	*children;	    /* Children of sub-menu */
-    vimmenu_T	*parent;	    /* Parent of menu */
-    vimmenu_T	*next;		    /* Next item in menu */
-#ifdef FEAT_GUI_X11
-    Widget	id;		    /* Manage this to enable item */
-    Widget	submenu_id;	    /* If this is submenu, add children here */
-#endif
-#ifdef FEAT_GUI_GTK
-    GtkWidget	*id;		    /* Manage this to enable item */
-    GtkWidget	*submenu_id;	    /* If this is submenu, add children here */
-    GtkWidget	*tearoff_handle;
-    GtkWidget   *label;		    /* Used by "set wak=" code. */
-#endif
-#ifdef FEAT_GUI_MOTIF
-    int		sensitive;	    /* turn button on/off */
-#endif
-#if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MOTIF)
-    Pixmap	image;		    /* Toolbar image */
-#endif
-#ifdef FEAT_GUI_MOTIF
-    Pixmap	image_ins;	    /* Toolbar image insensitive */
-#endif
-#ifdef FEAT_BEVAL_TIP
-    BalloonEval *tip;		    /* tooltip for this menu item */
-#endif
-#ifdef FEAT_GUI_W16
-    UINT	id;		    /* Id of menu item */
-    HMENU	submenu_id;	    /* If this is submenu, add children here */
-#endif
-#ifdef FEAT_GUI_W32
-    UINT	id;		    /* Id of menu item */
-    HMENU	submenu_id;	    /* If this is submenu, add children here */
-    HWND	tearoff_handle;	    /* hWnd of tearoff if created */
-#endif
-#if FEAT_GUI_BEOS
-    BMenuItem	*id;		    /* Id of menu item */
-    BMenu	*submenu_id;	    /* If this is submenu, add children here */
-#endif
-#ifdef FEAT_GUI_MAC
-/*  MenuHandle	id; */
-/*  short	index;	*/	    /* the item index within the father menu */
-    short	menu_id;	    /* the menu id to which this item belong */
-    short	submenu_id;	    /* the menu id of the children (could be
-				       get throught some tricks) */
-    MenuHandle	menu_handle;
-    MenuHandle	submenu_handle;
-#endif
-#if defined(FEAT_GUI_AMIGA)
-				    /* only one of these will ever be set, but
-				     * they are used to allow the menu routine
-				     * to easily get a hold of the parent menu
-				     * pointer which is needed by all items to
-				     * form the chain correctly */
-    int		    id;		    /* unused by the amiga, but used in the
-				     * code kept for compatibility */
-    struct Menu	    *menuPtr;
-    struct MenuItem *menuItemPtr;
-#endif
-#ifdef RISCOS
-    int		*id;		    /* Not used, but gui.c needs it */
-    int		greyed_out;	    /* Flag */
-    int		hidden;
-#endif
-#ifdef FEAT_GUI_PHOTON
-    PtWidget_t	*id;
-    PtWidget_t	*submenu_id;
-#endif
-};
-#else
-/* For generating prototypes when FEAT_MENU isn't defined. */
-typedef int vimmenu_T;
-
-#endif /* FEAT_MENU */
-
-/*
- * Struct to save values in before executing autocommands for a buffer that is
- * not the current buffer.
- */
-typedef struct
-{
-    buf_T	*save_buf;	/* saved curbuf */
-    buf_T	*new_curbuf;	/* buffer to be used */
-    win_T	*save_curwin;	/* saved curwin, NULL if it didn't change */
-    win_T	*new_curwin;	/* new curwin if save_curwin != NULL */
-    pos_T	save_cursor;	/* saved cursor pos of save_curwin */
-    linenr_T	save_topline;	/* saved topline of save_curwin */
-#ifdef FEAT_DIFF
-    int		save_topfill;	/* saved topfill of save_curwin */
-#endif
-} aco_save_T;
-
-/*
- * Generic option table item, only used for printer at the moment.
- */
-typedef struct
-{
-    const char	*name;
-    int		hasnum;
-    long	number;
-    char_u	*string;	/* points into option string */
-    int		strlen;
-    int		present;
-} option_table_T;
-
-/*
- * Structure to hold printing color and font attributes.
- */
-typedef struct
-{
-    long_u	fg_color;
-    long_u	bg_color;
-    int		bold;
-    int		italic;
-    int		underline;
-} prt_text_attr_T;
-
-/*
- * Structure passed back to the generic printer code.
- */
-typedef struct
-{
-    int		n_collated_copies;
-    int		n_uncollated_copies;
-    int		duplex;
-    int		chars_per_line;
-    int		lines_per_page;
-    int		has_color;
-    prt_text_attr_T number;
-#ifdef FEAT_SYN_HL
-    int		modec;
-    int		do_syntax;
-#endif
-    int		user_abort;
-    char_u	*jobname;
-#ifdef FEAT_POSTSCRIPT
-    char_u	*outfile;
-    char_u	*arguments;
-#endif
-} prt_settings_T;
-
-#define PRINT_NUMBER_WIDTH 8
diff -Nur vim63/src/undo.c vim63-bonobo/src/undo.c
--- vim63/src/undo.c	2004-04-05 20:23:45.000000000 +0200
+++ vim63-bonobo/src/undo.c	2005-09-09 20:14:02.760580592 +0200
@@ -764,6 +764,7 @@
 #endif
 }
 
+
 /*
  * u_sync: stop adding to the current entry list
  */
diff -Nur vim63/src/version.c.orig vim63-bonobo/src/version.c.orig
--- vim63/src/version.c.orig	2005-09-09 20:11:10.380786000 +0200
+++ vim63-bonobo/src/version.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1391 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved		by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-
-#include "vim.h"
-
-#ifdef AMIGA
-# include <time.h>	/* for time() */
-#endif
-
-/*
- * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)
- * It has been changed beyond recognition since then.
- *
- * Differences between version 5.x and 6.x can be found with ":help version6".
- * Differences between version 4.x and 5.x can be found with ":help version5".
- * Differences between version 3.0 and 4.x can be found with ":help version4".
- * All the remarks about older versions have been removed, they are not very
- * interesting.
- */
-
-#include "version.h"
-
-char	*Version = VIM_VERSION_SHORT;
-char	*mediumVersion = VIM_VERSION_MEDIUM;
-
-#if defined(HAVE_DATE_TIME) || defined(PROTO)
-# if (defined(VMS) && defined(VAXC)) || defined(PROTO)
-char	longVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)
-						      + sizeof(__TIME__) + 3];
-    void
-make_version()
-{
-    /*
-     * Construct the long version string.  Necessary because
-     * VAX C can't catenate strings in the preprocessor.
-     */
-    strcpy(longVersion, VIM_VERSION_LONG_DATE);
-    strcat(longVersion, __DATE__);
-    strcat(longVersion, " ");
-    strcat(longVersion, __TIME__);
-    strcat(longVersion, ")");
-}
-# else
-char	*longVersion = VIM_VERSION_LONG_DATE __DATE__ " " __TIME__ ")";
-# endif
-#else
-char	*longVersion = VIM_VERSION_LONG;
-#endif
-
-static void version_msg __ARGS((char *s));
-
-static char *(features[]) =
-{
-#ifdef AMIGA		/* only for Amiga systems */
-# ifdef FEAT_ARP
-	"+ARP",
-# else
-	"-ARP",
-# endif
-#endif
-#ifdef FEAT_ARABIC
-	"+arabic",
-#else
-	"-arabic",
-#endif
-#ifdef FEAT_AUTOCMD
-	"+autocmd",
-#else
-	"-autocmd",
-#endif
-#ifdef FEAT_BEVAL
-	"+balloon_eval",
-#else
-	"-balloon_eval",
-#endif
-#ifdef FEAT_BROWSE
-	"+browse",
-#else
-	"-browse",
-#endif
-#ifdef NO_BUILTIN_TCAPS
-	"-builtin_terms",
-#endif
-#ifdef SOME_BUILTIN_TCAPS
-	"+builtin_terms",
-#endif
-#ifdef ALL_BUILTIN_TCAPS
-	"++builtin_terms",
-#endif
-#ifdef FEAT_BYTEOFF
-	"+byte_offset",
-#else
-	"-byte_offset",
-#endif
-#ifdef FEAT_CINDENT
-	"+cindent",
-#else
-	"-cindent",
-#endif
-#ifdef FEAT_CLIENTSERVER
-	"+clientserver",
-#else
-	"-clientserver",
-#endif
-#ifdef FEAT_CLIPBOARD
-	"+clipboard",
-#else
-	"-clipboard",
-#endif
-#ifdef FEAT_CMDL_COMPL
-	"+cmdline_compl",
-#else
-	"-cmdline_compl",
-#endif
-#ifdef FEAT_CMDHIST
-	"+cmdline_hist",
-#else
-	"-cmdline_hist",
-#endif
-#ifdef FEAT_CMDL_INFO
-	"+cmdline_info",
-#else
-	"-cmdline_info",
-#endif
-#ifdef FEAT_COMMENTS
-	"+comments",
-#else
-	"-comments",
-#endif
-#ifdef FEAT_CRYPT
-	"+cryptv",
-#else
-	"-cryptv",
-#endif
-#ifdef FEAT_CSCOPE
-	"+cscope",
-#else
-	"-cscope",
-#endif
-#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)
-	"+dialog_con_gui",
-#else
-# if defined(FEAT_CON_DIALOG)
-	"+dialog_con",
-# else
-#  if defined(FEAT_GUI_DIALOG)
-	"+dialog_gui",
-#  else
-	"-dialog",
-#  endif
-# endif
-#endif
-#ifdef FEAT_DIFF
-	"+diff",
-#else
-	"-diff",
-#endif
-#ifdef FEAT_DIGRAPHS
-	"+digraphs",
-#else
-	"-digraphs",
-#endif
-#ifdef FEAT_DND
-	"+dnd",
-#else
-	"-dnd",
-#endif
-#ifdef EBCDIC
-	"+ebcdic",
-#else
-	"-ebcdic",
-#endif
-#ifdef FEAT_EMACS_TAGS
-	"+emacs_tags",
-#else
-	"-emacs_tags",
-#endif
-#ifdef FEAT_EVAL
-	"+eval",
-#else
-	"-eval",
-#endif
-#ifdef FEAT_EX_EXTRA
-	"+ex_extra",
-#else
-	"-ex_extra",
-#endif
-#ifdef FEAT_SEARCH_EXTRA
-	"+extra_search",
-#else
-	"-extra_search",
-#endif
-#ifdef FEAT_FKMAP
-	"+farsi",
-#else
-	"-farsi",
-#endif
-#ifdef FEAT_SEARCHPATH
-	"+file_in_path",
-#else
-	"-file_in_path",
-#endif
-#ifdef FEAT_FIND_ID
-	"+find_in_path",
-#else
-	"-find_in_path",
-#endif
-#ifdef FEAT_FOLDING
-	"+folding",
-#else
-	"-folding",
-#endif
-#ifdef FEAT_FOOTER
-	"+footer",
-#else
-	"-footer",
-#endif
-	    /* only interesting on Unix systems */
-#if !defined(USE_SYSTEM) && defined(UNIX)
-	"+fork()",
-#endif
-#ifdef FEAT_GETTEXT
-# ifdef DYNAMIC_GETTEXT
-	"+gettext/dyn",
-# else
-	"+gettext",
-# endif
-#else
-	"-gettext",
-#endif
-#ifdef FEAT_HANGULIN
-	"+hangul_input",
-#else
-	"-hangul_input",
-#endif
-#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)
-# ifdef DYNAMIC_ICONV
-	"+iconv/dyn",
-# else
-	"+iconv",
-# endif
-#else
-	"-iconv",
-#endif
-#ifdef FEAT_INS_EXPAND
-	"+insert_expand",
-#else
-	"-insert_expand",
-#endif
-#ifdef FEAT_JUMPLIST
-	"+jumplist",
-#else
-	"-jumplist",
-#endif
-#ifdef FEAT_KEYMAP
-	"+keymap",
-#else
-	"-keymap",
-#endif
-#ifdef FEAT_LANGMAP
-	"+langmap",
-#else
-	"-langmap",
-#endif
-#ifdef FEAT_LIBCALL
-	"+libcall",
-#else
-	"-libcall",
-#endif
-#ifdef FEAT_LINEBREAK
-	"+linebreak",
-#else
-	"-linebreak",
-#endif
-#ifdef FEAT_LISP
-	"+lispindent",
-#else
-	"-lispindent",
-#endif
-#ifdef FEAT_LISTCMDS
-	"+listcmds",
-#else
-	"-listcmds",
-#endif
-#ifdef FEAT_LOCALMAP
-	"+localmap",
-#else
-	"-localmap",
-#endif
-#ifdef FEAT_MENU
-	"+menu",
-#else
-	"-menu",
-#endif
-#ifdef FEAT_SESSION
-	"+mksession",
-#else
-	"-mksession",
-#endif
-#ifdef FEAT_MODIFY_FNAME
-	"+modify_fname",
-#else
-	"-modify_fname",
-#endif
-#ifdef FEAT_MOUSE
-	"+mouse",
-#  ifdef FEAT_MOUSESHAPE
-	"+mouseshape",
-#  else
-	"-mouseshape",
-#  endif
-# else
-	"-mouse",
-#endif
-#if defined(UNIX) || defined(VMS)
-# ifdef FEAT_MOUSE_DEC
-	"+mouse_dec",
-# else
-	"-mouse_dec",
-# endif
-# ifdef FEAT_MOUSE_GPM
-	"+mouse_gpm",
-# else
-	"-mouse_gpm",
-# endif
-# ifdef FEAT_MOUSE_JSB
-	"+mouse_jsbterm",
-# else
-	"-mouse_jsbterm",
-# endif
-# ifdef FEAT_MOUSE_NET
-	"+mouse_netterm",
-# else
-	"-mouse_netterm",
-# endif
-# ifdef FEAT_MOUSE_XTERM
-	"+mouse_xterm",
-# else
-	"-mouse_xterm",
-# endif
-#endif
-#ifdef __QNX__
-# ifdef FEAT_MOUSE_PTERM
-	"+mouse_pterm",
-# else
-	"-mouse_pterm",
-# endif
-#endif
-#ifdef FEAT_MBYTE_IME
-# ifdef DYNAMIC_IME
-	"+multi_byte_ime/dyn",
-# else
-	"+multi_byte_ime",
-# endif
-#else
-# ifdef FEAT_MBYTE
-	"+multi_byte",
-# else
-	"-multi_byte",
-# endif
-#endif
-#ifdef FEAT_MULTI_LANG
-	"+multi_lang",
-#else
-	"-multi_lang",
-#endif
-#ifdef FEAT_NETBEANS_INTG
-	"+netbeans_intg",
-#else
-	"-netbeans_intg",
-#endif
-#ifdef FEAT_GUI_W32
-# ifdef FEAT_OLE
-	"+ole",
-# else
-	"-ole",
-# endif
-#endif
-#ifdef FEAT_OSFILETYPE
-	"+osfiletype",
-#else
-	"-osfiletype",
-#endif
-#ifdef FEAT_PATH_EXTRA
-	"+path_extra",
-#else
-	"-path_extra",
-#endif
-#ifdef FEAT_PERL
-# ifdef DYNAMIC_PERL
-	"+perl/dyn",
-# else
-	"+perl",
-# endif
-#else
-	"-perl",
-#endif
-#ifdef FEAT_PRINTER
-# ifdef FEAT_POSTSCRIPT
-	"+postscript",
-# else
-	"-postscript",
-# endif
-	"+printer",
-#else
-	"-printer",
-#endif
-#ifdef FEAT_PYTHON
-# ifdef DYNAMIC_PYTHON
-	"+python/dyn",
-# else
-	"+python",
-# endif
-#else
-	"-python",
-#endif
-#ifdef FEAT_QUICKFIX
-	"+quickfix",
-#else
-	"-quickfix",
-#endif
-#ifdef FEAT_RIGHTLEFT
-	"+rightleft",
-#else
-	"-rightleft",
-#endif
-#ifdef FEAT_RUBY
-# ifdef DYNAMIC_RUBY
-	"+ruby/dyn",
-# else
-	"+ruby",
-# endif
-#else
-	"-ruby",
-#endif
-#ifdef FEAT_SCROLLBIND
-	"+scrollbind",
-#else
-	"-scrollbind",
-#endif
-#ifdef FEAT_SIGNS
-	"+signs",
-#else
-	"-signs",
-#endif
-#ifdef FEAT_SMARTINDENT
-	"+smartindent",
-#else
-	"-smartindent",
-#endif
-#ifdef FEAT_SNIFF
-	"+sniff",
-#else
-	"-sniff",
-#endif
-#ifdef FEAT_STL_OPT
-	"+statusline",
-#else
-	"-statusline",
-#endif
-#ifdef FEAT_SUN_WORKSHOP
-	"+sun_workshop",
-#else
-	"-sun_workshop",
-#endif
-#ifdef FEAT_SYN_HL
-	"+syntax",
-#else
-	"-syntax",
-#endif
-	    /* only interesting on Unix systems */
-#if defined(USE_SYSTEM) && (defined(UNIX) || defined(__EMX__))
-	"+system()",
-#endif
-#ifdef FEAT_TAG_BINS
-	"+tag_binary",
-#else
-	"-tag_binary",
-#endif
-#ifdef FEAT_TAG_OLDSTATIC
-	"+tag_old_static",
-#else
-	"-tag_old_static",
-#endif
-#ifdef FEAT_TAG_ANYWHITE
-	"+tag_any_white",
-#else
-	"-tag_any_white",
-#endif
-#ifdef FEAT_TCL
-# ifdef DYNAMIC_TCL
-	"+tcl/dyn",
-# else
-	"+tcl",
-# endif
-#else
-	"-tcl",
-#endif
-#if defined(UNIX) || defined(__EMX__)
-/* only Unix (or OS/2 with EMX!) can have terminfo instead of termcap */
-# ifdef TERMINFO
-	"+terminfo",
-# else
-	"-terminfo",
-# endif
-#else		    /* unix always includes termcap support */
-# ifdef HAVE_TGETENT
-	"+tgetent",
-# else
-	"-tgetent",
-# endif
-#endif
-#ifdef FEAT_TERMRESPONSE
-	"+termresponse",
-#else
-	"-termresponse",
-#endif
-#ifdef FEAT_TEXTOBJ
-	"+textobjects",
-#else
-	"-textobjects",
-#endif
-#ifdef FEAT_TITLE
-	"+title",
-#else
-	"-title",
-#endif
-#ifdef FEAT_TOOLBAR
-	"+toolbar",
-#else
-	"-toolbar",
-#endif
-#ifdef FEAT_USR_CMDS
-	"+user_commands",
-#else
-	"-user_commands",
-#endif
-#ifdef FEAT_VERTSPLIT
-	"+vertsplit",
-#else
-	"-vertsplit",
-#endif
-#ifdef FEAT_VIRTUALEDIT
-	"+virtualedit",
-#else
-	"-virtualedit",
-#endif
-#ifdef FEAT_VISUAL
-	"+visual",
-# ifdef FEAT_VISUALEXTRA
-	"+visualextra",
-# else
-	"-visualextra",
-# endif
-#else
-	"-visual",
-#endif
-#ifdef FEAT_VIMINFO
-	"+viminfo",
-#else
-	"-viminfo",
-#endif
-#ifdef FEAT_VREPLACE
-	"+vreplace",
-#else
-	"-vreplace",
-#endif
-#ifdef FEAT_WILDIGN
-	"+wildignore",
-#else
-	"-wildignore",
-#endif
-#ifdef FEAT_WILDMENU
-	"+wildmenu",
-#else
-	"-wildmenu",
-#endif
-#ifdef FEAT_WINDOWS
-	"+windows",
-#else
-	"-windows",
-#endif
-#ifdef FEAT_WRITEBACKUP
-	"+writebackup",
-#else
-	"-writebackup",
-#endif
-#if defined(UNIX) || defined(VMS)
-# ifdef FEAT_X11
-	"+X11",
-# else
-	"-X11",
-# endif
-#endif
-#ifdef FEAT_XFONTSET
-	"+xfontset",
-#else
-	"-xfontset",
-#endif
-#ifdef FEAT_XIM
-	"+xim",
-#else
-	"-xim",
-#endif
-#if defined(UNIX) || defined(VMS)
-# ifdef USE_XSMP_INTERACT
-	"+xsmp_interact",
-# else
-#  ifdef USE_XSMP
-	"+xsmp",
-#  else
-	"-xsmp",
-#  endif
-# endif
-# ifdef FEAT_XCLIPBOARD
-	"+xterm_clipboard",
-# else
-	"-xterm_clipboard",
-# endif
-#endif
-#ifdef FEAT_XTERM_SAVE
-	"+xterm_save",
-#else
-	"-xterm_save",
-#endif
-#ifdef WIN3264
-# ifdef FEAT_XPM_W32
-	"+xpm_w32",
-# else
-	"-xpm_w32",
-# endif
-#endif
-	NULL
-};
-
-static int included_patches[] =
-{   /* Add new patch number below this line */
-/**/
-    86,
-/**/
-    85,
-/**/
-    84,
-/**/
-    83,
-/**/
-    82,
-/**/
-    81,
-/**/
-    80,
-/**/
-    79,
-/**/
-    78,
-/**/
-    77,
-/**/
-    76,
-/**/
-    75,
-/**/
-    74,
-/**/
-    73,
-/**/
-    72,
-/**/
-    71,
-/**/
-    70,
-/**/
-    69,
-/**/
-    68,
-/**/
-    67,
-/**/
-    66,
-/**/
-    65,
-/**/
-    64,
-/**/
-    63,
-/**/
-    62,
-/**/
-    61,
-/**/
-    60,
-/**/
-    59,
-/**/
-    58,
-/**/
-    57,
-/**/
-    56,
-/**/
-    55,
-/**/
-    54,
-/**/
-    53,
-/**/
-    52,
-/**/
-    51,
-/**/
-    50,
-/**/
-    49,
-/**/
-    48,
-/**/
-    47,
-/**/
-    46,
-/**/
-    45,
-/**/
-    44,
-/**/
-    43,
-/**/
-    42,
-/**/
-    41,
-/**/
-    40,
-/**/
-    39,
-/**/
-    38,
-/**/
-    37,
-/**/
-    36,
-/**/
-    35,
-/**/
-    34,
-/**/
-    33,
-/**/
-    32,
-/**/
-    31,
-/**/
-    30,
-/**/
-    29,
-/**/
-    28,
-/**/
-    27,
-/**/
-    26,
-/**/
-    25,
-/**/
-    24,
-/**/
-    23,
-/**/
-    22,
-/**/
-    21,
-/**/
-    20,
-/**/
-    19,
-/**/
-    18,
-/**/
-    17,
-/**/
-    16,
-/**/
-    15,
-/**/
-    14,
-/**/
-    13,
-/**/
-    12,
-/**/
-    11,
-/**/
-    10,
-/**/
-    9,
-/**/
-    8,
-/**/
-    7,
-/**/
-    6,
-/**/
-    5,
-/**/
-    4,
-/**/
-    3,
-/**/
-    2,
-/**/
-    1,
-/**/
-    0
-};
-
-    int
-highest_patch()
-{
-    int		i;
-    int		h = 0;
-
-    for (i = 0; included_patches[i] != 0; ++i)
-	if (included_patches[i] > h)
-	    h = included_patches[i];
-    return h;
-}
-
-#if defined(FEAT_EVAL) || defined(PROTO)
-/*
- * Return TRUE if patch "n" has been included.
- */
-    int
-has_patch(n)
-    int		n;
-{
-    int		i;
-
-    for (i = 0; included_patches[i] != 0; ++i)
-	if (included_patches[i] == n)
-	    return TRUE;
-    return FALSE;
-}
-#endif
-
-    void
-ex_version(eap)
-    exarg_T	*eap;
-{
-    /*
-     * Ignore a ":version 9.99" command.
-     */
-    if (*eap->arg == NUL)
-    {
-	msg_putchar('\n');
-	list_version();
-    }
-}
-
-    void
-list_version()
-{
-    int		i;
-    int		first;
-    char	*s = "";
-
-    /*
-     * When adding features here, don't forget to update the list of
-     * internal variables in eval.c!
-     */
-    MSG(longVersion);
-#ifdef WIN3264
-# ifdef FEAT_GUI_W32
-#  if defined(_MSC_VER) && (_MSC_VER <= 1010)
-    /* Only MS VC 4.1 and earlier can do Win32s */
-    MSG_PUTS(_("\nMS-Windows 16/32 bit GUI version"));
-#  else
-    MSG_PUTS(_("\nMS-Windows 32 bit GUI version"));
-#  endif
-    if (gui_is_win32s())
-	MSG_PUTS(_(" in Win32s mode"));
-# ifdef FEAT_OLE
-    MSG_PUTS(_(" with OLE support"));
-# endif
-# else
-    MSG_PUTS(_("\nMS-Windows 32 bit console version"));
-# endif
-#endif
-#ifdef WIN16
-    MSG_PUTS(_("\nMS-Windows 16 bit version"));
-#endif
-#ifdef MSDOS
-# ifdef DJGPP
-    MSG_PUTS(_("\n32 bit MS-DOS version"));
-# else
-    MSG_PUTS(_("\n16 bit MS-DOS version"));
-# endif
-#endif
-#ifdef MACOS
-# ifdef MACOS_X
-#  ifdef MACOS_X_UNIX
-    MSG_PUTS(_("\nMacOS X (unix) version"));
-#  else
-    MSG_PUTS(_("\nMacOS X version"));
-#  endif
-#else
-    MSG_PUTS(_("\nMacOS version"));
-# endif
-#endif
-
-#ifdef RISCOS
-    MSG_PUTS(_("\nRISC OS version"));
-#endif
-#ifdef VMS
-    MSG_PUTS("\nOpenVMS version");
-#endif
-
-    /* Print the list of patch numbers if there is at least one. */
-    /* Print a range when patches are consecutive: "1-10, 12, 15-40, 42-45" */
-    if (included_patches[0] != 0)
-    {
-	MSG_PUTS(_("\nIncluded patches: "));
-	first = -1;
-	/* find last one */
-	for (i = 0; included_patches[i] != 0; ++i)
-	    ;
-	while (--i >= 0)
-	{
-	    if (first < 0)
-		first = included_patches[i];
-	    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)
-	    {
-		MSG_PUTS(s);
-		s = ", ";
-		msg_outnum((long)first);
-		if (first != included_patches[i])
-		{
-		    MSG_PUTS("-");
-		    msg_outnum((long)included_patches[i]);
-		}
-		first = -1;
-	    }
-	}
-    }
-
-#ifdef MODIFIED_BY
-    MSG_PUTS("\n");
-    MSG_PUTS(_("Modified by "));
-    MSG_PUTS(MODIFIED_BY);
-#endif
-
-#ifdef HAVE_PATHDEF
-    if (*compiled_user != NUL || *compiled_sys != NUL)
-    {
-	MSG_PUTS(_("\nCompiled "));
-	if (*compiled_user != NUL)
-	{
-	    MSG_PUTS(_("by "));
-	    MSG_PUTS(compiled_user);
-	}
-	if (*compiled_sys != NUL)
-	{
-	    MSG_PUTS("@");
-	    MSG_PUTS(compiled_sys);
-	}
-    }
-#endif
-
-#ifdef FEAT_HUGE
-    MSG_PUTS(_("\nHuge version "));
-#else
-# ifdef FEAT_BIG
-    MSG_PUTS(_("\nBig version "));
-# else
-#  ifdef FEAT_NORMAL
-    MSG_PUTS(_("\nNormal version "));
-#  else
-#   ifdef FEAT_SMALL
-    MSG_PUTS(_("\nSmall version "));
-#   else
-    MSG_PUTS(_("\nTiny version "));
-#   endif
-#  endif
-# endif
-#endif
-#ifndef FEAT_GUI
-    MSG_PUTS(_("without GUI."));
-#else
-# ifdef FEAT_GUI_GTK
-#  ifdef FEAT_GUI_GNOME
-#   ifdef HAVE_GTK2
-    MSG_PUTS(_("with GTK2-GNOME GUI."));
-#   else
-    MSG_PUTS(_("with GTK-GNOME GUI."));
-#   endif
-#  else
-#   ifdef HAVE_GTK2
-    MSG_PUTS(_("with GTK2 GUI."));
-#   else
-    MSG_PUTS(_("with GTK GUI."));
-#   endif
-#  endif
-# else
-#  ifdef FEAT_GUI_MOTIF
-    MSG_PUTS(_("with X11-Motif GUI."));
-#  else
-#   ifdef FEAT_GUI_ATHENA
-#    ifdef FEAT_GUI_NEXTAW
-    MSG_PUTS(_("with X11-neXtaw GUI."));
-#    else
-    MSG_PUTS(_("with X11-Athena GUI."));
-#    endif
-#   else
-#    ifdef FEAT_GUI_BEOS
-    MSG_PUTS(_("with BeOS GUI."));
-#    else
-#     ifdef FEAT_GUI_PHOTON
-    MSG_PUTS(_("with Photon GUI."));
-#     else
-#      if defined(MSWIN)
-    MSG_PUTS(_("with GUI."));
-#      else
-#	if defined (TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON
-    MSG_PUTS(_("with Carbon GUI."));
-#	else
-#	 if defined (TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX
-    MSG_PUTS(_("with Cocoa GUI."));
-#	 else
-#	  if defined (MACOS)
-    MSG_PUTS(_("with (classic) GUI."));
-#	  endif
-#	 endif
-#	endif
-#      endif
-#     endif
-#    endif
-#   endif
-#  endif
-# endif
-#endif
-    version_msg(_("  Features included (+) or not (-):\n"));
-
-    /* print all the features */
-    for (i = 0; features[i] != NULL; ++i)
-    {
-	version_msg(features[i]);
-	if (msg_col > 0)
-	    version_msg(" ");
-    }
-
-    version_msg("\n");
-#ifdef SYS_VIMRC_FILE
-    version_msg(_("   system vimrc file: \""));
-    version_msg(SYS_VIMRC_FILE);
-    version_msg("\"\n");
-#endif
-#ifdef USR_VIMRC_FILE
-    version_msg(_("     user vimrc file: \""));
-    version_msg(USR_VIMRC_FILE);
-    version_msg("\"\n");
-#endif
-#ifdef USR_VIMRC_FILE2
-    version_msg(_(" 2nd user vimrc file: \""));
-    version_msg(USR_VIMRC_FILE2);
-    version_msg("\"\n");
-#endif
-#ifdef USR_VIMRC_FILE3
-    version_msg(_(" 3rd user vimrc file: \""));
-    version_msg(USR_VIMRC_FILE3);
-    version_msg("\"\n");
-#endif
-#ifdef USR_EXRC_FILE
-    version_msg(_("      user exrc file: \""));
-    version_msg(USR_EXRC_FILE);
-    version_msg("\"\n");
-#endif
-#ifdef USR_EXRC_FILE2
-    version_msg(_("  2nd user exrc file: \""));
-    version_msg(USR_EXRC_FILE2);
-    version_msg("\"\n");
-#endif
-#ifdef FEAT_GUI
-# ifdef SYS_GVIMRC_FILE
-    version_msg(_("  system gvimrc file: \""));
-    version_msg(SYS_GVIMRC_FILE);
-    version_msg("\"\n");
-# endif
-    version_msg(_("    user gvimrc file: \""));
-    version_msg(USR_GVIMRC_FILE);
-    version_msg("\"\n");
-# ifdef USR_GVIMRC_FILE2
-    version_msg(_("2nd user gvimrc file: \""));
-    version_msg(USR_GVIMRC_FILE2);
-    version_msg("\"\n");
-# endif
-# ifdef USR_GVIMRC_FILE3
-    version_msg(_("3rd user gvimrc file: \""));
-    version_msg(USR_GVIMRC_FILE3);
-    version_msg("\"\n");
-# endif
-#endif
-#ifdef FEAT_GUI
-# ifdef SYS_MENU_FILE
-    version_msg(_("    system menu file: \""));
-    version_msg(SYS_MENU_FILE);
-    version_msg("\"\n");
-# endif
-#endif
-#ifdef HAVE_PATHDEF
-    if (*default_vim_dir != NUL)
-    {
-	version_msg(_("  fall-back for $VIM: \""));
-	version_msg((char *)default_vim_dir);
-	version_msg("\"\n");
-    }
-    if (*default_vimruntime_dir != NUL)
-    {
-	version_msg(_(" f-b for $VIMRUNTIME: \""));
-	version_msg((char *)default_vimruntime_dir);
-	version_msg("\"\n");
-    }
-    version_msg(_("Compilation: "));
-    version_msg((char *)all_cflags);
-    version_msg("\n");
-#ifdef VMS
-    if (*compiler_version != NUL)
-    {
-	version_msg(_("Compiler: "));
-	version_msg((char *)compiler_version);
-	version_msg("\n");
-    }
-#endif
-    version_msg(_("Linking: "));
-    version_msg((char *)all_lflags);
-#endif
-#ifdef DEBUG
-    version_msg("\n");
-    version_msg(_("  DEBUG BUILD"));
-#endif
-}
-
-/*
- * Output a string for the version message.  If it's going to wrap, output a
- * newline, unless the message is too long to fit on the screen anyway.
- */
-    static void
-version_msg(s)
-    char	*s;
-{
-    int		len = (int)STRLEN(s);
-
-    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns
-								&& *s != '\n')
-	msg_putchar('\n');
-    if (!got_int)
-	MSG_PUTS(s);
-}
-
-static void do_intro_line __ARGS((int row, char_u *mesg, int add_version, int attr));
-
-/*
- * Give an introductory message about Vim.
- * Only used when starting Vim on an empty file, without a file name.
- * Or with the ":intro" command (for Sven :-).
- */
-    void
-intro_message(colon)
-    int		colon;		/* TRUE for ":intro" */
-{
-    int		i;
-    int		row;
-    int		blanklines;
-    int		sponsor;
-    char	*p;
-    static char	*(lines[]) =
-    {
-	N_("VIM - Vi IMproved"),
-	"",
-	N_("version "),
-	N_("by Bram Moolenaar et al."),
-#ifdef MODIFIED_BY
-	" ",
-#endif
-	N_("Vim is open source and freely distributable"),
-	"",
-	N_("Help poor children in Uganda!"),
-	N_("type  :help iccf<Enter>       for information "),
-	"",
-	N_("type  :q<Enter>               to exit         "),
-	N_("type  :help<Enter>  or  <F1>  for on-line help"),
-	N_("type  :help version6<Enter>   for version info"),
-	NULL,
-	"",
-	N_("Running in Vi compatible mode"),
-	N_("type  :set nocp<Enter>        for Vim defaults"),
-	N_("type  :help cp-default<Enter> for info on this"),
-    };
-#ifdef FEAT_GUI
-    static char	*(gui_lines[]) =
-    {
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-#ifdef MODIFIED_BY
-	NULL,
-#endif
-	NULL,
-	NULL,
-	NULL,
-	N_("menu  Help->Orphans           for information    "),
-	NULL,
-	N_("Running modeless, typed text is inserted"),
-	N_("menu  Edit->Global Settings->Toggle Insert Mode  "),
-	N_("                              for two modes      "),
-	NULL,
-	NULL,
-	NULL,
-	N_("menu  Edit->Global Settings->Toggle Vi Compatible"),
-	N_("                              for Vim defaults   "),
-    };
-#endif
-
-    /* blanklines = screen height - # message lines */
-    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);
-    if (!p_cp)
-	blanklines += 4;  /* add 4 for not showing "Vi compatible" message */
-#if defined(WIN3264) && !defined(FEAT_GUI_W32)
-    if (mch_windows95())
-	blanklines -= 3;  /* subtract 3 for showing "Windows 95" message */
-#endif
-
-#ifdef FEAT_WINDOWS
-    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */
-    if (p_ls > 1)
-	blanklines -= Rows - topframe->fr_height;
-#endif
-    if (blanklines < 0)
-	blanklines = 0;
-
-    /* Show the sponsor and register message one out of four times, the Uganda
-     * message two out of four times. */
-    sponsor = time(NULL);
-    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);
-
-    /* start displaying the message lines after half of the blank lines */
-    row = blanklines / 2;
-    if ((row >= 2 && Columns >= 50) || colon)
-    {
-	for (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)
-	{
-	    p = lines[i];
-#ifdef FEAT_GUI
-	    if (p_im && gui.in_use && gui_lines[i] != NULL)
-		p = gui_lines[i];
-#endif
-	    if (p == NULL)
-	    {
-		if (!p_cp)
-		    break;
-		continue;
-	    }
-	    if (sponsor != 0)
-	    {
-		if (strstr(p, "children") != NULL)
-		    p = sponsor < 0
-			? N_("Sponsor Vim development!")
-			: N_("Become a registered Vim user!");
-		else if (strstr(p, "iccf") != NULL)
-		    p = sponsor < 0
-			? N_("type  :help sponsor<Enter>    for information ")
-			: N_("type  :help register<Enter>   for information ");
-		else if (strstr(p, "Orphans") != NULL)
-		    p = N_("menu  Help->Sponsor/Register  for information    ");
-	    }
-	    if (*p != NUL)
-		do_intro_line(row, (char_u *)_(p), i == 2, 0);
-	    ++row;
-	}
-#if defined(WIN3264) && !defined(FEAT_GUI_W32)
-	if (mch_windows95())
-	{
-	    do_intro_line(++row,
-		    (char_u *)_("WARNING: Windows 95/98/ME detected"),
-							FALSE, hl_attr(HLF_E));
-	    do_intro_line(++row,
-		(char_u *)_("type  :help windows95<Enter>  for info on this"),
-								    FALSE, 0);
-	}
-#endif
-    }
-
-    /* Make the wait-return message appear just below the text. */
-    if (colon)
-	msg_row = row;
-}
-
-    static void
-do_intro_line(row, mesg, add_version, attr)
-    int		row;
-    char_u	*mesg;
-    int		add_version;
-    int		attr;
-{
-    char_u	vers[20];
-    int		col;
-    char_u	*p;
-    int		l;
-    int		clen;
-#ifdef MODIFIED_BY
-# define MODBY_LEN 150
-    char_u	modby[MODBY_LEN];
-
-    if (*mesg == ' ')
-    {
-	STRNCPY(modby, _("Modified by "), MODBY_LEN);
-	modby[MODBY_LEN - 1] = NUL;
-	l = STRLEN(modby);
-	STRNCPY(modby + l, MODIFIED_BY, MODBY_LEN - l);
-	modby[MODBY_LEN - 1] = NUL;
-	mesg = modby;
-    }
-#endif
-
-    /* Center the message horizontally. */
-    col = vim_strsize(mesg);
-    if (add_version)
-    {
-	STRCPY(vers, mediumVersion);
-	if (highest_patch())
-	{
-	    /* Check for 9.9x or 9.9xx, alpha/beta version */
-	    if (isalpha((int)mediumVersion[3]))
-	    {
-		if (isalpha((int)mediumVersion[4]))
-		    sprintf((char *)vers + 5, ".%d%s", highest_patch(),
-							   mediumVersion + 5);
-		else
-		    sprintf((char *)vers + 4, ".%d%s", highest_patch(),
-							   mediumVersion + 4);
-	    }
-	    else
-		sprintf((char *)vers + 3, ".%d", highest_patch());
-	}
-	col += (int)STRLEN(vers);
-    }
-    col = (Columns - col) / 2;
-    if (col < 0)
-	col = 0;
-
-    /* Split up in parts to highlight <> items differently. */
-    for (p = mesg; *p != NUL; p += l)
-    {
-	clen = 0;
-	for (l = 0; p[l] != NUL
-			 && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)
-	{
-#ifdef FEAT_MBYTE
-	    if (has_mbyte)
-	    {
-		clen += ptr2cells(p + l);
-		l += (*mb_ptr2len_check)(p + l) - 1;
-	    }
-	    else
-#endif
-		clen += byte2cells(p[l]);
-	}
-	screen_puts_len(p, l, row, col, *p == '<' ? hl_attr(HLF_8) : attr);
-	col += clen;
-    }
-
-    /* Add the version number to the version line. */
-    if (add_version)
-	screen_puts(vers, row, col, 0);
-}
-
-/*
- * ":intro": clear screen, display intro screen and wait for return.
- */
-/*ARGSUSED*/
-    void
-ex_intro(eap)
-    exarg_T	*eap;
-{
-    screenclear();
-    intro_message(TRUE);
-    wait_return(TRUE);
-}
diff -Nur vim63/src/vim_bonobo_control.c vim63-bonobo/src/vim_bonobo_control.c
--- vim63/src/vim_bonobo_control.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_control.c	2005-09-09 20:14:02.763580136 +0200
@@ -0,0 +1,612 @@
+/**
+ * vim_bonobo_control.c
+ *
+ * Author:
+ *   Jason Hildebrand <jason@peaceworks.ca>
+ *
+ */
+#include <stdio.h>
+
+#include "vim.h"
+#include "vim_bonobo_control.h"
+#include "gtkhtml_editor.h"
+
+#include <gnome.h>
+#include <libbonoboui.h>
+#include <libbonobo.h>
+/*#include <libnautilus/nautilus-view.h>*/
+#include <X11/Intrinsic.h>
+#include <X11/Xatom.h>
+#include <gdk/gdkx.h>
+
+struct _VimControlPrivate {
+    BonoboUIComponent *component;
+};
+
+static GObjectClass *vim_control_parent_class;
+
+static gboolean
+quit_vim(gpointer data)
+{
+    getout_preserve_modified(0);
+}
+
+static void
+vim_control_destroy (BonoboObject *control)
+{
+	BonoboUIComponent *uic;
+
+	g_return_if_fail (control != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (control));
+
+    g_message ("Destroying VimControl...");
+
+	uic = bonobo_control_get_ui_component (BONOBO_CONTROL (control));
+    if( uic != CORBA_OBJECT_NIL )
+        bonobo_ui_component_unset_container (uic, NULL);
+
+	BONOBO_OBJECT_CLASS (vim_control_parent_class)->destroy (control);
+
+    /* we only support creating one vim control per process, so when this one
+     * is finished, we're done. */ 
+    g_timeout_add(50, &quit_vim, NULL);
+}
+
+static void
+vim_control_finalize (GObject *object)
+{
+	VimControl *control;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (object));
+
+	control = VIM_CONTROL (object);
+
+	g_free (control->priv);
+
+	G_OBJECT_CLASS (vim_control_parent_class)->finalize (object);
+}
+
+static void
+vim_control_set_ui_container (VimControl *control,
+			      Bonobo_UIContainer ui_container)
+{
+	BonoboUIComponent *uic;
+	
+	g_return_if_fail (control != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (control));
+	g_return_if_fail (ui_container != CORBA_OBJECT_NIL);
+
+	uic = bonobo_control_get_ui_component (BONOBO_CONTROL (control));
+	bonobo_ui_component_set_container (uic, ui_container, NULL);
+
+    /* schedule a UI update */
+    update_ui_later();
+}
+
+static void
+vim_control_unset_ui_container (VimControl *control)
+{
+	BonoboUIComponent *uic;
+
+	g_return_if_fail (control != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (control));
+
+	uic = bonobo_control_get_ui_component (BONOBO_CONTROL (control));
+	bonobo_ui_component_unset_container (uic, NULL);
+}
+
+static grab_keys = 0;
+
+#if 0
+static GdkFilterReturn
+filter_key_events (GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
+{
+ /* GdkScreen *screen = gdk_drawable_get_screen (event->any.window);
+  GdkDisplay *display = gdk_screen_get_display (screen);*/
+  XEvent *xevent = (XEvent *)gdk_xevent;
+                                                                                
+  GdkFilterReturn return_val;
+                                                                                
+  return_val = GDK_FILTER_CONTINUE;
+                                                                                
+  switch (xevent->type)
+  {
+      case KeyPress:
+        g_warning("Key press!");
+        break;
+
+      case KeyRelease:
+        g_warning("Key release!");
+        break;
+
+      default:
+        break;
+  }
+  return return_val;
+}
+#endif
+
+static void
+set_frame_cb (BonoboControl *object, gpointer data)
+{
+    Bonobo_ControlFrame frame;
+	VimControl *control;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (object));
+
+    frame = bonobo_control_get_control_frame (object, NULL);
+    if (frame == CORBA_OBJECT_NIL)
+        return;
+    CORBA_Object_release (frame, NULL);
+
+	control = VIM_CONTROL (object);
+
+    Bonobo_UIContainer ui_container;
+
+    ui_container = bonobo_control_get_remote_ui_container (BONOBO_CONTROL (control), NULL);
+    if (ui_container != CORBA_OBJECT_NIL) {
+        vim_control_set_ui_container (control, ui_container);
+        bonobo_object_release_unref (ui_container, NULL);
+    }
+
+}
+
+static void
+embedded_cb (GtkPlug *plug)
+{
+    Atom     wm_class;
+    Atom     actual_type;
+    int        actual_format;
+    unsigned long actual_length;
+    unsigned long remaining_bytes;
+    unsigned char * wm_class_value;
+    Window   win;
+    Window   root;
+    Window   parent;
+    Window * children = NULL;
+    unsigned int nchildren;
+    int     result;
+
+    wm_class = gdk_x11_get_xatom_by_name("WM_CLASS");
+    win = GDK_WINDOW_XID(plug->socket_window);
+
+    while( TRUE ) {
+        /*g_warning("checking xid %d", win);*/
+        result = XGetWindowProperty (GDK_WINDOW_XDISPLAY (plug->socket_window), 
+                            win, 
+                            wm_class, 0, 120, False, XA_STRING, 
+                            &actual_type, &actual_format,
+                  &actual_length, &remaining_bytes, &wm_class_value);
+        if( result == Success && actual_type != None) {
+            /*g_warning("WM_CLASS is %s", wm_class_value);*/
+            apply_autocmds(EVENT_EMBEDDED_COMPONENT, wm_class_value, NULL, FALSE, persistent_buffer);
+            XFree(wm_class_value);         
+            break;
+        }
+        gdk_error_trap_push ();
+        result = XQueryTree(GDK_WINDOW_XDISPLAY(plug->socket_window),
+                       win,
+                       &root, &parent, &children, &nchildren);
+        if (gdk_error_trap_pop () || !result) {
+            break;
+        }
+        if( children ) {
+            XFree(children);
+            children = NULL;
+        }
+        if( root == parent) {
+            /* we've reached the root window */
+            break;
+        }
+        win = parent;
+    }
+}
+
+static void
+vim_control_class_init (VimControl *klass)
+{
+	GObjectClass *gobject_class = (GObjectClass *)klass;
+	BonoboObjectClass *bonobo_object_class = (BonoboObjectClass *)klass;
+	BonoboControlClass *control_class = (BonoboControlClass *)klass;
+
+	vim_control_parent_class= g_type_class_peek_parent (klass);
+
+	bonobo_object_class->destroy = vim_control_destroy;
+	gobject_class->finalize = vim_control_finalize;
+}
+
+static char_u * stream_buffer = NULL;
+static int stream_offset = 0;
+static CORBA_long  stream_length = 0;
+static Bonobo_Stream current_stream;
+
+/* It seems like it is an error to attempt to read more data
+ * than is available from a bonobo stream.  So we slurp in
+ * the entire file in one chunk, and then pass it back in 
+ * pieces to the caller. 
+ */
+int
+vim_control_persist_stream_read(char_u * buffer, int reqsize)
+{
+    int read_size;
+
+    if( stream_offset >= stream_length ) {
+        return 0;
+    }
+    read_size = stream_length - stream_offset >= reqsize ? 
+                    reqsize : stream_length - stream_offset;
+    mch_memmove(buffer, &stream_buffer[stream_offset], read_size);
+    stream_offset += read_size;
+    return read_size;
+}
+
+int
+vim_control_persist_stream_write(char_u * buffer, int reqsize)
+{
+    CORBA_Environment ev;
+
+    CORBA_exception_init(&ev);
+    bonobo_stream_client_write(current_stream, buffer, reqsize, &ev);
+	if (ev._major != CORBA_NO_EXCEPTION ) {
+        g_warning("Error writing to stream");
+		CORBA_exception_free (&ev);
+        return 0;
+	}
+    CORBA_exception_free (&ev);
+    return reqsize;
+}
+
+void
+component_set_dirty(gboolean dirty)
+{
+    bonobo_persist_set_dirty(BONOBO_PERSIST(gui.pstream), dirty);
+    bonobo_persist_set_dirty(BONOBO_PERSIST(gui.pfile), dirty);
+}
+
+static void load_buffer_from_stream( const Bonobo_Stream         stream,
+                      Bonobo_Persist_ContentType  type,
+                      CORBA_Environment          *ev)
+{
+    exarg_T		ea;			/* Ex command arguments */
+
+    g_warning ("load_buffer_from_stream");
+
+    stream_buffer = bonobo_stream_client_read( stream, -1, &stream_length, ev);
+	if (ev->_major != CORBA_NO_EXCEPTION) {
+        g_warning("Error reading from stream");
+        return;
+	}
+    stream_offset = 0;
+
+    if( persistent_buffer ) {
+        /* make it possible to delete the existing buffer, so that it 
+         * can be replaced with what we are about to load */
+        persistent_buffer->emb_buffer = FALSE;
+    }
+
+    vim_memset(&ea, 0, sizeof(ea));
+    ea.cmd = "e ++enc=utf-8";
+    ea.force_enc = 8; /* this is the offset of "utf-8" in the cmd */
+
+    read_from_container = PERSIST_STREAM_IO;
+    do_ecmd(0, NULL, NULL, &ea, 1, ECMD_OLDBUF|ECMD_FORCEIT);
+    read_from_container = NORMAL_IO;
+
+    /* we've set the fileencoding to utf-8; set encoding to utf-8 as * well.*/
+    do_cmdline_cmd("set encoding=utf-8");
+
+    /* remember this buffer */
+	persistent_buffer = curbuf;
+    ga_clear(&error_ga);
+    g_free(stream_buffer);
+
+        
+    /* run a filter to obtain plain text from the html */
+    if( !strcmp( type, "text/html" )) {
+        vim_bonobo_call_begin();
+        /* Substitutions to recognize quoted text */
+        do_cmdline_cmd("%s/<!--+GtkHTML[^>]*class=\"ClueFlow\"[^>]*key=\"orig\"[^>]*value=\"1\">-->/<pre>GtkHTML_QUOTE_ON<\\/pre>");
+        do_cmdline_cmd("%s/<!--+GtkHTML[^>]*class=\"ClueFlow\"[^>]*clear=\"orig\"[^>]*>-->/<pre>GtkHTML_QUOTE_OFF<\\/pre>");
+        do_cmdline_cmd("%s/<\\/i><\\/blockquote>/<\\/pre><\\/i><\\/blockquote>/");
+        do_cmdline_cmd("%!html2text -nobs");
+        do_cmdline_cmd("call EvoQuote()");
+        vim_bonobo_call_end();
+    }
+    do_cmdline_cmd("set nomodified");
+    component_set_dirty(FALSE);
+}
+
+static void load_buffer_from_stream_cb(BonoboPersistStream *ps,
+                      const Bonobo_Stream         stream,
+                      Bonobo_Persist_ContentType  type,
+                      void                       *closure,
+                      CORBA_Environment          *ev)
+{
+    load_buffer_from_stream(stream, type, ev);
+}
+
+static void 
+save_buffer_to_stream( const Bonobo_Stream         stream,
+                      Bonobo_Persist_ContentType  type,
+                      CORBA_Environment          *ev)
+{
+    buf_T * buf;
+    exarg_T		ea;			/* Ex command arguments */
+
+    /*g_warning ("save_buffer_to_stream");*/
+
+    current_stream = stream;
+    write_to_container = PERSIST_STREAM_IO;
+
+    if( !strcmp(type, "text/html")) {
+        vim_control_persist_stream_write("<pre>", 5);
+    }
+
+    vim_memset(&ea, 0, sizeof(ea));
+    ea.cmd = "e ++enc=utf-8";
+    ea.force_enc = 8; /* this is the offset of "utf-8" in the cmd */
+
+    buf = persistent_buffer;
+    buf_write(buf, "dummy", "dummy", 1, buf->b_ml.ml_line_count, 
+                &ea, FALSE, FALSE, TRUE, TRUE);
+    if( !strcmp(type, "text/html")) {
+        vim_control_persist_stream_write("</pre>", 6);
+    }
+    write_to_container = NORMAL_IO;
+    ga_clear(&error_ga);
+}
+
+static void 
+save_buffer_to_stream_cb(BonoboPersistStream         *ps,
+                      const Bonobo_Stream         stream,
+                      Bonobo_Persist_ContentType  type,
+                      void                       *closure,
+                      CORBA_Environment          *ev)
+{
+    save_buffer_to_stream(stream, type, ev);
+}
+
+static gint
+load_buffer_from_file (BonoboPersistFile *pf,
+                const CORBA_char  *filename,
+		        CORBA_Environment *ev,
+                void              *closure)
+{
+	Bonobo_PersistStream ps = closure;
+	BonoboStream *stream;
+	
+    /* FIXME!! */
+    stream = bonobo_get_object(filename, "IDL:Bonobo/Stream:1.0", ev);
+
+	if (!stream)
+		return 0;
+
+	load_buffer_from_stream (ps, "text/plain", ev);
+	return 0; /* Return 0 on success */
+}
+
+static gint
+save_to_file (BonoboPersistFile *pf,
+              const CORBA_char  *filename,
+              CORBA_Environment *ev,
+              void              *closure)
+{
+	Bonobo_PersistStream ps = closure;
+	BonoboStream *stream;
+	
+    
+    /*
+	stream = bonobo_stream_open (
+		BONOBO_IO_DRIVER_FS,
+		filename, Bonobo_STORAGE_WRITE | Bonobo_STORAGE_CREATE,
+		S_IRUSR | S_IWUSR | S_IRGRP);
+
+	if (!stream)
+		return 0;
+
+	save_buffer_to_stream (NULL, ps, "text/plain", ev);
+    */
+	return 0; /* Return 0 on success */
+}
+
+
+Bonobo_Persist_ContentTypeList * 
+persist_stream_types( BonoboPersistStream * ps, void * closure, CORBA_Environment *ev )
+{
+    /*g_warning ("persist_stream_types");*/
+    return bonobo_persist_generate_content_types(2, "text/plain", "text/html");
+}
+
+
+#if 0
+static void
+nv_load_location_cb (NautilusView *view, const char *location, gpointer user_data)
+{
+	g_return_if_fail (NAUTILUS_IS_VIEW (view));
+	g_return_if_fail (location != NULL);
+
+	nautilus_view_report_load_underway (NAUTILUS_VIEW (view));
+
+    /* FIXME: load the file here (using gnome-vfs)! */
+	nautilus_view_report_load_complete (NAUTILUS_VIEW (view));
+}
+#endif
+
+static enum {
+    EDITOR_NEEDS_ESCAPE
+} EditorControlProps;
+
+editor_get_prop (BonoboPropertyBag *bag,
+         BonoboArg         *arg,
+         guint              arg_id,
+         CORBA_Environment *ev,
+         gpointer           user_data)
+{
+    //GtkHTMLControlData *cd = user_data;
+                                                                                
+    switch (arg_id) {
+    case EDITOR_NEEDS_ESCAPE:
+        BONOBO_ARG_SET_BOOLEAN (arg, TRUE);
+        break;
+    default:
+        bonobo_exception_set (ev, ex_Bonobo_PropertyBag_NotFound);
+        break;
+    }
+}
+
+static void
+editor_set_prop (BonoboPropertyBag *bag,
+         const BonoboArg   *arg,
+         guint              arg_id,
+         CORBA_Environment *ev,
+         gpointer           user_data)
+{
+    //GtkHTMLControlData *cd = user_data;
+                                                                                
+    switch (arg_id) {
+    case EDITOR_NEEDS_ESCAPE:
+        bonobo_exception_set (ev, ex_Bonobo_PropertyBag_ReadOnly);
+        break;
+    default:
+        bonobo_exception_set (ev, ex_Bonobo_PropertyBag_NotFound);
+        break;
+    }
+}
+
+static void
+vim_control_init (VimControl *control)
+{
+	control->priv = g_new0 (VimControlPrivate, 1);
+}
+
+BONOBO_TYPE_FUNC (VimControl, BONOBO_TYPE_CONTROL, vim_control);
+
+BonoboObject *
+vim_control_add_interfaces (VimControl     *control,
+			  BonoboObject *to_aggregate)
+{
+	BonoboPersistFile   *file;
+    //NautilusView        *nv;
+	BonoboPersistStream *stream;
+    EditorEngine        *engine; /* GtkHTML editor engine interface */
+	//BonoboItemContainer *item_container;
+
+	
+	g_return_val_if_fail (VIM_IS_CONTROL (control), NULL);
+	g_return_val_if_fail (BONOBO_IS_OBJECT (to_aggregate), NULL);
+
+	/* Interface Bonobo::PersistStream */
+    stream = bonobo_persist_stream_new (load_buffer_from_stream_cb,
+                                        save_buffer_to_stream_cb, 
+                                        persist_stream_types, 
+                                        VIM_OAFIID, 
+                                        control);
+    if (!stream) {
+        bonobo_object_unref (BONOBO_OBJECT (to_aggregate));
+        return NULL;
+    }
+	bonobo_object_add_interface (BONOBO_OBJECT (to_aggregate),
+				     BONOBO_OBJECT (stream));
+    gui.pstream = stream;
+
+	/* Interface Bonobo::PersistFile */
+	file = bonobo_persist_file_new (load_buffer_from_file, 
+					    save_buffer_to_stream, VIM_OAFIID, control);
+	if (!file) {
+		bonobo_object_unref (BONOBO_OBJECT (to_aggregate));
+		return NULL;
+	}
+	bonobo_object_add_interface (BONOBO_OBJECT (to_aggregate),
+				     BONOBO_OBJECT (file));
+    gui.pfile = file;
+
+    /*
+    nv = nautilus_view_new_from_bonobo_control(BONOBO_CONTROL(control));
+    if( !nv ) {
+        bonobo_object_unref (BONOBO_OBJECT(to_aggregate));
+        return NULL;
+    }
+	bonobo_object_add_interface (BONOBO_OBJECT (to_aggregate),
+				     BONOBO_OBJECT (nv));
+
+	g_signal_connect (G_OBJECT (nv), "load_location",
+			  G_CALLBACK (nv_load_location_cb), NULL);
+        */
+
+    engine = editor_engine_new();
+    if( !engine ) {
+        bonobo_object_unref (BONOBO_OBJECT(to_aggregate));
+        return NULL;
+    }
+	bonobo_object_add_interface (BONOBO_OBJECT (to_aggregate),
+				     BONOBO_OBJECT (engine));
+
+	return to_aggregate;
+}
+
+VimControl *
+vim_control_construct (VimControl    *control)
+{
+	GtkWidget             *button;
+	GtkWidget             *label;
+    BonoboPlug            *plug;
+    GtkAccelGroup         *group;
+    GClosure              *closure;
+	//VimControlPrivate     *priv;
+    BonoboPropertyBag  *pb;
+    BonoboArg          *def;
+	
+	g_return_val_if_fail (control != NULL, NULL);
+	g_return_val_if_fail (VIM_IS_CONTROL (control), NULL);
+
+
+	if (!vim_control_add_interfaces (control, BONOBO_OBJECT (control)))
+		return NULL;
+
+    gui.control = BONOBO_CONTROL(control);
+    gui.plug = (BonoboPlug *)bonobo_control_get_plug(control);
+    gui.mainwin = GTK_WIDGET(gui.plug);
+    gui_mch_init();
+
+    g_signal_connect (control, "set_frame", G_CALLBACK (set_frame_cb), NULL);
+    g_signal_connect (gui.plug, "embedded", G_CALLBACK (embedded_cb), NULL);
+
+	/* Create the vim-view */
+	//priv->image_view = vim_image_view_new (vim, FALSE);
+	//if (!priv->image_view) {
+		//bonobo_object_unref (BONOBO_OBJECT (control));
+		//return NULL;
+	//}
+
+    pb = bonobo_property_bag_new (editor_get_prop, editor_set_prop, NULL);
+    bonobo_control_set_properties (control, BONOBO_OBJREF (pb), NULL);
+                                                                                
+    def = bonobo_arg_new (BONOBO_ARG_BOOLEAN);
+    BONOBO_ARG_SET_BOOLEAN (def, TRUE);
+                                                                                
+    bonobo_property_bag_add (pb, "EditorNeedsEscape", EDITOR_NEEDS_ESCAPE,
+                 BONOBO_ARG_BOOLEAN, def,
+                 "Whether the editor requires Escape key events",
+                 0);
+                                                                                
+    CORBA_free (def);
+
+    bonobo_object_unref (BONOBO_OBJECT (pb));
+    
+	return control;
+}
+
+VimControl *
+vim_control_new (void)
+{
+	VimControl *control;
+	
+    g_message ("Creating VimControl...");
+
+	control = g_object_new (VIM_CONTROL_TYPE, NULL);
+
+	return vim_control_construct (control);
+}
+
diff -Nur vim63/src/vim_bonobo_control.h vim63-bonobo/src/vim_bonobo_control.h
--- vim63/src/vim_bonobo_control.h	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_control.h	2005-09-09 20:14:02.764579984 +0200
@@ -0,0 +1,50 @@
+/*
+ * vim_bonobo_control.h
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#ifndef _VIM_CONTROL_H_
+#define _VIM_CONTROL_H_
+
+#include <bonobo/bonobo-control.h>
+#define VIM_OAFIID "OAFIID:Vim_Control"
+#define NORMAL_IO 0
+#define PERSIST_STREAM_IO 1
+#define PERSIST_FILE_IO 2
+
+G_BEGIN_DECLS
+ 
+#define VIM_CONTROL_TYPE           (vim_control_get_type ())
+#define VIM_CONTROL(o)             (G_TYPE_CHECK_INSTANCE_CAST ((o), VIM_CONTROL_TYPE, VimControl))
+#define VIM_CONTROL_CLASS(k)       (G_TYPE_CHECK_CLASS_CAST((k), VIM_CONTROL_TYPE, VimControlClass))
+
+#define VIM_IS_CONTROL(o)          (G_TYPE_CHECK_INSTANCE_TYPE ((o), VIM_CONTROL_TYPE))
+#define VIM_IS_CONTROL_CLASS(k)    (G_TYPE_CHECK_CLASS_TYPE ((k), VIM_CONTROL_TYPE))
+#define VIM_CONTROL_GET_CLASS(o)   (G_TYPE_INSTANCE_GET_CLASS ((o), VIM_CONTROL_TYPE, VimControlClass))
+
+typedef struct _VimControl         VimControl;
+typedef struct _VimControlClass    VimControlClass;
+typedef struct _VimControlPrivate  VimControlPrivate;
+
+struct _VimControl {
+	BonoboControl control;
+
+	VimControlPrivate *priv;
+};
+
+struct _VimControlClass {
+	BonoboControlClass parent_class;
+};
+
+GType         vim_control_get_type                    (void);
+VimControl    *vim_control_new                         (void);
+VimControl    *vim_control_construct                   (VimControl    *control);
+
+void set_curbuf_persistent(void);
+
+G_END_DECLS
+
+#endif /* _VIM_CONTROL_H_*/
diff -Nur vim63/src/vim_bonobo_factory.c vim63-bonobo/src/vim_bonobo_factory.c
--- vim63/src/vim_bonobo_factory.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_factory.c	2005-09-09 20:14:02.764579984 +0200
@@ -0,0 +1,73 @@
+/*
+ * vim_bonobo_factory.c
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#include "vim.h"
+#include "version.h"
+#include <bonobo/bonobo-generic-factory.h>
+#include "vim_bonobo_control.h"
+
+static BonoboGenericFactory *factory = NULL;
+static int vim_instantiated = 0;
+
+static BonoboObject *
+vim_bonobo_factory(BonoboGenericFactory *this,
+              const char           *oaf_iid,
+              void                 *data)
+{
+    VimControl     *vim;
+    BonoboObject *retval;
+
+    g_return_val_if_fail (this != NULL, NULL);
+    g_return_val_if_fail (oaf_iid != NULL, NULL);
+
+    if( vim_instantiated ) {
+        /* we cannot instantiate more than one control from this process,
+         * because of all of vim's global variables */
+        return NULL;
+    }
+                                                                                
+    g_message ("Trying to produce a '%s'...", oaf_iid);
+                                                                                
+    if (strcmp (oaf_iid, VIM_OAFIID) == 0) {
+        vim = vim_control_new ();
+        if (vim == NULL)
+            return NULL;
+        retval = BONOBO_OBJECT (vim);
+    } else {
+        g_warning ("Unknown IID `%s' requested", oaf_iid);
+        return NULL;
+    }
+    vim_instantiated = 1;
+                                                                                
+    return retval;
+}
+
+/* wait until this component is instantiated */
+int vim_bonobo_wait_for_instantiation()
+{
+    while( !vim_instantiated) {
+        MAIN_ITERATION_DO(TRUE);
+    }
+}
+
+
+int vim_bonobo_init(int *argc, char *argv[])
+{
+    if (!bonobo_ui_init ("gnome-vim", VIM_VERSION_SHORT, argc, argv))
+        g_error (_("Could not initialize Bonobo"));
+                                                                                
+    factory = bonobo_generic_factory_new (
+        VIM_FACTORY_OAFIID, vim_bonobo_factory, NULL);
+                                                                                
+    if (factory == NULL) {
+        g_error ("Couldn't create factory.\n");
+        return 0;
+    }
+    return 1;
+}
+
diff -Nur vim63/src/vim_bonobo_factory.h vim63-bonobo/src/vim_bonobo_factory.h
--- vim63/src/vim_bonobo_factory.h	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_factory.h	2005-09-09 20:14:02.765579832 +0200
@@ -0,0 +1,17 @@
+/*
+ * vim_bonobo_factory.h
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#if !defined( _VIM_BONOBO_FACTORY_H)
+#define _VIM_BONOBO_FACTORY_H
+
+#define VIM_FACTORY_OAFIID     "OAFIID:Vim_Control_Factory"
+
+void gui_component_init(int *argc, char *argv []);
+int gui_component_wait_for_instantiation(void);
+
+#endif
diff -Nur vim63/src/vim_bonobo_main.c vim63-bonobo/src/vim_bonobo_main.c
--- vim63/src/vim_bonobo_main.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_main.c	2005-09-09 20:14:02.765579832 +0200
@@ -0,0 +1,98 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+#include "vim.h"
+
+#include <glib/gmain.h>
+#include <glib-object.h>
+#include <bonobo/Bonobo.h>
+
+static guint              bonobo_main_loop_level = 0;
+static GSList *           bonobo_main_loops = NULL;
+
+static gboolean           in_bonobo_call = FALSE;
+
+
+/**
+ * bonobo_main:
+ * 
+ * Activates the Bonobo POA Manager and enters the main event loop.
+ */
+void
+vim_bonobo_main (void)
+{
+	GMainLoop *loop;
+
+    if( in_bonobo_call ) {
+        return;
+    }
+
+	bonobo_activate ();
+
+	bonobo_main_loop_level++;
+  
+	loop = g_main_loop_new (NULL, TRUE);
+	bonobo_main_loops = g_slist_prepend (bonobo_main_loops, loop);
+
+	if (g_main_loop_is_running (bonobo_main_loops->data))
+		g_main_loop_run (loop);
+
+	bonobo_main_loops = g_slist_remove (bonobo_main_loops, loop);
+
+	g_main_loop_unref (loop);
+
+	bonobo_main_loop_level--;
+}
+
+/**
+ * bonobo_main_quit:
+ * 
+ * Quits the main event loop.
+ */
+void
+vim_bonobo_main_quit (void)
+{
+	g_return_if_fail (bonobo_main_loops != NULL);
+
+	g_main_loop_quit (bonobo_main_loops->data);
+}
+
+int
+vim_bonobo_main_level(void)
+{
+    return bonobo_main_loop_level;
+}
+
+static long save_p_report;
+static int save_msg_silent;
+static int save_emsg_silent;
+
+void
+vim_bonobo_call_begin(void)
+{
+    in_bonobo_call = TRUE;
+    gui.processing_call = TRUE;
+    save_p_report = p_report;
+    p_report = 100000;
+    save_msg_silent = msg_silent;
+    msg_silent = TRUE;
+    save_emsg_silent = emsg_silent;
+    emsg_silent = TRUE;
+}
+
+void
+vim_bonobo_call_end(void)
+{
+    in_bonobo_call = FALSE;
+    gui.processing_call = FALSE;
+    msg_silent = save_msg_silent;
+    emsg_silent = save_emsg_silent;
+    p_report = save_p_report;
+}
+
+gboolean
+vim_bonobo_main_iteration_do(may_block)
+{
+    if( ! in_bonobo_call ) {
+        g_main_context_iteration(NULL, may_block);
+    }
+}
+
diff -Nur vim63/src/vim_bonobo_main.h vim63-bonobo/src/vim_bonobo_main.h
--- vim63/src/vim_bonobo_main.h	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_main.h	2005-09-09 20:14:02.765579832 +0200
@@ -0,0 +1,16 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+#ifndef __VIM_BONOBO_MAIN_H__
+#define __VIM_BONOBO_MAIN_H__
+
+#include <glib-object.h>
+#include <bonobo/Bonobo.h>
+
+void			    vim_bonobo_main			 (void);
+void                vim_bonobo_main_quit     (void);
+int                 vim_bonobo_level(void);
+gboolean            vim_bonobo_main_iteration_do(int may_block);
+void                vim_bonobo_call_begin(void);
+void                vim_bonobo_call_end(void);
+
+#endif /* __VIM_BONOBO_MAIN_H__ */
diff -Nur vim63/src/vim-container.xml vim63-bonobo/src/vim-container.xml
--- vim63/src/vim-container.xml	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim-container.xml	2005-09-09 20:14:02.761580440 +0200
@@ -0,0 +1,83 @@
+<Root>
+
+<commands>
+	<cmd name="FileNewWindow" _label="_New Window" _tip="Open a new window"
+             pixtype="stock" pixname="gtk-new" accel="*Control*n"/>
+
+	<cmd name="FileOpen" _label="_Open..." _tip="Open a file"
+	     pixtype="stock" pixname="gtk-open" accel="*Control*o"/>
+
+	<cmd name="FileCloseWindow" _label="_Close" _tip="Close window"
+             pixtype="stock" pixname="gtk-close" accel="*Control*w"/>
+
+        <cmd name="FileExit" _label="_Quit" _tip="Quit the program"
+	     pixtype="stock" pixname="gtk-quit" accel="*Control*q"/>
+	
+	<cmd name="Preferences" _label="_Preferences..." _tip="Change preferences"  sensitive="0"
+	     pixtype="stock" pixname="gtk-preferences"/>
+
+	<cmd name="HelpAbout" _label="_About" _tip="About this application"
+	     pixtype="stock" pixname="About"/>
+	<cmd name="Help" _label="Contents" _tip="Help On this application"
+	     pixtype="stock" pixname="Help" accel="F1"/>
+
+
+	<cmd name="DnDNewWindow" _label="Open in new window"/>
+	<cmd name="DnDSameWindow" _label="Open in this window"/>
+	<cmd name="DnDCancel" _label="Cancel"
+	     pixtype="stock" pixname="Cancel"/>
+</commands>
+
+<menu>
+        <submenu name="File" _label="_File">
+
+		<menuitem name="FileNewWindow" verb=""/>
+
+		<placeholder name="Open Placeholder" delimit="top">
+			<menuitem name="FileOpen" verb=""/>
+		</placeholder>
+
+		<placeholder name="File Items Placeholder" delimit="top"/>
+
+		<separator/>
+
+		<menuitem name="FileCloseWindow" verb=""/>
+
+		<menuitem name="FileExit" verb=""/>
+
+	</submenu>
+
+	<submenu name="Edit" _label="_Edit">
+		<menuitem name="Preferences" verb=""/>
+        </submenu>
+
+	<submenu name="View" _label="_View" hidden="1">
+		<placeholder name="View Preferences Placeholder"/>
+		<placeholder name="View Items Placeholder" delimit="top"/>
+	</submenu>
+
+	<submenu name="Help" _label="_Help">
+		<menuitem name="Help" verb=""/>
+	        <menuitem name="HelpAbout" verb=""/>
+	</submenu>
+</menu>
+
+<dockitem name="Toolbar" relief="none" homogeneous="1" behavior="exclusive">
+
+        <toolitem name="TBOpen" _label="Open" pixtype="stock"
+                  pixname="Open" verb="FileOpen"/>
+
+        <toolitem name="TBCloseWindow" _label="Close" pixtype="stock"
+                  pixname="Close" verb="FileCloseWindow"/>
+</dockitem>
+
+<popups>
+        <popup name="dragndrop">
+	      <menuitem name="DnDNewWindow" verb=""/>
+	      <menuitem name="DnDSameWindow" verb=""/>
+	      <separator/>
+	      <menuitem name="DnDCancel" verb=""/>
+        </popup>
+</popups>
+
+</Root>
diff -Nur vim63/src/Vim_Control.server vim63-bonobo/src/Vim_Control.server
--- vim63/src/Vim_Control.server	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/Vim_Control.server	2005-09-09 20:14:02.695590472 +0200
@@ -0,0 +1,42 @@
+<oaf_info>
+
+<oaf_server iid="OAFIID:Vim_Proxy_Factory" type="exe" location="/usr/local/bin/vim-factory">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/GenericFactory:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control factory"/>
+  <oaf_attribute name="description" type="string" value="Vim Control factory"/>
+</oaf_server>
+
+<oaf_server iid="OAFIID:Vim_Control_Factory" type="exe" location="/usr/local/bin/vim-component">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/GenericFactory:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control factory"/>
+  <oaf_attribute name="description" type="string" value="Vim Control factory"/>
+</oaf_server>
+
+<oaf_server iid="OAFIID:Vim_Control" type="factory"
+ location="OAFIID:Vim_Proxy_Factory">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/Unknown:1.0"/>
+    <item value="IDL:Bonobo/Control:1.0"/>
+    <item value="IDL:Bonobo/ItemContainer:1.0"/>
+    <item value="IDL:Bonobo/PersistStream:1.0"/>
+    <item value="IDL:Bonobo/PersistFile:1.0"/>
+    <item value="IDL:Bonobo/Persist:1.0"/>
+    <item value="IDL:Nautilus/View:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control"/>
+  <oaf_attribute name="description" type="string" value="Vim Control"/>
+  <oaf_attribute name="bonobo:editable" type="boolean" value="false"/>
+  <oaf_attribute name="bonobo:supported_mime_types" type="stringv">
+    <item value="text/plain"/>
+    <item value="text/*"/>
+  </oaf_attribute>
+  <oaf_attribute name="nautilus:view_as_name" type="string" value="Text"/>
+  <oaf_attribute name="nautilus:view_as_label" type="string" value="View/Edit in Vim"/>
+  <oaf_attribute name="nautilus:viewer_label" type="string" value="Vim"/>
+</oaf_server>
+
+</oaf_info>
diff -Nur vim63/src/Vim_Control.server.in vim63-bonobo/src/Vim_Control.server.in
--- vim63/src/Vim_Control.server.in	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/Vim_Control.server.in	2005-09-09 20:14:02.696590320 +0200
@@ -0,0 +1,42 @@
+<oaf_info>
+
+<oaf_server iid="OAFIID:Vim_Proxy_Factory" type="exe" location="@DEST_BIN@/vim-factory">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/GenericFactory:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control factory"/>
+  <oaf_attribute name="description" type="string" value="Vim Control factory"/>
+</oaf_server>
+
+<oaf_server iid="OAFIID:Vim_Control_Factory" type="exe" location="@DEST_BIN@/@VIMNAME@">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/GenericFactory:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control factory"/>
+  <oaf_attribute name="description" type="string" value="Vim Control factory"/>
+</oaf_server>
+
+<oaf_server iid="OAFIID:Vim_Control" type="factory"
+ location="OAFIID:Vim_Proxy_Factory">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/Unknown:1.0"/>
+    <item value="IDL:Bonobo/Control:1.0"/>
+    <item value="IDL:Bonobo/ItemContainer:1.0"/>
+    <item value="IDL:Bonobo/PersistStream:1.0"/>
+    <item value="IDL:Bonobo/PersistFile:1.0"/>
+    <item value="IDL:Bonobo/Persist:1.0"/>
+    <item value="IDL:Nautilus/View:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control"/>
+  <oaf_attribute name="description" type="string" value="Vim Control"/>
+  <oaf_attribute name="bonobo:editable" type="boolean" value="false"/>
+  <oaf_attribute name="bonobo:supported_mime_types" type="stringv">
+    <item value="text/plain"/>
+    <item value="text/*"/>
+  </oaf_attribute>
+  <oaf_attribute name="nautilus:view_as_name" type="string" value="Text"/>
+  <oaf_attribute name="nautilus:view_as_label" type="string" value="View/Edit in Vim"/>
+  <oaf_attribute name="nautilus:viewer_label" type="string" value="Vim"/>
+</oaf_server>
+
+</oaf_info>
diff -Nur vim63/src/vim.h vim63-bonobo/src/vim.h
--- vim63/src/vim.h	2005-09-09 20:11:10.612751000 +0200
+++ vim63-bonobo/src/vim.h	2005-09-09 20:14:02.762580288 +0200
@@ -755,6 +755,10 @@
 #define READ_STDIN	0x04	/* read from stdin */
 #define READ_BUFFER	0x08	/* read from curbuf (converting stdin) */
 #define READ_DUMMY	0x10	/* reading into a dummy buffer */
+#define READ_EMB_STREAM 0x20    /* read from container stream object 
+                                        (i.e. Bonobo Persist Stream) */
+#define READ_EMB_FILE   0x40    /* read from container file object 
+                                        (i.e. Bonobo Persist File) */
 
 /* Values for change_indent() */
 #define INDENT_SET	1	/* set indent */
@@ -1045,6 +1049,7 @@
     EVENT_CURSORHOLD,		/* cursor in same position for a while */
     EVENT_FUNCUNDEFINED,	/* if calling a function which doesn't exist */
     EVENT_REMOTEREPLY,		/* upon string reception from a remote vim */
+    EVENT_EMBEDDED_COMPONENT,	/* upon embedding of vim as a component */
     NUM_EVENTS			/* MUST be the last one */
 };
 
diff -Nur vim63/src/vim.h.orig vim63-bonobo/src/vim.h.orig
--- vim63/src/vim.h.orig	2005-09-09 20:11:10.175817000 +0200
+++ vim63-bonobo/src/vim.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1793 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- */
-
-#ifndef VIM__H
-# define VIM__H
-
-/* use fastcall for Borland, when compiling for Win32 (not for DOS16) */
-#if defined(__BORLANDC__) && defined(WIN32) && !defined(DEBUG)
-#if defined(FEAT_PERL) || \
-    defined(FEAT_PYTHON) || \
-    defined(FEAT_RUBY) || \
-    defined(FEAT_TCL) || \
-    defined(DYNAMIC_GETTEXT) || \
-    defined(DYNAMIC_ICONV) || \
-    defined(DYNAMIC_IME) || \
-    defined(XPM)
-#  pragma option -pc
-# else
-#  pragma option -pr
-# endif
-#endif
-
-/* ============ the header file puzzle (ca. 50-100 pieces) ========= */
-
-#ifdef HAVE_CONFIG_H	/* GNU autoconf (or something else) was here */
-# include "auto/config.h"
-# define HAVE_PATHDEF
-
-/*
- * Check if configure correcly managed to find sizeof(int).  If this failed,
- * it becomes zero.  This is likely a problem of not being able to run the
- * test program.  Other items from configure may also be wrong then!
- */
-# if (SIZEOF_INT == 0)
-    Error: configure did not run properly.  Check auto/config.log.
-# endif
-
-/*
- * Cygwin may have fchdir() in a newer rleease, but in most versions it
- * doesn't work well and avoiding it keeps the binary backward compatible.
- */
-# if defined(__CYGWIN32__) && defined(HAVE_FCHDIR)
-#  undef HAVE_FCHDIR
-# endif
-#endif
-
-#ifdef __EMX__		/* hand-edited config.h for OS/2 with EMX */
-# include "os_os2_cfg.h"
-#endif
-
-/*
- * MACOS_CLASSIC compiling for MacOS prior to MacOS X
- * MACOS_X_UNIX  compiling for MacOS X (using os_unix.c)
- * MACOS_X       compiling for MacOS X (using os_unix.c or os_mac.c)
- * MACOS	 compiling for either one
- */
-#if defined(macintosh) && !defined(MACOS_CLASSIC)
-#  define MACOS_CLASSIC
-#endif
-#if defined(MACOS_X_UNIX)
-# define MACOS_X
-# ifndef HAVE_CONFIG_H
-#  define UNIX
-# endif
-#endif
-#if defined(MACOS_X) || defined(MACOS_CLASSIC)
-#  define MACOS
-#endif
-#if defined(MACOS_X) && defined(MACOS_CLASSIC)
-    Error: To compile for both MACOS X and Classic use a Classic Carbon
-#endif
-/* Unless made through the Makefile enforce GUI on Mac */
-#if defined(MACOS) && !defined(HAVE_CONFIG_H)
-# define FEAT_GUI_MAC
-#endif
-
-
-#if defined(FEAT_GUI_MOTIF) \
-    || defined(FEAT_GUI_GTK) \
-    || defined(FEAT_GUI_ATHENA) \
-    || defined(FEAT_GUI_MAC) \
-    || defined(FEAT_GUI_W32) \
-    || defined(FEAT_GUI_W16) \
-    || defined(FEAT_GUI_BEOS) \
-    || defined(FEAT_GUI_AMIGA) \
-    || defined(FEAT_GUI_PHOTON)
-# ifndef FEAT_GUI
-#  define FEAT_GUI
-# endif
-#endif
-
-#if defined(FEAT_GUI_W32) || defined(FEAT_GUI_W16)
-# define FEAT_GUI_MSWIN
-#endif
-#if defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# define MSWIN
-#endif
-/* Practically everything is common to both Win32 and Win64 */
-#if defined(WIN32) || defined(_WIN64)
-# define WIN3264
-#endif
-
-/*
- * SIZEOF_INT is used in feature.h, and the system-specific included files
- * need items from feature.h.  Therefore define SIZEOF_INT here.
- */
-#ifdef WIN3264
-# define SIZEOF_INT 4
-#endif
-#ifdef MSDOS
-# ifdef DJGPP
-#  ifndef FEAT_GUI_GTK		/* avoid problems when generating prototypes */
-#   define SIZEOF_INT 4		/* 32 bit ints */
-#  endif
-#  define DOS32
-#  define FEAT_CLIPBOARD
-# else
-#  ifndef FEAT_GUI_GTK		/* avoid problems when generating prototypes */
-#   define SIZEOF_INT 2		/* 16 bit ints */
-#  endif
-#  define SMALL_MALLOC		/* 16 bit storage allocation */
-#  define DOS16
-# endif
-#endif
-
-#ifdef AMIGA
-  /* Be conservative about sizeof(int). It could be 4 too. */
-# ifndef FEAT_GUI_GTK	/* avoid problems when generating prototypes */
-#  ifdef __GNUC__
-#   define SIZEOF_INT	4
-#  else
-#   define SIZEOF_INT	2
-#  endif
-# endif
-#endif
-#ifdef MACOS
-# if defined(__POWERPC__) || defined(__fourbyteints__) \
-  || defined(__MRC__) || defined(__SC__) || defined(__APPLE_CC__)/* MPW Compilers */
-#  define SIZEOF_INT 4
-# else
-#  define SIZEOF_INT 2
-# endif
-#endif
-#ifdef RISCOS
-# define SIZEOF_INT 4
-#endif
-
-
-#include "feature.h"	/* #defines for optionals and features */
-
-/* +x11 is only enabled when it's both available and wanted. */
-#if defined(HAVE_X11) && defined(WANT_X11)
-# define FEAT_X11
-#endif
-
-/* Can't use "PACKAGE" here, conflicts with a Perl include file. */
-#ifndef VIMPACKAGE
-# define VIMPACKAGE	"vim"
-#endif
-
-/*
- * Find out if function definitions should include argument types
- */
-#ifdef AZTEC_C
-# include <functions.h>
-# define __ARGS(x)  x
-#endif
-
-#ifdef SASC
-# include <clib/exec_protos.h>
-# define __ARGS(x)  x
-#endif
-
-#ifdef _DCC
-# include <clib/exec_protos.h>
-# define __ARGS(x)  x
-#endif
-
-#ifdef __TURBOC__
-# define __ARGS(x) x
-#endif
-
-#ifdef __BEOS__
-# include "os_beos.h"
-# define __ARGS(x)  x
-#endif
-
-#if (defined(UNIX) || defined(__EMX__) || defined(VMS)) \
-	&& (!defined(MACOS_X) || defined(HAVE_CONFIG_H))
-# include "os_unix.h"	    /* bring lots of system header files */
-#endif
-
-#if defined(MACOS) && (defined(__MRC__) || defined(__SC__))
-   /* Apple's Compilers support prototypes */
-# define __ARGS(x) x
-#endif
-#ifndef __ARGS
-# if defined(__STDC__) || defined(__GNUC__) || defined(WIN3264)
-#  define __ARGS(x) x
-# else
-#  define __ARGS(x) ()
-# endif
-#endif
-
-/* __ARGS and __PARMS are the same thing. */
-#ifndef __PARMS
-# define __PARMS(x) __ARGS(x)
-#endif
-
-#if defined(UNIX) && !defined(MACOS_X) /* MACOS_X doesn't yet support osdef.h */
-# include "auto/osdef.h"	/* bring missing declarations in */
-#endif
-
-#ifdef __EMX__
-# define    getcwd  _getcwd2
-# define    chdir   _chdir2
-# undef	    CHECK_INODE
-#endif
-
-#ifdef AMIGA
-# include "os_amiga.h"
-#endif
-
-#ifdef MSDOS
-# include "os_msdos.h"
-#endif
-
-#ifdef WIN16
-# include "os_win16.h"
-#endif
-
-#ifdef WIN3264
-# include "os_win32.h"
-#endif
-
-#ifdef __MINT__
-# include "os_mint.h"
-#endif
-
-#if defined(MACOS)
-# if defined(__MRC__) || defined(__SC__) /* MPW Compilers */
-#  define HAVE_SETENV
-# endif
-# include "os_mac.h"
-#endif
-
-#ifdef RISCOS
-# include "os_riscos.h"
-#endif
-
-#ifdef __QNX__
-# include "os_qnx.h"
-#endif
-
-#ifdef FEAT_SUN_WORKSHOP
-# include "workshop.h"
-#endif
-
-#ifdef X_LOCALE
-# include <X11/Xlocale.h>
-#else
-# ifdef HAVE_LOCALE_H
-#  include <locale.h>
-# endif
-#endif
-
-/*
- * Maximum length of a path (for non-unix systems) Make it a bit long, to stay
- * on the safe side.  But not too long to put on the stack.
- */
-#ifndef MAXPATHL
-# ifdef MAXPATHLEN
-#  define MAXPATHL  MAXPATHLEN
-# else
-#  define MAXPATHL  256
-# endif
-#endif
-#ifdef BACKSLASH_IN_FILENAME
-# define PATH_ESC_CHARS ((char_u *)" *?[{`%#")
-#else
-# ifdef COLON_AS_PATHSEP
-#  define PATH_ESC_CHARS ((char_u *)" *?[{`$%#/")
-# else
-#  define PATH_ESC_CHARS ((char_u *)" *?[{`$\\%#'\"|")
-# endif
-#endif
-
-#define NUMBUFLEN 30	    /* length of a buffer to store a number in ASCII */
-
-/*
- * Shorthand for unsigned variables. Many systems, but not all, have u_char
- * already defined, so we use char_u to avoid trouble.
- */
-typedef unsigned char	char_u;
-typedef unsigned short	short_u;
-typedef unsigned int	int_u;
-/* Make sure long_u is big enough to hold a pointer.  On Win64 longs are 32
- * bit and pointers 64 bit. */
-#ifdef _WIN64
-typedef unsigned __int64 long_u;
-#else
-typedef unsigned long	long_u;
-#endif
-
-/*
- * The characters and attributes cached for the screen.
- * Currently a single byte.  The attributes may become larger some day.
- */
-#define schar_T	char_u
-#define sattr_T	char_u
-
-/*
- * The u8char_T can hold one decoded UTF-8 character.
- * Vim always use an int (32 bits) for characters most places, so that we can
- * handle 32 bit characters in the file.  u8char_T is only used for
- * displaying.  That should be enough, because there is no font for > 16 bits.
- */
-#ifdef FEAT_MBYTE
-typedef unsigned short u8char_T;
-#endif
-
-#ifndef UNIX		    /* For Unix this is included in os_unix.h */
-# include <stdio.h>
-# include <ctype.h>
-#endif
-
-#include "ascii.h"
-#include "keymap.h"
-#include "term.h"
-#include "macros.h"
-
-#ifdef LATTICE
-# include <sys/types.h>
-# include <sys/stat.h>
-#endif
-#ifdef _DCC
-# include <sys/stat.h>
-#endif
-#if defined(MSDOS) || defined(MSWIN)
-# include <sys/stat.h>
-#endif
-
-/*
- * Allow other (non-unix) systems to configure themselves now
- * These are also in os_unix.h, because osdef.sh needs them there.
- */
-#ifndef UNIX
-/* Note: Some systems need both string.h and strings.h (Savage).  If the
- * system can't handle this, define NO_STRINGS_WITH_STRING_H. */
-# ifdef HAVE_STRING_H
-#  include <string.h>
-# endif
-# if defined(HAVE_STRINGS_H) && !defined(NO_STRINGS_WITH_STRING_H)
-#   include <strings.h>
-# endif
-# ifdef HAVE_STAT_H
-#  include <stat.h>
-# endif
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif /* NON-UNIX */
-
-#include <assert.h>
-
-/* ================ end of the header file puzzle =============== */
-
-/*
- * For dynamically loaded imm library. Currently, only for Win32.
- */
-#ifdef DYNAMIC_IME
-# ifndef FEAT_MBYTE_IME
-#  define FEAT_MBYTE_IME
-# endif
-#endif
-
-/*
- * Check input method control.
- */
-#if defined(FEAT_XIM) || \
-    (defined(FEAT_GUI) && (defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME)))
-# define USE_IM_CONTROL
-#endif
-
-/*
- * For dynamically loaded gettext library.  Currently, only for Win32.
- */
-#ifdef DYNAMIC_GETTEXT
-# ifndef FEAT_GETTEXT
-#  define FEAT_GETTEXT
-# endif
-/* These are in os_win32.c */
-extern char* (*dyn_libintl_gettext)(const char* msgid);
-extern char* (*dyn_libintl_bindtextdomain)(const char* domainname, const char* dirname);
-extern char* (*dyn_libintl_textdomain)(const char* domainname);
-#endif
-
-
-/*
- * The _() stuff is for using gettext().  It is a no-op when libintl.h is not
- * found or the +multilang feature is disabled.
- */
-#ifdef FEAT_GETTEXT
-# ifdef DYNAMIC_GETTEXT
-#  define _(x) (*dyn_libintl_gettext)((char *)(x))
-#  define N_(x) x
-#  define bindtextdomain(domain,dir) (*dyn_libintl_bindtextdomain)(domain,dir)
-#  define textdomain(domain) (*dyn_libintl_textdomain)(domain)
-# else
-#  include <libintl.h>
-#  define _(x) gettext((char *)(x))
-#  ifdef gettext_noop
-#   define N_(x) gettext_noop(x)
-#  else
-#   define N_(x) x
-#  endif
-# endif
-#else
-# define _(x) ((char *)(x))
-# define N_(x) x
-# ifdef bindtextdomain
-#  undef bindtextdomain
-# endif
-# define bindtextdomain(x, y) /* empty */
-# ifdef textdomain
-#  undef textdomain
-# endif
-# define textdomain(x) /* empty */
-#endif
-
-/*
- * flags for update_screen()
- * The higher the value, the higher the priority
- */
-#define VALID			10  /* buffer not changed, or changes marked
-				       with b_mod_* */
-#define INVERTED		20  /* redisplay inverted part that changed */
-#define INVERTED_ALL		25  /* redisplay whole inverted part */
-#define REDRAW_TOP		30  /* display first w_upd_rows screen lines */
-#define NOT_VALID		40  /* buffer needs complete redraw */
-#define CLEAR			50  /* screen messed up, clear it */
-
-/*
- * Hints used to optimize screen updating.
- */
-#define HINT_NONE	0	    /* no current hint */
-#define HINT_DEL_CHAR	1	    /* delete character */
-#define HINT_INS_CHAR	2	    /* insert character */
-
-/*
- * Flags for w_valid.
- * These are set when something in a window structure becomes invalid, except
- * when the cursor is moved.  Call check_cursor_moved() before testing one of
- * the flags.
- * These are reset when that thing has been updated and is valid again.
- *
- * Every function that invalidates one of these must call one of the
- * invalidate_* functions.
- *
- * w_valid is supposed to be used only in screen.c.  From other files, use the
- * functions that set or reset the flags.
- *
- * VALID_BOTLINE    VALID_BOTLINE_AP
- *     on		on		w_botline valid
- *     off		on		w_botline approximated
- *     off		off		w_botline not valid
- *     on		off		not possible
- */
-#define VALID_WROW	0x01	/* w_wrow (window row) is valid */
-#define VALID_WCOL	0x02	/* w_wcol (window col) is valid */
-#define VALID_VIRTCOL	0x04	/* w_virtcol (file col) is valid */
-#define VALID_CHEIGHT	0x08	/* w_cline_height and w_cline_folded valid */
-#define VALID_CROW	0x10	/* w_cline_row is valid */
-#define VALID_BOTLINE	0x20	/* w_botine and w_empty_rows are valid */
-#define VALID_BOTLINE_AP 0x40	/* w_botine is approximated */
-#define VALID_TOPLINE	0x80	/* w_topline is valid (for cursor position) */
-
-/*
- * Terminal highlighting attribute bits.
- * Attibutes above HL_ALL are used for syntax highlighting.
- */
-#define HL_NORMAL		0x00
-#define HL_INVERSE		0x01
-#define HL_BOLD			0x02
-#define HL_ITALIC		0x04
-#define HL_UNDERLINE		0x08
-#define HL_STANDOUT		0x10
-#define HL_ALL			0x1f
-
-/* special attribute addition: Put message in history */
-#define MSG_HIST		0x1000
-
-/*
- * values for State
- *
- * The lower bits up to 0x20 are used to distinguish normal/visual/op_pending
- * and cmdline/insert+replace mode.  This is used for mapping.  If none of
- * these bits are set, no mapping is done.
- * The upper bits are used to distinguish between other states.
- */
-#define NORMAL		0x01	/* Normal mode, command expected */
-#define VISUAL		0x02	/* Visual mode - use get_real_state() */
-#define OP_PENDING	0x04	/* Normal mode, operator is pending - use
-				   get_real_state() */
-#define CMDLINE		0x08	/* Editing command line */
-#define INSERT		0x10	/* Insert mode */
-#define LANGMAP		0x20	/* Language mapping, can be combined with
-				   INSERT and CMDLINE */
-#define MAP_ALL_MODES	0x3f	/* all mode bits used for mapping */
-
-#define REPLACE_FLAG	0x40	/* Replace mode flag */
-#define REPLACE		(REPLACE_FLAG + INSERT)
-#ifdef FEAT_VREPLACE
-# define VREPLACE_FLAG	0x80	/* Virtual-replace mode flag */
-# define VREPLACE	(REPLACE_FLAG + VREPLACE_FLAG + INSERT)
-#endif
-#define LREPLACE	(REPLACE_FLAG + LANGMAP)
-
-#define NORMAL_BUSY	(0x100 + NORMAL) /* Normal mode, busy with a command */
-#define HITRETURN	(0x200 + NORMAL) /* waiting for return or command */
-#define ASKMORE		0x300	/* Asking if you want --more-- */
-#define SETWSIZE	0x400	/* window size has changed */
-#define ABBREV		0x500	/* abbreviation instead of mapping */
-#define EXTERNCMD	0x600	/* executing an external command */
-#define SHOWMATCH	(0x700 + INSERT) /* show matching paren */
-#define CONFIRM		0x800	/* ":confirm" prompt */
-
-/* directions */
-#define FORWARD			1
-#define BACKWARD		(-1)
-#define FORWARD_FILE		3
-#define BACKWARD_FILE		(-3)
-
-/* return values for functions */
-#if !(defined(OK) && (OK == 1))
-/* OK already defined to 1 in MacOS X curses, skip this */
-# define OK			1
-#endif
-#define FAIL			0
-
-/* flags for b_flags */
-#define BF_RECOVERED	0x01	/* buffer has been recovered */
-#define BF_CHECK_RO	0x02	/* need to check readonly when loading file
-				   into buffer (set by ":e", may be reset by
-				   ":buf" */
-#define BF_NEVERLOADED	0x04	/* file has never been loaded into buffer,
-				   many variables still need to be set */
-#define BF_NOTEDITED	0x08	/* Set when file name is changed after
-				   starting to edit, reset when file is
-				   written out. */
-#define BF_NEW		0x10	/* file didn't exist when editing started */
-#define BF_NEW_W	0x20	/* Warned for BF_NEW and file created */
-#define BF_READERR	0x40	/* got errors while reading the file */
-
-/* Mask to check for flags that prevent normal writing */
-#define BF_WRITE_MASK	(BF_NOTEDITED + BF_NEW + BF_READERR)
-
-/*
- * values for xp_context when doing command line completion
- */
-#define CONTEXT_UNKNOWN		(-3)
-#define EXPAND_UNSUCCESSFUL	(-2)
-#define EXPAND_OK		(-1)
-#define EXPAND_NOTHING		0
-#define EXPAND_COMMANDS		1
-#define EXPAND_FILES		2
-#define EXPAND_DIRECTORIES	3
-#define EXPAND_SETTINGS		4
-#define EXPAND_BOOL_SETTINGS	5
-#define EXPAND_TAGS		6
-#define EXPAND_OLD_SETTING	7
-#define EXPAND_HELP		8
-#define EXPAND_BUFFERS		9
-#define EXPAND_EVENTS		10
-#define EXPAND_MENUS		11
-#define EXPAND_SYNTAX		12
-#define EXPAND_HIGHLIGHT	13
-#define EXPAND_AUGROUP		14
-#define EXPAND_USER_VARS	15
-#define EXPAND_MAPPINGS		16
-#define EXPAND_TAGS_LISTFILES	17
-#define EXPAND_FUNCTIONS	18
-#define EXPAND_USER_FUNC	19
-#define EXPAND_EXPRESSION	20
-#define EXPAND_MENUNAMES	21
-#define EXPAND_USER_COMMANDS	22
-#define EXPAND_USER_CMD_FLAGS	23
-#define EXPAND_USER_NARGS	24
-#define EXPAND_USER_COMPLETE	25
-#define EXPAND_ENV_VARS		26
-#define EXPAND_LANGUAGE		27
-#define EXPAND_COLORS		28
-#define EXPAND_COMPILER		29
-#define EXPAND_USER_DEFINED	30
-
-/* Values for exmode_active (0 is no exmode) */
-#define EXMODE_NORMAL		1
-#define EXMODE_VIM		2
-
-/* Values for nextwild() and ExpandOne().  See ExpandOne() for meaning. */
-#define WILD_FREE		1
-#define WILD_EXPAND_FREE	2
-#define WILD_EXPAND_KEEP	3
-#define WILD_NEXT		4
-#define WILD_PREV		5
-#define WILD_ALL		6
-#define WILD_LONGEST		7
-
-#define WILD_LIST_NOTFOUND	1
-#define WILD_HOME_REPLACE	2
-#define WILD_USE_NL		4
-#define WILD_NO_BEEP		8
-#define WILD_ADD_SLASH		16
-#define WILD_KEEP_ALL		32
-#define WILD_SILENT		64
-#define WILD_ESCAPE		128
-
-/* Flags for expand_wildcards() */
-#define EW_DIR		1	/* include directory names */
-#define EW_FILE		2	/* include file names */
-#define EW_NOTFOUND	4	/* include not found names */
-#define EW_ADDSLASH	8	/* append slash to directory name */
-#define EW_KEEPALL	16	/* keep all matches */
-#define EW_SILENT	32	/* don't print "1 returned" from shell */
-/* Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND
- * is used when executing commands and EW_SILENT for interactive expanding. */
-
-#ifdef FEAT_VERTSPLIT
-# define W_WINCOL(wp)	(wp->w_wincol)
-# define W_WIDTH(wp)	(wp->w_width)
-# define W_ENDCOL(wp)	(wp->w_wincol + wp->w_width)
-# define W_VSEP_WIDTH(wp) (wp->w_vsep_width)
-#else
-# define W_WINCOL(wp)	0
-# define W_WIDTH(wp)	Columns
-# define W_ENDCOL(wp)	Columns
-# define W_VSEP_WIDTH(wp) 0
-#endif
-#ifdef FEAT_WINDOWS
-# define W_STATUS_HEIGHT(wp) (wp->w_status_height)
-# define W_WINROW(wp)	(wp->w_winrow)
-#else
-# define W_STATUS_HEIGHT(wp) 0
-# define W_WINROW(wp)	0
-#endif
-
-#ifdef NO_EXPANDPATH
-# define gen_expand_wildcards mch_expand_wildcards
-#endif
-
-/* Values for the find_pattern_in_path() function args 'type' and 'action': */
-#define FIND_ANY	1
-#define FIND_DEFINE	2
-#define CHECK_PATH	3
-
-#define ACTION_SHOW	1
-#define ACTION_GOTO	2
-#define ACTION_SPLIT	3
-#define ACTION_SHOW_ALL	4
-#ifdef FEAT_INS_EXPAND
-# define ACTION_EXPAND	5
-#endif
-
-#ifdef FEAT_SYN_HL
-# define SST_MIN_ENTRIES 150	/* minimal size for state stack array */
-# ifdef FEAT_GUI_W16
-#  define SST_MAX_ENTRIES 500	/* (only up to 64K blocks) */
-# else
-#  define SST_MAX_ENTRIES 1000	/* maximal size for state stack array */
-# endif
-# define SST_FIX_STATES	 7	/* size of sst_stack[]. */
-# define SST_DIST	 16	/* normal distance between entries */
-# define SST_INVALID	(synstate_T *)-1	/* invalid syn_state pointer */
-#endif
-
-/* Values for 'options' argument in do_search() and searchit() */
-#define SEARCH_REV    0x01  /* go in reverse of previous dir. */
-#define SEARCH_ECHO   0x02  /* echo the search command and handle options */
-#define SEARCH_MSG    0x0c  /* give messages (yes, it's not 0x04) */
-#define SEARCH_NFMSG  0x08  /* give all messages except not found */
-#define SEARCH_OPT    0x10  /* interpret optional flags */
-#define SEARCH_HIS    0x20  /* put search pattern in history */
-#define SEARCH_END    0x40  /* put cursor at end of match */
-#define SEARCH_NOOF   0x80  /* don't add offset to position */
-#define SEARCH_START 0x100  /* start search without col offset */
-#define SEARCH_MARK  0x200  /* set previous context mark */
-#define SEARCH_KEEP  0x400  /* keep previous search pattern */
-#define SEARCH_PEEK  0x800  /* peek for typed char, cancel search */
-
-/* Values for find_ident_under_cursor() */
-#define FIND_IDENT	1	/* find identifier (word) */
-#define FIND_STRING	2	/* find any string (WORD) */
-#define FIND_EVAL	4	/* include "->", "[]" and "." */
-
-/* Values for file_name_in_line() */
-#define FNAME_MESS	1	/* give error message */
-#define FNAME_EXP	2	/* expand to path */
-#define FNAME_HYP	4	/* check for hypertext link */
-#define FNAME_INCL	8	/* apply 'includeexpr' */
-#define FNAME_REL	16	/* ".." and "./" are relative to the (current)
-				   file instead of the current directory */
-
-/* Values for buflist_getfile() */
-#define GETF_SETMARK	0x01	/* set pcmark before jumping */
-#define GETF_ALT	0x02	/* jumping to alternate file (not buf num) */
-#define GETF_SWITCH	0x04	/* respect 'switchbuf' settings when jumping */
-
-/* Values for buflist_new() flags */
-#define BLN_CURBUF	1	/* May re-use curbuf for new buffer */
-#define BLN_LISTED	2	/* Put new buffer in buffer list */
-#define BLN_DUMMY	4	/* Allocating dummy buffer */
-
-/* Values for in_cinkeys() */
-#define KEY_OPEN_FORW	0x101
-#define KEY_OPEN_BACK	0x102
-#define KEY_COMPLETE	0x103	/* end of completion */
-
-/* Values for "noremap" argument of ins_typebuf().  Also used for
- * map->m_noremap and menu->noremap[]. */
-#define REMAP_YES	0	/* allow remapping */
-#define REMAP_NONE	-1	/* no remapping */
-#define REMAP_SCRIPT	-2	/* remap script-local mappings only */
-#define REMAP_SKIP	-3	/* no remapping for first char */
-
-/* Values for mch_call_shell() second argument */
-#define SHELL_FILTER	1	/* filtering text */
-#define SHELL_EXPAND	2	/* expanding wildcards */
-#define SHELL_COOKED	4	/* set term to cooked mode */
-#define SHELL_DOOUT	8	/* redirecting output */
-#define SHELL_SILENT	16	/* don't print error returned by command */
-
-/* Values returned by mch_nodetype() */
-#define NODE_NORMAL	0	/* file or directory, check with mch_isdir()*/
-#define NODE_WRITABLE	1	/* something we can write to (character
-				   device, fifo, socket, ..) */
-#define NODE_OTHER	2	/* non-writable thing (e.g., block device) */
-
-/* Values for readfile() flags */
-#define READ_NEW	0x01	/* read a file into a new buffer */
-#define READ_FILTER	0x02	/* read filter output */
-#define READ_STDIN	0x04	/* read from stdin */
-#define READ_BUFFER	0x08	/* read from curbuf (converting stdin) */
-#define READ_DUMMY	0x10	/* reading into a dummy buffer */
-
-/* Values for change_indent() */
-#define INDENT_SET	1	/* set indent */
-#define INDENT_INC	2	/* increase indent */
-#define INDENT_DEC	3	/* decrease indent */
-
-/* Values for flags argument for findmatchlimit() */
-#define FM_BACKWARD	0x01	/* search backwards */
-#define FM_FORWARD	0x02	/* search forwards */
-#define FM_BLOCKSTOP	0x04	/* stop at start/end of block */
-#define FM_SKIPCOMM	0x08	/* skip comments */
-
-/* Values for action argument for do_buffer() */
-#define DOBUF_GOTO	0	/* go to specified buffer */
-#define DOBUF_SPLIT	1	/* split window and go to specified buffer */
-#define DOBUF_UNLOAD	2	/* unload specified buffer(s) */
-#define DOBUF_DEL	3	/* delete specified buffer(s) from buflist */
-#define DOBUF_WIPE	4	/* delete specified buffer(s) really */
-
-/* Values for start argument for do_buffer() */
-#define DOBUF_CURRENT	0	/* "count" buffer from current buffer */
-#define DOBUF_FIRST	1	/* "count" buffer from first buffer */
-#define DOBUF_LAST	2	/* "count" buffer from last buffer */
-#define DOBUF_MOD	3	/* "count" mod. buffer from current buffer */
-
-/* Values for sub_cmd and which_pat argument for search_regcomp() */
-/* Also used for which_pat argument for searchit() */
-#define RE_SEARCH	0	/* save/use pat in/from search_pattern */
-#define RE_SUBST	1	/* save/use pat in/from subst_pattern */
-#define RE_BOTH		2	/* save pat in both patterns */
-#define RE_LAST		2	/* use last used pattern if "pat" is NULL */
-
-/* Second argument for vim_regcomp(). */
-#define RE_MAGIC	1	/* 'magic' option */
-#define RE_STRING	2	/* match in string instead of buffer text */
-
-#ifdef FEAT_SYN_HL
-/* values for reg_do_extmatch */
-# define REX_SET	1	/* to allow \z\(...\), */
-# define REX_USE	2	/* to allow \z\1 et al. */
-#endif
-
-/* Return values for fullpathcmp() */
-/* Note: can use (fullpathcmp() & FPC_SAME) to check for equal files */
-#define FPC_SAME	1	/* both exist and are the same file. */
-#define FPC_DIFF	2	/* both exist and are different files. */
-#define FPC_NOTX	4	/* both don't exist. */
-#define FPC_DIFFX	6	/* one of them doesn't exist. */
-#define FPC_SAMEX	7	/* both don't exist and file names are same. */
-
-/* flags for do_ecmd() */
-#define ECMD_HIDE	0x01	/* don't free the current buffer */
-#define ECMD_SET_HELP	0x02	/* set b_help flag of (new) buffer before
-				   opening file */
-#define ECMD_OLDBUF	0x04	/* use existing buffer if it exists */
-#define ECMD_FORCEIT	0x08	/* ! used in Ex command */
-#define ECMD_ADDBUF	0x10	/* don't edit, just add to buffer list */
-
-/* for lnum argument in do_ecmd() */
-#define ECMD_LASTL	(linenr_T)0	/* use last position in loaded file */
-#define ECMD_LAST	(linenr_T)-1	/* use last position in all files */
-#define ECMD_ONE	(linenr_T)1	/* use first line */
-
-/* flags for do_cmdline() */
-#define DOCMD_VERBOSE	0x01	/* included command in error message */
-#define DOCMD_NOWAIT	0x02	/* don't call wait_return() and friends */
-#define DOCMD_REPEAT	0x04	/* repeat exec. until getline() returns NULL */
-#define DOCMD_KEYTYPED	0x08	/* don't reset KeyTyped */
-#define DOCMD_EXCRESET	0x10	/* reset exception environment (for debugging)*/
-#define DOCMD_KEEPLINE  0x20	/* keep typed line for repeating with "." */
-
-/* flags for beginline() */
-#define BL_WHITE	1	/* cursor on first non-white in the line */
-#define BL_SOL		2	/* use 'sol' option */
-#define BL_FIX		4	/* don't leave cursor on a NUL */
-
-/* flags for mf_sync() */
-#define MFS_ALL		1	/* also sync blocks with negative numbers */
-#define MFS_STOP	2	/* stop syncing when a character is available */
-#define MFS_FLUSH	4	/* flushed file to disk */
-#define MFS_ZERO	8	/* only write block 0 */
-
-/* flags for buf_copy_options() */
-#define BCO_ENTER	1	/* going to enter the buffer */
-#define BCO_ALWAYS	2	/* always copy the options */
-#define BCO_NOHELP	4	/* don't touch the help related options */
-
-/* flags for do_put() */
-#define PUT_FIXINDENT	1	/* make indent look nice */
-#define PUT_CURSEND	2	/* leave cursor after end of new text */
-#define PUT_LINE	4	/* put register as lines */
-#define PUT_LINE_SPLIT	8	/* split line for linewise register */
-#define PUT_LINE_FORWARD 16	/* put linewise register below Visual sel. */
-
-/* flags for set_indent() */
-#define SIN_CHANGED	1	/* call changed_bytes() when line changed */
-#define SIN_INSERT	2	/* insert indent before existing text */
-#define SIN_UNDO	4	/* save line for undo before changing it */
-
-/* flags for insertchar() */
-#define INSCHAR_FORMAT	1	/* force formatting */
-#define INSCHAR_DO_COM	2	/* format comments */
-#define INSCHAR_CTRLV	4	/* char typed just after CTRL-V */
-
-/* flags for open_line() */
-#define OPENLINE_DELSPACES  1	/* delete spaces after cursor */
-#define OPENLINE_DO_COM	    2	/* format comments */
-#define OPENLINE_KEEPTRAIL  4	/* keep trailing spaces */
-#define OPENLINE_MARKFIX    8	/* fix mark positions */
-
-/*
- * There are four history tables:
- */
-#define HIST_CMD	0	/* colon commands */
-#define HIST_SEARCH	1	/* search commands */
-#define HIST_EXPR	2	/* expressions (from entering = register) */
-#define HIST_INPUT	3	/* input() lines */
-#define HIST_DEBUG	4	/* debug commands */
-#define HIST_COUNT	5	/* number of history tables */
-
-/*
- * Flags for chartab[].
- */
-#define CT_CELL_MASK	0x07	/* mask: nr of display cells (1, 2 or 4) */
-#define CT_PRINT_CHAR	0x10	/* flag: set for printable chars */
-#define CT_ID_CHAR	0x20	/* flag: set for ID chars */
-#define CT_FNAME_CHAR	0x40	/* flag: set for file name chars */
-
-/*
- * Values for do_tag().
- */
-#define DT_TAG		1	/* jump to newer position or same tag again */
-#define DT_POP		2	/* jump to older position */
-#define DT_NEXT		3	/* jump to next match of same tag */
-#define DT_PREV		4	/* jump to previous match of same tag */
-#define DT_FIRST	5	/* jump to first match of same tag */
-#define DT_LAST		6	/* jump to first match of same tag */
-#define DT_SELECT	7	/* jump to selection from list */
-#define DT_HELP		8	/* like DT_TAG, but no wildcards */
-#define DT_JUMP		9	/* jump to new tag or selection from list */
-#define DT_CSCOPE	10	/* cscope find command (like tjump) */
-
-/*
- * flags for find_tags().
- */
-#define TAG_HELP	1	/* only search for help tags */
-#define TAG_NAMES	2	/* only return name of tag */
-#define	TAG_REGEXP	4	/* use tag pattern as regexp */
-#define	TAG_NOIC	8	/* don't always ignore case */
-#ifdef FEAT_CSCOPE
-# define TAG_CSCOPE	16	/* cscope tag */
-#endif
-#define TAG_VERBOSE	32	/* message verbosity */
-#define TAG_INS_COMP	64	/* Currently doing insert completion */
-#define TAG_KEEP_LANG	128	/* keep current language */
-
-#define TAG_MANY	200	/* When finding many tags (for completion),
-				   find up to this many tags */
-
-/*
- * Types of dialogs passed to do_vim_dialog().
- */
-#define VIM_GENERIC	0
-#define VIM_ERROR	1
-#define VIM_WARNING	2
-#define VIM_INFO	3
-#define VIM_QUESTION	4
-#define VIM_LAST_TYPE	4	/* sentinel value */
-
-/*
- * Return values for functions like gui_yesnocancel()
- */
-#define VIM_OK		1
-#define VIM_YES		2
-#define VIM_NO		3
-#define VIM_CANCEL	4
-#define VIM_ALL		5
-#define VIM_DISCARDALL  6
-
-/*
- * arguments for win_split()
- */
-#define WSP_ROOM	1	/* require enough room */
-#define WSP_VERT	2	/* split vertically */
-#define WSP_TOP		4	/* window at top-left of shell */
-#define WSP_BOT		8	/* window at bottom-right of shell */
-#define WSP_HELP	16	/* creating the help window */
-#define WSP_BELOW	32	/* put new window below/right */
-#define WSP_ABOVE	64	/* put new window above/left */
-
-/*
- * "flags" values for option-setting functions.
- * When OPT_GLOBAL and OPT_LOCAL are both missing, set both local and global
- * values, get local value.
- */
-#define OPT_FREE	1	/* free old value if it was allocated */
-#define OPT_GLOBAL	2	/* use global value */
-#define OPT_LOCAL	4	/* use local value */
-#define OPT_MODELINE	8	/* option in modeline */
-
-/* Magic chars used in confirm dialog strings */
-#define DLG_BUTTON_SEP	'\n'
-#define DLG_HOTKEY_CHAR	'&'
-
-/* Values for "starting" */
-#define NO_SCREEN	2	/* no screen updating yet */
-#define NO_BUFFERS	1	/* not all buffers loaded yet */
-/*			0	   not starting anymore */
-
-/* Values for swap_exists_action: what to do when swap file already exists */
-#define SEA_NONE	0	/* don't use dialog */
-#define SEA_DIALOG	1	/* use dialog when */
-#define SEA_QUIT	2	/* quit editing the file */
-#define SEA_RECOVER	3	/* recover the file */
-
-/*
- * Minimal size for block 0 of a swap file.
- * NOTE: This depends on size of struct block0! It's not done with a sizeof(),
- * because struct block0 is defined in memline.c (Sorry).
- * The maximal block size is arbitrary.
- */
-#define MIN_SWAP_PAGE_SIZE 1048
-#define MAX_SWAP_PAGE_SIZE 50000
-
-/* Special values for current_SID. */
-#define SID_MODELINE	-1	/* when using a modeline */
-#define SID_CMDARG	-2	/* for "--cmd" argument */
-#define SID_CARG	-3	/* for "-c" argument */
-#define SID_ENV		-4	/* for sourcing environment variable */
-
-/*
- * Events for autocommands.
- */
-enum auto_event
-{
-    EVENT_BUFADD = 0,		/* after adding a buffer to the buffer list */
-    EVENT_BUFNEW,		/* after creating any buffer */
-    EVENT_BUFDELETE,		/* deleting a buffer from the buffer list */
-    EVENT_BUFWIPEOUT,		/* just before really deleting a buffer */
-    EVENT_BUFENTER,		/* after entering a buffer */
-    EVENT_BUFFILEPOST,		/* after renaming a buffer */
-    EVENT_BUFFILEPRE,		/* before renaming a buffer */
-    EVENT_BUFLEAVE,		/* before leaving a buffer */
-    EVENT_BUFNEWFILE,		/* when creating a buffer for a new file */
-    EVENT_BUFREADPOST,		/* after reading a buffer */
-    EVENT_BUFREADPRE,		/* before reading a buffer */
-    EVENT_BUFREADCMD,		/* read buffer using command */
-    EVENT_BUFUNLOAD,		/* just before unloading a buffer */
-    EVENT_BUFHIDDEN,		/* just after buffer becomes hidden */
-    EVENT_BUFWINENTER,		/* after showing a buffer in a window */
-    EVENT_BUFWINLEAVE,		/* just after buffer removed from window */
-    EVENT_BUFWRITEPOST,		/* after writing a buffer */
-    EVENT_BUFWRITEPRE,		/* before writing a buffer */
-    EVENT_BUFWRITECMD,		/* write buffer using command */
-    EVENT_CMDWINENTER,		/* after entering the cmdline window */
-    EVENT_CMDWINLEAVE,		/* before leaving the cmdline window */
-    EVENT_FILEAPPENDPOST,	/* after appending to a file */
-    EVENT_FILEAPPENDPRE,	/* before appending to a file */
-    EVENT_FILEAPPENDCMD,	/* appende to a file using command */
-    EVENT_FILECHANGEDSHELL,	/* after shell command that changed file */
-    EVENT_FILECHANGEDRO,	/* before first change to read-only file */
-    EVENT_FILEREADPOST,		/* after reading a file */
-    EVENT_FILEREADPRE,		/* before reading a file */
-    EVENT_FILEREADCMD,		/* read from a file using command */
-    EVENT_FILETYPE,		/* new file type detected (user defined) */
-    EVENT_FILEWRITEPOST,	/* after writing a file */
-    EVENT_FILEWRITEPRE,		/* before writing a file */
-    EVENT_FILEWRITECMD,		/* write to a file using command */
-    EVENT_FILTERREADPOST,	/* after reading from a filter */
-    EVENT_FILTERREADPRE,	/* before reading from a filter */
-    EVENT_FILTERWRITEPOST,	/* after writing to a filter */
-    EVENT_FILTERWRITEPRE,	/* before writing to a filter */
-    EVENT_FOCUSGAINED,		/* got the focus */
-    EVENT_FOCUSLOST,		/* lost the focus to another app */
-    EVENT_GUIENTER,		/* after starting the GUI */
-    EVENT_STDINREADPOST,	/* after reading from stdin */
-    EVENT_STDINREADPRE,		/* before reading from stdin */
-    EVENT_SYNTAX,		/* syntax selected */
-    EVENT_TERMCHANGED,		/* after changing 'term' */
-    EVENT_TERMRESPONSE,		/* after setting "v:termresponse" */
-    EVENT_USER,			/* user defined autocommand */
-    EVENT_VIMENTER,		/* after starting Vim */
-    EVENT_VIMLEAVE,		/* before exiting Vim */
-    EVENT_VIMLEAVEPRE,		/* before exiting Vim and writing .viminfo */
-    EVENT_WINENTER,		/* after entering a window */
-    EVENT_WINLEAVE,		/* before leaving a window */
-    EVENT_ENCODINGCHANGED,	/* after changing the 'encoding' option */
-    EVENT_CURSORHOLD,		/* cursor in same position for a while */
-    EVENT_FUNCUNDEFINED,	/* if calling a function which doesn't exist */
-    EVENT_REMOTEREPLY,		/* upon string reception from a remote vim */
-    NUM_EVENTS			/* MUST be the last one */
-};
-
-typedef enum auto_event EVENT_T;
-
-/*
- * Values for index in highlight_attr[].
- * When making changes, also update HL_FLAGS below!  And update the default
- * value of 'highlight' in option.c.
- */
-enum hlf_value
-{
-    HLF_8 = 0	    /* Meta & special keys listed with ":map", text that is
-		       displayed different from what it is */
-    , HLF_AT	    /* @ and ~ characters at end of screen, characters that
-		       don't really exist in the text */
-    , HLF_D	    /* directories in CTRL-D listing */
-    , HLF_E	    /* error messages */
-    , HLF_H	    /* obsolete, ignored */
-    , HLF_I	    /* incremental search */
-    , HLF_L	    /* last search string */
-    , HLF_M	    /* "--More--" message */
-    , HLF_CM	    /* Mode (e.g., "-- INSERT --") */
-    , HLF_N	    /* line number for ":number" and ":#" commands */
-    , HLF_R	    /* return to continue message and yes/no questions */
-    , HLF_S	    /* status lines */
-    , HLF_SNC	    /* status lines of not-current windows */
-    , HLF_C	    /* column to separate vertically split windows */
-    , HLF_T	    /* Titles for output from ":set all", ":autocmd" etc. */
-    , HLF_V	    /* Visual mode */
-    , HLF_VNC	    /* Visual mode, autoselecting and not clipboard owner */
-    , HLF_W	    /* warning messages */
-    , HLF_WM	    /* Wildmenu highlight */
-    , HLF_FL	    /* Folded line */
-    , HLF_FC	    /* Fold column */
-    , HLF_ADD	    /* Added diff line */
-    , HLF_CHD	    /* Changed diff line */
-    , HLF_DED	    /* Deleted diff line */
-    , HLF_TXD	    /* Text Changed in diff line */
-    , HLF_SC	    /* Sign column */
-    , HLF_COUNT	    /* MUST be the last one */
-};
-
-/* the HL_FLAGS must be in the same order as the HLF_ enums! */
-#define HL_FLAGS {'8', '@', 'd', 'e', 'h', 'i', 'l', 'm', 'M', \
-		  'n', 'r', 's', 'S', 'c', 't', 'v', 'V', 'w', 'W', \
-		  'f', 'F', 'A', 'C', 'D', 'T', '>'}
-
-/*
- * Boolean constants
- */
-#ifndef TRUE
-# define FALSE	0	    /* note: this is an int, not a long! */
-# define TRUE	1
-#endif
-
-#define MAYBE	2	    /* sometimes used for a variant on TRUE */
-
-/* May be returned by add_new_completion(): */
-#define RET_ERROR		(-1)
-
-/*
- * Operator IDs; The order must correspond to opchars[] in ops.c!
- */
-#define OP_NOP		0	/* no pending operation */
-#define OP_DELETE	1	/* "d"  delete operator */
-#define OP_YANK		2	/* "y"  yank operator */
-#define OP_CHANGE	3	/* "c"  change operator */
-#define OP_LSHIFT	4	/* "<"  left shift operator */
-#define OP_RSHIFT	5	/* ">"  right shift operator */
-#define OP_FILTER	6	/* "!"  filter operator */
-#define OP_TILDE	7	/* "g~" switch case operator */
-#define OP_INDENT	8	/* "="  indent operator */
-#define OP_FORMAT	9	/* "gq" format operator */
-#define OP_COLON	10	/* ":"  colon operator */
-#define OP_UPPER	11	/* "gU" make upper case operator */
-#define OP_LOWER	12	/* "gu" make lower case operator */
-#define OP_JOIN		13	/* "J"  join operator, only for Visual mode */
-#define OP_JOIN_NS	14	/* "gJ"  join operator, only for Visual mode */
-#define OP_ROT13	15	/* "g?" rot-13 encoding */
-#define OP_REPLACE	16	/* "r"  replace chars, only for Visual mode */
-#define OP_INSERT	17	/* "I"  Insert column, only for Visual mode */
-#define OP_APPEND	18	/* "A"  Append column, only for Visual mode */
-#define OP_FOLD		19	/* "zf" define a fold */
-#define OP_FOLDOPEN	20	/* "zo" open folds */
-#define OP_FOLDOPENREC	21	/* "zO" open folds recursively */
-#define OP_FOLDCLOSE	22	/* "zc" close folds */
-#define OP_FOLDCLOSEREC	23	/* "zC" close folds recursively */
-#define OP_FOLDDEL	24	/* "zd" delete folds */
-#define OP_FOLDDELREC	25	/* "zD" delete folds recursively */
-#define OP_FORMAT2	26	/* "gw" format operator, keeps cursor pos */
-
-/*
- * Motion types, used for operators and for yank/delete registers.
- */
-#define MCHAR	0		/* character-wise movement/register */
-#define MLINE	1		/* line-wise movement/register */
-#define MBLOCK	2		/* block-wise register */
-
-#define MAUTO	0xff		/* Decide between MLINE/MCHAR */
-
-/*
- * Minimum screen size
- */
-#define MIN_COLUMNS	12	/* minimal columns for screen */
-#define MIN_LINES	2	/* minimal lines for screen */
-#define STATUS_HEIGHT	1	/* height of a status line under a window */
-#define QF_WINHEIGHT	10	/* default height for quickfix window */
-
-/*
- * Buffer sizes
- */
-#ifndef CMDBUFFSIZE
-# define CMDBUFFSIZE	256	/* size of the command processing buffer */
-#endif
-
-#define LSIZE	    512		/* max. size of a line in the tags file */
-
-#define IOSIZE	   (1024+1)	/* file i/o and sprintf buffer size */
-
-#ifdef FEAT_MBYTE
-# define MSG_BUF_LEN 240	/* length of buffer for small messages */
-#else
-# define MSG_BUF_LEN 80		/* length of buffer for small messages */
-#endif
-
-#if defined(AMIGA) || defined(__linux__) || defined(__QNX__) || defined(__CYGWIN32__) || defined(_AIX)
-# define TBUFSZ 2048		/* buffer size for termcap entry */
-#else
-# define TBUFSZ 1024		/* buffer size for termcap entry */
-#endif
-
-/*
- * Maximum length of key sequence to be mapped.
- * Must be able to hold an Amiga resize report.
- */
-#define MAXMAPLEN   50
-
-#ifdef BINARY_FILE_IO
-# define WRITEBIN   "wb"	/* no CR-LF translation */
-# define READBIN    "rb"
-# define APPENDBIN  "ab"
-#else
-# define WRITEBIN   "w"
-# define READBIN    "r"
-# define APPENDBIN  "a"
-#endif
-
-/*
- * EMX doesn't have a global way of making open() use binary I/O.
- * Use O_BINARY for all open() calls.
- */
-#if defined(__EMX__) || defined(__CYGWIN32__)
-# define O_EXTRA    O_BINARY
-#else
-# define O_EXTRA    0
-#endif
-
-#ifndef W_OK
-# define W_OK 2		/* for systems that don't have W_OK in unistd.h */
-#endif
-#ifndef R_OK
-# define R_OK 4		/* for systems that don't have R_OK in unistd.h */
-#endif
-
-/*
- * defines to avoid typecasts from (char_u *) to (char *) and back
- * (vim_strchr() and vim_strrchr() are now in alloc.c)
- */
-#define STRLEN(s)	    strlen((char *)(s))
-#define STRCPY(d, s)	    strcpy((char *)(d), (char *)(s))
-#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))
-#define STRCMP(d, s)	    strcmp((char *)(d), (char *)(s))
-#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))
-#ifdef HAVE_STRCASECMP
-# define STRICMP(d, s)	    strcasecmp((char *)(d), (char *)(s))
-#else
-# ifdef HAVE_STRICMP
-#  define STRICMP(d, s)	    stricmp((char *)(d), (char *)(s))
-# else
-#  define STRICMP(d, s)	    vim_stricmp((char *)(d), (char *)(s))
-# endif
-#endif
-
-#ifdef HAVE_STRNCASECMP
-# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))
-#else
-# ifdef HAVE_STRNICMP
-#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))
-# else
-#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))
-# endif
-#endif
-
-#ifdef FEAT_MBYTE
-# define MB_STRICMP(d, s)	(has_mbyte ? mb_strnicmp((char_u *)(d), (char_u *)(s), (int)MAXCOL) : STRICMP((d), (s)))
-# define MB_STRNICMP(d, s, n)	(has_mbyte ? mb_strnicmp((char_u *)(d), (char_u *)(s), (int)(n)) : STRNICMP((d), (s), (n)))
-#else
-# define MB_STRICMP(d, s)	STRICMP((d), (s))
-# define MB_STRNICMP(d, s, n)	STRNICMP((d), (s), (n))
-# define transchar_byte(c)	transchar(c)
-#endif
-
-#define STRCAT(d, s)	    strcat((char *)(d), (char *)(s))
-#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))
-
-#ifdef HAVE_STRPBRK
-# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))
-#endif
-
-#define MSG(s)			    msg((char_u *)(s))
-#define MSG_ATTR(s, attr)	    msg_attr((char_u *)(s), (attr))
-#define EMSG(s)			    emsg((char_u *)(s))
-#define EMSG2(s, p)		    emsg2((char_u *)(s), (char_u *)(p))
-#define EMSG3(s, p, q)		    emsg3((char_u *)(s), (char_u *)(p), (char_u *)(q))
-#define EMSGN(s, n)		    emsgn((char_u *)(s), (long)(n))
-#define OUT_STR(s)		    out_str((char_u *)(s))
-#define OUT_STR_NF(s)		    out_str_nf((char_u *)(s))
-#define MSG_PUTS(s)		    msg_puts((char_u *)(s))
-#define MSG_PUTS_ATTR(s, a)	    msg_puts_attr((char_u *)(s), (a))
-#define MSG_PUTS_TITLE(s)	    msg_puts_title((char_u *)(s))
-#define MSG_PUTS_LONG(s)	    msg_puts_long((char_u *)(s))
-#define MSG_PUTS_LONG_ATTR(s, a)    msg_puts_long_attr((char_u *)(s), (a))
-
-/* Prefer using emsg3(), because perror() may send the output to the wrong
- * destination and mess up the screen. */
-#ifdef HAVE_STRERROR
-# define PERROR(msg)		    (void)emsg3((char_u *)"%s: %s", (char_u *)msg, (char_u *)strerror(errno))
-#else
-# define PERROR(msg)		    perror(msg)
-#endif
-
-typedef long	    linenr_T;		/* line number type */
-typedef unsigned    colnr_T;		/* column number type */
-typedef unsigned short disptick_T;	/* display tick type */
-
-#define MAXLNUM (0x7fffffffL)		/* maximum (invalid) line number */
-
-/*
- * Well, you won't believe it, but some S/390 machines ("host", now also known
- * as zServer) us 31 bit pointers. There are also some newer machines, that
- * use 64 bit pointers. I don't know how to distinguish between 31 and 64 bit
- * machines, so the best way is to assume 31 bits whenever we detect OS/390
- * Unix.
- * With this we restrict the maximum line length to 1073741823. I guess this is
- * not a real problem. BTW:  Longer lines are split.
- */
-#if SIZEOF_INT >= 4
-# ifdef __MVS__
-#  define MAXCOL (0x3fffffffL)		/* maximum column number, 30 bits */
-# else
-#  define MAXCOL (0x7fffffffL)		/* maximum column number, 31 bits */
-# endif
-#else
-# define MAXCOL	(0x7fff)		/* maximum column number, 15 bits */
-#endif
-
-#define SHOWCMD_COLS 10			/* columns needed by shown command */
-#define STL_MAX_ITEM 80			/* max nr of %<flag> in statusline */
-
-typedef void	    *vim_acl_T;		/* dummy to pass an ACL to a function */
-
-/*
- * Include a prototype for mch_memmove(), it may not be in alloc.pro.
- */
-#ifdef VIM_MEMMOVE
-void mch_memmove __ARGS((void *, void *, size_t));
-#else
-# ifndef mch_memmove
-#  define mch_memmove(to, from, len) memmove(to, from, len)
-# endif
-#endif
-
-/*
- * fnamecmp() is used to compare file names.
- * On some systems case in a file name does not matter, on others it does.
- * (this does not account for maximum name lengths and things like "../dir",
- * thus it is not 100% accurate!)
- */
-#ifdef CASE_INSENSITIVE_FILENAME
-# ifdef BACKSLASH_IN_FILENAME
-#  define fnamecmp(x, y) vim_fnamecmp((x), (y))
-#  define fnamencmp(x, y, n) vim_fnamencmp((x), (y), (size_t)(n))
-# else
-#  define fnamecmp(x, y) MB_STRICMP((x), (y))
-#  define fnamencmp(x, y, n) MB_STRNICMP((x), (y), (n))
-# endif
-#else
-# define fnamecmp(x, y) strcmp((char *)(x), (char *)(y))
-# define fnamencmp(x, y, n) strncmp((char *)(x), (char *)(y), (size_t)(n))
-#endif
-
-#ifdef HAVE_MEMSET
-# define vim_memset(ptr, c, size)   memset((ptr), (c), (size))
-#else
-void *vim_memset __ARGS((void *, int, size_t));
-#endif
-
-#ifdef HAVE_MEMCMP
-# define vim_memcmp(p1, p2, len)   memcmp((p1), (p2), (len))
-#else
-# ifdef HAVE_BCMP
-#  define vim_memcmp(p1, p2, len)   bcmp((p1), (p2), (len))
-# else
-int vim_memcmp __ARGS((void *, void *, size_t));
-#  define VIM_MEMCMP
-# endif
-#endif
-
-#if defined(UNIX) || defined(FEAT_GUI) || defined(OS2) || defined(VMS) \
-	|| defined(FEAT_CLIENTSERVER)
-# define USE_INPUT_BUF
-#endif
-
-#ifdef MSWIN
-/* On MS-Windows the third argument isn't size_t.  This matters for Win64,
- * where sizeof(size_t)==8, not 4 */
-# define vim_read(fd, buf, count)   read((fd), (char *)(buf), (unsigned int)(count))
-# define vim_write(fd, buf, count)  write((fd), (char *)(buf), (unsigned int)(count))
-#else
-# define vim_read(fd, buf, count)   read((fd), (char *)(buf), (size_t) (count))
-# define vim_write(fd, buf, count)  write((fd), (char *)(buf), (size_t) (count))
-#endif
-
-/*
- * Enums need a typecast to be used as array index (for Ultrix).
- */
-#define hl_attr(n)	highlight_attr[(int)(n)]
-#define term_str(n)	term_strings[(int)(n)]
-
-/*
- * vim_iswhite() is used for "^" and the like. It differs from isspace()
- * because it doesn't include <CR> and <LF> and the like.
- */
-#define vim_iswhite(x)	((x) == ' ' || (x) == '\t')
-
-/* Note that gui.h is included by structs.h */
-
-#include "structs.h"	    /* file that defines many structures */
-
-#ifdef FEAT_MOUSE
-
-/* Codes for mouse button events in lower three bits: */
-# define MOUSE_LEFT	0x00
-# define MOUSE_MIDDLE	0x01
-# define MOUSE_RIGHT	0x02
-# define MOUSE_RELEASE	0x03
-
-/* bit masks for modifiers: */
-# define MOUSE_SHIFT	0x04
-# define MOUSE_ALT	0x08
-# define MOUSE_CTRL	0x10
-
-/* mouse buttons that are handled like a key press (GUI only) */
-# define MOUSE_4	0x100	/* scroll wheel down */
-# define MOUSE_5	0x200	/* scroll wheel up */
-
-# define MOUSE_X1	0x300 /* Mouse-button X1 (6th) */
-# define MOUSE_X2	0x400 /* Mouse-button X2 */
-
-/* 0x20 is reserved by xterm */
-# define MOUSE_DRAG_XTERM   0x40
-
-# define MOUSE_DRAG	(0x40 | MOUSE_RELEASE)
-
-/* Lowest button code for using the mouse wheel (xterm only) */
-# define MOUSEWHEEL_LOW		0x60
-
-# define MOUSE_CLICK_MASK	0x03
-
-# define NUM_MOUSE_CLICKS(code) \
-    (((unsigned)((code) & 0xC0) >> 6) + 1)
-
-# define SET_NUM_MOUSE_CLICKS(code, num) \
-    (code) = ((code) & 0x3f) | ((((num) - 1) & 3) << 6)
-
-/*
- * jump_to_mouse() returns one of first four these values, possibly with
- * some of the other three added.
- */
-# define IN_UNKNOWN		0
-# define IN_BUFFER		1
-# define IN_STATUS_LINE		2	/* on status or command line */
-# define IN_SEP_LINE		4	/* on vertical separator line */
-# define IN_OTHER_WIN		8	/* in other window but can't go there */
-# define CURSOR_MOVED		0x100
-# define MOUSE_FOLD_CLOSE	0x200	/* clicked on '-' in fold column */
-# define MOUSE_FOLD_OPEN	0x400	/* clicked on '+' in fold column */
-
-/* flags for jump_to_mouse() */
-# define MOUSE_FOCUS		0x01	/* need to stay in this window */
-# define MOUSE_MAY_VIS		0x02	/* may start Visual mode */
-# define MOUSE_DID_MOVE		0x04	/* only act when mouse has moved */
-# define MOUSE_SETPOS		0x08	/* only set current mouse position */
-# define MOUSE_MAY_STOP_VIS	0x10	/* may stop Visual mode */
-# define MOUSE_RELEASED		0x20	/* button was released */
-
-# if defined(UNIX) && defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
-#  define CHECK_DOUBLE_CLICK 1	/* Checking for double clicks ourselves. */
-# endif
-
-#endif /* FEAT_MOUSE */
-
-/* defines for eval_vars() */
-#define VALID_PATH		1
-#define VALID_HEAD		2
-
-/* Defines for Vim variables.  These must match vimvars[] in eval.c! */
-#define VV_COUNT	0
-#define VV_COUNT1	1
-#define VV_PREVCOUNT	2
-#define VV_ERRMSG	3
-#define VV_WARNINGMSG	4
-#define VV_STATUSMSG	5
-#define VV_SHELL_ERROR	6
-#define VV_THIS_SESSION	7
-#define VV_VERSION	8
-#define VV_LNUM		9
-#define VV_TERMRESPONSE	10
-#define VV_FNAME	11
-#define VV_LANG		12
-#define VV_LC_TIME	13
-#define VV_CTYPE	14
-#define VV_CC_FROM	15
-#define VV_CC_TO	16
-#define VV_FNAME_IN	17
-#define VV_FNAME_OUT	18
-#define VV_FNAME_NEW	19
-#define VV_FNAME_DIFF	20
-#define VV_CMDARG	21
-#define VV_FOLDSTART	22
-#define VV_FOLDEND	23
-#define VV_FOLDDASHES	24
-#define VV_FOLDLEVEL	25
-#define VV_PROGNAME	26
-#define VV_SEND_SERVER	27
-#define VV_DYING	28
-#define VV_EXCEPTION	29
-#define VV_THROWPOINT	30
-#define VV_REG		31
-#define VV_CMDBANG	32
-#define VV_LEN		33	/* number of v: vars */
-
-#ifdef FEAT_CLIPBOARD
-
-/* VIM_ATOM_NAME is the older Vim-specific selection type for X11.  Still
- * supported for when a mix of Vim versions is used. VIMENC_ATOM_NAME includes
- * the encoding to support Vims using different 'encoding' values. */
-#define VIM_ATOM_NAME "_VIM_TEXT"
-#define VIMENC_ATOM_NAME "_VIMENC_TEXT"
-
-/* Selection states for modeless selection */
-# define SELECT_CLEARED		0
-# define SELECT_IN_PROGRESS	1
-# define SELECT_DONE		2
-
-# define SELECT_MODE_CHAR	0
-# define SELECT_MODE_WORD	1
-# define SELECT_MODE_LINE	2
-
-# ifdef FEAT_GUI_W32
-#  ifdef FEAT_OLE
-#   define WM_OLE (WM_APP+0)
-#  endif
-#  ifdef FEAT_NETBEANS_INTG
-    /* message for Netbeans socket event */
-#   define WM_NETBEANS (WM_APP+1)
-#  endif
-# endif
-
-/* Info about selected text */
-typedef struct VimClipboard
-{
-    int		available;	/* Is clipboard available? */
-    int		owned;		/* Flag: do we own the selection? */
-    pos_T	start;		/* Start of selected area */
-    pos_T	end;		/* End of selected area */
-    int		vmode;		/* Visual mode character */
-
-    /* Fields for selection that doesn't use Visual mode */
-    short_u	origin_row;
-    short_u	origin_start_col;
-    short_u	origin_end_col;
-    short_u	word_start_col;
-    short_u	word_end_col;
-
-    pos_T	prev;		/* Previous position */
-    short_u	state;		/* Current selection state */
-    short_u	mode;		/* Select by char, word, or line. */
-
-# if defined(FEAT_GUI_X11) || defined(FEAT_XCLIPBOARD)
-    Atom	sel_atom;	/* PRIMARY/CLIPBOARD selection ID */
-# endif
-
-# ifdef FEAT_GUI_GTK
-    GdkAtom     gtk_sel_atom;	/* PRIMARY/CLIPBOARD selection ID */
-# endif
-
-# ifdef MSWIN
-    int_u	format;		/* Vim's own special clipboard format */
-    int_u	format_raw;	/* Vim's raw text clipboard format */
-# endif
-# ifdef FEAT_GUI_BEOS
-				/* no clipboard at the moment */
-# endif
-} VimClipboard;
-#else
-typedef int VimClipboard;	/* This is required for the prototypes. */
-#endif
-
-#ifdef __BORLANDC__
-/* work around a bug in the Borland 'stat' function: */
-# include <io.h>	    /* for access() */
-
-# define stat(a,b) (access(a,0) ? -1 : stat(a,b))
-#endif
-
-/*
- * EXTERN is only defined in main.c.  That's where global variables are
- * actually defined and initialized.
- */
-#ifndef EXTERN
-# define EXTERN extern
-# define INIT(x)
-#else
-# ifndef INIT
-#  define INIT(x) x
-#  define DO_INIT
-# endif
-#endif
-
-#include "option.h"	    /* option variables and defines */
-#include "ex_cmds.h"	    /* Ex command defines */
-#include "proto.h"	    /* function prototypes */
-
-/* This has to go after the include of proto.h, as proto/gui.pro declares
- * functions of these names. The declarations would break if the defines had
- * been seen at that stage.  But it must be before globals.h, where error_ga
- * is declared. */
-#if !defined(FEAT_GUI_W32) && !defined(FEAT_GUI_X11) \
-	&& !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MAC)
-# define mch_errmsg(str)	fprintf(stderr, "%s", (str))
-# define display_errors()	fflush(stderr)
-# define mch_msg(str)		printf("%s", (str))
-#else
-# define USE_MCH_ERRMSG
-#endif
-
-#include "globals.h"	    /* global variables and messages */
-
-#ifdef FEAT_SNIFF
-# include "if_sniff.h"
-#endif
-
-#ifndef FEAT_VIRTUALEDIT
-# define getvvcol(w, p, s, c, e) getvcol(w, p, s, c, e)
-# define virtual_active() 0
-# define virtual_op FALSE
-#endif
-
-/*
- * If console dialog not supported, but GUI dialog is, use the GUI one.
- */
-#if defined(FEAT_GUI_DIALOG) && !defined(FEAT_CON_DIALOG)
-# define do_dialog gui_mch_dialog
-#endif
-
-/*
- * Default filters for gui_mch_browse().
- * The filters are almost system independent.  Except for the difference
- * between "*" and "*.*" for MSDOS-like systems.
- * NOTE: Motif only uses the very first pattern.  Therefore
- * BROWSE_FILTER_DEFAULT should start with a "*" pattern.
- */
-#ifdef FEAT_BROWSE
-# ifdef BACKSLASH_IN_FILENAME
-#  define BROWSE_FILTER_MACROS \
-	(char_u *)"Vim macro files (*.vim)\t*.vim\nAll Files (*.*)\t*.*\n"
-#  define BROWSE_FILTER_ALL_FILES (char_u *)"All Files (*.*)\t*.*\n"
-#  define BROWSE_FILTER_DEFAULT \
-	(char_u *)"All Files (*.*)\t*.*\nC source (*.c, *.h)\t*.c;*.h\nC++ source (*.cpp, *.hpp)\t*.cpp;*.hpp\nVB code (*.bas, *.frm)\t*.bas;*.frm\nVim files (*.vim, _vimrc, _gvimrc)\t*.vim;_vimrc;_gvimrc\n"
-# else
-#  define BROWSE_FILTER_MACROS \
-	(char_u *)"Vim macro files (*.vim)\t*.vim\nAll Files (*)\t*\n"
-#  define BROWSE_FILTER_ALL_FILES (char_u *)"All Files (*)\t*\n"
-#  define BROWSE_FILTER_DEFAULT \
-	(char_u *)"All Files (*)\t*\nC source (*.c, *.h)\t*.c;*.h\nC++ source (*.cpp, *.hpp)\t*.cpp;*.hpp\nVim files (*.vim, _vimrc, _gvimrc)\t*.vim;_vimrc;_gvimrc\n"
-# endif
-#endif
-
-/* stop using fastcall for Borland */
-#if defined(__BORLANDC__) && defined(WIN32) && !defined(DEBUG)
-# pragma option -p.
-#endif
-
-#if defined(MEM_PROFILE)
-# define vim_realloc(ptr, size)  mem_realloc((ptr), (size))
-#else
-# define vim_realloc(ptr, size)  realloc((ptr), (size))
-#endif
-
-/*
- * The following macros stop displat/event loop nesting at the wrong time.
- */
-#ifdef ALT_X_INPUT
-# define ALT_INPUT_LOCK_OFF	suppress_alternate_input = FALSE
-# define ALT_INPUT_LOCK_ON	suppress_alternate_input = TRUE
-#endif
-
-#ifdef FEAT_MBYTE
-/* Maximum number of bytes in a multi-byte character.  It can be one 32-bit
- * character of up to 6 bytes, or one 16-bit character of up to three bytes
- * plus two following composing characters of three bytes each. */
-# define MB_MAXBYTES	9
-
-/*
- * Return byte length of character that starts with byte "b".
- * Returns 1 for a single-byte character.
- * MB_BYTE2LEN_CHECK() can be used to count a special key as one byte.
- * Don't call MB_BYTE2LEN(b) with b < 0 or b > 255!
- */
-# define MB_BYTE2LEN(b)		mb_bytelen_tab[b]
-# define MB_BYTE2LEN_CHECK(b)	(((b) < 0 || (b) > 255) ? 1 : mb_bytelen_tab[b])
-#endif
-
-#if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT)
-/* properties used in enc_canon_table[] (first three mutually exclusive) */
-# define ENC_8BIT	0x01
-# define ENC_DBCS	0x02
-# define ENC_UNICODE	0x04
-
-# define ENC_ENDIAN_B	0x10	    /* Unicode: Big endian */
-# define ENC_ENDIAN_L	0x20	    /* Unicode: Little endian */
-
-# define ENC_2BYTE	0x40	    /* Unicode: UCS-2 */
-# define ENC_4BYTE	0x80	    /* Unicode: UCS-4 */
-# define ENC_2WORD	0x100	    /* Unicode: UTF-16 */
-
-# define ENC_LATIN1	0x200	    /* Latin1 */
-# define ENC_MACROMAN	0x400	    /* Mac Roman (not Macro Man! :-) */
-#endif
-
-#ifdef FEAT_MBYTE
-# ifdef USE_ICONV
-#  ifndef EILSEQ
-#   define EILSEQ 123
-#  endif
-#  ifdef DYNAMIC_ICONV
-/* On Win32 iconv.dll is dynamically loaded. */
-#   define ICONV_ERRNO (*iconv_errno())
-#   define ICONV_E2BIG  7
-#   define ICONV_EINVAL 22
-#   define ICONV_EILSEQ 42
-#  else
-#   define ICONV_ERRNO errno
-#   define ICONV_E2BIG  E2BIG
-#   define ICONV_EINVAL EINVAL
-#   define ICONV_EILSEQ EILSEQ
-#  endif
-# endif
-
-#endif
-
-/* ISSYMLINK(mode) tests if a file is a symbolic link. */
-#if (defined(S_IFMT) && defined(S_IFLNK)) || defined(S_ISLNK)
-# define HAVE_ISSYMLINK
-# if defined(S_IFMT) && defined(S_IFLNK)
-#  define ISSYMLINK(mode) (((mode) & S_IFMT) == S_IFLNK)
-# else
-#  define ISSYMLINK(mode) S_ISLNK(mode)
-# endif
-#endif
-
-#define SIGN_BYTE 1	    /* byte value used where sign is displayed;
-			       attribute value is sign type */
-
-#ifdef FEAT_NETBEANS_INTG
-# define MULTISIGN_BYTE 2   /* byte value used where sign is displayed if
-			       multiple signs exist on the line */
-#endif
-
-#if defined(FEAT_GUI) && defined(FEAT_XCLIPBOARD)
-# ifdef FEAT_GUI_GTK
-   /* Avoid using a global variable for the X display.  It's ugly
-    * and is likely to cause trouble in multihead environments. */
-#  define X_DISPLAY	((gui.in_use) ? gui_mch_get_display() : xterm_dpy)
-# else
-#  define X_DISPLAY	(gui.in_use ? gui.dpy : xterm_dpy)
-# endif
-#else
-# ifdef FEAT_GUI
-#  ifdef FEAT_GUI_GTK
-#   define X_DISPLAY	((gui.in_use) ? gui_mch_get_display() : (Display *)NULL)
-#  else
-#   define X_DISPLAY	gui.dpy
-#  endif
-# else
-#  define X_DISPLAY	xterm_dpy
-# endif
-#endif
-
-#ifdef NBDEBUG /* Netbeans debugging. */
-# include "nbdebug.h"
-#else
-# define nbdebug(a)
-#endif
-
-#ifdef IN_PERL_FILE
-  /*
-   * Avoid clashes between Perl and Vim namespace.
-   */
-# undef NORMAL
-# undef STRLEN
-# undef FF
-# undef OP_DELETE
-# undef OP_JOIN
-# ifdef __BORLANDC__
-#  define NOPROTO 1
-# endif
-  /* remove MAX and MIN, included by glib.h, redefined by sys/param.h */
-# ifdef MAX
-#  undef MAX
-# endif
-# ifdef MIN
-#  undef MIN
-# endif
-  /* We use _() for gettext(), Perl uses it for function prototypes... */
-# ifdef _
-#  undef _
-# endif
-# ifdef DEBUG
-#  undef DEBUG
-# endif
-# ifdef _DEBUG
-#  undef _DEBUG
-# endif
-# ifdef instr
-#  undef instr
-# endif
-  /* bool causes trouble on MACOS but is required on a few other systems */
-# if defined(bool) && defined(MACOS)
-#  undef bool
-# endif
-
-# ifdef __BORLANDC__
-  /* Borland has the structure stati64 but not _stati64 */
-#  define _stati64 stati64
-# endif
-
-# include <EXTERN.h>
-# include <perl.h>
-# include <XSUB.h>
-#endif
-
-#endif /* VIM__H */
diff -Nur vim63/src/vim_proxy_factory.c vim63-bonobo/src/vim_proxy_factory.c
--- vim63/src/vim_proxy_factory.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_proxy_factory.c	2005-09-09 20:14:02.766579680 +0200
@@ -0,0 +1,66 @@
+/*
+ * vim_proxy_factory.c
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#include "vim.h"
+#include "version.h"
+#include <libbonobo.h>
+#include <bonobo/bonobo-foreign-object.h>
+#include <bonobo/bonobo-generic-factory.h>
+#include "vim_bonobo_control.h"
+#include "vim_bonobo_factory.h"
+
+#define VIM_PROXY_OAFIID "OAFIID:Vim_Proxy_Factory"
+
+static BonoboGenericFactory *factory = NULL;
+
+static BonoboObject *
+vim_proxy_factory(BonoboGenericFactory *this,
+              const char           *oaf_iid,
+              void                 *data)
+{
+    CORBA_Object realfactory;
+    CORBA_Environment ev;
+    BonoboObject * vim_control = NULL;
+    CORBA_Object corba_control;
+
+    g_return_val_if_fail (this != NULL, NULL);
+    g_return_val_if_fail (oaf_iid != NULL, NULL);
+
+    g_message ("Trying to produce a '%s'...", oaf_iid);
+                                                                                
+    if (strcmp (oaf_iid, VIM_OAFIID) == 0) {
+        CORBA_exception_init(&ev);
+
+        realfactory = bonobo_activation_activate_from_id (VIM_FACTORY_OAFIID,
+                                                  Bonobo_ACTIVATION_FLAG_PRIVATE,
+                                                  NULL,
+                                                  &ev);
+        if (ev._major != CORBA_NO_EXCEPTION ) {
+            CORBA_exception_free (&ev);
+            return NULL;
+        }
+
+        corba_control = Bonobo_GenericFactory_createObject(realfactory, VIM_OAFIID, &ev);
+        if (ev._major != CORBA_NO_EXCEPTION ) {
+            CORBA_exception_free (&ev);
+            return NULL;
+        }
+        CORBA_exception_free (&ev);
+        vim_control = bonobo_foreign_object_new(corba_control);
+    } else {
+        g_warning ("Unknown IID `%s' requested", oaf_iid);
+        return NULL;
+    }
+    return vim_control;
+}
+
+
+BONOBO_ACTIVATION_FACTORY (VIM_PROXY_OAFIID,
+               "Vim Proxy Factory", "1.0",
+               vim_proxy_factory, NULL);
+
