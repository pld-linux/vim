diff -Nur vim63/src/buffer.c vim63-bonobo/src/buffer.c
--- vim63/src/buffer.c	2005-09-09 20:11:09.929854000 +0200
+++ vim63-bonobo/src/buffer.c	2005-09-09 20:14:02.699589864 +0200
@@ -28,6 +28,10 @@
 
 #include "vim.h"
 
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+#include "vim_bonobo_control.h"
+#endif
+
 #if defined(FEAT_CMDL_COMPL) || defined(FEAT_LISTCMDS) || defined(FEAT_EVAL) || defined(FEAT_PERL)
 static char_u	*buflist_match __ARGS((regprog_T *prog, buf_T *buf));
 # define HAVE_BUFLIST_MATCH
@@ -137,10 +141,20 @@
 	if (curbuf->b_help)
 	    fix_help_buffer();
     }
-    else if (read_stdin)
+    else if (read_stdin
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+                || read_from_container
+#endif
+            )
     {
 	int		save_bin = curbuf->b_p_bin;
 	linenr_T	line_count;
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+        int flags = READ_NEW + READ_EMB_STREAM;
+	curbuf->emb_buffer = TRUE;
+#else
+        int flags = READ_NEW + READ_STDIN;
+#endif
 
 	/*
 	 * First read the text in binary mode into the buffer.
@@ -150,7 +164,7 @@
 	 */
 	curbuf->b_p_bin = TRUE;
 	retval = readfile(NULL, NULL, (linenr_T)0,
-		  (linenr_T)0, (linenr_T)MAXLNUM, NULL, READ_NEW + READ_STDIN);
+ 		  (linenr_T)0, (linenr_T)MAXLNUM, eap, flags);
 	curbuf->b_p_bin = save_bin;
 	if (retval == OK)
 	{
@@ -172,14 +186,21 @@
 	    /* Put the cursor on the first line. */
 	    curwin->w_cursor.lnum = 1;
 	    curwin->w_cursor.col = 0;
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+            if (read_stdin) 
+            {
+#endif
 #ifdef FEAT_AUTOCMD
 # ifdef FEAT_EVAL
-	    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,
+                apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,
 							curbuf, &retval);
 # else
-	    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);
+                apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);
 # endif
 #endif
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+            }
+#endif
 	}
     }
 
@@ -4634,6 +4655,11 @@
 	return "[Scratch]";
     }
 #endif
+#if defined(FEAT_QUICKFIX) && defined(FEAT_GUI_COMPONENT)
+    if ( buf->emb_buffer ) {
+	return "[Embedded File]";
+    }
+#endif
     if (buf->b_fname == NULL)
 	return _("[No File]");
     return NULL;
diff -Nur vim63/src/config.h.in vim63-bonobo/src/config.h.in
--- vim63/src/config.h.in	2005-09-09 20:11:10.543761000 +0200
+++ vim63-bonobo/src/config.h.in	2005-09-09 20:14:02.700589712 +0200
@@ -321,6 +321,9 @@
 /* Define if GTK+ multihead support is available (requires GTK+ >= 2.1.1). */
 #undef HAVE_GTK_MULTIHEAD
 
+/* Define if you want component (i.e. Bonobo) support. */
+#undef FEAT_GUI_COMPONENT
+ 
 /* Define if your X has own locale library */
 #undef X_LOCALE
 
diff -Nur vim63/src/config.mk.in vim63-bonobo/src/config.mk.in
--- vim63/src/config.mk.in	2005-09-09 20:11:10.543761000 +0200
+++ vim63-bonobo/src/config.mk.in	2005-09-09 20:14:02.700589712 +0200
@@ -106,6 +106,9 @@
 ### Prefix for location of man pages
 MANDIR		= @mandir@
 
+### Extra targets to be built by default
+EXTRA_TARGETS = @EXTRA_TARGETS@
+
 ### Do we have a GUI
 GUI_INC_LOC	= @GUI_INC_LOC@
 GUI_LIB_LOC	= @GUI_LIB_LOC@
diff -Nur vim63/src/configure.in vim63-bonobo/src/configure.in
--- vim63/src/configure.in	2005-09-09 20:11:10.546761000 +0200
+++ vim63-bonobo/src/configure.in	2005-09-09 20:14:02.703589256 +0200
@@ -56,6 +56,7 @@
   sh ./toolcheck 1>&AC_FD_MSG
 fi
 
+EXTRA_TARGETS="";
 OS_EXTRA_SRC=""; OS_EXTRA_OBJ=""
 
 dnl Check for BeOS, which needs an extra source file
@@ -123,6 +124,7 @@
 
 AC_SUBST(OS_EXTRA_SRC)
 AC_SUBST(OS_EXTRA_OBJ)
+AC_SUBST(EXTRA_TARGETS)
 
 dnl Add /usr/local/lib to $LDFLAGS and /usr/local/include to CFLAGS.
 dnl Only when the directory exists and it wasn't there yet.
@@ -1831,6 +1833,23 @@
 	  AC_DEFINE(FEAT_GUI_GNOME)
 	  GUI_INC_LOC="$GUI_INC_LOC $GNOME_INCLUDEDIR"
 	  GTK_LIBNAME="$GTK_LIBNAME $GNOME_LIBDIR $GNOME_LIBS"
+          AC_MSG_CHECKING(whether or not to include bonobo support)
+          AC_ARG_ENABLE(bonobo,
+            [  --enable-bonobo         If using GNOME, enable bonobo support [default=no]],
+            , enable_bonobo="no")
+          if test "x$enable_bonobo" = "xno"; then
+            AC_MSG_RESULT($enable_bonobo);
+          else
+            if test "x$SKIP_BONOBO" != "xYES" -a $gtk_major_version -ge 2; then
+              AC_MSG_RESULT(yes);
+              AC_DEFINE(FEAT_GUI_COMPONENT) 
+              GUITYPE=BONOBO
+              VIMNAME="vim-component"
+              EXTRA_TARGETS="vim-factory Vim_Control.server"
+            else
+              AC_MSG_RESULT(no (Bonobo requires Gnome 2));
+            fi
+          fi
 	fi
       }
       fi
diff -Nur vim63/src/container.c vim63-bonobo/src/container.c
--- vim63/src/container.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/container.c	2005-09-09 20:14:02.704589104 +0200
@@ -0,0 +1,266 @@
+
+#include <bonobo.h>
+#include <glib.h>
+
+BonoboControlFrame  *ctrl_frame;
+BonoboUIComponent   *ui_comp;
+
+/* vbox */
+GtkWidget           *box;
+GtkWidget           *ctrl_widget;
+
+char * filename;
+
+static Bonobo_Control
+instantiate_control()
+{
+	Bonobo_Control control;
+	Bonobo_PersistFile pfile;
+	Bonobo_PersistStream pstream;
+	CORBA_Environment ev;
+    Bonobo_Stream stream;
+
+	CORBA_exception_init (&ev);
+
+	/* get control component */
+	control = bonobo_get_object ("OAFIID:Vim_Control",
+				     "Bonobo/Control", &ev);
+	if (BONOBO_EX (&ev) || (control == CORBA_OBJECT_NIL))
+    {
+		CORBA_exception_free (&ev);
+        return NULL;
+    }
+	
+#if 0
+	/* get PersistFile interface */
+    pfile = Bonobo_Unknown_queryInterface (control, "IDL:Bonobo/PersistFile:1.0", &ev);
+    if (BONOBO_EX (&ev) || (pfile == CORBA_OBJECT_NIL))
+    exit(1);
+	
+	/* load the file */
+    Bonobo_PersistFile_load (pfile, filename, &ev);
+	bonobo_object_release_unref (pfile, NULL);
+#endif
+
+	/* get PersistStream interface */
+    pstream = Bonobo_Unknown_queryInterface (control, "IDL:Bonobo/PersistStream:1.0", &ev);
+    if (BONOBO_EX (&ev) || (pstream == CORBA_OBJECT_NIL))
+    {
+		CORBA_exception_free (&ev);
+        return NULL;
+    }
+	
+	/* load the file */
+    stream = bonobo_get_object(filename, "IDL:Bonobo/Stream:1.0", &ev);
+	if (ev._major != CORBA_NO_EXCEPTION) {
+        g_warning("Error getting stream interface");
+		bonobo_object_unref (BONOBO_OBJECT (stream));
+		CORBA_exception_free (&ev);
+		return NULL;
+	}
+    Bonobo_PersistStream_load (pstream, stream, "text/plain", &ev);
+	if (ev._major != CORBA_NO_EXCEPTION) {
+        g_warning("Error loading stream!");
+		bonobo_object_unref (BONOBO_OBJECT (stream));
+		CORBA_exception_free (&ev);
+		return NULL;
+	}
+	bonobo_object_release_unref (pstream, NULL);
+    return control;
+}
+
+static void
+verb_FileNewWindow (BonoboUIComponent *uic, gpointer user_data, const char *cname)
+{
+    printf("Got New Window!\n");
+}
+
+static void
+verb_DoNothing (BonoboUIComponent *uic, gpointer user_data, const char *cname)
+{
+}
+
+static BonoboUIVerb app_verbs[] = {
+	BONOBO_UI_VERB ("FileNewWindow", verb_FileNewWindow),
+	BONOBO_UI_VERB ("FileOpen",      verb_DoNothing),
+	BONOBO_UI_VERB ("FileCloseWindow", verb_DoNothing),
+	BONOBO_UI_VERB ("FileExit",      verb_DoNothing),
+	BONOBO_UI_VERB ("Preferences",   verb_DoNothing),
+	BONOBO_UI_VERB ("HelpAbout",     verb_DoNothing),
+	BONOBO_UI_VERB ("Help",          verb_DoNothing),
+	BONOBO_UI_VERB ("DnDNewWindow",  verb_DoNothing),
+	BONOBO_UI_VERB ("DnDSameWindow", verb_DoNothing),
+	BONOBO_UI_VERB ("DnDCancel",     verb_DoNothing),
+	BONOBO_UI_VERB_END
+};
+
+static void 
+add_control_to_ui (BonoboWindow *window, Bonobo_Control control)
+{
+	CORBA_Environment ev;
+	Bonobo_PropertyControl prop_control;
+	BonoboUIContainer *ui_container;
+    char *curdir;
+
+	g_return_if_fail (window != NULL);
+	g_return_if_fail (BONOBO_IS_WINDOW (window));
+	
+	CORBA_exception_init (&ev);
+
+	ui_container = bonobo_window_get_ui_container (BONOBO_WINDOW (window));
+	ctrl_frame = bonobo_control_frame_new (BONOBO_OBJREF (ui_container));
+
+	/* bind and view new control widget */
+	bonobo_control_frame_bind_to_control (ctrl_frame, control, &ev);
+	bonobo_control_frame_control_activate (ctrl_frame);
+	if (control != CORBA_OBJECT_NIL && ctrl_widget == NULL) {
+		ctrl_widget = bonobo_control_frame_get_widget (ctrl_frame);
+		if (!ctrl_widget)
+			g_assert_not_reached ();
+
+        bonobo_window_set_contents (BONOBO_WINDOW(window), GTK_WIDGET(ctrl_widget));
+		gtk_widget_show (ctrl_widget);
+	}
+
+	ui_comp = bonobo_ui_component_new ("vim-container");
+	bonobo_ui_component_set_container (ui_comp, BONOBO_OBJREF (ui_container), NULL);
+
+    curdir = (char *)getcwd(NULL, 0);
+	bonobo_ui_util_set_ui (ui_comp, curdir, "vim-container.xml", "Vim", NULL);
+    free( curdir );
+    bonobo_ui_component_add_verb_list_with_data (ui_comp, app_verbs, window);
+
+	/* update sensitivity of the properties menu item */
+	prop_control = Bonobo_Unknown_queryInterface (control, 
+						      "IDL:Bonobo/PropertyControl:1.0", &ev);
+	bonobo_ui_component_set_prop (ui_comp,
+				      "/commands/Preferences",
+				      "sensitive",
+				      prop_control == CORBA_OBJECT_NIL ? "0" : "1",
+				      &ev);
+	
+	bonobo_object_release_unref (prop_control, &ev);
+
+	/* enable view menu */
+	/* FIXME: We should check if the component adds anything to 
+	 *        the menu, so that we don't view an empty menu.
+	 */
+	/*bonobo_ui_component_set_prop (ui_comp, "/menu/View", "hidden", "0", &ev);*/
+
+	CORBA_exception_free (&ev);
+
+	/* retrieve control properties and install listeners */
+	//check_for_control_properties (window);
+}
+
+static void write_stream_to_file(Bonobo_Control control)
+{
+    Bonobo_Storage storage;
+    gchar * dirname;
+    gchar * basename;
+	CORBA_Environment ev;
+	Bonobo_PersistStream pstream;
+    Bonobo_Stream stream;
+
+    g_warning("write stream to file!");
+	CORBA_exception_init (&ev);
+
+    dirname = g_path_get_dirname(filename);
+    storage = bonobo_get_object(dirname, "IDL:Bonobo/Storage:1.0", &ev);
+    g_free(dirname);
+    if (BONOBO_EX (&ev) || (storage == CORBA_OBJECT_NIL))
+    {
+		CORBA_exception_free (&ev);
+        return;
+    }
+
+    pstream = Bonobo_Unknown_queryInterface (control, "IDL:Bonobo/PersistStream:1.0", &ev);
+    if (BONOBO_EX (&ev) || (pstream == CORBA_OBJECT_NIL))
+    {
+        bonobo_object_release_unref(storage, NULL);
+		CORBA_exception_free (&ev);
+        return;
+    }
+
+    basename = g_path_get_basename(filename);
+    stream = Bonobo_Storage_openStream(storage, basename, Bonobo_Storage_WRITE, &ev );
+    g_free(basename);
+    if (BONOBO_EX (&ev) || (stream == CORBA_OBJECT_NIL))
+    {
+        bonobo_object_release_unref(pstream, NULL);
+        bonobo_object_release_unref(storage, NULL);
+		CORBA_exception_free (&ev);
+        return;
+    }
+
+    Bonobo_PersistStream_save (pstream, stream, "text/plain", &ev);
+	if (ev._major != CORBA_NO_EXCEPTION) {
+        g_warning("Error saving stream!");
+		bonobo_object_unref (BONOBO_OBJECT (stream));
+        bonobo_object_release_unref(pstream, NULL);
+        bonobo_object_release_unref(storage, NULL);
+		CORBA_exception_free (&ev);
+		return;
+	}
+    bonobo_object_release_unref(stream, NULL);
+    bonobo_object_release_unref(pstream, NULL);
+    bonobo_object_release_unref(storage, NULL);
+    return;
+}
+
+static void
+window_destroyed (GtkWindow *window, char * data)
+{
+    Bonobo_Control control;
+
+    control = bonobo_control_frame_get_control(ctrl_frame);
+    write_stream_to_file(control);
+    bonobo_control_frame_control_deactivate(ctrl_frame);
+    bonobo_object_release_unref( control, NULL );
+    bonobo_main_quit();
+}
+
+int main(int argc, char * argv[] ) 
+{
+    BonoboWidget * bw;
+    BonoboWindow      *window;
+	BonoboUIEngine    *engine;
+	BonoboUIContainer *container;
+    Bonobo_Control    control;
+    gchar             *cwd;
+
+    if( argc <= 1 ) { 
+        fprintf(stderr, "%s: not enough args\n", argv[0] );
+        fprintf(stderr, "Usage: %s <text file>\n", argv[0]);
+        exit(1);
+    }
+    cwd = g_get_current_dir();
+    filename = g_build_filename( "file:", cwd, argv[1], NULL );
+    g_free(cwd);
+
+    bonobo_ui_init ("container", "1.0", &argc, argv);
+
+	if(gnome_vfs_init () == FALSE)
+		g_error (_("Could not initialize GnomeVFS!\n"));
+
+	window = BONOBO_WINDOW ( bonobo_window_new ("Window", "Vim Test Container"));
+
+    // instantiate a control
+    control = instantiate_control();
+    if( control == NULL )
+        return 1;
+    
+    // put it into our window
+    add_control_to_ui (window, control);
+
+    g_signal_connect (window, "destroy",
+          G_CALLBACK (window_destroyed),
+          &window);
+
+
+    gtk_widget_show_all( GTK_WIDGET( window ));
+
+    bonobo_main();
+
+    return 0;
+}
diff -Nur vim63/src/ex_cmds2.c vim63-bonobo/src/ex_cmds2.c
--- vim63/src/ex_cmds2.c	2005-09-09 20:11:09.884861000 +0200
+++ vim63-bonobo/src/ex_cmds2.c	2005-09-09 20:14:02.707588648 +0200
@@ -709,6 +709,12 @@
     int		forceit;
     int		allbuf;		/* may write all buffers */
 {
+#ifdef FEAT_GUI_COMPONENT
+    if ( buf->emb_buffer ) {
+	EMSG(_("E467: Cannot close embedded file"));
+        return TRUE;
+    }
+#endif
     if (       !forceit
 	    && bufIsChanged(buf)
 	    && (mult_win || buf->b_nwindows <= 1)
diff -Nur vim63/src/ex_docmd.c vim63-bonobo/src/ex_docmd.c
--- vim63/src/ex_docmd.c	2005-09-09 20:11:10.556759000 +0200
+++ vim63-bonobo/src/ex_docmd.c	2005-09-09 20:14:02.712587888 +0200
@@ -5729,8 +5729,13 @@
     }
     else
     {
+#ifdef FEAT_GUI_COMPONENT
+        EMSG(_(e_compnoquit));
+        not_exiting();
+        return;
+#endif
 #ifdef FEAT_WINDOWS
-	if (only_one_window())	    /* quit last window */
+        if (only_one_window()) 	    /* quit last window */
 #endif
 	    getout(0);
 #ifdef FEAT_WINDOWS
@@ -5751,8 +5756,12 @@
 ex_cquit(eap)
     exarg_T	*eap;
 {
+#ifdef FEAT_GUI_COMPONENT
+    EMSG(_(e_compnoquit));
+    return;
+#endif
     getout(1);	/* this does not always pass on the exit code to the Manx
-		   compiler. why? */
+                   compiler. why? */
 }
 
 /*
@@ -5772,6 +5781,10 @@
 	return;
     }
 # endif
+#ifdef FEAT_GUI_COMPONENT
+    EMSG(_(e_compnoquit));
+    return;
+#endif
     exiting = TRUE;
     if (eap->forceit || !check_changed_any(FALSE))
 	getout(0);
@@ -5966,8 +5979,13 @@
     }
     else
     {
+#ifdef FEAT_GUI_COMPONENT
+        EMSG(_(e_compnoquit));
+        not_exiting();
+        return;
+#endif
 #ifdef FEAT_WINDOWS
-	if (only_one_window())	    /* quit last window, exit Vim */
+        if ( only_one_window())	    /* quit last window, exit Vim */
 #endif
 	    getout(0);
 #ifdef FEAT_WINDOWS
diff -Nur vim63/src/fileio.c vim63-bonobo/src/fileio.c
--- vim63/src/fileio.c	2005-09-09 20:11:10.108827000 +0200
+++ vim63-bonobo/src/fileio.c	2005-09-09 20:18:45.327623872 +0200
@@ -41,6 +41,10 @@
 # define CRYPT_MAGIC_LEN	12		/* must be multiple of 4! */
 #endif
 
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME) 
+#include "vim_bonobo_control.h"
+#endif
+
 /* Is there any system that doesn't have access()? */
 #ifndef MACOS_CLASSIC /* Not available on MacOS 9 */
 # define USE_MCH_ACCESS
@@ -202,6 +206,7 @@
  * READ_BUFFER	read from curbuf instead of a file (converting after reading
  *		stdin)
  * READ_DUMMY	read into a dummy buffer (to check if file contents changed)
+ * READ_EMB_STREAM read from a bonobo persist stream
  *
  * return FAIL for failure, OK otherwise
  */
@@ -221,6 +226,11 @@
     int		filtering = (flags & READ_FILTER);
     int		read_stdin = (flags & READ_STDIN);
     int		read_buffer = (flags & READ_BUFFER);
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+    int		read_pstream = (flags & READ_EMB_STREAM);
+#else
+#define read_pstream 0
+#endif
     linenr_T	read_buf_lnum = 1;	/* next line to read from curbuf */
     colnr_T	read_buf_col = 0;	/* next char to read from this line */
     char_u	c;
@@ -327,7 +337,7 @@
      * The BufReadCmd and FileReadCmd events intercept the reading process by
      * executing the associated commands instead.
      */
-    if (!filtering && !read_stdin && !read_buffer)
+    if (!filtering && !read_stdin && !read_buffer && !read_pstream)
     {
 	pos_T	    pos;
 
@@ -392,7 +402,7 @@
      * On Unix it is possible to read a directory, so we have to
      * check for it before the mch_open().
      */
-    if (!read_stdin && !read_buffer)
+    if (!read_stdin && !read_buffer && !read_pstream)
     {
 	perm = mch_getperm(fname);
 	if (perm >= 0 && !S_ISREG(perm)		    /* not a regular file ... */
@@ -443,7 +453,7 @@
     if (check_readonly && !readonlymode)    /* default: set file not readonly */
 	curbuf->b_p_ro = FALSE;
 
-    if (newfile && !read_stdin && !read_buffer)
+    if (newfile && !read_stdin && !read_buffer && !read_pstream)
     {
 	/* Remember time of file.
 	 * For RISCOS, also remember the filetype.
@@ -509,6 +519,11 @@
 	setmode(0, O_BINARY);
 #endif
     }
+#ifdef FEAT_GUI_COMPONENT
+    else if (read_pstream)
+    {
+    }
+#endif
     else if (!read_buffer)
     {
 #ifdef USE_MCH_ACCESS
@@ -643,7 +658,7 @@
     /* If "Quit" selected at ATTENTION dialog, don't load the file */
     if (swap_exists_action == SEA_QUIT)
     {
-	if (!read_buffer && !read_stdin)
+	if (!read_buffer && !read_stdin && !read_pstream)
 	    close(fd);
 	return FAIL;
     }
@@ -668,7 +683,7 @@
 	 * The file must be closed again, the autocommands may want to change
 	 * the file before reading it.
 	 */
-	if (!read_stdin)
+	if (!read_stdin && !read_pstream)
 	    close(fd);		/* ignore errors */
 
 	/*
@@ -705,7 +720,7 @@
 	 * Don't allow the autocommands to change the current buffer.
 	 * Try to re-open the file.
 	 */
-	if (!read_stdin && (curbuf != old_curbuf
+	if (!read_stdin && !read_pstream && (curbuf != old_curbuf
 		|| (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) < 0))
 	{
 	    --no_wait_return;
@@ -745,7 +760,7 @@
 	    }
 #endif
 	}
-	else if (!read_buffer)
+	else if (!read_buffer && !read_pstream)
 	    filemess(curbuf, sfname, (char_u *)"", 0);
     }
 
@@ -850,7 +865,7 @@
 	    read_buf_lnum = 1;
 	    read_buf_col = 0;
 	}
-	else if (read_stdin || lseek(fd, (off_t)0L, SEEK_SET) != 0)
+	else if (read_stdin || read_pstream || lseek(fd, (off_t)0L, SEEK_SET) != 0)
 	{
 	    /* Can't rewind the file, give up. */
 	    error = TRUE;
@@ -996,7 +1011,7 @@
 	 * Use the 'charconvert' expression when conversion is required
 	 * and we can't do it internally or with iconv().
 	 */
-	if (fio_flags == 0 && !read_stdin && !read_buffer && *p_ccv != NUL
+	if (fio_flags == 0 && !read_stdin && !read_buffer && !read_pstream && *p_ccv != NUL
 #  ifdef USE_ICONV
 						    && iconv_fd == (iconv_t)-1
 #  endif
@@ -1045,7 +1060,7 @@
     /* Set can_retry when it's possible to rewind the file and try with
      * another "fenc" value.  It's FALSE when no other "fenc" to try, reading
      * stdin or "fenc" was specified with "++enc=". */
-    can_retry = (*fenc != NUL && !read_stdin
+    can_retry = (*fenc != NUL && !read_stdin && !read_pstream
 				     && (eap == NULL || eap->force_enc == 0));
 #endif
 
@@ -1214,6 +1229,11 @@
 			}
 		    }
 		}
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME) 
+                else if( read_pstream ) {
+                    size = vim_control_persist_stream_read(ptr, size);   
+                }
+#endif
 		else
 		{
 		    /*
@@ -1927,7 +1947,7 @@
 			    else if (ff_error != EOL_DOS)
 			    {
 				if (   try_unix
-				    && !read_stdin
+				    && !read_stdin && !read_pstream
 				    && (read_buffer
 					|| lseek(fd, (off_t)0L, SEEK_SET) == 0))
 				{
@@ -2016,7 +2036,7 @@
 # endif
 #endif
 
-    if (!read_buffer && !read_stdin)
+    if (!read_buffer && !read_stdin && !read_pstream)
 	close(fd);				/* errors are ignored */
     vim_free(buffer);
 
@@ -2205,7 +2225,7 @@
 #ifdef ALWAYS_USE_GUI
 	    /* Don't show the message when reading stdin, it would end up in a
 	     * message box (which might be shown when exiting!) */
-	    if (read_stdin || read_buffer)
+	    if (read_stdin || read_buffer )
 		p = msg_may_trunc(FALSE, IObuff);
 	    else
 #endif
@@ -2271,7 +2291,7 @@
      */
     write_no_eol_lnum = read_no_eol_lnum;
 
-    if (!read_stdin && !read_buffer)
+    if (!read_stdin && !read_buffer && !read_pstream)
     {
 	int m = msg_scroll;
 	int n = msg_scrolled;
@@ -2608,6 +2628,11 @@
     int		    prev_got_int = got_int;
     int		    file_readonly = FALSE;  /* overwritten file is read-only */
     static char	    *err_readonly = "is read-only (cannot override: \"W\" in 'cpoptions')";
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+    int		    write_pstream = write_to_container;
+#else
+#define write_pstream 0
+#endif
 #if defined(UNIX) || defined(__EMX__XX)	    /*XXX fix me sometime? */
     int		    made_writable = FALSE;  /* 'w' bit has been set */
 #endif
@@ -2984,7 +3009,7 @@
     }
 #endif /* !UNIX */
 
-    if (!device && !newfile)
+    if (!device && !newfile && !write_pstream )
     {
 	/*
 	 * Check if the file is really writable (when renaming the file to
@@ -3043,6 +3068,10 @@
     if (dobackup && *p_bsk != NUL && match_file_list(p_bsk, sfname, ffname))
 	dobackup = FALSE;
 #endif
+#ifdef FEAT_GUI_COMPONENT
+    if( write_pstream )
+        dobackup = FALSE;
+#endif
 
     /*
      * Save the value of got_int and reset it.  We don't want a previous
@@ -3695,95 +3724,97 @@
      * (this may happen when the user reached his quotum for number of files).
      * Appending will fail if the file does not exist and forceit is FALSE.
      */
-    while ((fd = mch_open((char *)wfname, O_WRONLY | O_EXTRA | (append
-			? (forceit ? (O_APPEND | O_CREAT) : O_APPEND)
-			: (O_CREAT | O_TRUNC))
-			, perm < 0 ? 0666 : (perm & 0777))) < 0)
-    {
-	/*
-	 * A forced write will try to create a new file if the old one is
-	 * still readonly. This may also happen when the directory is
-	 * read-only. In that case the mch_remove() will fail.
-	 */
-	if (errmsg == NULL)
+    if (!write_pstream) {
+	while ((fd = mch_open((char *)wfname, O_WRONLY | O_EXTRA | (append
+			    ? (forceit ? (O_APPEND | O_CREAT) : O_APPEND)
+			    : (O_CREAT | O_TRUNC))
+			    , perm < 0 ? 0666 : (perm & 0777))) < 0)
 	{
+	    /*
+	     * A forced write will try to create a new file if the old one is
+	     * still readonly. This may also happen when the directory is
+	     * read-only. In that case the mch_remove() will fail.
+	     */
+	    if (errmsg == NULL)
+	    {
 #ifdef UNIX
-	    struct stat	st;
+		struct stat	st;
 
-	    /* Don't delete the file when it's a hard or symbolic link. */
-	    if ((!newfile && st_old.st_nlink > 1)
-		    || (mch_lstat((char *)fname, &st) == 0
-			&& (st.st_dev != st_old.st_dev
-			    || st.st_ino != st_old.st_ino)))
-		errmsg = (char_u *)_("E166: Can't open linked file for writing");
-	    else
+		/* Don't delete the file when it's a hard or symbolic link. */
+		if ((!newfile && st_old.st_nlink > 1)
+			|| (mch_lstat((char *)fname, &st) == 0
+			    && (st.st_dev != st_old.st_dev
+				|| st.st_ino != st_old.st_ino)))
+		    errmsg = (char_u *)_("E166: Can't open linked file for writing");
+		else
 #endif
-	    {
-		errmsg = (char_u *)_("E212: Can't open file for writing");
-		if (forceit && vim_strchr(p_cpo, CPO_FWRITE) == NULL
-								 && perm >= 0)
 		{
+		    errmsg = (char_u *)_("E212: Can't open file for writing");
+		    if (forceit && vim_strchr(p_cpo, CPO_FWRITE) == NULL
+								     && perm >= 0)
+		    {
 #ifdef UNIX
-		    /* we write to the file, thus it should be marked
-		       writable after all */
-		    if (!(perm & 0200))
-			made_writable = TRUE;
-		    perm |= 0200;
-		    if (st_old.st_uid != getuid() || st_old.st_gid != getgid())
-			perm &= 0777;
+			/* we write to the file, thus it should be marked
+			   writable after all */
+			if (!(perm & 0200))
+			    made_writable = TRUE;
+			perm |= 0200;
+			if (st_old.st_uid != getuid() || st_old.st_gid != getgid())
+			    perm &= 0777;
 #endif
-		    if (!append)	    /* don't remove when appending */
-			mch_remove(wfname);
-		    continue;
+			if (!append)	    /* don't remove when appending */
+			    mch_remove(wfname);
+			continue;
+		    }
 		}
 	    }
-	}
-
-restore_backup:
-	{
-	    struct stat st;
 
-	    /*
-	     * If we failed to open the file, we don't need a backup. Throw it
-	     * away.  If we moved or removed the original file try to put the
-	     * backup in its place.
-	     */
-	    if (backup != NULL && wfname == fname)
+    restore_backup:
 	    {
-		if (backup_copy)
+		struct stat st;
+
+		/*
+		 * If we failed to open the file, we don't need a backup. Throw it
+		 * away.  If we moved or removed the original file try to put the
+		 * backup in its place.
+		 */
+		if (backup != NULL && wfname == fname)
 		{
-		    /*
-		     * There is a small chance that we removed the original,
-		     * try to move the copy in its place.
-		     * This may not work if the vim_rename() fails.
-		     * In that case we leave the copy around.
-		     */
-		    /* If file does not exist, put the copy in its place */
-		    if (mch_stat((char *)fname, &st) < 0)
+		    if (backup_copy)
+		    {
+			/*
+			 * There is a small chance that we removed the original,
+			 * try to move the copy in its place.
+			 * This may not work if the vim_rename() fails.
+			 * In that case we leave the copy around.
+			 */
+			/* If file does not exist, put the copy in its place */
+			if (mch_stat((char *)fname, &st) < 0)
+			    vim_rename(backup, fname);
+			/* if original file does exist throw away the copy */
+			if (mch_stat((char *)fname, &st) >= 0)
+			    mch_remove(backup);
+		    }
+		    else
+		    {
+			/* try to put the original file back */
 			vim_rename(backup, fname);
-		    /* if original file does exist throw away the copy */
-		    if (mch_stat((char *)fname, &st) >= 0)
-			mch_remove(backup);
-		}
-		else
-		{
-		    /* try to put the original file back */
-		    vim_rename(backup, fname);
+		    }
 		}
-	    }
 
-	    /* if original file no longer exists give an extra warning */
-	    if (!newfile && mch_stat((char *)fname, &st) < 0)
-		end = 0;
-	}
+		/* if original file no longer exists give an extra warning */
+		if (!newfile && mch_stat((char *)fname, &st) < 0)
+		    end = 0;
+	    }
 
 #ifdef FEAT_MBYTE
-	if (wfname != fname)
-	    vim_free(wfname);
+	    if (wfname != fname)
+		vim_free(wfname);
 #endif
-	goto fail;
+	    goto fail;
+	}
+	errmsg = NULL;
     }
-    errmsg = NULL;
 
 #if defined(MACOS_CLASSIC) || defined(WIN3264)
     /* TODO: Is it need for MACOS_X? (Dany) */
@@ -3999,7 +4030,7 @@
     }
 #endif
 
-    if (close(fd) != 0)
+    if (!write_pstream && close(fd) != 0)
     {
 	errmsg = (char_u *)_("E512: Close failed");
 	end = 0;
@@ -4415,6 +4446,10 @@
     buf_T	*buf;
     char_u	*fname;
 {
+#ifdef FEAT_GUI_COMPONENT
+    if (buf->emb_buffer)
+        fname = (char_u *)"[Embedded File]";
+#endif
     if (fname == NULL)
 	fname = (char_u *)"-stdin-";
     home_replace(buf, fname, IObuff + 1, IOSIZE - 4, TRUE);
@@ -4939,7 +4974,12 @@
     /* Repeat the write(), it may be interrupted by a signal. */
     while (len)
     {
-	wlen = vim_write(ip->bw_fd, buf, len);
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+        if( write_to_container )
+            wlen = vim_control_persist_stream_write(buf, len);
+        else
+#endif
+            wlen = vim_write(ip->bw_fd, buf, len);
 	if (wlen <= 0)		    /* error! */
 	    return FAIL;
 	len -= wlen;
@@ -6672,6 +6712,7 @@
     {"BufWriteCmd",	EVENT_BUFWRITECMD},
     {"CmdwinEnter",	EVENT_CMDWINENTER},
     {"CmdwinLeave",	EVENT_CMDWINLEAVE},
+    {"EmbeddingOn",	EVENT_EMBEDDED_COMPONENT},
     {"EncodingChanged",	EVENT_ENCODINGCHANGED},
     {"FileEncoding",	EVENT_ENCODINGCHANGED},
     {"CursorHold",	EVENT_CURSORHOLD},
diff -Nur vim63/src/globals.h vim63-bonobo/src/globals.h
--- vim63/src/globals.h	2005-09-09 20:11:10.559759000 +0200
+++ vim63-bonobo/src/globals.h	2005-09-09 20:14:02.721586520 +0200
@@ -837,6 +837,12 @@
 EXTERN int	readonlymode INIT(= FALSE); /* Set to TRUE for "view" */
 EXTERN int	recoverymode INIT(= FALSE); /* Set to TRUE for "-r" option */
 
+#ifdef FEAT_GUI_COMPONENT
+EXTERN int      read_from_container INIT(= 0); /* read the buffer from the container app */
+EXTERN int      write_to_container INIT(= 0); /* write the buffer to the container app */
+EXTERN buf_T    *persistent_buffer INIT(= NULL); /* the buffer which the container is interested in */
+#endif
+
 EXTERN struct buffheader stuffbuff	/* stuff buffer */
 #ifdef DO_INIT
 		    = {{NULL, {NUL}}, NULL, 0, 0}
@@ -1363,6 +1369,9 @@
 #ifdef FEAT_NETBEANS_INTG
 EXTERN char_u e_guarded[]	INIT(=N_("E463: Region is guarded, cannot modify"));
 #endif
+#ifdef FEAT_GUI_COMPONENT
+EXTERN char_u e_compnoquit[]	INIT(=N_("E464: Quit not allowed from embedded component"));
+#endif
 #ifdef MACOS_X_UNIX
 EXTERN short disallow_gui	INIT(= FALSE);
 #endif
diff -Nur vim63/src/gtkhtml_editor.c vim63-bonobo/src/gtkhtml_editor.c
--- vim63/src/gtkhtml_editor.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml_editor.c	2005-09-09 20:14:02.726585760 +0200
@@ -0,0 +1,385 @@
+#include "vim.h"
+
+#include <bonobo.h>
+#include "gtkhtml_editor.h"
+
+static BonoboObjectClass *engine_parent_class;
+
+inline static EditorEngine *
+gtkhtml_editor_engine_from_servant (PortableServer_Servant servant)
+{
+	return EDITOR_ENGINE (bonobo_object_from_servant (servant));
+}
+
+static CORBA_char *
+impl_get_paragraph_data (PortableServer_Servant servant, const CORBA_char * key, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+}
+
+static void
+impl_set_paragraph_data (PortableServer_Servant servant,
+			 const CORBA_char * key, const CORBA_char * value,
+			 CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+}
+
+static void
+impl_set_object_data_by_type (PortableServer_Servant servant,
+			 const CORBA_char * type_name, const CORBA_char * key, const CORBA_char * value,
+			 CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+}
+
+static void
+impl_set_listener (PortableServer_Servant servant, const GNOME_GtkHTML_Editor_Listener value, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+
+	bonobo_object_release_unref (e->listener, NULL);
+	e->listener        = bonobo_object_dup_ref (value, NULL);
+}
+
+static GNOME_GtkHTML_Editor_Listener
+impl_get_listener (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+	return gtkhtml_editor_engine_from_servant (servant)->listener;
+}
+
+
+
+static CORBA_boolean
+impl_run_command (PortableServer_Servant servant, const CORBA_char * command, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+	printf ("command: %s\n", command);
+    CORBA_boolean retval = CORBA_TRUE;
+    int save_p_report = p_report;
+
+    p_report = 1000;
+
+    aco_save_T	aco;
+    aucmd_prepbuf(&aco, persistent_buffer);
+
+    if( strcmp( command, "cursor-position-save" ) == 0 ) {
+        do_cmdline_cmd("normal mz");
+    } else if( strcmp( command, "cursor-position-restore" ) == 0 ) {
+        do_cmdline_cmd("normal 'z");
+        update_screen(CLEAR);
+        gui_update_cursor(TRUE, FALSE);
+    } else if( strcmp( command, "cursor-bod" ) == 0 ) {
+        do_cmdline_cmd("normal G");
+    } else if( strcmp( command, "select-paragraph" ) == 0 ) {
+        do_cmdline_cmd("normal V}");
+    } else if( strcmp( command, "delete" ) == 0 ) {
+        do_cmdline_cmd("normal d");
+    } else if( strcmp( command, "is-saved" ) == 0 ) {
+        retval = !persistent_buffer->b_changed;
+    } else if( strcmp( command, "insert-paragraph" ) == 0 ) {
+        do_cmdline_cmd("normal o");
+    }
+    aucmd_restbuf(&aco);
+    p_report = save_p_report;
+	return retval;
+}
+
+static CORBA_boolean
+impl_is_paragraph_empty (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+	return CORBA_FALSE;
+}
+
+static CORBA_boolean
+impl_is_previous_paragraph_empty (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+	return CORBA_FALSE;
+}
+
+struct keyvalue {
+    char * key;
+    char * value;
+    char mark;
+};
+
+static GSList * keylist = NULL;
+static char free_mark = 'y';
+
+static void set_mark_at_cursor( char * key, char * value ) 
+{
+    char cmd[5];
+    struct keyvalue * kv = NULL;
+    GSList * node = keylist;
+    while( node != NULL ) {
+        kv = node->data; 
+        if( strcmp( kv->key, key ) == 0 && strcmp( kv->value, value ) == 0 ) {
+            break;
+        }
+        node = node->next;
+    }
+    if( kv == NULL ) {
+        kv = g_new0( struct keyvalue, 1 );
+        kv->key = g_strdup( key );
+        kv->value = g_strdup( value );
+
+        kv->mark = free_mark;
+        free_mark -= 1;
+        keylist = g_slist_prepend( keylist, kv );
+    }
+
+    setmark(kv->mark);
+}
+
+static void
+impl_insert_html (PortableServer_Servant servant, const CORBA_char * html, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+    const char * c;
+    const char * s;
+    char * d;
+    int level = 0;
+    gboolean in_data = 0;
+    char key[50];
+    char value[50];
+    char cmd[50];
+    gchar **lines;
+    int curline;
+    int begin;
+    int i;
+
+	g_warning("insert html: \"%s\"", html ); 
+    
+    aco_save_T	aco;
+    aucmd_prepbuf(&aco, persistent_buffer);
+
+    // This gets a bit ugly...
+    // Look for DATA tags with KEY and VALUE attributes.  We set a mark
+    // in vim on the first line of the inserted HTML if one of these tags is present
+    // (we assume that they occur at the beginning of the inserted paragraph).
+    // we also assume that only one of these sequences will occur in the html.
+    strcpy( key, "" );
+    strcpy( value, "" );
+    for( c = html; *c != '\0'; c++ ) {
+        if( *c == '<' ) {
+            level += 1;
+            if( strncmp( c, "<DATA", 5 ) == 0 ) {
+                in_data = TRUE;
+            }
+        } else if( *c == '>' ) {
+            level -= 1;
+            if( in_data ) {
+                if( *key && *value ) {
+                    g_warning( "got key=%s and value=%s", key, value );
+                }
+                in_data = FALSE;
+            }
+        } else if( in_data && strncmp( c, "key=", 4 ) == 0 ) {
+            // extract the key
+            d = key;
+            for( s = &c[4]; *s != '\"'; s++ );
+            s++;
+            for( ; *s != '\"'; s++ ) {
+                *d++ = *s; 
+            }
+            *d = '\0';
+        } else if( in_data && strncmp( c, "value=", 6 ) == 0 ) {
+            // extract the value
+            d = value;
+            for( s = &c[4]; *s != '\"'; s++ );
+            s++;
+            for( ; *s != '\"'; s++ ) {
+                *d++ = *s; 
+            }
+            *d = '\0';
+        }
+    }
+
+    /* insert the html into the buffer, remembering the starting line */
+    begin = curwin->w_cursor.lnum;
+    curline = begin;
+    lines = g_strsplit(html, "\n", 0);
+    for(i = 0; lines[i]; i += 1) {
+        ml_append(curline, lines[i], strlen(html) + 1, FALSE); 
+        appended_lines_mark(curwin->w_cursor.lnum, 1);
+        curline += 1;
+    }
+    g_strfreev(lines);
+
+    /* run a filter to obtain plain text from the html */
+    vim_bonobo_call_begin();
+    g_snprintf( cmd, 50, "%d,%d!html2text -nobs", begin, curline);
+    do_cmdline_cmd(cmd);
+    vim_bonobo_call_end();
+    if( *key && *value ) {
+        set_mark_at_cursor( key, value );
+    }
+    aucmd_restbuf(&aco);
+}
+
+static CORBA_boolean
+impl_search_by_data (PortableServer_Servant servant, const CORBA_long level, const CORBA_char * klass,
+		     const CORBA_char * key, const CORBA_char * value, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+
+    GSList * node = keylist;
+    struct keyvalue * kv = NULL;
+    char cmd[15];
+    char * data;
+    aco_save_T	aco;
+    int retval = FALSE;
+
+    aucmd_prepbuf(&aco, persistent_buffer);
+
+	g_warning("search by data: key=\"%s\" value=\"%s\"", key, value ); 
+    while( node != NULL ) {
+        kv = node->data; 
+        if( strcmp( kv->key, key ) == 0 && strcmp( kv->value, value ) == 0 ) {
+            break;
+        }
+        node = node->next;
+    }
+    if( kv != NULL ) {
+        pos_T *pos;
+
+        pos = getmark(kv->mark, FALSE);
+        if( pos->lnum != 0 ) {
+            /* jump to the mark in the text */
+            g_snprintf( cmd, 15, "normal '%c", kv->mark );
+            do_cmdline_cmd( cmd );
+            g_warning( "Found key!" );
+            retval = TRUE;
+        } else {
+            g_warning( "Key not found" );
+            // mark not found.  Delete it from our list.
+            g_free( kv->key );
+            g_free( kv->value );
+            g_free( kv );
+            keylist = g_slist_remove( keylist, kv );
+        }
+    }
+    aucmd_restbuf(&aco);
+	return retval;
+}
+
+static void
+impl_freeze (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+}
+
+static void
+impl_thaw (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+}
+
+static void
+impl_undo_begin (PortableServer_Servant servant, const CORBA_char * undo_name, const CORBA_char * redo_name,
+		 CORBA_Environment * ev)
+{
+}
+
+static void
+impl_undo_end (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+}
+
+static void
+impl_ignore_word (PortableServer_Servant servant, const CORBA_char * word, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+}
+
+/* Return whether we have any undos. */
+static CORBA_boolean
+impl_has_undo (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+    u_header_T *curhead;
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+
+    if( !persistent_buffer) {
+        return CORBA_FALSE;
+    }
+    /* this logic comes from undo.c */
+    curhead = persistent_buffer->b_u_curhead;
+    if (persistent_buffer->b_u_curhead == NULL) {		/* first undo */
+		curhead = persistent_buffer->b_u_newhead;
+    } else if (p_ul > 0) {			/* multi level undo */ 
+		curhead = persistent_buffer->b_u_curhead->uh_next;
+    }
+    if (curbuf->b_u_numhead == 0 || curhead == NULL) {
+        return CORBA_FALSE;
+    }
+    return CORBA_TRUE;
+}
+
+static void
+impl_drop_undo (PortableServer_Servant servant, CORBA_Environment * ev)
+{
+	EditorEngine *e = gtkhtml_editor_engine_from_servant (servant);
+	printf ("dropUndo\n");
+}
+
+static void
+engine_object_finalize (GObject *object)
+{
+	EditorEngine *e = EDITOR_ENGINE (object);
+
+	bonobo_object_release_unref (e->listener, NULL);
+
+	G_OBJECT_CLASS (engine_parent_class)->finalize (object);
+}
+
+static void
+editor_engine_init (GObject *object)
+{
+	EditorEngine *e = EDITOR_ENGINE (object);
+
+	e->listener = CORBA_OBJECT_NIL;
+}
+
+static void
+editor_engine_class_init (EditorEngineClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	POA_GNOME_GtkHTML_Editor_Engine__epv *epv = &klass->epv;
+
+	engine_parent_class = g_type_class_peek_parent (klass);
+	object_class->finalize = engine_object_finalize;
+
+	epv->_set_listener            = impl_set_listener;
+	epv->_get_listener            = impl_get_listener;
+	epv->setParagraphData         = impl_set_paragraph_data;
+	epv->getParagraphData         = impl_get_paragraph_data;
+	epv->setObjectDataByType      = impl_set_object_data_by_type;
+	epv->runCommand               = impl_run_command;
+	epv->isParagraphEmpty         = impl_is_paragraph_empty;
+	epv->isPreviousParagraphEmpty = impl_is_previous_paragraph_empty;
+	epv->searchByData             = impl_search_by_data;
+	epv->insertHTML               = impl_insert_html;
+	epv->freeze                   = impl_freeze;
+	epv->thaw                     = impl_thaw;
+	epv->undoBegin                = impl_undo_begin;
+	epv->undoEnd                  = impl_undo_end;
+	epv->ignoreWord               = impl_ignore_word;
+	epv->hasUndo                  = impl_has_undo;
+	epv->dropUndo                 = impl_drop_undo;
+}
+
+BONOBO_TYPE_FUNC_FULL (
+	EditorEngine,                  /* Glib class name */
+	GNOME_GtkHTML_Editor_Engine,   /* CORBA interface name */
+	BONOBO_TYPE_OBJECT,            /* parent type */
+	editor_engine);                /* local prefix ie. 'echo'_class_init */
+
+EditorEngine *
+editor_engine_new (void)
+{
+	EditorEngine *ee;
+
+	ee = g_object_new (EDITOR_ENGINE_TYPE, NULL);
+
+	return ee;
+}
diff -Nur vim63/src/gtkhtml_editor_common.c vim63-bonobo/src/gtkhtml_editor_common.c
--- vim63/src/gtkhtml_editor_common.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml_editor_common.c	2005-09-09 20:14:02.727585608 +0200
@@ -0,0 +1,306 @@
+/*
+ * This file was generated by orbit-idl-2 - DO NOT EDIT!
+ */
+
+#include <string.h>
+#define ORBIT2_STUBS_API
+#define ORBIT_IDL_C_COMMON
+#define Editor_COMMON
+#include "gtkhtml.h"
+
+static const CORBA_unsigned_long ORBit_zero_int = 0;
+
+#if ( (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_0 == 'E') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_1 == 'd') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_2 == 'i') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_3 == 't') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_4 == 'o') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_5 == 'r') \
+) && !defined(TC_DEF_TC_GNOME_GtkHTML_Editor_Listener)
+#define TC_DEF_TC_GNOME_GtkHTML_Editor_Listener 1
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+const struct CORBA_TypeCode_struct TC_GNOME_GtkHTML_Editor_Listener_struct = {
+   {&ORBit_TypeCode_epv, ORBIT_REFCOUNT_STATIC},
+   CORBA_tk_objref,
+   0,
+   0,
+   ORBIT_ALIGNOF_CORBA_POINTER,
+   0,
+   0,
+   NULL,
+   CORBA_OBJECT_NIL,
+   "Listener",
+   "IDL:GNOME/GtkHTML/Editor/Listener:1.0",
+   NULL,
+   NULL,
+   -1,
+   0,
+   0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_0 == 'E') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_1 == 'd') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_2 == 'i') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_3 == 't') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_4 == 'o') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_5 == 'r') \
+) && !defined(TC_DEF_TC_GNOME_GtkHTML_Editor_Engine)
+#define TC_DEF_TC_GNOME_GtkHTML_Editor_Engine 1
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+const struct CORBA_TypeCode_struct TC_GNOME_GtkHTML_Editor_Engine_struct = {
+   {&ORBit_TypeCode_epv, ORBIT_REFCOUNT_STATIC},
+   CORBA_tk_objref,
+   0,
+   0,
+   ORBIT_ALIGNOF_CORBA_POINTER,
+   0,
+   0,
+   NULL,
+   CORBA_OBJECT_NIL,
+   "Engine",
+   "IDL:GNOME/GtkHTML/Editor/Engine:1.0",
+   NULL,
+   NULL,
+   -1,
+   0,
+   0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_0 == 'E') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_1 == 'd') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_2 == 'i') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_3 == 't') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_4 == 'o') \
+&& (TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_5 == 'r') \
+) && !defined(TC_DEF_TC_GNOME_GtkHTML_Editor_URLRequestEvent)
+#define TC_DEF_TC_GNOME_GtkHTML_Editor_URLRequestEvent 1
+static const char *anon_subnames_array6[] = { "url", "stream" };
+static const CORBA_TypeCode anon_subtypes_array7[] =
+   { (CORBA_TypeCode) & TC_CORBA_string_struct,
+      (CORBA_TypeCode) & TC_Bonobo_Stream_struct };
+
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+const struct CORBA_TypeCode_struct
+   TC_GNOME_GtkHTML_Editor_URLRequestEvent_struct = {
+   {&ORBit_TypeCode_epv, ORBIT_REFCOUNT_STATIC},
+   CORBA_tk_struct,
+   0,
+   0,
+   ORBIT_ALIGNOF_CORBA_POINTER,
+   0,
+   2,
+   (CORBA_TypeCode *) anon_subtypes_array7,
+   CORBA_OBJECT_NIL,
+   "URLRequestEvent",
+   "IDL:GNOME/GtkHTML/Editor/URLRequestEvent:1.0",
+   (char **) anon_subnames_array6,
+   NULL,
+   -1,
+   0,
+   0, 0
+};
+#endif
+
+#ifndef ORBIT_IDL_C_IMODULE_Editor
+CORBA_unsigned_long GNOME_GtkHTML_Editor_Listener__classid = 0;
+#endif
+
+#ifndef ORBIT_IDL_C_IMODULE_Editor
+CORBA_unsigned_long GNOME_GtkHTML_Editor_Engine__classid = 0;
+#endif
+
+/* Interface type data */
+
+static ORBit_IArg GNOME_GtkHTML_Editor_Listener_event__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "name"},
+   {TC_CORBA_any, ORBit_I_ARG_IN, "arg"}
+};
+
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+ORBit_IMethod GNOME_GtkHTML_Editor_Listener__imethods[] = {
+   {
+    {2, 2, GNOME_GtkHTML_Editor_Listener_event__arginfo, FALSE},
+    {0, 0, NULL, FALSE},
+    {0, 0, NULL, FALSE},
+    TC_CORBA_any, "event", 5,
+    0}
+};
+static CORBA_string GNOME_GtkHTML_Editor_Listener__base_itypes[] = {
+   "IDL:Bonobo/Unknown:1.0",
+   "IDL:omg.org/CORBA/Object:1.0"
+};
+
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+ORBit_IInterface GNOME_GtkHTML_Editor_Listener__iinterface = {
+   TC_GNOME_GtkHTML_Editor_Listener, {1, 1,
+				      GNOME_GtkHTML_Editor_Listener__imethods,
+				      FALSE},
+   {2, 2, GNOME_GtkHTML_Editor_Listener__base_itypes, FALSE}
+};
+
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine__set_listener__arginfo[] = {
+   {TC_GNOME_GtkHTML_Editor_Listener, ORBit_I_ARG_IN, "value"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_runCommand__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "command"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_getParagraphData__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "key"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_setParagraphData__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "key"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "value"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_setObjectDataByType__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "type_name"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "key"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "data"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_searchByData__arginfo[] = {
+   {TC_CORBA_long, ORBit_I_ARG_IN | ORBit_I_COMMON_FIXED_SIZE, "level"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "klass"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "key"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "value"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_insertHTML__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "html"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_undoBegin__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "undo_name"},
+   {TC_CORBA_string, ORBit_I_ARG_IN, "redo_name"}
+};
+static ORBit_IArg GNOME_GtkHTML_Editor_Engine_ignoreWord__arginfo[] = {
+   {TC_CORBA_string, ORBit_I_ARG_IN, "word"}
+};
+
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+ORBit_IMethod GNOME_GtkHTML_Editor_Engine__imethods[] = {
+   {
+    {0, 0, NULL, FALSE},
+    {0, 0, NULL, FALSE},
+    {0, 0, NULL, FALSE},
+    TC_GNOME_GtkHTML_Editor_Listener, "_get_listener", 13,
+    0}
+   , {
+      {1, 1, GNOME_GtkHTML_Editor_Engine__set_listener__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "_set_listener", 13,
+      0}
+   , {
+      {1, 1, GNOME_GtkHTML_Editor_Engine_runCommand__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_boolean, "runCommand", 10,
+      0 | ORBit_I_COMMON_FIXED_SIZE}
+   , {
+      {1, 1, GNOME_GtkHTML_Editor_Engine_getParagraphData__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_string, "getParagraphData", 16,
+      0}
+   , {
+      {2, 2, GNOME_GtkHTML_Editor_Engine_setParagraphData__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "setParagraphData", 16,
+      0}
+   , {
+      {3, 3, GNOME_GtkHTML_Editor_Engine_setObjectDataByType__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "setObjectDataByType", 19,
+      0}
+   , {
+      {4, 4, GNOME_GtkHTML_Editor_Engine_searchByData__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_boolean, "searchByData", 12,
+      0 | ORBit_I_COMMON_FIXED_SIZE}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_boolean, "isParagraphEmpty", 16,
+      0 | ORBit_I_COMMON_FIXED_SIZE}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_boolean, "isPreviousParagraphEmpty", 24,
+      0 | ORBit_I_COMMON_FIXED_SIZE}
+   , {
+      {1, 1, GNOME_GtkHTML_Editor_Engine_insertHTML__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "insertHTML", 10,
+      0}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "freeze", 6,
+      0}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "thaw", 4,
+      0}
+   , {
+      {2, 2, GNOME_GtkHTML_Editor_Engine_undoBegin__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "undoBegin", 9,
+      0}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "undoEnd", 7,
+      0}
+   , {
+      {1, 1, GNOME_GtkHTML_Editor_Engine_ignoreWord__arginfo, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "ignoreWord", 10,
+      0}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_void, "dropUndo", 8,
+      0}
+   , {
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      {0, 0, NULL, FALSE},
+      TC_CORBA_boolean, "hasUndo", 7,
+      0 | ORBit_I_COMMON_FIXED_SIZE}
+};
+static CORBA_string GNOME_GtkHTML_Editor_Engine__base_itypes[] = {
+   "IDL:Bonobo/Unknown:1.0",
+   "IDL:omg.org/CORBA/Object:1.0"
+};
+
+#ifdef ORBIT_IDL_C_IMODULE_Editor
+static
+#endif
+ORBit_IInterface GNOME_GtkHTML_Editor_Engine__iinterface = {
+   TC_GNOME_GtkHTML_Editor_Engine, {17, 17,
+				    GNOME_GtkHTML_Editor_Engine__imethods,
+				    FALSE},
+   {2, 2, GNOME_GtkHTML_Editor_Engine__base_itypes, FALSE}
+};
diff -Nur vim63/src/gtkhtml_editor.h vim63-bonobo/src/gtkhtml_editor.h
--- vim63/src/gtkhtml_editor.h	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml_editor.h	2005-09-09 20:14:02.727585608 +0200
@@ -0,0 +1,34 @@
+#ifndef GTKHTML_ENGINE_H_
+#define GTKHTML_ENGINE_H_
+
+G_BEGIN_DECLS
+
+typedef struct _EditorEngine EditorEngine;
+
+#include <gtk/gtktypeutils.h>
+#include <bonobo/bonobo-object.h>
+#include "gtkhtml.h"
+
+#define EDITOR_ENGINE_TYPE        (editor_engine_get_type ())
+#define EDITOR_ENGINE(o)          (GTK_CHECK_CAST ((o), EDITOR_ENGINE_TYPE, EditorEngine))
+#define EDITOR_ENGINE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), EDITOR_ENGINE_TYPE, EditorEngineClass))
+#define IS_EDITOR_ENGINE(o)       (GTK_CHECK_TYPE ((o), EDITOR_ENGINE_TYPE))
+#define IS_EDITOR_ENGINE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), EDITOR_ENGINE_TYPE))
+
+struct _EditorEngine {
+	BonoboObject parent;
+	GNOME_GtkHTML_Editor_Listener listener;
+};
+
+typedef struct {
+	BonoboObjectClass parent_class;
+	POA_GNOME_GtkHTML_Editor_Engine__epv epv;
+} EditorEngineClass;
+
+GtkType                               editor_engine_get_type   (void);
+EditorEngine                         *editor_engine_new        (void);
+POA_GNOME_GtkHTML_Editor_Engine__epv *editor_engine_get_epv    (void);
+
+G_END_DECLS
+
+#endif /* GTKHTML_ENGINE_H_ */
diff -Nur vim63/src/gtkhtml_editor_skels.c vim63-bonobo/src/gtkhtml_editor_skels.c
--- vim63/src/gtkhtml_editor_skels.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml_editor_skels.c	2005-09-09 20:14:02.728585456 +0200
@@ -0,0 +1,658 @@
+/*
+ * This file was generated by orbit-idl-2 - DO NOT EDIT!
+ */
+
+#include <string.h>
+#define ORBIT2_STUBS_API
+#include "gtkhtml.h"
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Listener_event
+   (POA_GNOME_GtkHTML_Editor_Listener * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_any * (*_impl_event) (PortableServer_Servant _servant,
+				const CORBA_char * name,
+				const CORBA_any * arg,
+				CORBA_Environment * ev))
+{
+   *(CORBA_any * *)_o_retval =
+      _impl_event(_o_servant, *(const CORBA_char * *) _o_args[0],
+		  (const CORBA_any *) _o_args[1], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__get_listener
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    GNOME_GtkHTML_Editor_Listener(*_impl__get_listener)
+    (PortableServer_Servant _servant, CORBA_Environment * ev))
+{
+   *(GNOME_GtkHTML_Editor_Listener *) _o_retval =
+      _impl__get_listener(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__set_listener
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl__set_listener) (PortableServer_Servant _servant,
+				 const GNOME_GtkHTML_Editor_Listener value,
+				 CORBA_Environment * ev))
+{
+   _impl__set_listener(_o_servant,
+		       *(const GNOME_GtkHTML_Editor_Listener *) _o_args[0],
+		       _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_runCommand
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_boolean(*_impl_runCommand) (PortableServer_Servant _servant,
+				      const CORBA_char * command,
+				      CORBA_Environment * ev))
+{
+   *(CORBA_boolean *) _o_retval =
+      _impl_runCommand(_o_servant, *(const CORBA_char * *) _o_args[0], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_getParagraphData
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_string(*_impl_getParagraphData) (PortableServer_Servant _servant,
+					   const CORBA_char * key,
+					   CORBA_Environment * ev))
+{
+   *(CORBA_string *) _o_retval =
+      _impl_getParagraphData(_o_servant, *(const CORBA_char * *) _o_args[0],
+			     _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setParagraphData
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_setParagraphData) (PortableServer_Servant _servant,
+				    const CORBA_char * key,
+				    const CORBA_char * value,
+				    CORBA_Environment * ev))
+{
+   _impl_setParagraphData(_o_servant, *(const CORBA_char * *) _o_args[0],
+			  *(const CORBA_char * *) _o_args[1], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setObjectDataByType
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_setObjectDataByType) (PortableServer_Servant _servant,
+				       const CORBA_char * type_name,
+				       const CORBA_char * key,
+				       const CORBA_char * data,
+				       CORBA_Environment * ev))
+{
+   _impl_setObjectDataByType(_o_servant, *(const CORBA_char * *) _o_args[0],
+			     *(const CORBA_char * *) _o_args[1],
+			     *(const CORBA_char * *) _o_args[2], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_searchByData
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_boolean(*_impl_searchByData) (PortableServer_Servant _servant,
+					const CORBA_long level,
+					const CORBA_char * klass,
+					const CORBA_char * key,
+					const CORBA_char * value,
+					CORBA_Environment * ev))
+{
+   *(CORBA_boolean *) _o_retval =
+      _impl_searchByData(_o_servant, *(const CORBA_long *) _o_args[0],
+			 *(const CORBA_char * *) _o_args[1],
+			 *(const CORBA_char * *) _o_args[2],
+			 *(const CORBA_char * *) _o_args[3], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isParagraphEmpty
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_boolean(*_impl_isParagraphEmpty) (PortableServer_Servant _servant,
+					    CORBA_Environment * ev))
+{
+   *(CORBA_boolean *) _o_retval = _impl_isParagraphEmpty(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_boolean(*_impl_isPreviousParagraphEmpty) (PortableServer_Servant
+						    _servant,
+						    CORBA_Environment * ev))
+{
+   *(CORBA_boolean *) _o_retval =
+      _impl_isPreviousParagraphEmpty(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_insertHTML
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_insertHTML) (PortableServer_Servant _servant,
+			      const CORBA_char * html,
+			      CORBA_Environment * ev))
+{
+   _impl_insertHTML(_o_servant, *(const CORBA_char * *) _o_args[0], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_freeze
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_freeze) (PortableServer_Servant _servant,
+			  CORBA_Environment * ev))
+{
+   _impl_freeze(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_thaw
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_thaw) (PortableServer_Servant _servant,
+			CORBA_Environment * ev))
+{
+   _impl_thaw(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoBegin
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_undoBegin) (PortableServer_Servant _servant,
+			     const CORBA_char * undo_name,
+			     const CORBA_char * redo_name,
+			     CORBA_Environment * ev))
+{
+   _impl_undoBegin(_o_servant, *(const CORBA_char * *) _o_args[0],
+		   *(const CORBA_char * *) _o_args[1], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoEnd
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_undoEnd) (PortableServer_Servant _servant,
+			   CORBA_Environment * ev))
+{
+   _impl_undoEnd(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_ignoreWord
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_ignoreWord) (PortableServer_Servant _servant,
+			      const CORBA_char * word,
+			      CORBA_Environment * ev))
+{
+   _impl_ignoreWord(_o_servant, *(const CORBA_char * *) _o_args[0], _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_dropUndo
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    void (*_impl_dropUndo) (PortableServer_Servant _servant,
+			    CORBA_Environment * ev))
+{
+   _impl_dropUndo(_o_servant, _o_ev);
+}
+
+void
+_ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_hasUndo
+   (POA_GNOME_GtkHTML_Editor_Engine * _o_servant, gpointer _o_retval,
+    gpointer * _o_args, CORBA_Context _o_ctx, CORBA_Environment * _o_ev,
+    CORBA_boolean(*_impl_hasUndo) (PortableServer_Servant _servant,
+				   CORBA_Environment * ev))
+{
+   *(CORBA_boolean *) _o_retval = _impl_hasUndo(_o_servant, _o_ev);
+}
+static ORBitSmallSkeleton
+get_skel_small_GNOME_GtkHTML_Editor_Listener(POA_GNOME_GtkHTML_Editor_Listener
+					     * servant, const char *opname,
+					     gpointer * m_data,
+					     gpointer * impl)
+{
+   switch (opname[0]) {
+     case 'e':
+      if (strcmp((opname + 1), "vent"))
+	 break;
+      *impl =
+	 (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Listener_epv->event;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Listener__iinterface.methods.
+	 _buffer[0];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Listener_event;
+      break;
+     case 'q':
+      if (strcmp((opname + 1), "ueryInterface"))
+	 break;
+      *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
+      *m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
+      break;
+     case 'r':
+      if (strcmp((opname + 1), "ef"))
+	 break;
+      *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
+      *m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[0];
+      return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_ref;
+      break;
+     case 'u':
+      if (strcmp((opname + 1), "nref"))
+	 break;
+      *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
+      *m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
+      return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_unref;
+      break;
+     default:
+      break;
+   }
+   return NULL;
+}
+
+void
+POA_GNOME_GtkHTML_Editor_Listener__init(PortableServer_Servant servant,
+					CORBA_Environment * env)
+{
+   static PortableServer_ClassInfo class_info =
+      { NULL,
+(ORBit_small_impl_finder) & get_skel_small_GNOME_GtkHTML_Editor_Listener,
+	 "IDL:GNOME/GtkHTML/Editor/Listener:1.0",
+	 &GNOME_GtkHTML_Editor_Listener__classid, NULL,
+	 &GNOME_GtkHTML_Editor_Listener__iinterface };
+   POA_GNOME_GtkHTML_Editor_Listener__vepv *fakevepv = NULL;
+
+   if (((PortableServer_ServantBase *) servant)->vepv[0]->finalize == 0) {
+      ((PortableServer_ServantBase *) servant)->vepv[0]->finalize =
+	 POA_GNOME_GtkHTML_Editor_Listener__fini;
+   }
+   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
+				    env);
+   POA_Bonobo_Unknown__init(servant, env);
+   ORBit_classinfo_register(&class_info);
+   ORBIT_SERVANT_SET_CLASSINFO(servant, &class_info);
+
+   if (!class_info.vepvmap) {
+      class_info.vepvmap =
+	 g_new0(ORBit_VepvIdx, GNOME_GtkHTML_Editor_Listener__classid + 1);
+      class_info.vepvmap[Bonobo_Unknown__classid] =
+	 (((char *) &(fakevepv->Bonobo_Unknown_epv)) -
+	  ((char *) (fakevepv))) / sizeof(GFunc);
+      class_info.vepvmap[GNOME_GtkHTML_Editor_Listener__classid] =
+	 (((char *) &(fakevepv->GNOME_GtkHTML_Editor_Listener_epv)) -
+	  ((char *) (fakevepv))) / sizeof(GFunc);
+   }
+}
+
+void
+POA_GNOME_GtkHTML_Editor_Listener__fini(PortableServer_Servant servant,
+					CORBA_Environment * env)
+{
+   POA_Bonobo_Unknown__fini(servant, env);
+   PortableServer_ServantBase__fini(servant, env);
+}
+
+static ORBitSmallSkeleton
+get_skel_small_GNOME_GtkHTML_Editor_Engine(POA_GNOME_GtkHTML_Editor_Engine *
+					   servant, const char *opname,
+					   gpointer * m_data, gpointer * impl)
+{
+   switch (opname[0]) {
+     case '_':
+      switch (opname[1]) {
+	case 'g':
+	 if (strcmp((opname + 2), "et_listener"))
+	    break;
+	 *impl =
+	    (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	    _get_listener;
+	 *m_data =
+	    (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	    _buffer[0];
+	 return (ORBitSmallSkeleton)
+	    _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__get_listener;
+	 break;
+	case 's':
+	 if (strcmp((opname + 2), "et_listener"))
+	    break;
+	 *impl =
+	    (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	    _set_listener;
+	 *m_data =
+	    (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	    _buffer[1];
+	 return (ORBitSmallSkeleton)
+	    _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__set_listener;
+	 break;
+	default:
+	 break;
+      }
+      break;
+     case 'd':
+      if (strcmp((opname + 1), "ropUndo"))
+	 break;
+      *impl =
+	 (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->dropUndo;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	 _buffer[15];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_dropUndo;
+      break;
+     case 'f':
+      if (strcmp((opname + 1), "reeze"))
+	 break;
+      *impl =
+	 (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->freeze;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	 _buffer[10];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_freeze;
+      break;
+     case 'g':
+      if (strcmp((opname + 1), "etParagraphData"))
+	 break;
+      *impl =
+	 (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	 getParagraphData;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	 _buffer[3];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_getParagraphData;
+      break;
+     case 'h':
+      if (strcmp((opname + 1), "asUndo"))
+	 break;
+      *impl =
+	 (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->hasUndo;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	 _buffer[16];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_hasUndo;
+      break;
+     case 'i':
+      switch (opname[1]) {
+	case 'g':
+	 if (strcmp((opname + 2), "noreWord"))
+	    break;
+	 *impl =
+	    (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	    ignoreWord;
+	 *m_data =
+	    (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	    _buffer[14];
+	 return (ORBitSmallSkeleton)
+	    _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_ignoreWord;
+	 break;
+	case 'n':
+	 if (strcmp((opname + 2), "sertHTML"))
+	    break;
+	 *impl =
+	    (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	    insertHTML;
+	 *m_data =
+	    (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	    _buffer[9];
+	 return (ORBitSmallSkeleton)
+	    _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_insertHTML;
+	 break;
+	case 's':
+	 switch (opname[2]) {
+	   case 'P':
+	    switch (opname[3]) {
+	      case 'a':
+	       if (strcmp((opname + 4), "ragraphEmpty"))
+		  break;
+	       *impl =
+		  (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+		  isParagraphEmpty;
+	       *m_data =
+		  (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		  methods._buffer[7];
+	       return (ORBitSmallSkeleton)
+		  _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isParagraphEmpty;
+	       break;
+	      case 'r':
+	       if (strcmp((opname + 4), "eviousParagraphEmpty"))
+		  break;
+	       *impl =
+		  (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+		  isPreviousParagraphEmpty;
+	       *m_data =
+		  (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		  methods._buffer[8];
+	       return (ORBitSmallSkeleton)
+		  _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty;
+	       break;
+	      default:
+	       break;
+	    }
+	    break;
+	   default:
+	    break;
+	 }
+	 break;
+	default:
+	 break;
+      }
+      break;
+     case 'q':
+      if (strcmp((opname + 1), "ueryInterface"))
+	 break;
+      *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
+      *m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
+      break;
+     case 'r':
+      switch (opname[1]) {
+	case 'e':
+	 if (strcmp((opname + 2), "f"))
+	    break;
+	 *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
+	 *m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[0];
+	 return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_ref;
+	 break;
+	case 'u':
+	 if (strcmp((opname + 2), "nCommand"))
+	    break;
+	 *impl =
+	    (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	    runCommand;
+	 *m_data =
+	    (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	    _buffer[2];
+	 return (ORBitSmallSkeleton)
+	    _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_runCommand;
+	 break;
+	default:
+	 break;
+      }
+      break;
+     case 's':
+      switch (opname[1]) {
+	case 'e':
+	 switch (opname[2]) {
+	   case 'a':
+	    if (strcmp((opname + 3), "rchByData"))
+	       break;
+	    *impl =
+	       (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+	       searchByData;
+	    *m_data =
+	       (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	       _buffer[6];
+	    return (ORBitSmallSkeleton)
+	       _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_searchByData;
+	    break;
+	   case 't':
+	    switch (opname[3]) {
+	      case 'O':
+	       if (strcmp((opname + 4), "bjectDataByType"))
+		  break;
+	       *impl =
+		  (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+		  setObjectDataByType;
+	       *m_data =
+		  (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		  methods._buffer[5];
+	       return (ORBitSmallSkeleton)
+		  _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setObjectDataByType;
+	       break;
+	      case 'P':
+	       if (strcmp((opname + 4), "aragraphData"))
+		  break;
+	       *impl =
+		  (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
+		  setParagraphData;
+	       *m_data =
+		  (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		  methods._buffer[4];
+	       return (ORBitSmallSkeleton)
+		  _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setParagraphData;
+	       break;
+	      default:
+	       break;
+	    }
+	    break;
+	   default:
+	    break;
+	 }
+	 break;
+	default:
+	 break;
+      }
+      break;
+     case 't':
+      if (strcmp((opname + 1), "haw"))
+	 break;
+      *impl = (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->thaw;
+      *m_data =
+	 (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.methods.
+	 _buffer[11];
+      return (ORBitSmallSkeleton)
+	 _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_thaw;
+      break;
+     case 'u':
+      switch (opname[1]) {
+	case 'n':
+	 switch (opname[2]) {
+	   case 'd':
+	    switch (opname[3]) {
+	      case 'o':
+	       switch (opname[4]) {
+		 case 'B':
+		  if (strcmp((opname + 5), "egin"))
+		     break;
+		  *impl =
+		     (gpointer) servant->vepv->
+		     GNOME_GtkHTML_Editor_Engine_epv->undoBegin;
+		  *m_data =
+		     (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		     methods._buffer[12];
+		  return (ORBitSmallSkeleton)
+		     _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoBegin;
+		  break;
+		 case 'E':
+		  if (strcmp((opname + 5), "nd"))
+		     break;
+		  *impl =
+		     (gpointer) servant->vepv->
+		     GNOME_GtkHTML_Editor_Engine_epv->undoEnd;
+		  *m_data =
+		     (gpointer) & GNOME_GtkHTML_Editor_Engine__iinterface.
+		     methods._buffer[13];
+		  return (ORBitSmallSkeleton)
+		     _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoEnd;
+		  break;
+		 default:
+		  break;
+	       }
+	       break;
+	      default:
+	       break;
+	    }
+	    break;
+	   case 'r':
+	    if (strcmp((opname + 3), "ef"))
+	       break;
+	    *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
+	    *m_data =
+	       (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
+	    return (ORBitSmallSkeleton)
+	       _ORBIT_skel_small_Bonobo_Unknown_unref;
+	    break;
+	   default:
+	    break;
+	 }
+	 break;
+	default:
+	 break;
+      }
+      break;
+     default:
+      break;
+   }
+   return NULL;
+}
+
+void
+POA_GNOME_GtkHTML_Editor_Engine__init(PortableServer_Servant servant,
+				      CORBA_Environment * env)
+{
+   static PortableServer_ClassInfo class_info =
+      { NULL,
+(ORBit_small_impl_finder) & get_skel_small_GNOME_GtkHTML_Editor_Engine, "IDL:GNOME/GtkHTML/Editor/Engine:1.0",
+	 &GNOME_GtkHTML_Editor_Engine__classid, NULL,
+	 &GNOME_GtkHTML_Editor_Engine__iinterface };
+   POA_GNOME_GtkHTML_Editor_Engine__vepv *fakevepv = NULL;
+
+   if (((PortableServer_ServantBase *) servant)->vepv[0]->finalize == 0) {
+      ((PortableServer_ServantBase *) servant)->vepv[0]->finalize =
+	 POA_GNOME_GtkHTML_Editor_Engine__fini;
+   }
+   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
+				    env);
+   POA_Bonobo_Unknown__init(servant, env);
+   ORBit_classinfo_register(&class_info);
+   ORBIT_SERVANT_SET_CLASSINFO(servant, &class_info);
+
+   if (!class_info.vepvmap) {
+      class_info.vepvmap =
+	 g_new0(ORBit_VepvIdx, GNOME_GtkHTML_Editor_Engine__classid + 1);
+      class_info.vepvmap[Bonobo_Unknown__classid] =
+	 (((char *) &(fakevepv->Bonobo_Unknown_epv)) -
+	  ((char *) (fakevepv))) / sizeof(GFunc);
+      class_info.vepvmap[GNOME_GtkHTML_Editor_Engine__classid] =
+	 (((char *) &(fakevepv->GNOME_GtkHTML_Editor_Engine_epv)) -
+	  ((char *) (fakevepv))) / sizeof(GFunc);
+   }
+}
+
+void
+POA_GNOME_GtkHTML_Editor_Engine__fini(PortableServer_Servant servant,
+				      CORBA_Environment * env)
+{
+   POA_Bonobo_Unknown__fini(servant, env);
+   PortableServer_ServantBase__fini(servant, env);
+}
diff -Nur vim63/src/gtkhtml_editor_stubs.c vim63-bonobo/src/gtkhtml_editor_stubs.c
--- vim63/src/gtkhtml_editor_stubs.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml_editor_stubs.c	2005-09-09 20:14:02.729585304 +0200
@@ -0,0 +1,496 @@
+/*
+ * This file was generated by orbit-idl-2 - DO NOT EDIT!
+ */
+
+#include <string.h>
+#define ORBIT2_STUBS_API
+#include "gtkhtml.h"
+
+CORBA_any *
+GNOME_GtkHTML_Editor_Listener_event(GNOME_GtkHTML_Editor_Listener _obj,
+				    const CORBA_char * name,
+				    const CORBA_any * arg,
+				    CORBA_Environment * ev)
+{
+   CORBA_any *_ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Listener__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Listener__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Listener__epv *) ORBIT_STUB_GetEpv(_obj,
+								     GNOME_GtkHTML_Editor_Listener__classid))->
+       event) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->event(ORBIT_STUB_GetServant(_obj), name, arg, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[2];
+
+      _args[0] = (gpointer) & name;
+      _args[1] = (gpointer) arg;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Listener__iinterface.
+				methods, 0, &_ORBIT_retval, _args, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+GNOME_GtkHTML_Editor_Listener
+GNOME_GtkHTML_Editor_Engine__get_listener(GNOME_GtkHTML_Editor_Engine _obj,
+					  CORBA_Environment * ev)
+{
+   GNOME_GtkHTML_Editor_Listener _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       _get_listener) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->_get_listener(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 0, &_ORBIT_retval, NULL, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+void
+GNOME_GtkHTML_Editor_Engine__set_listener(GNOME_GtkHTML_Editor_Engine _obj,
+					  const GNOME_GtkHTML_Editor_Listener
+					  value, CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       _set_listener) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->_set_listener(ORBIT_STUB_GetServant(_obj), value, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[1];
+
+      _args[0] = (gpointer) & value;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 1, NULL, _args, NULL, ev);
+
+   }
+}
+CORBA_boolean
+GNOME_GtkHTML_Editor_Engine_runCommand(GNOME_GtkHTML_Editor_Engine _obj,
+				       const CORBA_char * command,
+				       CORBA_Environment * ev)
+{
+   CORBA_boolean _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       runCommand) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->runCommand(ORBIT_STUB_GetServant(_obj), command, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[1];
+
+      _args[0] = (gpointer) & command;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 2, &_ORBIT_retval, _args, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+CORBA_string
+GNOME_GtkHTML_Editor_Engine_getParagraphData(GNOME_GtkHTML_Editor_Engine _obj,
+					     const CORBA_char * key,
+					     CORBA_Environment * ev)
+{
+   CORBA_string _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       getParagraphData) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->getParagraphData(ORBIT_STUB_GetServant(_obj), key, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[1];
+
+      _args[0] = (gpointer) & key;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 3, &_ORBIT_retval, _args, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+void
+GNOME_GtkHTML_Editor_Engine_setParagraphData(GNOME_GtkHTML_Editor_Engine _obj,
+					     const CORBA_char * key,
+					     const CORBA_char * value,
+					     CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       setParagraphData) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->setParagraphData(ORBIT_STUB_GetServant(_obj), key, value,
+				   ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[2];
+
+      _args[0] = (gpointer) & key;
+      _args[1] = (gpointer) & value;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 4, NULL, _args, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_setObjectDataByType(GNOME_GtkHTML_Editor_Engine
+						_obj,
+						const CORBA_char * type_name,
+						const CORBA_char * key,
+						const CORBA_char * data,
+						CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       setObjectDataByType) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->setObjectDataByType(ORBIT_STUB_GetServant(_obj), type_name,
+				      key, data, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[3];
+
+      _args[0] = (gpointer) & type_name;
+      _args[1] = (gpointer) & key;
+      _args[2] = (gpointer) & data;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 5, NULL, _args, NULL, ev);
+
+   }
+}
+CORBA_boolean
+GNOME_GtkHTML_Editor_Engine_searchByData(GNOME_GtkHTML_Editor_Engine _obj,
+					 const CORBA_long level,
+					 const CORBA_char * klass,
+					 const CORBA_char * key,
+					 const CORBA_char * value,
+					 CORBA_Environment * ev)
+{
+   CORBA_boolean _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       searchByData) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->searchByData(ORBIT_STUB_GetServant(_obj), level, klass,
+				  key, value, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[4];
+
+      _args[0] = (gpointer) & level;
+      _args[1] = (gpointer) & klass;
+      _args[2] = (gpointer) & key;
+      _args[3] = (gpointer) & value;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 6, &_ORBIT_retval, _args, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+CORBA_boolean
+GNOME_GtkHTML_Editor_Engine_isParagraphEmpty(GNOME_GtkHTML_Editor_Engine _obj,
+					     CORBA_Environment * ev)
+{
+   CORBA_boolean _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       isParagraphEmpty) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->isParagraphEmpty(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 7, &_ORBIT_retval, NULL, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+CORBA_boolean
+GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty
+   (GNOME_GtkHTML_Editor_Engine _obj, CORBA_Environment * ev)
+{
+   CORBA_boolean _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       isPreviousParagraphEmpty) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval =
+	 _ORBIT_epv->isPreviousParagraphEmpty(ORBIT_STUB_GetServant(_obj),
+					      ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 8, &_ORBIT_retval, NULL, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
+
+void
+GNOME_GtkHTML_Editor_Engine_insertHTML(GNOME_GtkHTML_Editor_Engine _obj,
+				       const CORBA_char * html,
+				       CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       insertHTML) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->insertHTML(ORBIT_STUB_GetServant(_obj), html, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[1];
+
+      _args[0] = (gpointer) & html;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 9, NULL, _args, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_freeze(GNOME_GtkHTML_Editor_Engine _obj,
+				   CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       freeze) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->freeze(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 10, NULL, NULL, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_thaw(GNOME_GtkHTML_Editor_Engine _obj,
+				 CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       thaw) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->thaw(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 11, NULL, NULL, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_undoBegin(GNOME_GtkHTML_Editor_Engine _obj,
+				      const CORBA_char * undo_name,
+				      const CORBA_char * redo_name,
+				      CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       undoBegin) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->undoBegin(ORBIT_STUB_GetServant(_obj), undo_name, redo_name,
+			    ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[2];
+
+      _args[0] = (gpointer) & undo_name;
+      _args[1] = (gpointer) & redo_name;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 12, NULL, _args, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_undoEnd(GNOME_GtkHTML_Editor_Engine _obj,
+				    CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       undoEnd) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->undoEnd(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 13, NULL, NULL, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_ignoreWord(GNOME_GtkHTML_Editor_Engine _obj,
+				       const CORBA_char * word,
+				       CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       ignoreWord) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->ignoreWord(ORBIT_STUB_GetServant(_obj), word, ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      gpointer _args[1];
+
+      _args[0] = (gpointer) & word;
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 14, NULL, _args, NULL, ev);
+
+   }
+}
+void
+GNOME_GtkHTML_Editor_Engine_dropUndo(GNOME_GtkHTML_Editor_Engine _obj,
+				     CORBA_Environment * ev)
+{
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       dropUndo) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_epv->dropUndo(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 15, NULL, NULL, NULL, ev);
+
+   }
+}
+CORBA_boolean
+GNOME_GtkHTML_Editor_Engine_hasUndo(GNOME_GtkHTML_Editor_Engine _obj,
+				    CORBA_Environment * ev)
+{
+   CORBA_boolean _ORBIT_retval;
+   POA_GNOME_GtkHTML_Editor_Engine__epv *_ORBIT_epv;
+
+   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
+       ORBIT_STUB_IsBypass(_obj, GNOME_GtkHTML_Editor_Engine__classid) &&
+       (_ORBIT_epv =
+	(POA_GNOME_GtkHTML_Editor_Engine__epv *) ORBIT_STUB_GetEpv(_obj,
+								   GNOME_GtkHTML_Editor_Engine__classid))->
+       hasUndo) {
+      ORBIT_STUB_PreCall(_obj);
+      _ORBIT_retval = _ORBIT_epv->hasUndo(ORBIT_STUB_GetServant(_obj), ev);
+      ORBIT_STUB_PostCall(_obj);
+   } else {			/* remote marshal */
+      ORBit_small_invoke_stub_n(_obj,
+				&GNOME_GtkHTML_Editor_Engine__iinterface.
+				methods, 16, &_ORBIT_retval, NULL, NULL, ev);
+
+   }
+   return _ORBIT_retval;
+}
diff -Nur vim63/src/gtkhtml.h vim63-bonobo/src/gtkhtml.h
--- vim63/src/gtkhtml.h	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/gtkhtml.h	2005-09-09 20:14:02.725585912 +0200
@@ -0,0 +1,480 @@
+/*
+ * This file was generated by orbit-idl-2 - DO NOT EDIT!
+ */
+
+#ifndef Editor_H
+#define Editor_H 1
+#include <glib.h>
+#define ORBIT_IDL_SERIAL 19
+#include <orbit/orbit-types.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif				/* __cplusplus */
+
+/** typedefs **/
+#include <bonobo/Bonobo.h>
+#if !defined(ORBIT_DECL_GNOME_GtkHTML_Editor_Listener) && !defined(_GNOME_GtkHTML_Editor_Listener_defined)
+#define ORBIT_DECL_GNOME_GtkHTML_Editor_Listener 1
+#define _GNOME_GtkHTML_Editor_Listener_defined 1
+#define GNOME_GtkHTML_Editor_Listener__freekids CORBA_Object__freekids
+   typedef CORBA_Object GNOME_GtkHTML_Editor_Listener;
+   extern CORBA_unsigned_long GNOME_GtkHTML_Editor_Listener__classid;
+#if !defined(TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_0)
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_0 'E'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_1 'd'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_2 'i'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_3 't'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_4 'o'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Listener_5 'r'
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   const struct CORBA_TypeCode_struct TC_GNOME_GtkHTML_Editor_Listener_struct;
+#define TC_GNOME_GtkHTML_Editor_Listener ((CORBA_TypeCode)&TC_GNOME_GtkHTML_Editor_Listener_struct)
+#endif
+#endif
+#if !defined(ORBIT_DECL_GNOME_GtkHTML_Editor_Engine) && !defined(_GNOME_GtkHTML_Editor_Engine_defined)
+#define ORBIT_DECL_GNOME_GtkHTML_Editor_Engine 1
+#define _GNOME_GtkHTML_Editor_Engine_defined 1
+#define GNOME_GtkHTML_Editor_Engine__freekids CORBA_Object__freekids
+   typedef CORBA_Object GNOME_GtkHTML_Editor_Engine;
+   extern CORBA_unsigned_long GNOME_GtkHTML_Editor_Engine__classid;
+#if !defined(TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_0)
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_0 'E'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_1 'd'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_2 'i'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_3 't'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_4 'o'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_Engine_5 'r'
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   const struct CORBA_TypeCode_struct TC_GNOME_GtkHTML_Editor_Engine_struct;
+#define TC_GNOME_GtkHTML_Editor_Engine ((CORBA_TypeCode)&TC_GNOME_GtkHTML_Editor_Engine_struct)
+#endif
+#endif
+#if !defined(_GNOME_GtkHTML_Editor_URLRequestEvent_defined)
+#define _GNOME_GtkHTML_Editor_URLRequestEvent_defined 1
+   typedef struct GNOME_GtkHTML_Editor_URLRequestEvent_type
+      GNOME_GtkHTML_Editor_URLRequestEvent;
+   struct GNOME_GtkHTML_Editor_URLRequestEvent_type
+   {
+      CORBA_string url;
+      Bonobo_Stream stream;
+   };
+
+#if !defined(TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_0)
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_0 'E'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_1 'd'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_2 'i'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_3 't'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_4 'o'
+#define TC_IMPL_TC_GNOME_GtkHTML_Editor_URLRequestEvent_5 'r'
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   const struct CORBA_TypeCode_struct
+      TC_GNOME_GtkHTML_Editor_URLRequestEvent_struct;
+#define TC_GNOME_GtkHTML_Editor_URLRequestEvent ((CORBA_TypeCode)&TC_GNOME_GtkHTML_Editor_URLRequestEvent_struct)
+#endif
+#define GNOME_GtkHTML_Editor_URLRequestEvent__alloc() ((GNOME_GtkHTML_Editor_URLRequestEvent *)ORBit_small_alloc (TC_GNOME_GtkHTML_Editor_URLRequestEvent))
+#define GNOME_GtkHTML_Editor_URLRequestEvent__freekids(m,d) ORBit_small_freekids (TC_GNOME_GtkHTML_Editor_URLRequestEvent,(m),(d))
+#endif
+
+/** POA structures **/
+#ifndef _defined_POA_GNOME_GtkHTML_Editor_Listener
+#define _defined_POA_GNOME_GtkHTML_Editor_Listener 1
+   typedef struct
+   {
+      void *_private;
+      CORBA_any *(*event) (PortableServer_Servant _servant,
+			   const CORBA_char * name, const CORBA_any * arg,
+			   CORBA_Environment * ev);
+   }
+   POA_GNOME_GtkHTML_Editor_Listener__epv;
+   typedef struct
+   {
+      PortableServer_ServantBase__epv *_base_epv;
+      POA_Bonobo_Unknown__epv *Bonobo_Unknown_epv;
+      POA_GNOME_GtkHTML_Editor_Listener__epv
+	 *GNOME_GtkHTML_Editor_Listener_epv;
+   }
+   POA_GNOME_GtkHTML_Editor_Listener__vepv;
+   typedef struct
+   {
+      void *_private;
+      POA_GNOME_GtkHTML_Editor_Listener__vepv *vepv;
+   }
+   POA_GNOME_GtkHTML_Editor_Listener;
+   extern void POA_GNOME_GtkHTML_Editor_Listener__init(PortableServer_Servant
+						       servant,
+						       CORBA_Environment *
+						       ev);
+   extern void POA_GNOME_GtkHTML_Editor_Listener__fini(PortableServer_Servant
+						       servant,
+						       CORBA_Environment *
+						       ev);
+#endif				/* _defined_POA_GNOME_GtkHTML_Editor_Listener */
+#ifndef _defined_POA_GNOME_GtkHTML_Editor_Engine
+#define _defined_POA_GNOME_GtkHTML_Editor_Engine 1
+   typedef struct
+   {
+      void *_private;
+       GNOME_GtkHTML_Editor_Listener(*_get_listener) (PortableServer_Servant
+						      _servant,
+						      CORBA_Environment * ev);
+      void (*_set_listener) (PortableServer_Servant _servant,
+			     const GNOME_GtkHTML_Editor_Listener value,
+			     CORBA_Environment * ev);
+       CORBA_boolean(*runCommand) (PortableServer_Servant _servant,
+				   const CORBA_char * command,
+				   CORBA_Environment * ev);
+       CORBA_string(*getParagraphData) (PortableServer_Servant _servant,
+					const CORBA_char * key,
+					CORBA_Environment * ev);
+      void (*setParagraphData) (PortableServer_Servant _servant,
+				const CORBA_char * key,
+				const CORBA_char * value,
+				CORBA_Environment * ev);
+      void (*setObjectDataByType) (PortableServer_Servant _servant,
+				   const CORBA_char * type_name,
+				   const CORBA_char * key,
+				   const CORBA_char * data,
+				   CORBA_Environment * ev);
+       CORBA_boolean(*searchByData) (PortableServer_Servant _servant,
+				     const CORBA_long level,
+				     const CORBA_char * klass,
+				     const CORBA_char * key,
+				     const CORBA_char * value,
+				     CORBA_Environment * ev);
+       CORBA_boolean(*isParagraphEmpty) (PortableServer_Servant _servant,
+					 CORBA_Environment * ev);
+       CORBA_boolean(*isPreviousParagraphEmpty) (PortableServer_Servant
+						 _servant,
+						 CORBA_Environment * ev);
+      void (*insertHTML) (PortableServer_Servant _servant,
+			  const CORBA_char * html, CORBA_Environment * ev);
+      void (*freeze) (PortableServer_Servant _servant,
+		      CORBA_Environment * ev);
+      void (*thaw) (PortableServer_Servant _servant, CORBA_Environment * ev);
+      void (*undoBegin) (PortableServer_Servant _servant,
+			 const CORBA_char * undo_name,
+			 const CORBA_char * redo_name,
+			 CORBA_Environment * ev);
+      void (*undoEnd) (PortableServer_Servant _servant,
+		       CORBA_Environment * ev);
+      void (*ignoreWord) (PortableServer_Servant _servant,
+			  const CORBA_char * word, CORBA_Environment * ev);
+      void (*dropUndo) (PortableServer_Servant _servant,
+			CORBA_Environment * ev);
+       CORBA_boolean(*hasUndo) (PortableServer_Servant _servant,
+				CORBA_Environment * ev);
+   }
+   POA_GNOME_GtkHTML_Editor_Engine__epv;
+   typedef struct
+   {
+      PortableServer_ServantBase__epv *_base_epv;
+      POA_Bonobo_Unknown__epv *Bonobo_Unknown_epv;
+      POA_GNOME_GtkHTML_Editor_Engine__epv *GNOME_GtkHTML_Editor_Engine_epv;
+   }
+   POA_GNOME_GtkHTML_Editor_Engine__vepv;
+   typedef struct
+   {
+      void *_private;
+      POA_GNOME_GtkHTML_Editor_Engine__vepv *vepv;
+   }
+   POA_GNOME_GtkHTML_Editor_Engine;
+   extern void POA_GNOME_GtkHTML_Editor_Engine__init(PortableServer_Servant
+						     servant,
+						     CORBA_Environment * ev);
+   extern void POA_GNOME_GtkHTML_Editor_Engine__fini(PortableServer_Servant
+						     servant,
+						     CORBA_Environment * ev);
+#endif				/* _defined_POA_GNOME_GtkHTML_Editor_Engine */
+
+/** skel prototypes **/
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Listener_event
+      (POA_GNOME_GtkHTML_Editor_Listener * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_any * (*_impl_event) (PortableServer_Servant _servant,
+				   const CORBA_char * name,
+				   const CORBA_any * arg,
+				   CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__get_listener
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       GNOME_GtkHTML_Editor_Listener(*_impl__get_listener)
+       (PortableServer_Servant _servant, CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine__set_listener
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl__set_listener) (PortableServer_Servant _servant,
+				    const GNOME_GtkHTML_Editor_Listener value,
+				    CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_runCommand
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_boolean(*_impl_runCommand) (PortableServer_Servant _servant,
+					 const CORBA_char * command,
+					 CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_getParagraphData
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_string(*_impl_getParagraphData) (PortableServer_Servant _servant,
+					      const CORBA_char * key,
+					      CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setParagraphData
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_setParagraphData) (PortableServer_Servant _servant,
+				       const CORBA_char * key,
+				       const CORBA_char * value,
+				       CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_setObjectDataByType
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_setObjectDataByType) (PortableServer_Servant _servant,
+					  const CORBA_char * type_name,
+					  const CORBA_char * key,
+					  const CORBA_char * data,
+					  CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_searchByData
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_boolean(*_impl_searchByData) (PortableServer_Servant _servant,
+					   const CORBA_long level,
+					   const CORBA_char * klass,
+					   const CORBA_char * key,
+					   const CORBA_char * value,
+					   CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isParagraphEmpty
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_boolean(*_impl_isParagraphEmpty) (PortableServer_Servant
+					       _servant,
+					       CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_boolean(*_impl_isPreviousParagraphEmpty) (PortableServer_Servant
+						       _servant,
+						       CORBA_Environment *
+						       ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_insertHTML
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_insertHTML) (PortableServer_Servant _servant,
+				 const CORBA_char * html,
+				 CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_freeze
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_freeze) (PortableServer_Servant _servant,
+			     CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_thaw
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_thaw) (PortableServer_Servant _servant,
+			   CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoBegin
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_undoBegin) (PortableServer_Servant _servant,
+				const CORBA_char * undo_name,
+				const CORBA_char * redo_name,
+				CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_undoEnd
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_undoEnd) (PortableServer_Servant _servant,
+			      CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_ignoreWord
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_ignoreWord) (PortableServer_Servant _servant,
+				 const CORBA_char * word,
+				 CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_dropUndo
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       void (*_impl_dropUndo) (PortableServer_Servant _servant,
+			       CORBA_Environment * ev));
+   void
+      _ORBIT_skel_small_GNOME_GtkHTML_Editor_Engine_hasUndo
+      (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
+       gpointer _ORBIT_retval, gpointer * _ORBIT_args, CORBA_Context ctx,
+       CORBA_Environment * ev,
+       CORBA_boolean(*_impl_hasUndo) (PortableServer_Servant _servant,
+				      CORBA_Environment * ev));
+
+/** stub prototypes **/
+#define GNOME_GtkHTML_Editor_Listener_ref Bonobo_Unknown_ref
+#define GNOME_GtkHTML_Editor_Listener_unref Bonobo_Unknown_unref
+#define GNOME_GtkHTML_Editor_Listener_queryInterface Bonobo_Unknown_queryInterface
+   CORBA_any
+      *GNOME_GtkHTML_Editor_Listener_event(GNOME_GtkHTML_Editor_Listener _obj,
+					   const CORBA_char * name,
+					   const CORBA_any * arg,
+					   CORBA_Environment * ev);
+#define GNOME_GtkHTML_Editor_Engine_ref Bonobo_Unknown_ref
+#define GNOME_GtkHTML_Editor_Engine_unref Bonobo_Unknown_unref
+#define GNOME_GtkHTML_Editor_Engine_queryInterface Bonobo_Unknown_queryInterface
+   GNOME_GtkHTML_Editor_Listener
+      GNOME_GtkHTML_Editor_Engine__get_listener(GNOME_GtkHTML_Editor_Engine
+						_obj, CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine__set_listener(GNOME_GtkHTML_Editor_Engine
+						  _obj,
+						  const
+						  GNOME_GtkHTML_Editor_Listener
+						  value,
+						  CORBA_Environment * ev);
+   CORBA_boolean
+      GNOME_GtkHTML_Editor_Engine_runCommand(GNOME_GtkHTML_Editor_Engine _obj,
+					     const CORBA_char * command,
+					     CORBA_Environment * ev);
+   CORBA_string
+      GNOME_GtkHTML_Editor_Engine_getParagraphData(GNOME_GtkHTML_Editor_Engine
+						   _obj,
+						   const CORBA_char * key,
+						   CORBA_Environment * ev);
+   void
+      GNOME_GtkHTML_Editor_Engine_setParagraphData(GNOME_GtkHTML_Editor_Engine
+						   _obj,
+						   const CORBA_char * key,
+						   const CORBA_char * value,
+						   CORBA_Environment * ev);
+   void
+      GNOME_GtkHTML_Editor_Engine_setObjectDataByType
+      (GNOME_GtkHTML_Editor_Engine _obj, const CORBA_char * type_name,
+       const CORBA_char * key, const CORBA_char * data,
+       CORBA_Environment * ev);
+   CORBA_boolean
+      GNOME_GtkHTML_Editor_Engine_searchByData(GNOME_GtkHTML_Editor_Engine
+					       _obj, const CORBA_long level,
+					       const CORBA_char * klass,
+					       const CORBA_char * key,
+					       const CORBA_char * value,
+					       CORBA_Environment * ev);
+   CORBA_boolean
+      GNOME_GtkHTML_Editor_Engine_isParagraphEmpty(GNOME_GtkHTML_Editor_Engine
+						   _obj,
+						   CORBA_Environment * ev);
+   CORBA_boolean
+      GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty
+      (GNOME_GtkHTML_Editor_Engine _obj, CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_insertHTML(GNOME_GtkHTML_Editor_Engine
+					       _obj, const CORBA_char * html,
+					       CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_freeze(GNOME_GtkHTML_Editor_Engine _obj,
+					   CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_thaw(GNOME_GtkHTML_Editor_Engine _obj,
+					 CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_undoBegin(GNOME_GtkHTML_Editor_Engine
+					      _obj,
+					      const CORBA_char * undo_name,
+					      const CORBA_char * redo_name,
+					      CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_undoEnd(GNOME_GtkHTML_Editor_Engine _obj,
+					    CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_ignoreWord(GNOME_GtkHTML_Editor_Engine
+					       _obj, const CORBA_char * word,
+					       CORBA_Environment * ev);
+   void GNOME_GtkHTML_Editor_Engine_dropUndo(GNOME_GtkHTML_Editor_Engine _obj,
+					     CORBA_Environment * ev);
+   CORBA_boolean
+      GNOME_GtkHTML_Editor_Engine_hasUndo(GNOME_GtkHTML_Editor_Engine _obj,
+					  CORBA_Environment * ev);
+
+/** more internals **/
+#if !defined(MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_0)
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_0 'E'
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_1 'd'
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_2 'i'
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_3 't'
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_4 'o'
+#define MARSHAL_IMPL_GNOME_GtkHTML_Editor_URLRequestEvent_5 'r'
+#endif
+#include <orbit/orb-core/orbit-interface.h>
+
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   ORBit_IInterface GNOME_GtkHTML_Editor_Listener__iinterface;
+#define GNOME_GtkHTML_Editor_Listener_IMETHODS_LEN 1
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   ORBit_IMethod
+      GNOME_GtkHTML_Editor_Listener__imethods
+      [GNOME_GtkHTML_Editor_Listener_IMETHODS_LEN];
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   ORBit_IInterface GNOME_GtkHTML_Editor_Engine__iinterface;
+#define GNOME_GtkHTML_Editor_Engine_IMETHODS_LEN 17
+#ifdef ORBIT_IDL_C_IMODULE
+   static
+#else
+   extern
+#endif
+   ORBit_IMethod
+      GNOME_GtkHTML_Editor_Engine__imethods
+      [GNOME_GtkHTML_Editor_Engine_IMETHODS_LEN];
+#ifdef __cplusplus
+}
+#endif				/* __cplusplus */
+
+#ifndef EXCLUDE_ORBIT_H
+#include <orbit/orbit.h>
+
+#endif				/* EXCLUDE_ORBIT_H */
+#endif
+#undef ORBIT_IDL_SERIAL
diff -Nur vim63/src/gui.c vim63-bonobo/src/gui.c
--- vim63/src/gui.c	2005-09-09 20:11:10.562758000 +0200
+++ vim63-bonobo/src/gui.c	2005-09-09 20:14:02.733584696 +0200
@@ -440,8 +440,12 @@
      * Create the GUI shell.
      */
     gui.in_use = TRUE;		/* Must be set after menus have been set up */
+#ifdef FEAT_GUI_COMPONENT
+    vim_bonobo_wait_for_instantiation();
+#else
     if (gui_mch_init() == FAIL)
 	goto error;
+#endif
 
     /* Avoid a delay for an error message that was printed in the terminal
      * where Vim was started. */
@@ -4193,8 +4197,8 @@
 	add_to_input_buf(st, 8);
 #ifdef FEAT_GUI_GTK
 	/* Need to wake up the main loop */
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
+	if (MAIN_LEVEL() > 0)
+	    MAIN_QUIT();
 #endif
     }
 }
@@ -4407,8 +4411,12 @@
     int
 no_console_input()
 {
-    return ((!gui.in_use || gui.starting)
-# ifndef NO_CONSOLE
+    return ((!gui.in_use || gui.starting || !gui.shell_created
+#ifdef FEAT_GUI_COMPONENT
+            || gui.processing_call
+#endif
+                )
+# if !defined(NO_CONSOLE) && !defined(FEAT_GUI_COMPONENT)
 	    && !isatty(0) && !isatty(2)
 # endif
 	    );
diff -Nur vim63/src/gui_gtk.c vim63-bonobo/src/gui_gtk.c
--- vim63/src/gui_gtk.c	2005-09-09 20:11:09.520917000 +0200
+++ vim63-bonobo/src/gui_gtk.c	2005-09-09 20:14:02.737584088 +0200
@@ -39,7 +39,7 @@
 
 #include "vim.h"
 
-#ifdef FEAT_GUI_GNOME
+#if 0
 /* Gnome redefines _() and N_().  Grrr... */
 # ifdef _
 #  undef _
@@ -554,9 +554,332 @@
 
 # endif /* !HAVE_GTK2 */
 
+#ifdef FEAT_GUI_COMPONENT
+
+
+static void
+verb_activate( BonoboUIComponent *uic, gpointer data, const char *cname )
+{
+    gui_menu_cb((vimmenu_T *) data);
+
+    /* make sure the menu action is taken immediately */
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
+}
+
+/* Takes name (a label), and appends a normalized version of name to
+ * the destination string.  Normalization in this case means taking only 
+ * alphanumeric characters, and discarding all others.  */
+static void g_string_append_normalized_name( GString * dest, char_u * name )
+{
+    gchar * cur;
+
+    if( name == NULL ) 
+    {
+        return;
+    }
+    cur = name;
+    while( *cur != '\0' ) {
+        gunichar wc;
+        wc = g_utf8_get_char(cur);
+        if( g_unichar_isalnum( wc ) ) {
+            g_string_append_unichar( dest, wc );
+        }
+        cur = g_utf8_next_char(cur);
+    }
+}
+
+/* for the given menu, create the corresponding xml path.
+ * if to_parent is TRUE, returns the path to the parent of the given menu.
+ */
+static
+char * xml_path_for_menu( vimmenu_T * menu, int to_parent )
+{
+    GString * normname;
+    GString * path;
+    char * retpath;
+    
+    normname = g_string_sized_new( 64 );
+    path = g_string_sized_new( 128 );
+    while( 1 ) {
+        if( menu_is_toolbar(menu->name) ) {
+            /* "Toolbar" is a standard Bonobo UI element, but Vim uses "ToolBar", so we
+             * have to check for this. */
+            g_string_prepend( path, "/Toolbar");
+        } else {
+            g_string_assign( normname, "" );
+            g_string_append_normalized_name( normname, menu->dname );
+            g_string_prepend( path, normname->str );
+            g_string_prepend( path, "/" );
+        }
+        if( menu->parent == NULL ) {
+            if( menu && menu_is_menubar( menu->name ) ) {
+                g_string_prepend( path, "/menu" );
+            }
+            break;
+        }
+        menu = menu->parent;
+    }
+    g_string_free( normname, TRUE );
+    retpath = path->str;
+    g_string_free( path, FALSE );
+
+    if( to_parent ) {
+        gchar * slash;
+        slash = g_strrstr(retpath, "/");
+        if( slash == retpath )
+            slash[1] = '\0';
+        else if( slash ) 
+            *slash = '\0';
+    }
+    return( retpath );
+}
+
+/* Because the container which embeds Vim may not have the same toolbar icons
+ * installed, we need to send the icons in the XML stream.  This function
+ * takes the given GtkImage, encodes it as XML and returns the resulting XML
+ * as a string. */
+static char *
+gtk_image_to_xml_attrs( GtkImage * image)
+{
+    GString * xml = g_string_sized_new(32);
+    GtkImageType type = gtk_image_get_storage_type(image);
+    char * attrs;
+    char * imagexml;
+
+    if( type == GTK_IMAGE_STOCK ) {
+        GtkIconSize size;
+        GtkIconSet * iconset;
+        gchar * stockname;
+        GdkPixbuf * pixbuf;
+
+        gtk_image_get_stock(image, &stockname, &size);
+        pixbuf = gtk_widget_render_icon(gui.drawarea, stockname, size, NULL);
+        imagexml = bonobo_ui_util_pixbuf_to_xml(pixbuf);
+        g_string_append_printf(xml, " pixtype=\"pixbuf\" pixname=\"%s\"", imagexml);
+        g_object_unref(pixbuf);
+        g_free(imagexml);
+    } else if( type == GTK_IMAGE_PIXBUF ) {
+        imagexml = bonobo_ui_util_pixbuf_to_xml(gtk_image_get_pixbuf(image));
+        g_string_append_printf(xml, " pixtype=\"pixbuf\" pixname=\"%s\"", imagexml);
+        g_free(imagexml);
+    }
+    attrs = xml->str;
+    g_string_free(xml, FALSE);
+    return( attrs );
+}
+
+
+/* Generate XML which represents Vim's menus and toolbars.  Starts from the
+ * given menu entry.  XML is appended to "xml", and commands/verbs are added
+ * to the "commands" list.  If do_siblings is true, XML is also generated for
+ * the siblings of the given menu (following the menu->next pointer); otherwise
+ * only the menu and its descendents are processed.
+ */
+static
+void generate_gui_xml_recurse( vimmenu_T * menu, GString * xml, GSList ** commands, int do_siblings)
+{
+    GString * normname = g_string_sized_new(16);
+    GString * verbname = g_string_sized_new(32);
+    char_u * label;
+    int use_mnemonic;
+    BonoboUIComponent *uic;
+    gchar * command;
+
+    uic = bonobo_control_get_ui_component (BONOBO_CONTROL (gui.control));
+
+    while( menu ) 
+    {
+        use_mnemonic = (p_wak[0] != 'n' );
+        label = translate_mnemonic_tag( menu->name, use_mnemonic );
+        g_string_assign( normname, "" );
+        g_string_append_normalized_name( normname, menu->dname );
+        if( menu->children ) {
+            if( menu_is_toolbar( menu->name )) {
+                g_string_append( xml, "<dockitem name=\"Toolbar\" look=\"icon\" tips=\"1\">");
+                generate_gui_xml_recurse( menu->children, xml, commands, TRUE );
+                g_string_append( xml, "</dockitem>");
+            } else {
+                g_string_append_printf( xml, "<submenu name=\"%s\" label=\"%s\">\n", normname->str, label);
+
+                generate_gui_xml_recurse( menu->children, xml, commands, TRUE );
+                g_string_append( xml, "</submenu>\n");
+            }
+        } else if( menu_is_separator(menu->name)) {
+            g_string_append( xml, "<separator />\n" );
+        } else if( menu->parent && menu_is_toolbar(menu->parent->name)) {
+            char * menupath = xml_path_for_menu(menu, FALSE);
+            GtkImage *image = NULL;
+            char * imagexml;
+            char_u *tooltip;
+
+            g_string_assign(verbname, "");
+            g_string_append_normalized_name(verbname, menupath);
+            vim_free(menupath);
+            image = GTK_IMAGE(create_menu_icon(menu, GTK_ICON_SIZE_SMALL_TOOLBAR));
+            imagexml = gtk_image_to_xml_attrs(image);
+            tooltip = CONVERT_TO_UTF8(menu->strings[MENU_INDEX_TIP]);
+            g_string_append_printf( xml, "<toolitem name=\"%s\" label=\"%s\" verb=\"%s\" tip=\"%s\" %s />\n", normname->str, label, verbname->str, tooltip, imagexml);
+            gtk_object_sink(GTK_OBJECT(image));
+            g_free(imagexml);
+            CONVERT_TO_UTF8_FREE(tooltip);
+            
+            command = g_strdup_printf( "<cmd name=\"%s\" sensitive=\"%c\" />\n", verbname->str, menu->sensitive ? '1' : '0');
+            *commands = g_slist_prepend( *commands, command );
+            bonobo_ui_component_add_verb(uic, verbname->str, verb_activate, menu);
+        } else if( menu_is_menubar(menu->name)) {
+            char * menupath = xml_path_for_menu(menu, FALSE);
+
+            g_string_assign(verbname, "");
+            g_string_append_normalized_name(verbname, menupath);
+            vim_free(menupath);
+            
+            g_string_append_printf( xml, "<menuitem name=\"%s\" label=\"%s\" verb=\"%s\" />\n", normname->str, label, verbname->str);
+
+            command = g_strdup_printf( "<cmd name=\"%s\" sensitive=\"%c\" />\n", verbname->str, menu->sensitive ? '1' : '0');
+            *commands = g_slist_prepend( *commands, command );
+            bonobo_ui_component_add_verb(uic, verbname->str, verb_activate, menu);
+        }
+        if( label ) {
+            vim_free( label );
+        }
+        if( do_siblings ) {
+            menu = menu->next;
+        } else {
+            menu = NULL;
+        }
+    }
+    g_string_free( normname, TRUE );
+}
+
+/* Create XML representing the menus and toolbars, and send them to the
+ * container application.  We only need to process menu entries which
+ * have changed (they are marked "dirty"). */
+static
+void set_gui_xml(vimmenu_T * menu)
+{
+    GSList * commands = NULL;
+    GSList * command;
+    BonoboUIComponent *uic;
+    GString * xml = g_string_sized_new(1024);
+    int path_exists;
+    uic = bonobo_control_get_ui_component (BONOBO_CONTROL (gui.control));
+
+    if( bonobo_ui_component_get_container(uic) == CORBA_OBJECT_NIL ) {
+        return;
+    }
+
+    while( menu ) {
+        if( menu->dirty ) {
+            if (menu_is_popup(menu->name)) {
+                /* do nothing */            
+            } else if( menu_is_menubar(menu->name)) {
+                char * menupath = xml_path_for_menu(menu, TRUE);
+                path_exists = bonobo_ui_component_path_exists(uic, menupath, NULL);
+                g_string_assign(xml, "");
+                generate_gui_xml_recurse (menu, xml, &commands, FALSE);
+                /*fprintf(stdout, "set %s\n", menupath);*/
+                /*fprintf(stdout, "set %s\n%s", menupath, xml->str);*/
+                /*fflush(stdout);*/
+                bonobo_ui_component_set(uic, menupath, xml->str, NULL);
+                g_free(menupath);
+            } else if( menu_is_toolbar(menu->name)) {
+                char * menupath = xml_path_for_menu(menu, TRUE);
+                path_exists = bonobo_ui_component_path_exists(uic, menupath, NULL);
+                g_string_assign(xml, "");
+                generate_gui_xml_recurse (menu, xml, &commands, FALSE);
+                /*fprintf(stdout, "set %s\n", menupath);*/
+                /*fprintf(stdout, "set %s\n%s", menupath, xml->str);*/
+                /*fflush(stdout);*/
+                bonobo_ui_component_set(uic, menupath, xml->str, NULL);
+                g_free(menupath);
+            }
+            menu->dirty = FALSE;
+        }
+        menu = menu->next;
+    }
+    /* the commands are inserted separately into a list, and set one by one,
+     * otherwise it's not possible to update a subtree of the UI 
+     */
+    command = commands;
+    while( command ) {
+        /*fprintf(stdout, "set %s\n%s", "/commands", command->data);
+        fflush(stdout);*/
+        bonobo_ui_component_set(uic, "/commands", command->data, NULL);
+        g_free(command->data);
+        command = command->next;
+    }
+    g_slist_free( commands );
+}
+
+
+/* remember whether a timeout has been scheduled for updating the gui */
+static gboolean update_gui_idle_installed = FALSE;
+
+/* if we have been embedded in a container, update the gui now, otherwise
+ * wait awhile and try again. */
+static gboolean
+update_gui_idle(gpointer data)
+{
+    BonoboUIComponent *uic;
+
+    uic = bonobo_control_get_ui_component (BONOBO_CONTROL (gui.control));
+    if( bonobo_ui_component_get_container(uic) == CORBA_OBJECT_NIL ) {
+        /* we aren't in a container yet; try again later... */
+        g_timeout_add(100, &update_gui_idle, NULL);
+        return FALSE;
+    }
+    bonobo_ui_component_freeze(uic, NULL);
+    set_gui_xml( (vimmenu_T *)root_menu );
+    update_gui_idle_installed = FALSE;
+    bonobo_ui_component_thaw(uic, NULL);
+    return FALSE; /* don't call me again */
+}
+
+/* Mark the given menu as dirty -- we need to re-send the XML representing
+ * this menu to the container.  But don't do the update immediately; otherwise
+ * we'd be generating the complete UI XML each time a menu entry is added,
+ * which would be very slow.  Instead, schedule an update in which all 
+ * dirty menus will be processed. */
+void
+update_menu_later(vimmenu_T *menu)
+{
+    if (!update_gui_idle_installed)
+    {
+        update_gui_idle_installed = TRUE;
+        g_idle_add_full(GDK_PRIORITY_EVENTS + 10,
+                        &update_gui_idle, NULL, NULL);
+    }
+    while( menu->parent ) 
+        menu = menu->parent;
+    menu->dirty = TRUE;
+}
+
+/* Schedule an update for the entire UI (all menus and toolbars) */
+void update_ui_later()
+{
+    vimmenu_T *menu = root_menu;
+
+    if (!update_gui_idle_installed)
+    {
+        update_gui_idle_installed = TRUE;
+        g_idle_add_full(GDK_PRIORITY_EVENTS + 10,
+                        &update_gui_idle, NULL, NULL);
+    }
+    while( menu ) {
+        menu->dirty = TRUE;
+        menu = menu->next;
+    }
+}
+#endif
+
     void
 gui_mch_add_menu(vimmenu_T *menu, int idx)
 {
+#ifdef FEAT_GUI_COMPONENT
+    update_menu_later(menu);
+    return;
+#else
     vimmenu_T	*parent;
     GtkWidget	*parent_widget;
 
@@ -602,6 +925,7 @@
     if (vim_strchr(p_go, GO_TEAROFF) != NULL)
 	gtk_widget_show(menu->tearoff_handle);
     gtk_menu_prepend(GTK_MENU(menu->submenu_id), menu->tearoff_handle);
+#endif
 }
 
 /*ARGSUSED*/
@@ -618,8 +942,8 @@
 # endif
 
     /* make sure the menu action is taken immediately */
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 # if defined(FEAT_TOOLBAR) && !defined(HAVE_GTK2)
@@ -724,6 +1048,10 @@
     void
 gui_mch_add_menu_item(vimmenu_T *menu, int idx)
 {
+#ifdef FEAT_GUI_COMPONENT
+    update_menu_later(menu);
+    return;
+#else
     vimmenu_T *parent;
 
     parent = menu->parent;
@@ -833,6 +1161,7 @@
 	    gtk_signal_connect(GTK_OBJECT(menu->id), "activate",
 			       GTK_SIGNAL_FUNC(menu_item_activate), menu);
     }
+#endif
 }
 #endif /* FEAT_MENU */
 
@@ -857,6 +1186,10 @@
     guint	accel_key;
 # endif
 
+#ifdef FEAT_GUI_COMPONENT
+    return;
+#endif
+
     for (menu = root_menu; menu != NULL; menu = menu->next)
     {
 	if (menu->id == NULL)
@@ -913,6 +1246,9 @@
     void
 gui_mch_toggle_tearoffs(int enable)
 {
+#ifdef FEAT_GUI_COMPONENT
+    return;
+#endif
     recurse_tearoffs(root_menu, enable);
 }
 #endif /* FEAT_MENU */
@@ -1019,6 +1355,9 @@
     void
 gui_mch_destroy_menu(vimmenu_T *menu)
 {
+#ifdef FEAT_GUI_COMPONENT
+    return;
+#endif
 # ifdef FEAT_TOOLBAR
     if (menu->parent != NULL && menu_is_toolbar(menu->parent->name))
     {
@@ -1160,8 +1499,8 @@
 
     gui_drag_scrollbar(sb, value, dragging);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /* SBAR_VERT or SBAR_HORIZ */
@@ -1220,8 +1559,8 @@
     vw->browse_fname = (char_u *)g_strdup(gtk_file_selection_get_filename(
 					GTK_FILE_SELECTION(vw->filedlg)));
     gtk_widget_hide(vw->filedlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*ARGSUSED*/
@@ -1236,8 +1575,8 @@
 	vw->browse_fname = NULL;
     }
     gtk_widget_hide(vw->filedlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*ARGSUSED*/
@@ -1251,8 +1590,8 @@
     }
     gui.filedlg = NULL;
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 
     return FALSE;
 }
@@ -1335,7 +1674,7 @@
 
     gtk_widget_show(gui.filedlg);
     while (gui.filedlg && GTK_WIDGET_DRAWABLE(gui.filedlg))
-	gtk_main_iteration_do(TRUE);
+	MAIN_ITERATION_DO(TRUE);
 
     if (gui.browse_fname == NULL)
 	return NULL;
@@ -1560,8 +1899,8 @@
 dlg_destroy_cb(int *p)
 {
     *p = TRUE;		/* set dialog_destroyed to break out of the loop */
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /* ARGSUSED */
@@ -1865,7 +2204,7 @@
     /* loop here until the dialog goes away */
     while (dialog_status == -1 && !dialog_destroyed
 					       && GTK_WIDGET_DRAWABLE(dialog))
-	gtk_main_iteration_do(TRUE);
+	MAIN_ITERATION_DO(TRUE);
 
     if (dialog_status < 0)
 	dialog_status = 0;
@@ -2898,8 +3237,8 @@
     CONVERT_FROM_UTF8_FREE(find_text);
 #endif
 
-    if (rc && gtk_main_level() > 0)
-	gtk_main_quit(); /* make sure cmd will be handled immediately */
+    if (rc && MAIN_LEVEL() > 0)
+        MAIN_QUIT(); /* make sure cmd will be handled immediately */
 }
 
 /* our usual callback function */
diff -Nur vim63/src/gui_gtk_x11.c vim63-bonobo/src/gui_gtk_x11.c
--- vim63/src/gui_gtk_x11.c	2004-05-03 11:19:17.000000000 +0200
+++ vim63-bonobo/src/gui_gtk_x11.c	2005-09-09 20:14:02.742583328 +0200
@@ -24,6 +24,7 @@
 #include "vim.h"
 #ifdef FEAT_GUI_GNOME
 /* Gnome redefines _() and N_().  Grrr... */
+#if 0
 # ifdef _
 #  undef _
 # endif
@@ -36,6 +37,7 @@
 # ifdef bindtextdomain
 #  undef bindtextdomain
 # endif
+#endif
 # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
 #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
 # endif
@@ -627,9 +629,10 @@
 expose_event(GtkWidget *widget, GdkEventExpose *event, gpointer data)
 {
     /* Skip this when the GUI isn't set up yet, will redraw later. */
-    if (gui.starting)
+    if (gui.starting) {
+        g_warning("ignoring expose_event; gui still starting.\n");
 	return FALSE;
-
+    }
     out_flush();		/* make sure all output has been processed */
     gui_redraw(event->area.x, event->area.y,
 	       event->area.width, event->area.height);
@@ -670,8 +673,8 @@
 	xev.xproperty.state = PropertyNewValue;
 	serverEventProc(GDK_WINDOW_XDISPLAY(widget->window), &xev);
 
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
+ 	if (MAIN_LEVEL() > 0)
+ 	    MAIN_QUIT();
     }
     return FALSE;
 }
@@ -772,6 +775,10 @@
     if (blink_state == BLINK_NONE)
 	gui_mch_start_blink();
 
+#ifdef FEAT_GUI_COMPONENT
+    /*gtk_plug_grab_focus(GTK_PLUG(gui.plug));*/
+    /*gtk_window_set_focus(GTK_WINDOW(gui.plug), gui.drawarea);*/
+#endif
     /* make sure keyboard input goes there */
     if (gtk_socket_id == 0 || !GTK_WIDGET_HAS_FOCUS(gui.drawarea))
 	gtk_widget_grab_focus(gui.drawarea);
@@ -783,6 +790,11 @@
     static gint
 leave_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
 {
+#ifdef FEAT_GUI_COMPONENT
+    /*gtk_plug_ungrab_focus(GTK_PLUG(gui.plug));*/
+    /*gdk_display_keyboard_ungrab (gtk_widget_get_display (gui.drawarea),
+                                 gtk_get_current_event_time ());*/
+#endif
     if (blink_state != BLINK_NONE)
 	gui_mch_stop_blink();
 
@@ -793,8 +805,16 @@
     static gint
 focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
 {
+    GdkEventMask mask;
     gui_focus_change(TRUE);
 
+#ifdef FEAT_GUI_COMPONENT
+    gtk_widget_grab_focus(gui.drawarea);
+    mask = gdk_window_get_events(gui.drawarea->window);
+    mask |= GDK_KEY_PRESS | GDK_KEY_RELEASE;
+    gdk_window_set_events(gui.drawarea->window, mask);
+#endif
+
     if (blink_state == BLINK_NONE)
 	gui_mch_start_blink();
 
@@ -809,6 +829,9 @@
     static gint
 focus_out_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
 {
+#ifdef FEAT_GUI_COMPONENT
+/*    gtk_plug_ungrab_focus(GTK_PLUG(gui.plug));*/
+#endif
     gui_focus_change(FALSE);
 
     if (blink_state != BLINK_NONE)
@@ -1167,8 +1190,8 @@
     if (p_mh)
 	gui_mch_mousehide(TRUE);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();
 
     return TRUE;
 }
@@ -1203,8 +1226,8 @@
     else
 	clip_lose_selection(&clip_star);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+ 	MAIN_QUIT();
 
     return TRUE;
 }
@@ -1244,9 +1267,8 @@
 	received_selection = RS_FAIL;
 	/* clip_free_selection(cbd); ??? */
 
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
-
+        if (MAIN_LEVEL() > 0)
+            MAIN_QUIT();      /* make sure the above will be handled immediately */
 	return;
     }
 
@@ -1355,8 +1377,8 @@
     g_free(tmpbuf_utf8);
 #endif
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 }
 
 /*
@@ -1538,6 +1560,15 @@
 	using_gnome = 1;
 #endif
 
+
+#ifdef FEAT_GUI_COMPONENT
+    if( !vim_bonobo_init(&gui_argc, gui_argv))
+    {
+        /* in component mode, we don't care about trying to continue without 
+         * a gui; if we can't create the factory, we might as well quit. */
+        mch_exit(2);
+    }
+#else
     /* Don't use gtk_init() or gnome_init(), it exits on failure. */
     if (!gtk_init_check(&gui_argc, &gui_argv))
     {
@@ -1545,10 +1576,29 @@
 	EMSG(_(e_opendisp));
 	return FAIL;
     }
+#endif
 
     return OK;
 }
 
+#if FEAT_GUI_COMPONENT
+static gint
+control_activate_event(BonoboControl *control, gboolean activated)
+{
+    if (activated) 
+    {
+        gui_focus_change (TRUE);
+        if (blink_state == BLINK_NONE)
+            gui_mch_start_blink();
+    } else {
+        gui_focus_change (FALSE);
+        if (blink_state != BLINK_NONE)
+            gui_mch_stop_blink();
+    }
+    return TRUE;
+}
+#endif
+
 
 /****************************************************************************
  * Mouse handling callbacks
@@ -1609,8 +1659,8 @@
     /* inform the editor engine about the occurence of this event */
     gui_send_mouse_event(button, x, y, FALSE, vim_modifiers);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 
     /*
      * Auto repeat timer handling.
@@ -1805,8 +1855,8 @@
 	vim_modifiers |= MOUSE_ALT;
 
     gui_send_mouse_event(button, x, y, repeated_click, vim_modifiers);
-    if (gtk_main_level() > 0)
-	gtk_main_quit(); /* make sure the above will be handled immediately */
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 
     return TRUE;
 }
@@ -1854,8 +1904,8 @@
     gui_send_mouse_event(button, (int)event->x, (int)event->y,
 							FALSE, vim_modifiers);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit(); /* make sure the above will be handled immediately */
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();	/* make sure the above will be handled immediately */
 
     return TRUE;
 }
@@ -1890,8 +1940,8 @@
 	vim_modifiers |= MOUSE_ALT;
 
     gui_send_mouse_event(MOUSE_RELEASE, x, y, FALSE, vim_modifiers);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();	/* make sure it will be handled immediately */
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 
     return TRUE;
 }
@@ -2073,8 +2123,8 @@
     else
 	add_to_input_buf(dropkey + 3, (int)(sizeof(dropkey) - 3));
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 }
 
 /*
@@ -2540,6 +2590,7 @@
     static void
 mainwin_realize(GtkWidget *widget, gpointer data)
 {
+#ifndef FEAT_GUI_COMPONENT
 /* If you get an error message here, you still need to unpack the runtime
  * archive! */
 #ifdef magick
@@ -2623,6 +2674,7 @@
 
 #endif /* !HAVE_GTK2 */
     }
+#endif /* FEAT_GUI_COMPONENT */
 
 #if !(defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION))
     /* Register a handler for WM_SAVE_YOURSELF with GDK's low-level X I/F */
@@ -2641,7 +2693,7 @@
 #endif
 	setup_save_yourself();
 
-#ifdef FEAT_CLIENTSERVER
+#if defined(FEAT_CLIENTSERVER) &&!defined(FEAT_GUI_COMPONENT)
     if (serverName == NULL && serverDelayedStartName != NULL)
     {
 	/* This is a :gui command in a plain vim with no previous server */
@@ -2689,7 +2741,7 @@
     return cursor;
 }
 
-#ifdef HAVE_GTK_MULTIHEAD
+#if defined(HAVE_GTK_MULTIHEAD) && !defined(FEAT_GUI_COMPONENT)
 /*ARGSUSED1*/
     static void
 mainwin_screen_changed_cb(GtkWidget  *widget,
@@ -3014,7 +3066,11 @@
 #ifdef FEAT_GUI_GNOME
 	if (using_gnome)
 	{
-	    gui.mainwin = gnome_app_new("Vim", NULL);
+# if defined(FEAT_GUI_COMPONENT)
+            gui.mainwin = NULL;
+# else
+            gui.mainwin = gnome_app_new("vim", NULL);
+# endif
 # ifdef USE_XSMP
 	    /* Use the GNOME save-yourself functionality now. */
 	    xsmp_close();
@@ -3025,14 +3081,28 @@
 	    gui.mainwin = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     }
 
+#ifdef FEAT_GUI_COMPONENT
+    vbox = gtk_vbox_new(FALSE, 0);
+    gui.vbox = vbox;
+#else
     gtk_widget_set_name(gui.mainwin, "vim-main-window");
+#endif
 
 #ifdef HAVE_GTK2
     /* Create the PangoContext used for drawing all text. */
+#ifdef FEAT_GUI_COMPONENT
+    gui.text_context = gtk_widget_create_pango_context(GTK_WIDGET(gui.vbox));
+#else
     gui.text_context = gtk_widget_create_pango_context(gui.mainwin);
+#endif
     pango_context_set_base_dir(gui.text_context, PANGO_DIRECTION_LTR);
 #endif
 
+#ifdef FEAT_GUI_COMPONENT
+    bonobo_control_construct (BONOBO_CONTROL (gui.control), GTK_WIDGET(gui.vbox));
+    gtk_widget_add_events(GTK_WIDGET(gui.drawarea), GDK_VISIBILITY_NOTIFY_MASK);
+    gtk_widget_show_all(GTK_WIDGET(gui.vbox));
+#else
 #ifndef HAVE_GTK2
     gtk_window_set_policy(GTK_WINDOW(gui.mainwin), TRUE, TRUE, TRUE);
 #endif
@@ -3055,8 +3125,6 @@
     gui.accel_group = gtk_accel_group_get_default();
 #endif
 
-    vbox = gtk_vbox_new(FALSE, 0);
-
 #ifdef FEAT_GUI_GNOME
     if (using_gnome)
     {
@@ -3072,6 +3140,9 @@
 	gtk_container_add(GTK_CONTAINER(gui.mainwin), vbox);
 	gtk_widget_show(vbox);
     }
+#endif
+  
+#ifndef FEAT_GUI_COMPONENT
 
 #ifdef FEAT_MENU
     /*
@@ -3177,6 +3248,7 @@
 	gtk_box_pack_start(GTK_BOX(vbox), gui.toolbar, FALSE, FALSE, 0);
     }
 #endif /* FEAT_TOOLBAR */
+#endif /* FEAT_GUI_COMPONENT */
 
     gui.formwin = gtk_form_new();
     gtk_container_border_width(GTK_CONTAINER(gui.formwin), 0);
@@ -3204,6 +3276,11 @@
     gtk_widget_show(gui.formwin);
     gtk_box_pack_start(GTK_BOX(vbox), gui.formwin, TRUE, TRUE, 0);
 
+#ifdef FEAT_GUI_COMPONENT
+    GTK_WIDGET_SET_FLAGS (gui.drawarea, GTK_CAN_FOCUS);
+    g_signal_connect(G_OBJECT(gui.drawarea), "key_press_event",
+                        G_CALLBACK(key_press_event), NULL);
+#else
     /* For GtkSockets, key-presses must go to the focus widget (drawarea)
      * and not the window. */
     gtk_signal_connect((gtk_socket_id == 0) ? GTK_OBJECT(gui.mainwin)
@@ -3218,6 +3295,7 @@
 		     "key_release_event",
 		     G_CALLBACK(&key_release_event), NULL);
 #endif
+#endif /* FEAT_GUI_COMPONENT */
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "realize",
 		       GTK_SIGNAL_FUNC(drawarea_realize_cb), NULL);
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "unrealize",
@@ -3252,16 +3330,27 @@
      */
     gui.border_offset = gui.border_width;
 
+#ifdef FEAT_GUI_COMPONENT
+    gtk_signal_connect(GTK_OBJECT(gui.drawarea), "visibility_notify_event",
+		       GTK_SIGNAL_FUNC(visibility_event), NULL);
+#else
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "visibility_notify_event",
 		       GTK_SIGNAL_FUNC(visibility_event), NULL);
+#endif
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "expose_event",
 		       GTK_SIGNAL_FUNC(expose_event), NULL);
 
     /*
      * Only install these enter/leave callbacks when 'p' in 'guioptions'.
      * Only needed for some window managers.
+     *
+     * Force this on for bonobo, otherwise the toolbar gets the focus 
+     * after you click a button, and you can't get the focus back to the 
+     * drawarea.
      */
+#ifndef FEAT_GUI_COMPONENT
     if (vim_strchr(p_go, GO_POINTER) != NULL)
+#endif
     {
 	gtk_signal_connect(GTK_OBJECT(gui.drawarea), "leave_notify_event",
 			   GTK_SIGNAL_FUNC(leave_notify_event), NULL);
@@ -3269,10 +3358,19 @@
 			   GTK_SIGNAL_FUNC(enter_notify_event), NULL);
     }
 
+#ifdef FEAT_GUI_COMPONENT
+    g_signal_connect(G_OBJECT(gui.control), "activate",
+		     G_CALLBACK (control_activate_event), NULL);
+    gtk_signal_connect(GTK_OBJECT(gui.drawarea), "focus_out_event",
+			   GTK_SIGNAL_FUNC(focus_out_event), NULL);
+    gtk_signal_connect(GTK_OBJECT(gui.drawarea), "focus_in_event",
+			   GTK_SIGNAL_FUNC(focus_in_event), NULL);
+#else	
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "focus_out_event",
 			   GTK_SIGNAL_FUNC(focus_out_event), NULL);
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "focus_in_event",
 			   GTK_SIGNAL_FUNC(focus_in_event), NULL);
+#endif
 
     gtk_signal_connect(GTK_OBJECT(gui.drawarea), "motion_notify_event",
 		       GTK_SIGNAL_FUNC(motion_notify_event), NULL);
@@ -3445,7 +3543,7 @@
      * otherwise the hints don't work. */
     width  = gui_get_base_width();
     height = gui_get_base_height();
-# ifdef HAVE_GTK2
+# if defined( HAVE_GTK2 ) && !defined(FEAT_GUI_COMPONENT)
     width  += get_menu_tool_width();
     height += get_menu_tool_height();
 # endif
@@ -3492,8 +3590,18 @@
 form_configure_event(GtkWidget *widget, GdkEventConfigure *event,
 		     gpointer data)
 {
+    int height;
+
     gtk_form_freeze(GTK_FORM(gui.formwin));
-    gui_resize_shell(event->width, event->height);
+#ifdef FEAT_GUI_COMPONENT
+    /* width_inc and height_inc (see window manager hints, above) aren't
+     * respected for embedded controls, so we have to make a slight adjustment
+     * to make sure the bottom line doesn't get clipped. */
+    height = gui.char_height * ((event->height - 2 )/ gui.char_height);
+#else
+    height = event->height;
+#endif
+    gui_resize_shell(event->width, height);
     gtk_form_thaw(GTK_FORM(gui.formwin));
 
     return TRUE;
@@ -3625,8 +3733,10 @@
      * changed them). */
     highlight_gui_started();	/* re-init colors and fonts */
 
+#ifndef FEAT_GUI_COMPONENT
     gtk_signal_connect(GTK_OBJECT(gui.mainwin), "destroy",
 		       GTK_SIGNAL_FUNC(mainwin_destroy_cb), NULL);
+#endif
 
 #ifdef FEAT_HANGULIN
     hangul_keyboard_set();
@@ -3694,7 +3804,9 @@
 						  NULL);
 # endif
 #endif
-	gtk_widget_show(gui.mainwin);
+#ifndef FEAT_GUI_COMPONENT
+        gtk_widget_show(gui.mainwin);
+#endif
 
 #if defined(FEAT_GUI_GNOME) && defined(HAVE_GTK2) && defined(FEAT_MENU)
 	if (menu_handler != 0)
@@ -3724,8 +3836,8 @@
     if (gui.mainwin != NULL)
 	gtk_widget_destroy(gui.mainwin);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();	/* make sure the above will be handled immediately */
 }
 
 /*
@@ -3778,6 +3890,7 @@
     static gboolean
 force_shell_resize_idle(gpointer data)
 {
+    g_warning("force_shell_resize_idle called!");
     if (gui.mainwin != NULL
 	    && GTK_WIDGET_REALIZED(gui.mainwin)
 	    && GTK_WIDGET_VISIBLE(gui.mainwin))
@@ -3827,7 +3940,7 @@
     /* this will cause the proper resizement to happen too */
     update_window_manager_hints();
 
-#ifdef HAVE_GTK2
+#if defined( HAVE_GTK2 ) && !defined(FEAT_GUI_COMPONENT)
     /* With GTK+ 2, changing the size of the form widget doesn't resize
      * the window.  So lets do it the other way around and resize the
      * main window instead. */
@@ -3916,6 +4029,7 @@
 {
     GtkWidget *widget;
 
+#ifndef FEAT_GUI_COMPONENT
 # ifdef FEAT_GUI_GNOME
     if (using_gnome)
 	widget = gui.menubar_h;
@@ -3932,6 +4046,7 @@
 
 	update_window_manager_hints();
     }
+#endif
 }
 #endif /* FEAT_MENU */
 
@@ -3983,8 +4098,8 @@
 
     vw->fontname = (char_u *)gtk_font_selection_dialog_get_font_name(fs);
     gtk_widget_hide(vw->fontdlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 }
 
 /*ARGSUSED*/
@@ -3994,8 +4109,8 @@
     gui_T *vw = (gui_T *)cbdata;
 
     gtk_widget_hide(vw->fontdlg);
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 }
 
 /*ARGSUSED*/
@@ -4005,8 +4120,8 @@
     gui_T *vw = (gui_T *)cbdata;
 
     vw->fontdlg = NULL;
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 }
 #endif /* !HAVE_GTK2 */
 
@@ -4173,7 +4288,7 @@
 
     /* Wait for the font dialog to be closed. */
     while (gui.fontdlg && GTK_WIDGET_DRAWABLE(gui.fontdlg))
-	gtk_main_iteration_do(TRUE);
+	MAIN_ITERATION_DO(TRUE);
 
     if (gui.fontname != NULL)
     {
@@ -5727,8 +5842,13 @@
     void
 gui_mch_update(void)
 {
+#ifdef FEAT_GUI_COMPONENT
+    if( gui.processing_call ) {
+        return;
+    }
+#endif
     while (gtk_events_pending() && !vim_is_input_buf_full())
-	gtk_main_iteration_do(FALSE);
+        MAIN_ITERATION_DO(TRUE);
 }
 
     static gint
@@ -5739,8 +5859,8 @@
     /* Just inform the caller about the occurence of it */
     *timed_out = TRUE;
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+        MAIN_QUIT();      /* make sure the above will be handled immediately */
 
     return FALSE;		/* don't happen again */
 }
@@ -5760,8 +5880,8 @@
 
     add_to_input_buf(bytes, 3);
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 #endif
 
@@ -5828,7 +5948,7 @@
 	/*
 	 * Loop in GTK+ processing  until a timeout or input occurs.
 	 */
-	gtk_main();
+	MAIN();
 
 	/* Got char, return immediately */
 	if (input_available())
@@ -5903,6 +6023,7 @@
 	gdk_window_clear(gui.drawarea->window);
 }
 
+
 /*
  * Redraw any text revealed by scrolling up/down.
  */
@@ -6017,7 +6138,7 @@
 			      (guint32)GDK_CURRENT_TIME);
 
 	while (received_selection == RS_NONE)
-	    gtk_main();	/* wait for selection_received_cb */
+	    MAIN();     /* wait for selection_received_cb */
 
 	if (received_selection != RS_FAIL)
 	    return;
@@ -6085,6 +6206,13 @@
     void
 gui_mch_menu_grey(vimmenu_T *menu, int grey)
 {
+#ifdef FEAT_GUI_COMPONENT
+    if( menu->sensitive != !grey ) {
+        menu->sensitive = !grey;
+        update_menu_later(menu);
+    }
+    return;
+#endif
     if (menu->id == NULL)
 	return;
 
@@ -6222,6 +6350,40 @@
 static int last_shape = 0;
 #endif
 
+#if 0
+static BonoboWindow *
+bonobo_create_window(void)
+{
+    BonoboWindow      *win;
+    BonoboUIContainer *ui_container;
+    BonoboUIComponent *ui_component;
+                                                                                
+    win = BONOBO_WINDOW (bonobo_window_new ("vim", "vim"));                                                                                
+    ui_container = bonobo_window_get_ui_container (win);
+    bonobo_ui_engine_config_set_path (bonobo_window_get_ui_engine (win),
+                      "/gnome-vim/UIConfig/kvps");
+                                                                                
+    /* Create a UI component with which to communicate with the window */
+    ui_component = bonobo_ui_component_new_default ();
+
+    gui.component = ui_component;
+                                                                                
+    /* Associate the BonoboUIComponent with the container */
+    bonobo_ui_component_set_container (
+        ui_component, BONOBO_OBJREF (ui_container), NULL);
+                                                                                
+    //bonobo_ui_util_set_ui (ui_component, "", 
+                   //HELLO_SRCDIR HELLO_UI_XML,
+                   //"bonobo-hello", NULL);
+                                                                                
+    /* Associate our verb -> callback mapping with the BonoboWindow */
+    /* All the callback's user_data pointers will be set to 'win' */
+    //bonobo_ui_component_add_verb_list_with_data (ui_component, hello_verbs, win);
+                                                                                
+    return win;
+}
+#endif
+
 /*
  * Use the blank mouse pointer or not.
  *
diff -Nur vim63/src/gui.h vim63-bonobo/src/gui.h
--- vim63/src/gui.h	2005-09-09 20:11:10.563758000 +0200
+++ vim63-bonobo/src/gui.h	2005-09-09 20:14:02.734584544 +0200
@@ -52,6 +52,22 @@
 # include <gtk/gtk.h>
 #endif
 
+# if defined(FEAT_GUI_GNOME) && defined(FEAT_GUI_COMPONENT)
+    #include "libbonoboui.h"
+    #include "vim_bonobo_main.h"
+    #include "vim_bonobo_factory.h"
+    #define MAIN vim_bonobo_main
+    #define MAIN_LEVEL vim_bonobo_main_level
+    #define MAIN_QUIT vim_bonobo_main_quit
+    #define MAIN_ITERATION_DO vim_bonobo_main_iteration_do
+    #define NO_CONSOLE
+# else
+    #define MAIN gtk_main
+    #define MAIN_LEVEL gtk_main_level
+    #define MAIN_QUIT gtk_main_quit
+    #define MAIN_ITERATION_DO gtk_main_iteration_do
+#endif
+
 #ifdef FEAT_GUI_BEOS
 # include "gui_beos.h"
 #endif
@@ -427,6 +443,14 @@
     GtkWidget	*toolbar;	    /* toolbar */
 # endif
 # ifdef FEAT_GUI_GNOME
+#  ifdef FEAT_GUI_COMPONENT
+    GtkWidget     *vbox;
+    BonoboPlug    *plug;
+    BonoboControl *control;
+    BonoboPersistStream * pstream;
+    BonoboPersistFile * pfile;
+    int		 processing_call;   /* gui loop is handling a call */
+#  endif
     GtkWidget	*menubar_h;	    /* menubar handle */
     GtkWidget	*toolbar_h;	    /* toolbar handle */
 # endif
diff -Nur vim63/src/main.c vim63-bonobo/src/main.c
--- vim63/src/main.c	2005-09-09 20:11:10.571757000 +0200
+++ vim63-bonobo/src/main.c	2005-09-09 20:19:37.444700872 +0200
@@ -79,7 +79,7 @@
 # ifdef VIMDLL
 _export
 # endif
-# ifdef FEAT_GUI_MSWIN
+# if defined(FEAT_GUI_MSWIN)
 #  ifdef __BORLANDC__
 _cdecl
 #  endif
@@ -244,8 +244,12 @@
     TIME_MSG("locale set");
 #endif
 
-#ifdef FEAT_GUI
+#if defined(FEAT_GUI_COMPONENT)
+    gui.dofork = FALSE;		    /* don't use fork when running as component */
+#else
+# if defined(FEAT_GUI) && !defined(FEAT_GUI_COMPONENT)
     gui.dofork = TRUE;		    /* default is to use fork() */
+# endif
 #endif
 
 #if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER)
@@ -444,6 +448,10 @@
 	++initstr;
     }
 
+#ifdef FEAT_GUI_COMPONENT
+    main_start_gui();
+#endif
+
     if (TOLOWER_ASC(initstr[0]) == 'g' || initstr[0] == 'k')
     {
 	main_start_gui();
@@ -1679,6 +1687,7 @@
      * Call settmode and starttermcap here, so the T_KS and T_TI may be
      * defined by termcapinit and redifined in .exrc.
      */
+#ifndef FEAT_GUI_COMPONENT
     settmode(TMODE_RAW);
     TIME_MSG("setting raw mode");
 
@@ -1687,6 +1696,7 @@
 	wait_return(TRUE);
 	TIME_MSG("waiting for return");
     }
+#endif
 
     starttermcap();	    /* start termcap if not done by wait_return() */
     TIME_MSG("start termcap");
@@ -1815,6 +1825,9 @@
 	curwin = firstwin;
 	curbuf = curwin->w_buffer;
 #endif
+#ifdef FEAT_GUI_COMPONENT
+	persistent_buffer = curbuf;
+#endif
     }
     TIME_MSG("opening buffers");
 
diff -Nur vim63/src/Make_container.mak vim63-bonobo/src/Make_container.mak
--- vim63/src/Make_container.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/Make_container.mak	2005-09-09 20:14:02.692590928 +0200
@@ -0,0 +1,11 @@
+gnomeccFlags = `pkg-config --cflags libgnomeui-2.0 libgnome-2.0`
+ccFlags = -g -c ${gnomeccFlags}
+ldFlags = `pkg-config --libs libgnomeui-2.0 libgnome-2.0`
+
+all: container
+
+container: container.o
+	gcc -o container ${ldFlags} container.o
+
+%.o: %.c
+	gcc ${ccFlags} $< -o $@
diff -Nur vim63/src/Makefile vim63-bonobo/src/Makefile
--- vim63/src/Makefile	2005-09-09 20:11:10.529763000 +0200
+++ vim63-bonobo/src/Makefile	2005-09-09 20:14:02.695590472 +0200
@@ -1103,6 +1103,18 @@
 GTK_MAN_TARGETS = installghelplinks
 GTK_TESTTARGET = gui
 
+### Bonobo GUI
+BONOBO_SRC	= $(GTK_SRC)
+BONOBO_OBJ	= $(GTK_OBJ)
+BONOBO_DEFS	= $(GTK_DEFS) 
+BONOBO_IPATH	= $(GTK_IPATH)
+BONOBO_LIBS_DIR	=  $(GTK_LIBS_DIR)
+BONOBO_LIBS1	= $(GTK_LIBS1)
+BONOBO_LIBS2	=  $(GTK_LIBS2)
+BONOBO_TARGETS	=  $(GTK_TARGETS) vim-factory
+BONOBO_MAN_TARGETS =  $(GTK_MAN_TARGETS)
+BONOBO_TESTTARGET =  $(GTK_TESTTARGET)
+
 ### Motif GUI
 MOTIF_SRC	= gui.c gui_motif.c gui_x11.c pty.c gui_beval.c
 MOTIF_OBJ	= objects/gui.o objects/gui_motif.o objects/gui_x11.o \
@@ -1385,6 +1397,10 @@
 	objects/fileio.o \
 	objects/fold.o \
 	objects/getchar.o \
+        objects/gtkhtml_editor.o \
+        objects/gtkhtml_editor_common.o \
+        objects/gtkhtml_editor_skels.o \
+        objects/gtkhtml_editor_stubs.o \
 	$(HANGULIN_OBJ) \
 	objects/if_cscope.o \
 	objects/if_xcmdsrv.o \
@@ -1413,6 +1429,9 @@
 	objects/term.o \
 	objects/ui.o \
 	objects/undo.o \
+ 	objects/vim_bonobo_main.o \
+ 	objects/vim_bonobo_factory.o \
+ 	objects/vim_bonobo_control.o \
 	objects/window.o \
 	$(GUI_OBJ) \
 	$(PERL_OBJ) \
@@ -1422,7 +1441,7 @@
 	$(OS_EXTRA_OBJ) \
 	$(WORKSHOP_OBJ) \
 	$(NETBEANS_OBJ) \
-	$(WSDEBUG_OBJ)
+ 	$(WSDEBUG_OBJ)
 
 PRO_AUTO = \
 	buffer.pro \
@@ -1480,7 +1499,7 @@
 	os_mswin.pro os_beos.pro os_vms.pro os_riscos.pro $(PERL_PRO)
 
 # Default target is making the executable and tools
-all: $(VIMTARGET) $(TOOLS) languages
+all: $(VIMTARGET) $(TOOLS) $(EXTRA_TARGETS) languages
 
 tools: $(TOOLS)
 
@@ -1658,6 +1677,10 @@
 testclean:
 	cd testdir; $(MAKE) -f Makefile clean
 
+vim-factory: objects/vim_proxy_factory.o
+	gcc -o vim-factory $(ALL_LIB_DIRS) $(LDFLAGS) objects/vim_proxy_factory.o $(ALL_LIBS)
+
+
 #
 # Avoid overwriting an existing executable, somebody might be running it and
 # overwriting it could cause it to crash.  Deleting it is OK, it won't be
@@ -1684,6 +1707,23 @@
 # may create a link to the new executable from /usr/bin/vi
 	-$(LINKIT)
 
+Vim_Control.server: Vim_Control.server.in auto/config.mk
+	rm -f Vim_Control.server Vim_Control.server.tmp
+	sed -e 's,@DEST_BIN\@,$(DEST_BIN),g' \
+	    -e 's,@VIMNAME\@,$(VIMNAME),g' \
+		Vim_Control.server.in >Vim_Control.server.tmp
+	mv Vim_Control.server.tmp Vim_Control.server
+
+installbonobo: installvimbin
+# 	install factory to destbin
+	$(INSTALL_PROG) vim-factory $(DEST_BIN)
+	$(STRIP) $(DEST_BIN)/vim-factory
+	
+# 	install server file to /usr/lib/bonobo/servers (modulo prefix)
+	-$(SHELL) ./mkinstalldirs $(DESTDIR)$(prefix)/lib/bonobo/servers
+	$(INSTALL_PROG) Vim_Control.server $(DESTDIR)$(prefix)/lib/bonobo/servers
+
+
 # install the help files; first adjust the contents for the location
 installruntime: $(HELPSOURCE)/vim.1 $(DEST_MAN) $(DEST_VIM) $(DEST_RT) \
 		$(DEST_HELP) $(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND) \
@@ -2078,6 +2118,7 @@
 	if test -d $(PODIR); then \
 		cd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) clean; \
 	fi
+	-rm -f Vim_Control.server vim-factory vim-component
 
 # Make a shadow directory for compilation on another system or with different
 # features.
@@ -2285,6 +2326,18 @@
 objects/gui_mac.o: gui_mac.c
 	$(CCC) -o $@ gui_mac.c
 
+objects/gtkhtml_editor.o: gtkhtml_editor.c
+	$(CCC) -o $@ gtkhtml_editor.c
+
+objects/gtkhtml_editor_common.o: gtkhtml_editor_common.c
+	$(CCC) -o $@ gtkhtml_editor_common.c
+
+objects/gtkhtml_editor_skels.o: gtkhtml_editor_skels.c
+	$(CCC) -o $@ gtkhtml_editor_skels.c
+
+objects/gtkhtml_editor_stubs.o: gtkhtml_editor_stubs.c
+	$(CCC) -o $@ gtkhtml_editor_stubs.c
+
 objects/hangulin.o: hangulin.c
 	$(CCC) -o $@ hangulin.c
 
@@ -2408,6 +2461,18 @@
 objects/undo.o: undo.c
 	$(CCC) -o $@ undo.c
 
+objects/vim_bonobo_control.o: vim_bonobo_control.c
+	$(CCC) -o $@ vim_bonobo_control.c
+
+objects/vim_bonobo_factory.o: vim_bonobo_factory.c
+	$(CCC) -o $@ vim_bonobo_factory.c
+
+objects/vim_bonobo_main.o: vim_bonobo_main.c
+	$(CCC) -o $@ vim_bonobo_main.c
+
+objects/vim_proxy_factory.o: vim_proxy_factory.c
+	$(CCC) -o $@ vim_proxy_factory.c
+
 objects/window.o: window.c
 	$(CCC) -o $@ window.c
 
diff -Nur vim63/src/mbyte.c vim63-bonobo/src/mbyte.c
--- vim63/src/mbyte.c	2005-09-09 20:11:10.575756000 +0200
+++ vim63-bonobo/src/mbyte.c	2005-09-09 20:14:02.751581960 +0200
@@ -3382,8 +3382,8 @@
     /* This flag is used in changed() at next call. */
     xim_changed_while_preediting = TRUE;
 
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*
@@ -4515,7 +4515,11 @@
 	    if (gui.fontset != NOFONTSET
 		    && gui.fontset->type == GDK_FONT_FONTSET)
 	    {
+#ifdef FEAT_GUI_COMPONENT
+		widget = gui.drawarea;
+#else
 		widget = gui.mainwin;
+#endif
 		gdk_window_get_size(widget->window, &width, &height);
 
 		attrmask |= (int)GDK_IC_STATUS_AREA;
@@ -5121,9 +5125,15 @@
 	while (event_queue != NULL && processing_queued_event)
 	{
 	    GdkEvent *ev = event_queue->data;
-
+            GtkWidget *output;
+            
 	    gboolean *ret;
-	    gtk_signal_emit_by_name((GtkObject*)gui.mainwin, "key_press_event",
+#ifdef FEAT_GUI_COMPONENT
+            output = gui.drawarea;
+#else
+            output = gui.mainwin;
+#endif
+	    gtk_signal_emit_by_name((GtkObject*)output, "key_press_event",
 								    ev, &ret);
 	    gdk_event_free(ev);
 	    event_queue = event_queue->next;
@@ -5135,8 +5145,8 @@
 	    key_press_event_queue = NULL;
 	}
     }
-    if (gtk_main_level() > 0)
-	gtk_main_quit();
+    if (MAIN_LEVEL() > 0)
+	MAIN_QUIT();
 }
 
 /*
@@ -5292,7 +5302,11 @@
 	GtkWidget	*widget = gui.drawarea;
 
 	attr->style = (GdkIMStyle)xim_input_style;
+#ifdef FEAT_GUI_COMPONENT
+	attr->client_window = gui.drawarea->window;
+#else
 	attr->client_window = gui.mainwin->window;
+#endif
 
 	if ((colormap = gtk_widget_get_colormap(widget)) !=
 	    gtk_widget_get_default_colormap())
@@ -5339,7 +5353,11 @@
 	    }
 	    else
 	    {
+#ifdef FEAT_GUI_COMPONENT
+		gdk_window_get_size(gui.drawarea->window, &width, &height);
+#else
 		gdk_window_get_size(gui.mainwin->window, &width, &height);
+#endif
 		attrmask |= (int)GDK_IC_STATUS_AREA_REQ;
 		attr->status_area.x = 0;
 		attr->status_area.y = height - gui.char_height - 1;
diff -Nur vim63/src/misc1.c vim63-bonobo/src/misc1.c
--- vim63/src/misc1.c	2005-09-09 20:11:10.581755000 +0200
+++ vim63-bonobo/src/misc1.c	2005-09-09 20:14:02.756581200 +0200
@@ -2371,6 +2371,11 @@
 #ifdef FEAT_TITLE
 	need_maketitle = TRUE;	    /* set window title later */
 #endif
+#if defined(FEAT_GUI_COMPONENT)
+        if( curbuf == persistent_buffer) {
+            component_set_dirty(TRUE);
+        }
+#endif
     }
     ++curbuf->b_changedtick;
     ++global_changedtick;
@@ -2710,6 +2715,11 @@
 #ifdef FEAT_TITLE
 	need_maketitle = TRUE;	    /* set window title later */
 #endif
+#if defined(FEAT_GUI_COMPONENT)
+        if( curbuf == persistent_buffer) {
+            component_set_dirty(FALSE);
+        }
+#endif
     }
     ++buf->b_changedtick;
     ++global_changedtick;
diff -Nur vim63/src/quote vim63-bonobo/src/quote
--- vim63/src/quote	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/quote	2005-09-09 20:14:02.757581048 +0200
@@ -0,0 +1,7 @@
+function! Quote()
+normal msHmt
+%g/^GtkHTML_QUOTE_ON/.,/GtkHTML_QUOTE_OFF/s/^/> /
+%g/^> GtkHTML_QUOTE_ON/d
+%g/^> GtkHTML_QUOTE_OFF/d
+normal 'tzt's
+endfunction
diff -Nur vim63/src/structs.h vim63-bonobo/src/structs.h
--- vim63/src/structs.h	2005-09-09 20:11:10.607751000 +0200
+++ vim63-bonobo/src/structs.h	2005-09-09 20:14:02.759580744 +0200
@@ -1084,6 +1084,10 @@
     char_u	*b_p_bh;	/* 'bufhidden' */
     char_u	*b_p_bt;	/* 'buftype' */
 #endif
+#if defined(FEAT_GUI_COMPONENT)
+    int         emb_buffer;     /* this buffer is associated with the container application,
+                                   and cannot be removed */
+#endif
     int		b_p_bl;		/* 'buflisted' */
 #ifdef FEAT_CINDENT
     int		b_p_cin;	/* 'cindent' */
@@ -1281,6 +1285,9 @@
     int		b_was_netbeans_file;/* TRUE if b_netbeans_file was once set */
 #endif
 
+#if defined(FEAT_GUI_COMPONENT) && defined(FEAT_GUI_GNOME)
+    pos_T	b_saved_cursor_pos;	/* start pos of last VIsual */
+#endif
 };
 
 /*
@@ -1773,8 +1780,11 @@
     GtkWidget	*tearoff_handle;
     GtkWidget   *label;		    /* Used by "set wak=" code. */
 #endif
-#ifdef FEAT_GUI_MOTIF
+#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_COMPONENT)
     int		sensitive;	    /* turn button on/off */
+#if defined(FEAT_GUI_COMPONENT)
+    int         dirty;              /* menu item has been updated; container needs to know */
+#endif
 #endif
 #if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MOTIF)
     Pixmap	image;		    /* Toolbar image */
diff -Nur vim63/src/undo.c vim63-bonobo/src/undo.c
--- vim63/src/undo.c	2004-04-05 20:23:45.000000000 +0200
+++ vim63-bonobo/src/undo.c	2005-09-09 20:14:02.760580592 +0200
@@ -764,6 +764,7 @@
 #endif
 }
 
+
 /*
  * u_sync: stop adding to the current entry list
  */
diff -Nur vim63/src/vim_bonobo_control.c vim63-bonobo/src/vim_bonobo_control.c
--- vim63/src/vim_bonobo_control.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_control.c	2005-09-09 20:14:02.763580136 +0200
@@ -0,0 +1,612 @@
+/**
+ * vim_bonobo_control.c
+ *
+ * Author:
+ *   Jason Hildebrand <jason@peaceworks.ca>
+ *
+ */
+#include <stdio.h>
+
+#include "vim.h"
+#include "vim_bonobo_control.h"
+#include "gtkhtml_editor.h"
+
+#include <gnome.h>
+#include <libbonoboui.h>
+#include <libbonobo.h>
+/*#include <libnautilus/nautilus-view.h>*/
+#include <X11/Intrinsic.h>
+#include <X11/Xatom.h>
+#include <gdk/gdkx.h>
+
+struct _VimControlPrivate {
+    BonoboUIComponent *component;
+};
+
+static GObjectClass *vim_control_parent_class;
+
+static gboolean
+quit_vim(gpointer data)
+{
+    getout_preserve_modified(0);
+}
+
+static void
+vim_control_destroy (BonoboObject *control)
+{
+	BonoboUIComponent *uic;
+
+	g_return_if_fail (control != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (control));
+
+    g_message ("Destroying VimControl...");
+
+	uic = bonobo_control_get_ui_component (BONOBO_CONTROL (control));
+    if( uic != CORBA_OBJECT_NIL )
+        bonobo_ui_component_unset_container (uic, NULL);
+
+	BONOBO_OBJECT_CLASS (vim_control_parent_class)->destroy (control);
+
+    /* we only support creating one vim control per process, so when this one
+     * is finished, we're done. */ 
+    g_timeout_add(50, &quit_vim, NULL);
+}
+
+static void
+vim_control_finalize (GObject *object)
+{
+	VimControl *control;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (object));
+
+	control = VIM_CONTROL (object);
+
+	g_free (control->priv);
+
+	G_OBJECT_CLASS (vim_control_parent_class)->finalize (object);
+}
+
+static void
+vim_control_set_ui_container (VimControl *control,
+			      Bonobo_UIContainer ui_container)
+{
+	BonoboUIComponent *uic;
+	
+	g_return_if_fail (control != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (control));
+	g_return_if_fail (ui_container != CORBA_OBJECT_NIL);
+
+	uic = bonobo_control_get_ui_component (BONOBO_CONTROL (control));
+	bonobo_ui_component_set_container (uic, ui_container, NULL);
+
+    /* schedule a UI update */
+    update_ui_later();
+}
+
+static void
+vim_control_unset_ui_container (VimControl *control)
+{
+	BonoboUIComponent *uic;
+
+	g_return_if_fail (control != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (control));
+
+	uic = bonobo_control_get_ui_component (BONOBO_CONTROL (control));
+	bonobo_ui_component_unset_container (uic, NULL);
+}
+
+static grab_keys = 0;
+
+#if 0
+static GdkFilterReturn
+filter_key_events (GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
+{
+ /* GdkScreen *screen = gdk_drawable_get_screen (event->any.window);
+  GdkDisplay *display = gdk_screen_get_display (screen);*/
+  XEvent *xevent = (XEvent *)gdk_xevent;
+                                                                                
+  GdkFilterReturn return_val;
+                                                                                
+  return_val = GDK_FILTER_CONTINUE;
+                                                                                
+  switch (xevent->type)
+  {
+      case KeyPress:
+        g_warning("Key press!");
+        break;
+
+      case KeyRelease:
+        g_warning("Key release!");
+        break;
+
+      default:
+        break;
+  }
+  return return_val;
+}
+#endif
+
+static void
+set_frame_cb (BonoboControl *object, gpointer data)
+{
+    Bonobo_ControlFrame frame;
+	VimControl *control;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (VIM_IS_CONTROL (object));
+
+    frame = bonobo_control_get_control_frame (object, NULL);
+    if (frame == CORBA_OBJECT_NIL)
+        return;
+    CORBA_Object_release (frame, NULL);
+
+	control = VIM_CONTROL (object);
+
+    Bonobo_UIContainer ui_container;
+
+    ui_container = bonobo_control_get_remote_ui_container (BONOBO_CONTROL (control), NULL);
+    if (ui_container != CORBA_OBJECT_NIL) {
+        vim_control_set_ui_container (control, ui_container);
+        bonobo_object_release_unref (ui_container, NULL);
+    }
+
+}
+
+static void
+embedded_cb (GtkPlug *plug)
+{
+    Atom     wm_class;
+    Atom     actual_type;
+    int        actual_format;
+    unsigned long actual_length;
+    unsigned long remaining_bytes;
+    unsigned char * wm_class_value;
+    Window   win;
+    Window   root;
+    Window   parent;
+    Window * children = NULL;
+    unsigned int nchildren;
+    int     result;
+
+    wm_class = gdk_x11_get_xatom_by_name("WM_CLASS");
+    win = GDK_WINDOW_XID(plug->socket_window);
+
+    while( TRUE ) {
+        /*g_warning("checking xid %d", win);*/
+        result = XGetWindowProperty (GDK_WINDOW_XDISPLAY (plug->socket_window), 
+                            win, 
+                            wm_class, 0, 120, False, XA_STRING, 
+                            &actual_type, &actual_format,
+                  &actual_length, &remaining_bytes, &wm_class_value);
+        if( result == Success && actual_type != None) {
+            /*g_warning("WM_CLASS is %s", wm_class_value);*/
+            apply_autocmds(EVENT_EMBEDDED_COMPONENT, wm_class_value, NULL, FALSE, persistent_buffer);
+            XFree(wm_class_value);         
+            break;
+        }
+        gdk_error_trap_push ();
+        result = XQueryTree(GDK_WINDOW_XDISPLAY(plug->socket_window),
+                       win,
+                       &root, &parent, &children, &nchildren);
+        if (gdk_error_trap_pop () || !result) {
+            break;
+        }
+        if( children ) {
+            XFree(children);
+            children = NULL;
+        }
+        if( root == parent) {
+            /* we've reached the root window */
+            break;
+        }
+        win = parent;
+    }
+}
+
+static void
+vim_control_class_init (VimControl *klass)
+{
+	GObjectClass *gobject_class = (GObjectClass *)klass;
+	BonoboObjectClass *bonobo_object_class = (BonoboObjectClass *)klass;
+	BonoboControlClass *control_class = (BonoboControlClass *)klass;
+
+	vim_control_parent_class= g_type_class_peek_parent (klass);
+
+	bonobo_object_class->destroy = vim_control_destroy;
+	gobject_class->finalize = vim_control_finalize;
+}
+
+static char_u * stream_buffer = NULL;
+static int stream_offset = 0;
+static CORBA_long  stream_length = 0;
+static Bonobo_Stream current_stream;
+
+/* It seems like it is an error to attempt to read more data
+ * than is available from a bonobo stream.  So we slurp in
+ * the entire file in one chunk, and then pass it back in 
+ * pieces to the caller. 
+ */
+int
+vim_control_persist_stream_read(char_u * buffer, int reqsize)
+{
+    int read_size;
+
+    if( stream_offset >= stream_length ) {
+        return 0;
+    }
+    read_size = stream_length - stream_offset >= reqsize ? 
+                    reqsize : stream_length - stream_offset;
+    mch_memmove(buffer, &stream_buffer[stream_offset], read_size);
+    stream_offset += read_size;
+    return read_size;
+}
+
+int
+vim_control_persist_stream_write(char_u * buffer, int reqsize)
+{
+    CORBA_Environment ev;
+
+    CORBA_exception_init(&ev);
+    bonobo_stream_client_write(current_stream, buffer, reqsize, &ev);
+	if (ev._major != CORBA_NO_EXCEPTION ) {
+        g_warning("Error writing to stream");
+		CORBA_exception_free (&ev);
+        return 0;
+	}
+    CORBA_exception_free (&ev);
+    return reqsize;
+}
+
+void
+component_set_dirty(gboolean dirty)
+{
+    bonobo_persist_set_dirty(BONOBO_PERSIST(gui.pstream), dirty);
+    bonobo_persist_set_dirty(BONOBO_PERSIST(gui.pfile), dirty);
+}
+
+static void load_buffer_from_stream( const Bonobo_Stream         stream,
+                      Bonobo_Persist_ContentType  type,
+                      CORBA_Environment          *ev)
+{
+    exarg_T		ea;			/* Ex command arguments */
+
+    g_warning ("load_buffer_from_stream");
+
+    stream_buffer = bonobo_stream_client_read( stream, -1, &stream_length, ev);
+	if (ev->_major != CORBA_NO_EXCEPTION) {
+        g_warning("Error reading from stream");
+        return;
+	}
+    stream_offset = 0;
+
+    if( persistent_buffer ) {
+        /* make it possible to delete the existing buffer, so that it 
+         * can be replaced with what we are about to load */
+        persistent_buffer->emb_buffer = FALSE;
+    }
+
+    vim_memset(&ea, 0, sizeof(ea));
+    ea.cmd = "e ++enc=utf-8";
+    ea.force_enc = 8; /* this is the offset of "utf-8" in the cmd */
+
+    read_from_container = PERSIST_STREAM_IO;
+    do_ecmd(0, NULL, NULL, &ea, 1, ECMD_OLDBUF|ECMD_FORCEIT);
+    read_from_container = NORMAL_IO;
+
+    /* we've set the fileencoding to utf-8; set encoding to utf-8 as * well.*/
+    do_cmdline_cmd("set encoding=utf-8");
+
+    /* remember this buffer */
+	persistent_buffer = curbuf;
+    ga_clear(&error_ga);
+    g_free(stream_buffer);
+
+        
+    /* run a filter to obtain plain text from the html */
+    if( !strcmp( type, "text/html" )) {
+        vim_bonobo_call_begin();
+        /* Substitutions to recognize quoted text */
+        do_cmdline_cmd("%s/<!--+GtkHTML[^>]*class=\"ClueFlow\"[^>]*key=\"orig\"[^>]*value=\"1\">-->/<pre>GtkHTML_QUOTE_ON<\\/pre>");
+        do_cmdline_cmd("%s/<!--+GtkHTML[^>]*class=\"ClueFlow\"[^>]*clear=\"orig\"[^>]*>-->/<pre>GtkHTML_QUOTE_OFF<\\/pre>");
+        do_cmdline_cmd("%s/<\\/i><\\/blockquote>/<\\/pre><\\/i><\\/blockquote>/");
+        do_cmdline_cmd("%!html2text -nobs");
+        do_cmdline_cmd("call EvoQuote()");
+        vim_bonobo_call_end();
+    }
+    do_cmdline_cmd("set nomodified");
+    component_set_dirty(FALSE);
+}
+
+static void load_buffer_from_stream_cb(BonoboPersistStream *ps,
+                      const Bonobo_Stream         stream,
+                      Bonobo_Persist_ContentType  type,
+                      void                       *closure,
+                      CORBA_Environment          *ev)
+{
+    load_buffer_from_stream(stream, type, ev);
+}
+
+static void 
+save_buffer_to_stream( const Bonobo_Stream         stream,
+                      Bonobo_Persist_ContentType  type,
+                      CORBA_Environment          *ev)
+{
+    buf_T * buf;
+    exarg_T		ea;			/* Ex command arguments */
+
+    /*g_warning ("save_buffer_to_stream");*/
+
+    current_stream = stream;
+    write_to_container = PERSIST_STREAM_IO;
+
+    if( !strcmp(type, "text/html")) {
+        vim_control_persist_stream_write("<pre>", 5);
+    }
+
+    vim_memset(&ea, 0, sizeof(ea));
+    ea.cmd = "e ++enc=utf-8";
+    ea.force_enc = 8; /* this is the offset of "utf-8" in the cmd */
+
+    buf = persistent_buffer;
+    buf_write(buf, "dummy", "dummy", 1, buf->b_ml.ml_line_count, 
+                &ea, FALSE, FALSE, TRUE, TRUE);
+    if( !strcmp(type, "text/html")) {
+        vim_control_persist_stream_write("</pre>", 6);
+    }
+    write_to_container = NORMAL_IO;
+    ga_clear(&error_ga);
+}
+
+static void 
+save_buffer_to_stream_cb(BonoboPersistStream         *ps,
+                      const Bonobo_Stream         stream,
+                      Bonobo_Persist_ContentType  type,
+                      void                       *closure,
+                      CORBA_Environment          *ev)
+{
+    save_buffer_to_stream(stream, type, ev);
+}
+
+static gint
+load_buffer_from_file (BonoboPersistFile *pf,
+                const CORBA_char  *filename,
+		        CORBA_Environment *ev,
+                void              *closure)
+{
+	Bonobo_PersistStream ps = closure;
+	BonoboStream *stream;
+	
+    /* FIXME!! */
+    stream = bonobo_get_object(filename, "IDL:Bonobo/Stream:1.0", ev);
+
+	if (!stream)
+		return 0;
+
+	load_buffer_from_stream (ps, "text/plain", ev);
+	return 0; /* Return 0 on success */
+}
+
+static gint
+save_to_file (BonoboPersistFile *pf,
+              const CORBA_char  *filename,
+              CORBA_Environment *ev,
+              void              *closure)
+{
+	Bonobo_PersistStream ps = closure;
+	BonoboStream *stream;
+	
+    
+    /*
+	stream = bonobo_stream_open (
+		BONOBO_IO_DRIVER_FS,
+		filename, Bonobo_STORAGE_WRITE | Bonobo_STORAGE_CREATE,
+		S_IRUSR | S_IWUSR | S_IRGRP);
+
+	if (!stream)
+		return 0;
+
+	save_buffer_to_stream (NULL, ps, "text/plain", ev);
+    */
+	return 0; /* Return 0 on success */
+}
+
+
+Bonobo_Persist_ContentTypeList * 
+persist_stream_types( BonoboPersistStream * ps, void * closure, CORBA_Environment *ev )
+{
+    /*g_warning ("persist_stream_types");*/
+    return bonobo_persist_generate_content_types(2, "text/plain", "text/html");
+}
+
+
+#if 0
+static void
+nv_load_location_cb (NautilusView *view, const char *location, gpointer user_data)
+{
+	g_return_if_fail (NAUTILUS_IS_VIEW (view));
+	g_return_if_fail (location != NULL);
+
+	nautilus_view_report_load_underway (NAUTILUS_VIEW (view));
+
+    /* FIXME: load the file here (using gnome-vfs)! */
+	nautilus_view_report_load_complete (NAUTILUS_VIEW (view));
+}
+#endif
+
+static enum {
+    EDITOR_NEEDS_ESCAPE
+} EditorControlProps;
+
+editor_get_prop (BonoboPropertyBag *bag,
+         BonoboArg         *arg,
+         guint              arg_id,
+         CORBA_Environment *ev,
+         gpointer           user_data)
+{
+    //GtkHTMLControlData *cd = user_data;
+                                                                                
+    switch (arg_id) {
+    case EDITOR_NEEDS_ESCAPE:
+        BONOBO_ARG_SET_BOOLEAN (arg, TRUE);
+        break;
+    default:
+        bonobo_exception_set (ev, ex_Bonobo_PropertyBag_NotFound);
+        break;
+    }
+}
+
+static void
+editor_set_prop (BonoboPropertyBag *bag,
+         const BonoboArg   *arg,
+         guint              arg_id,
+         CORBA_Environment *ev,
+         gpointer           user_data)
+{
+    //GtkHTMLControlData *cd = user_data;
+                                                                                
+    switch (arg_id) {
+    case EDITOR_NEEDS_ESCAPE:
+        bonobo_exception_set (ev, ex_Bonobo_PropertyBag_ReadOnly);
+        break;
+    default:
+        bonobo_exception_set (ev, ex_Bonobo_PropertyBag_NotFound);
+        break;
+    }
+}
+
+static void
+vim_control_init (VimControl *control)
+{
+	control->priv = g_new0 (VimControlPrivate, 1);
+}
+
+BONOBO_TYPE_FUNC (VimControl, BONOBO_TYPE_CONTROL, vim_control);
+
+BonoboObject *
+vim_control_add_interfaces (VimControl     *control,
+			  BonoboObject *to_aggregate)
+{
+	BonoboPersistFile   *file;
+    //NautilusView        *nv;
+	BonoboPersistStream *stream;
+    EditorEngine        *engine; /* GtkHTML editor engine interface */
+	//BonoboItemContainer *item_container;
+
+	
+	g_return_val_if_fail (VIM_IS_CONTROL (control), NULL);
+	g_return_val_if_fail (BONOBO_IS_OBJECT (to_aggregate), NULL);
+
+	/* Interface Bonobo::PersistStream */
+    stream = bonobo_persist_stream_new (load_buffer_from_stream_cb,
+                                        save_buffer_to_stream_cb, 
+                                        persist_stream_types, 
+                                        VIM_OAFIID, 
+                                        control);
+    if (!stream) {
+        bonobo_object_unref (BONOBO_OBJECT (to_aggregate));
+        return NULL;
+    }
+	bonobo_object_add_interface (BONOBO_OBJECT (to_aggregate),
+				     BONOBO_OBJECT (stream));
+    gui.pstream = stream;
+
+	/* Interface Bonobo::PersistFile */
+	file = bonobo_persist_file_new (load_buffer_from_file, 
+					    save_buffer_to_stream, VIM_OAFIID, control);
+	if (!file) {
+		bonobo_object_unref (BONOBO_OBJECT (to_aggregate));
+		return NULL;
+	}
+	bonobo_object_add_interface (BONOBO_OBJECT (to_aggregate),
+				     BONOBO_OBJECT (file));
+    gui.pfile = file;
+
+    /*
+    nv = nautilus_view_new_from_bonobo_control(BONOBO_CONTROL(control));
+    if( !nv ) {
+        bonobo_object_unref (BONOBO_OBJECT(to_aggregate));
+        return NULL;
+    }
+	bonobo_object_add_interface (BONOBO_OBJECT (to_aggregate),
+				     BONOBO_OBJECT (nv));
+
+	g_signal_connect (G_OBJECT (nv), "load_location",
+			  G_CALLBACK (nv_load_location_cb), NULL);
+        */
+
+    engine = editor_engine_new();
+    if( !engine ) {
+        bonobo_object_unref (BONOBO_OBJECT(to_aggregate));
+        return NULL;
+    }
+	bonobo_object_add_interface (BONOBO_OBJECT (to_aggregate),
+				     BONOBO_OBJECT (engine));
+
+	return to_aggregate;
+}
+
+VimControl *
+vim_control_construct (VimControl    *control)
+{
+	GtkWidget             *button;
+	GtkWidget             *label;
+    BonoboPlug            *plug;
+    GtkAccelGroup         *group;
+    GClosure              *closure;
+	//VimControlPrivate     *priv;
+    BonoboPropertyBag  *pb;
+    BonoboArg          *def;
+	
+	g_return_val_if_fail (control != NULL, NULL);
+	g_return_val_if_fail (VIM_IS_CONTROL (control), NULL);
+
+
+	if (!vim_control_add_interfaces (control, BONOBO_OBJECT (control)))
+		return NULL;
+
+    gui.control = BONOBO_CONTROL(control);
+    gui.plug = (BonoboPlug *)bonobo_control_get_plug(control);
+    gui.mainwin = GTK_WIDGET(gui.plug);
+    gui_mch_init();
+
+    g_signal_connect (control, "set_frame", G_CALLBACK (set_frame_cb), NULL);
+    g_signal_connect (gui.plug, "embedded", G_CALLBACK (embedded_cb), NULL);
+
+	/* Create the vim-view */
+	//priv->image_view = vim_image_view_new (vim, FALSE);
+	//if (!priv->image_view) {
+		//bonobo_object_unref (BONOBO_OBJECT (control));
+		//return NULL;
+	//}
+
+    pb = bonobo_property_bag_new (editor_get_prop, editor_set_prop, NULL);
+    bonobo_control_set_properties (control, BONOBO_OBJREF (pb), NULL);
+                                                                                
+    def = bonobo_arg_new (BONOBO_ARG_BOOLEAN);
+    BONOBO_ARG_SET_BOOLEAN (def, TRUE);
+                                                                                
+    bonobo_property_bag_add (pb, "EditorNeedsEscape", EDITOR_NEEDS_ESCAPE,
+                 BONOBO_ARG_BOOLEAN, def,
+                 "Whether the editor requires Escape key events",
+                 0);
+                                                                                
+    CORBA_free (def);
+
+    bonobo_object_unref (BONOBO_OBJECT (pb));
+    
+	return control;
+}
+
+VimControl *
+vim_control_new (void)
+{
+	VimControl *control;
+	
+    g_message ("Creating VimControl...");
+
+	control = g_object_new (VIM_CONTROL_TYPE, NULL);
+
+	return vim_control_construct (control);
+}
+
diff -Nur vim63/src/vim_bonobo_control.h vim63-bonobo/src/vim_bonobo_control.h
--- vim63/src/vim_bonobo_control.h	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_control.h	2005-09-09 20:14:02.764579984 +0200
@@ -0,0 +1,50 @@
+/*
+ * vim_bonobo_control.h
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#ifndef _VIM_CONTROL_H_
+#define _VIM_CONTROL_H_
+
+#include <bonobo/bonobo-control.h>
+#define VIM_OAFIID "OAFIID:Vim_Control"
+#define NORMAL_IO 0
+#define PERSIST_STREAM_IO 1
+#define PERSIST_FILE_IO 2
+
+G_BEGIN_DECLS
+ 
+#define VIM_CONTROL_TYPE           (vim_control_get_type ())
+#define VIM_CONTROL(o)             (G_TYPE_CHECK_INSTANCE_CAST ((o), VIM_CONTROL_TYPE, VimControl))
+#define VIM_CONTROL_CLASS(k)       (G_TYPE_CHECK_CLASS_CAST((k), VIM_CONTROL_TYPE, VimControlClass))
+
+#define VIM_IS_CONTROL(o)          (G_TYPE_CHECK_INSTANCE_TYPE ((o), VIM_CONTROL_TYPE))
+#define VIM_IS_CONTROL_CLASS(k)    (G_TYPE_CHECK_CLASS_TYPE ((k), VIM_CONTROL_TYPE))
+#define VIM_CONTROL_GET_CLASS(o)   (G_TYPE_INSTANCE_GET_CLASS ((o), VIM_CONTROL_TYPE, VimControlClass))
+
+typedef struct _VimControl         VimControl;
+typedef struct _VimControlClass    VimControlClass;
+typedef struct _VimControlPrivate  VimControlPrivate;
+
+struct _VimControl {
+	BonoboControl control;
+
+	VimControlPrivate *priv;
+};
+
+struct _VimControlClass {
+	BonoboControlClass parent_class;
+};
+
+GType         vim_control_get_type                    (void);
+VimControl    *vim_control_new                         (void);
+VimControl    *vim_control_construct                   (VimControl    *control);
+
+void set_curbuf_persistent(void);
+
+G_END_DECLS
+
+#endif /* _VIM_CONTROL_H_*/
diff -Nur vim63/src/vim_bonobo_factory.c vim63-bonobo/src/vim_bonobo_factory.c
--- vim63/src/vim_bonobo_factory.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_factory.c	2005-09-09 20:14:02.764579984 +0200
@@ -0,0 +1,73 @@
+/*
+ * vim_bonobo_factory.c
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#include "vim.h"
+#include "version.h"
+#include <bonobo/bonobo-generic-factory.h>
+#include "vim_bonobo_control.h"
+
+static BonoboGenericFactory *factory = NULL;
+static int vim_instantiated = 0;
+
+static BonoboObject *
+vim_bonobo_factory(BonoboGenericFactory *this,
+              const char           *oaf_iid,
+              void                 *data)
+{
+    VimControl     *vim;
+    BonoboObject *retval;
+
+    g_return_val_if_fail (this != NULL, NULL);
+    g_return_val_if_fail (oaf_iid != NULL, NULL);
+
+    if( vim_instantiated ) {
+        /* we cannot instantiate more than one control from this process,
+         * because of all of vim's global variables */
+        return NULL;
+    }
+                                                                                
+    g_message ("Trying to produce a '%s'...", oaf_iid);
+                                                                                
+    if (strcmp (oaf_iid, VIM_OAFIID) == 0) {
+        vim = vim_control_new ();
+        if (vim == NULL)
+            return NULL;
+        retval = BONOBO_OBJECT (vim);
+    } else {
+        g_warning ("Unknown IID `%s' requested", oaf_iid);
+        return NULL;
+    }
+    vim_instantiated = 1;
+                                                                                
+    return retval;
+}
+
+/* wait until this component is instantiated */
+int vim_bonobo_wait_for_instantiation()
+{
+    while( !vim_instantiated) {
+        MAIN_ITERATION_DO(TRUE);
+    }
+}
+
+
+int vim_bonobo_init(int *argc, char *argv[])
+{
+    if (!bonobo_ui_init ("gnome-vim", VIM_VERSION_SHORT, argc, argv))
+        g_error (_("Could not initialize Bonobo"));
+                                                                                
+    factory = bonobo_generic_factory_new (
+        VIM_FACTORY_OAFIID, vim_bonobo_factory, NULL);
+                                                                                
+    if (factory == NULL) {
+        g_error ("Couldn't create factory.\n");
+        return 0;
+    }
+    return 1;
+}
+
diff -Nur vim63/src/vim_bonobo_factory.h vim63-bonobo/src/vim_bonobo_factory.h
--- vim63/src/vim_bonobo_factory.h	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_factory.h	2005-09-09 20:14:02.765579832 +0200
@@ -0,0 +1,17 @@
+/*
+ * vim_bonobo_factory.h
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#if !defined( _VIM_BONOBO_FACTORY_H)
+#define _VIM_BONOBO_FACTORY_H
+
+#define VIM_FACTORY_OAFIID     "OAFIID:Vim_Control_Factory"
+
+void gui_component_init(int *argc, char *argv []);
+int gui_component_wait_for_instantiation(void);
+
+#endif
diff -Nur vim63/src/vim_bonobo_main.c vim63-bonobo/src/vim_bonobo_main.c
--- vim63/src/vim_bonobo_main.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_main.c	2005-09-09 20:14:02.765579832 +0200
@@ -0,0 +1,98 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+#include "vim.h"
+
+#include <glib/gmain.h>
+#include <glib-object.h>
+#include <bonobo/Bonobo.h>
+
+static guint              bonobo_main_loop_level = 0;
+static GSList *           bonobo_main_loops = NULL;
+
+static gboolean           in_bonobo_call = FALSE;
+
+
+/**
+ * bonobo_main:
+ * 
+ * Activates the Bonobo POA Manager and enters the main event loop.
+ */
+void
+vim_bonobo_main (void)
+{
+	GMainLoop *loop;
+
+    if( in_bonobo_call ) {
+        return;
+    }
+
+	bonobo_activate ();
+
+	bonobo_main_loop_level++;
+  
+	loop = g_main_loop_new (NULL, TRUE);
+	bonobo_main_loops = g_slist_prepend (bonobo_main_loops, loop);
+
+	if (g_main_loop_is_running (bonobo_main_loops->data))
+		g_main_loop_run (loop);
+
+	bonobo_main_loops = g_slist_remove (bonobo_main_loops, loop);
+
+	g_main_loop_unref (loop);
+
+	bonobo_main_loop_level--;
+}
+
+/**
+ * bonobo_main_quit:
+ * 
+ * Quits the main event loop.
+ */
+void
+vim_bonobo_main_quit (void)
+{
+	g_return_if_fail (bonobo_main_loops != NULL);
+
+	g_main_loop_quit (bonobo_main_loops->data);
+}
+
+int
+vim_bonobo_main_level(void)
+{
+    return bonobo_main_loop_level;
+}
+
+static long save_p_report;
+static int save_msg_silent;
+static int save_emsg_silent;
+
+void
+vim_bonobo_call_begin(void)
+{
+    in_bonobo_call = TRUE;
+    gui.processing_call = TRUE;
+    save_p_report = p_report;
+    p_report = 100000;
+    save_msg_silent = msg_silent;
+    msg_silent = TRUE;
+    save_emsg_silent = emsg_silent;
+    emsg_silent = TRUE;
+}
+
+void
+vim_bonobo_call_end(void)
+{
+    in_bonobo_call = FALSE;
+    gui.processing_call = FALSE;
+    msg_silent = save_msg_silent;
+    emsg_silent = save_emsg_silent;
+    p_report = save_p_report;
+}
+
+gboolean
+vim_bonobo_main_iteration_do(may_block)
+{
+    if( ! in_bonobo_call ) {
+        g_main_context_iteration(NULL, may_block);
+    }
+}
+
diff -Nur vim63/src/vim_bonobo_main.h vim63-bonobo/src/vim_bonobo_main.h
--- vim63/src/vim_bonobo_main.h	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_bonobo_main.h	2005-09-09 20:14:02.765579832 +0200
@@ -0,0 +1,16 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+#ifndef __VIM_BONOBO_MAIN_H__
+#define __VIM_BONOBO_MAIN_H__
+
+#include <glib-object.h>
+#include <bonobo/Bonobo.h>
+
+void			    vim_bonobo_main			 (void);
+void                vim_bonobo_main_quit     (void);
+int                 vim_bonobo_level(void);
+gboolean            vim_bonobo_main_iteration_do(int may_block);
+void                vim_bonobo_call_begin(void);
+void                vim_bonobo_call_end(void);
+
+#endif /* __VIM_BONOBO_MAIN_H__ */
diff -Nur vim63/src/vim-container.xml vim63-bonobo/src/vim-container.xml
--- vim63/src/vim-container.xml	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim-container.xml	2005-09-09 20:14:02.761580440 +0200
@@ -0,0 +1,83 @@
+<Root>
+
+<commands>
+	<cmd name="FileNewWindow" _label="_New Window" _tip="Open a new window"
+             pixtype="stock" pixname="gtk-new" accel="*Control*n"/>
+
+	<cmd name="FileOpen" _label="_Open..." _tip="Open a file"
+	     pixtype="stock" pixname="gtk-open" accel="*Control*o"/>
+
+	<cmd name="FileCloseWindow" _label="_Close" _tip="Close window"
+             pixtype="stock" pixname="gtk-close" accel="*Control*w"/>
+
+        <cmd name="FileExit" _label="_Quit" _tip="Quit the program"
+	     pixtype="stock" pixname="gtk-quit" accel="*Control*q"/>
+	
+	<cmd name="Preferences" _label="_Preferences..." _tip="Change preferences"  sensitive="0"
+	     pixtype="stock" pixname="gtk-preferences"/>
+
+	<cmd name="HelpAbout" _label="_About" _tip="About this application"
+	     pixtype="stock" pixname="About"/>
+	<cmd name="Help" _label="Contents" _tip="Help On this application"
+	     pixtype="stock" pixname="Help" accel="F1"/>
+
+
+	<cmd name="DnDNewWindow" _label="Open in new window"/>
+	<cmd name="DnDSameWindow" _label="Open in this window"/>
+	<cmd name="DnDCancel" _label="Cancel"
+	     pixtype="stock" pixname="Cancel"/>
+</commands>
+
+<menu>
+        <submenu name="File" _label="_File">
+
+		<menuitem name="FileNewWindow" verb=""/>
+
+		<placeholder name="Open Placeholder" delimit="top">
+			<menuitem name="FileOpen" verb=""/>
+		</placeholder>
+
+		<placeholder name="File Items Placeholder" delimit="top"/>
+
+		<separator/>
+
+		<menuitem name="FileCloseWindow" verb=""/>
+
+		<menuitem name="FileExit" verb=""/>
+
+	</submenu>
+
+	<submenu name="Edit" _label="_Edit">
+		<menuitem name="Preferences" verb=""/>
+        </submenu>
+
+	<submenu name="View" _label="_View" hidden="1">
+		<placeholder name="View Preferences Placeholder"/>
+		<placeholder name="View Items Placeholder" delimit="top"/>
+	</submenu>
+
+	<submenu name="Help" _label="_Help">
+		<menuitem name="Help" verb=""/>
+	        <menuitem name="HelpAbout" verb=""/>
+	</submenu>
+</menu>
+
+<dockitem name="Toolbar" relief="none" homogeneous="1" behavior="exclusive">
+
+        <toolitem name="TBOpen" _label="Open" pixtype="stock"
+                  pixname="Open" verb="FileOpen"/>
+
+        <toolitem name="TBCloseWindow" _label="Close" pixtype="stock"
+                  pixname="Close" verb="FileCloseWindow"/>
+</dockitem>
+
+<popups>
+        <popup name="dragndrop">
+	      <menuitem name="DnDNewWindow" verb=""/>
+	      <menuitem name="DnDSameWindow" verb=""/>
+	      <separator/>
+	      <menuitem name="DnDCancel" verb=""/>
+        </popup>
+</popups>
+
+</Root>
diff -Nur vim63/src/Vim_Control.server vim63-bonobo/src/Vim_Control.server
--- vim63/src/Vim_Control.server	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/Vim_Control.server	2005-09-09 20:14:02.695590472 +0200
@@ -0,0 +1,42 @@
+<oaf_info>
+
+<oaf_server iid="OAFIID:Vim_Proxy_Factory" type="exe" location="/usr/local/bin/vim-factory">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/GenericFactory:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control factory"/>
+  <oaf_attribute name="description" type="string" value="Vim Control factory"/>
+</oaf_server>
+
+<oaf_server iid="OAFIID:Vim_Control_Factory" type="exe" location="/usr/local/bin/vim-component">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/GenericFactory:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control factory"/>
+  <oaf_attribute name="description" type="string" value="Vim Control factory"/>
+</oaf_server>
+
+<oaf_server iid="OAFIID:Vim_Control" type="factory"
+ location="OAFIID:Vim_Proxy_Factory">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/Unknown:1.0"/>
+    <item value="IDL:Bonobo/Control:1.0"/>
+    <item value="IDL:Bonobo/ItemContainer:1.0"/>
+    <item value="IDL:Bonobo/PersistStream:1.0"/>
+    <item value="IDL:Bonobo/PersistFile:1.0"/>
+    <item value="IDL:Bonobo/Persist:1.0"/>
+    <item value="IDL:Nautilus/View:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control"/>
+  <oaf_attribute name="description" type="string" value="Vim Control"/>
+  <oaf_attribute name="bonobo:editable" type="boolean" value="false"/>
+  <oaf_attribute name="bonobo:supported_mime_types" type="stringv">
+    <item value="text/plain"/>
+    <item value="text/*"/>
+  </oaf_attribute>
+  <oaf_attribute name="nautilus:view_as_name" type="string" value="Text"/>
+  <oaf_attribute name="nautilus:view_as_label" type="string" value="View/Edit in Vim"/>
+  <oaf_attribute name="nautilus:viewer_label" type="string" value="Vim"/>
+</oaf_server>
+
+</oaf_info>
diff -Nur vim63/src/Vim_Control.server.in vim63-bonobo/src/Vim_Control.server.in
--- vim63/src/Vim_Control.server.in	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/Vim_Control.server.in	2005-09-09 20:14:02.696590320 +0200
@@ -0,0 +1,42 @@
+<oaf_info>
+
+<oaf_server iid="OAFIID:Vim_Proxy_Factory" type="exe" location="@DEST_BIN@/vim-factory">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/GenericFactory:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control factory"/>
+  <oaf_attribute name="description" type="string" value="Vim Control factory"/>
+</oaf_server>
+
+<oaf_server iid="OAFIID:Vim_Control_Factory" type="exe" location="@DEST_BIN@/@VIMNAME@">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/GenericFactory:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control factory"/>
+  <oaf_attribute name="description" type="string" value="Vim Control factory"/>
+</oaf_server>
+
+<oaf_server iid="OAFIID:Vim_Control" type="factory"
+ location="OAFIID:Vim_Proxy_Factory">
+  <oaf_attribute name="repo_ids" type="stringv">
+    <item value="IDL:Bonobo/Unknown:1.0"/>
+    <item value="IDL:Bonobo/Control:1.0"/>
+    <item value="IDL:Bonobo/ItemContainer:1.0"/>
+    <item value="IDL:Bonobo/PersistStream:1.0"/>
+    <item value="IDL:Bonobo/PersistFile:1.0"/>
+    <item value="IDL:Bonobo/Persist:1.0"/>
+    <item value="IDL:Nautilus/View:1.0"/>
+  </oaf_attribute>
+  <oaf_attribute name="name" type="string" value="Vim Control"/>
+  <oaf_attribute name="description" type="string" value="Vim Control"/>
+  <oaf_attribute name="bonobo:editable" type="boolean" value="false"/>
+  <oaf_attribute name="bonobo:supported_mime_types" type="stringv">
+    <item value="text/plain"/>
+    <item value="text/*"/>
+  </oaf_attribute>
+  <oaf_attribute name="nautilus:view_as_name" type="string" value="Text"/>
+  <oaf_attribute name="nautilus:view_as_label" type="string" value="View/Edit in Vim"/>
+  <oaf_attribute name="nautilus:viewer_label" type="string" value="Vim"/>
+</oaf_server>
+
+</oaf_info>
diff -Nur vim63/src/vim.h vim63-bonobo/src/vim.h
--- vim63/src/vim.h	2005-09-09 20:11:10.612751000 +0200
+++ vim63-bonobo/src/vim.h	2005-09-09 20:14:02.762580288 +0200
@@ -755,6 +755,10 @@
 #define READ_STDIN	0x04	/* read from stdin */
 #define READ_BUFFER	0x08	/* read from curbuf (converting stdin) */
 #define READ_DUMMY	0x10	/* reading into a dummy buffer */
+#define READ_EMB_STREAM 0x20    /* read from container stream object 
+                                        (i.e. Bonobo Persist Stream) */
+#define READ_EMB_FILE   0x40    /* read from container file object 
+                                        (i.e. Bonobo Persist File) */
 
 /* Values for change_indent() */
 #define INDENT_SET	1	/* set indent */
@@ -1045,6 +1049,7 @@
     EVENT_CURSORHOLD,		/* cursor in same position for a while */
     EVENT_FUNCUNDEFINED,	/* if calling a function which doesn't exist */
     EVENT_REMOTEREPLY,		/* upon string reception from a remote vim */
+    EVENT_EMBEDDED_COMPONENT,	/* upon embedding of vim as a component */
     NUM_EVENTS			/* MUST be the last one */
 };
 
diff -Nur vim63/src/vim_proxy_factory.c vim63-bonobo/src/vim_proxy_factory.c
--- vim63/src/vim_proxy_factory.c	1970-01-01 01:00:00.000000000 +0100
+++ vim63-bonobo/src/vim_proxy_factory.c	2005-09-09 20:14:02.766579680 +0200
@@ -0,0 +1,66 @@
+/*
+ * vim_proxy_factory.c
+ *
+ * Author:
+ *   Jason Hildebrand (jason@peaceworks.ca)
+ *
+ */
+
+#include "vim.h"
+#include "version.h"
+#include <libbonobo.h>
+#include <bonobo/bonobo-foreign-object.h>
+#include <bonobo/bonobo-generic-factory.h>
+#include "vim_bonobo_control.h"
+#include "vim_bonobo_factory.h"
+
+#define VIM_PROXY_OAFIID "OAFIID:Vim_Proxy_Factory"
+
+static BonoboGenericFactory *factory = NULL;
+
+static BonoboObject *
+vim_proxy_factory(BonoboGenericFactory *this,
+              const char           *oaf_iid,
+              void                 *data)
+{
+    CORBA_Object realfactory;
+    CORBA_Environment ev;
+    BonoboObject * vim_control = NULL;
+    CORBA_Object corba_control;
+
+    g_return_val_if_fail (this != NULL, NULL);
+    g_return_val_if_fail (oaf_iid != NULL, NULL);
+
+    g_message ("Trying to produce a '%s'...", oaf_iid);
+                                                                                
+    if (strcmp (oaf_iid, VIM_OAFIID) == 0) {
+        CORBA_exception_init(&ev);
+
+        realfactory = bonobo_activation_activate_from_id (VIM_FACTORY_OAFIID,
+                                                  Bonobo_ACTIVATION_FLAG_PRIVATE,
+                                                  NULL,
+                                                  &ev);
+        if (ev._major != CORBA_NO_EXCEPTION ) {
+            CORBA_exception_free (&ev);
+            return NULL;
+        }
+
+        corba_control = Bonobo_GenericFactory_createObject(realfactory, VIM_OAFIID, &ev);
+        if (ev._major != CORBA_NO_EXCEPTION ) {
+            CORBA_exception_free (&ev);
+            return NULL;
+        }
+        CORBA_exception_free (&ev);
+        vim_control = bonobo_foreign_object_new(corba_control);
+    } else {
+        g_warning ("Unknown IID `%s' requested", oaf_iid);
+        return NULL;
+    }
+    return vim_control;
+}
+
+
+BONOBO_ACTIVATION_FACTORY (VIM_PROXY_OAFIID,
+               "Vim Proxy Factory", "1.0",
+               vim_proxy_factory, NULL);
+
