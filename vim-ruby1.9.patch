diff --git a/src/configure.in b/src/configure.in
index fa58c6e..f6761db 100644
--- a/src/configure.in
+++ b/src/configure.in
@@ -953,10 +953,30 @@ if test "$enable_rubyinterp" = "yes"; then
   AC_PATH_PROG(vi_cv_path_ruby, ruby)
   if test "X$vi_cv_path_ruby" != "X"; then
     AC_MSG_CHECKING(Ruby version)
-    if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.6.0" or exit 1' >/dev/null 2>/dev/null; then
+    if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.9.0" or exit 1' >/dev/null 2>/dev/null; then
       AC_MSG_RESULT(OK)
       AC_MSG_CHECKING(Ruby header files)
-      rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e 'print Config::CONFIG[["archdir"]] || $hdrdir' 2>/dev/null`
+      rubyhdrdirs=`$vi_cv_path_ruby -r rbconfig -e 'print RbConfig.expand("$(rubyhdrdir)/$(arch) $(rubyhdrdir)/ruby/backward $(rubyhdrdir)")' 2>/dev/null`
+      if test "X$rubyhdrdirs" != "X"; then
+	AC_MSG_RESULT($rubyhdrdirs)
+	for rubyhdrdir in $rubyhdrdirs; do
+	  RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyhdrdir"
+	done
+	librubyarg=`$vi_cv_path_ruby -r rbconfig -e 'print RbConfig::CONFIG[["LIBRUBYARG"]]'`
+	if test "X$librubyarg" != "X"; then
+	  RUBY_LIBS="$librubyarg"
+	fi
+	RUBY_SRC="if_ruby.c"
+	RUBY_OBJ="objects/if_ruby.o"
+	RUBY_PRO="if_ruby.pro"
+	AC_DEFINE(FEAT_RUBY)
+      else
+	AC_MSG_RESULT(not found, disabling Ruby)
+      fi
+    elif $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.6.0" or exit 1' >/dev/null 2>/dev/null; then
+      AC_MSG_RESULT(OK)
+      AC_MSG_CHECKING(Ruby header files)
+      rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e 'print Config::CONFIG[["rubyincludedir"]] || $hdrdir' 2>/dev/null`
       if test "X$rubyhdrdir" != "X"; then
 	AC_MSG_RESULT($rubyhdrdir)
 	RUBY_CFLAGS="-I$rubyhdrdir"
diff --git a/src/if_ruby.c b/src/if_ruby.c
index 0fed2c0..e571faa 100644
--- a/src/if_ruby.c
+++ b/src/if_ruby.c
@@ -129,7 +129,7 @@ static void ruby_vim_init(void);
 #define rb_str_concat			dll_rb_str_concat
 #define rb_str_new			dll_rb_str_new
 #define rb_str_new2			dll_rb_str_new2
-#define ruby_errinfo			(*dll_ruby_errinfo)
+#define rb_errinfo			dll_rb_errinfo
 #define ruby_init			dll_ruby_init
 #define ruby_init_loadpath		dll_ruby_init_loadpath
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
@@ -245,7 +245,7 @@ static struct
     {"rb_str_concat", (RUBY_PROC*)&dll_rb_str_concat},
     {"rb_str_new", (RUBY_PROC*)&dll_rb_str_new},
     {"rb_str_new2", (RUBY_PROC*)&dll_rb_str_new2},
-    {"ruby_errinfo", (RUBY_PROC*)&dll_ruby_errinfo},
+    {"rb_errinfo", (RUBY_PROC*)&dll_rb_errinfo},
     {"ruby_init", (RUBY_PROC*)&dll_ruby_init},
     {"ruby_init_loadpath", (RUBY_PROC*)&dll_ruby_init_loadpath},
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
@@ -433,9 +433,6 @@ static int ensure_ruby_initialized(void)
 
 static void error_print(int state)
 {
-#ifndef DYNAMIC_RUBY
-    RUBYEXTERN VALUE ruby_errinfo;
-#endif
     VALUE eclass;
     VALUE einfo;
     char buff[BUFSIZ];
@@ -468,9 +465,9 @@ static void error_print(int state)
 	break;
     case TAG_RAISE:
     case TAG_FATAL:
-	eclass = CLASS_OF(ruby_errinfo);
-	einfo = rb_obj_as_string(ruby_errinfo);
-	if (eclass == rb_eRuntimeError && RSTRING(einfo)->len == 0) {
+	eclass = CLASS_OF(rb_errinfo());
+	einfo = rb_obj_as_string(rb_errinfo());
+	if (eclass == rb_eRuntimeError && RSTRING_LEN(einfo) == 0) {
 	    EMSG(_("E272: unhandled exception"));
 	}
 	else {
@@ -479,7 +476,7 @@ static void error_print(int state)
 
 	    epath = rb_class_path(eclass);
 	    vim_snprintf(buff, BUFSIZ, "%s: %s",
-		     RSTRING(epath)->ptr, RSTRING(einfo)->ptr);
+		     RSTRING_PTR(epath), RSTRING_PTR(einfo));
 	    p = strchr(buff, '\n');
 	    if (p) *p = '\0';
 	    EMSG(buff);
@@ -497,8 +494,8 @@ static VALUE vim_message(VALUE self UNUSED, VALUE str)
     char *buff, *p;
 
     str = rb_obj_as_string(str);
-    buff = ALLOCA_N(char, RSTRING(str)->len);
-    strcpy(buff, RSTRING(str)->ptr);
+    buff = ALLOCA_N(char, RSTRING_LEN(str));
+    strcpy(buff, RSTRING_PTR(str));
     p = strchr(buff, '\n');
     if (p) *p = '\0';
     MSG(buff);
@@ -628,7 +625,7 @@ static VALUE get_buffer_line(buf_T *buf, linenr_T n)
 	char *line = (char *)ml_get_buf(buf, n, FALSE);
 	return line ? rb_str_new2(line) : Qnil;
     }
-    rb_raise(rb_eIndexError, "index %d out of buffer", n);
+    rb_raise(rb_eIndexError, "index %ld out of buffer", n);
 #ifndef __GNUC__
     return Qnil; /* For stop warning */
 #endif
@@ -669,7 +666,7 @@ static VALUE set_buffer_line(buf_T *buf, linenr_T n, VALUE str)
     }
     else
     {
-	rb_raise(rb_eIndexError, "index %d out of buffer", n);
+	rb_raise(rb_eIndexError, "index %ld out of buffer", n);
 #ifndef __GNUC__
 	return Qnil; /* For stop warning */
 #endif
@@ -715,7 +712,7 @@ static VALUE buffer_delete(VALUE self, VALUE num)
     }
     else
     {
-	rb_raise(rb_eIndexError, "index %d out of buffer", n);
+	rb_raise(rb_eIndexError, "index %ld out of buffer", n);
     }
     return Qnil;
 }
@@ -749,7 +746,7 @@ static VALUE buffer_append(VALUE self, VALUE num, VALUE str)
 	update_curbuf(NOT_VALID);
     }
     else {
-	rb_raise(rb_eIndexError, "index %d out of buffer", n);
+	rb_raise(rb_eIndexError, "index %ld out of buffer", n);
     }
     return str;
 }
@@ -890,10 +887,10 @@ static VALUE window_set_cursor(VALUE self, VALUE pos)
     win_T *win = get_win(self);
 
     Check_Type(pos, T_ARRAY);
-    if (RARRAY(pos)->len != 2)
+    if (RARRAY_LEN(pos) != 2)
 	rb_raise(rb_eArgError, "array length must be 2");
-    lnum = RARRAY(pos)->ptr[0];
-    col = RARRAY(pos)->ptr[1];
+    lnum = RARRAY_PTR(pos)[0];
+    col = RARRAY_PTR(pos)[1];
     win->w_cursor.lnum = NUM2LONG(lnum);
     win->w_cursor.col = NUM2UINT(col);
     check_cursor();		    /* put cursor on an existing line */
@@ -910,7 +907,7 @@ static VALUE f_p(int argc, VALUE *argv, VALUE self UNUSED)
 	if (i > 0) rb_str_cat(str, ", ", 2);
 	rb_str_concat(str, rb_inspect(argv[i]));
     }
-    MSG(RSTRING(str)->ptr);
+    MSG(RSTRING_PTR(str));
     return Qnil;
 }
 
