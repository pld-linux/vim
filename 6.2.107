To: vim-dev@vim.org
Subject: Patch 6.2.107 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 6.2.107 (extra)
Problem:    The NetBeans interface cannot be used on Win32.
Solution:   Add support for the NetBeans for Win32.  Add support for reading
	    XPM files on Win32.  Also fixes that a sign icon with a space in
	    the file name did not work through the NetBeans interface.
	    (Sergey Khorev)
	    Also: avoid repeating error messages when the connection is lost.
Files:	    Makefile, runtime/doc/netbeans.txt, src/Make_bc5.mak,
	    src/Make_cyg.mak, src/Make_ming.mak, src/Make_mvc.mak,
	    src/bigvim.bat, src/feature.h, src/gui_beval.c, src/gui_beval.h,
	    src/gui_w32.c, src/gui_w48.c, src/menu.c, src/nbdebug.c,
	    src/nbdebug.h, src/netbeans.c, src/os_mswin.c, src/os_win32.h,
	    src/proto/gui_beval.pro, src/proto/gui_w32.pro,
	    src/proto/netbeans.pro, src/proto.h, src/version.c, src/vim.h,
	    src/xpm_w32.c, src/xpm_w32.h


*** ../vim-6.2.106/Makefile	Sun Jun  1 12:07:20 2003
--- Makefile	Sun Oct 12 12:19:02 2003
***************
*** 438,443 ****
--- 438,445 ----
  		src/vim16.rc \
  		src/vimrun.c \
  		src/vimtbar.h \
+ 		src/xpm_w32.c \
+ 		src/xpm_w32.h \
  		src/xxd/Make_bc3.mak \
  		src/xxd/Make_bc5.mak \
  		src/xxd/Make_cyg.mak \
***************
*** 564,569 ****
--- 566,572 ----
  		src/gui_riscos.h \
  		src/if_sniff.c \
  		src/if_sniff.h \
+ 		src/infplist.xml \
  		src/link.390 \
  		src/os_beos.c \
  		src/os_beos.h \
*** ../vim-6.2.106/runtime/doc/netbeans.txt	Sun Jun  1 16:04:00 2003
--- runtime/doc/netbeans.txt	Fri Sep 12 21:37:19 2003
***************
*** 1,4 ****
! *netbeans.txt*  For Vim version 6.2.  Last change: 2003 Jun 01
  
  
  		  VIM REFERENCE MANUAL    by Gordon Prieur
--- 1,4 ----
! *netbeans.txt*  For Vim version 6.2.  Last change: 2003 Sep 12
  
  
  		  VIM REFERENCE MANUAL    by Gordon Prieur
***************
*** 67,72 ****
--- 67,77 ----
  ==============================================================================
  3. Configuring Vim for NetBeans			*netbeans-configure*
  
+ For more help installing vim, please read |usr_90.txt| in the Vim User Manual.
+ 
+ 
+ On Unix
+ 
  When running configure without arguments the NetBeans interface should be
  included.  That is, if the configure check to find out if your system supports
  the required features succeeds.
***************
*** 81,87 ****
  If Motif support is required the user must supply XPM libraries. See
  |workshop-xpm| for details on obtaining the latest version of XPM.
  
! For more help installing vim, please read |usr_90.txt| in the Vim User Manual.
  
  ==============================================================================
  4. Downloading NetBeans					*netbeans-download*
--- 86,99 ----
  If Motif support is required the user must supply XPM libraries. See
  |workshop-xpm| for details on obtaining the latest version of XPM.
  
! 
! On MS-Windows
! 
! The Win32 support is now in beta stage.
! 
! To use XPM signs on Win32 (e.g. when using with Netbeans) you can compile
! XPM by yourself or use precompiled libraries from http://iamphet.nm.ru/xpm
! (for MS Visual C++) or http://gnuwin32.sourceforge.net (for MinGW).
  
  ==============================================================================
  4. Downloading NetBeans					*netbeans-download*
***************
*** 391,397 ****
  		Not implemented.
  
  setDot off	Make the buffer the current buffer and set the cursor at the
! 		specified position.
  		In version 2.1 "lnum/col" can be used instead of "off".
  
  setExitDelay seconds
--- 411,418 ----
  		Not implemented.
  
  setDot off	Make the buffer the current buffer and set the cursor at the
! 		specified position.  If there are folds they are opened to
! 		make the cursor line visible.
  		In version 2.1 "lnum/col" can be used instead of "off".
  
  setExitDelay seconds
*** ../vim-6.2.106/src/Make_bc5.mak	Tue May 13 20:21:37 2003
--- src/Make_bc5.mak	Fri Sep 12 21:42:02 2003
***************
*** 72,77 ****
--- 72,80 ----
  #		(BIG for WIN32, SMALL for DOS16)
  # WINVER	0x400 or 0x500: minimum Win32 version to support (0x400)
  # CSCOPE	no or yes: include support for Cscope interface (yes)
+ # NETBEANS	no or yes: include support for Netbeans interface (yes if GUI
+ #		is yes)
+ # XPM		define to path to XPM dir to get support for loading XPM images.
  
  ### BOR: root of the BC installation
  !if ("$(BOR)"=="")
***************
*** 114,119 ****
--- 117,127 ----
  CSCOPE = yes
  !endif
  
+ ### NETBEANS: yes to enable NetBeans interface support, no to disable it
+ !if ("$(NETBEANS)"=="") && ("$(GUI)"=="yes")
+ NETBEANS = yes
+ !endif
+ 
  ### PERL: uncomment this line if you want perl support in vim
  # PERL=c:\perl
  
***************
*** 190,196 ****
  	("$(RUBY)"=="") && \
  	("$(ICONV)"!="yes") && \
  	("$(IME)"!="yes") && \
! 	("$(MBYTE)"!="yes")
  FASTCALL = yes
  !endif
  
--- 198,205 ----
  	("$(RUBY)"=="") && \
  	("$(ICONV)"!="yes") && \
  	("$(IME)"!="yes") && \
! 	("$(MBYTE)"!="yes") && \
! 	("$(XPM)"=="")
  FASTCALL = yes
  !endif
  
***************
*** 372,377 ****
--- 381,399 ----
  DEFINES = $(DEFINES) -DFEAT_CSCOPE
  !endif
  
+ !if ("$(NETBEANS)"=="yes")
+ DEFINES = $(DEFINES) -DFEAT_NETBEANS_INTG
+ !if ("$(DEBUG)"=="yes")
+ DEFINES = $(DEFINES) -DNBDEBUG
+ NBDEBUG_DEP = nbdebug.h nbdebug.c
+ !endif
+ !endif
+ 
+ !ifdef XPM
+ DEFINES = $(DEFINES) -DFEAT_XPM_W32
+ INCLUDE = $(XPM)\include;$(INCLUDE)
+ !endif
+ 
  !if ("$(GUI)"=="yes")
  DEFINES = $(DEFINES) -DFEAT_GUI_W32 -DFEAT_CLIPBOARD
  !if ("$(DEBUG)"=="yes")
***************
*** 448,454 ****
  LINK	= $(BOR)\BIN\ILink32
  !endif
  CC   = $(BOR)\BIN\Bcc32
! LFLAGS	= -OS -r -Tpe -c -m -L$(LIB) $(DEBUG_FLAG) $(LINK2)
  LFLAGSDLL  = -Tpd -c -m -L$(LIB) $(DEBUG_FLAG) $(LINK2)
  CFLAGS = -w-aus -w-par -w-pch -I$(INCLUDE) -d -x- -RT- -k- -Oi $(HEADERS) -f-
  !endif
--- 470,476 ----
  LINK	= $(BOR)\BIN\ILink32
  !endif
  CC   = $(BOR)\BIN\Bcc32
! LFLAGS	= -OS -Tpe -c -m -L$(LIB) $(DEBUG_FLAG) $(LINK2)
  LFLAGSDLL  = -Tpd -c -m -L$(LIB) $(DEBUG_FLAG) $(LINK2)
  CFLAGS = -w-aus -w-par -w-pch -I$(INCLUDE) -d -x- -RT- -k- -Oi $(HEADERS) -f-
  !endif
***************
*** 512,518 ****
  	$(OBJDIR)\normal.obj \
  	$(OBJDIR)\ops.obj \
  	$(OBJDIR)\option.obj \
- 	$(OBJDIR)\pathdef.obj \
  	$(OBJDIR)\quickfix.obj \
  	$(OBJDIR)\regexp.obj \
  	$(OBJDIR)\screen.obj \
--- 534,539 ----
***************
*** 523,529 ****
  	$(OBJDIR)\ui.obj \
  	$(OBJDIR)\undo.obj \
  	$(OBJDIR)\version.obj \
! 	$(OBJDIR)\window.obj
  
  !if ("$(OLE)"=="yes")
  vimobj = $(vimobj) \
--- 544,551 ----
  	$(OBJDIR)\ui.obj \
  	$(OBJDIR)\undo.obj \
  	$(OBJDIR)\version.obj \
! 	$(OBJDIR)\window.obj \
! 	$(OBJDIR)\pathdef.obj
  
  !if ("$(OLE)"=="yes")
  vimobj = $(vimobj) \
***************
*** 550,560 ****
      $(OBJDIR)\if_tcl.obj
  !endif
  
! !ifdef CSCOPE
  vimobj = $(vimobj) \
      $(OBJDIR)\if_cscope.obj
  !endif
  
  !if ("$(VIMDLL)"=="yes")
  vimdllobj = $(vimobj)
  !if ("$(DEBUG)"=="yes")
--- 572,592 ----
      $(OBJDIR)\if_tcl.obj
  !endif
  
! !if ("$(CSCOPE)"=="yes")
  vimobj = $(vimobj) \
      $(OBJDIR)\if_cscope.obj
  !endif
  
+ !if ("$(NETBEANS)"=="yes")
+ vimobj = $(vimobj) \
+     $(OBJDIR)\netbeans.obj $(OBJDIR)\gui_beval.obj
+ !endif
+ 
+ !ifdef XPM
+ vimobj = $(vimobj) \
+     $(OBJDIR)\xpm_w32.obj
+ !endif
+ 
  !if ("$(VIMDLL)"=="yes")
  vimdllobj = $(vimobj)
  !if ("$(DEBUG)"=="yes")
***************
*** 620,625 ****
--- 652,663 ----
  !if ("$(CSCOPE)"=="yes")
  MSG = $(MSG) CSCOPE
  !endif
+ !if ("$(NETBEANS)"=="yes")
+ MSG = $(MSG) NETBEANS
+ !endif
+ !ifdef XPM
+ MSG = $(MSG) XPM
+ !endif
  !ifdef PERL
  MSG = $(MSG) PERL
  ! if "$(DYNAMIC_PERL)" == "yes"
***************
*** 728,733 ****
--- 766,774 ----
  !ifdef TCL
  	-@del tcl.lib
  !endif
+ !ifdef XPM
+ 	-@del xpm.lib
+ !endif
  	cd xxd
  	$(MAKE) /f Make_bc5.mak BOR="$(BOR)" clean
  	cd ..
***************
*** 762,767 ****
--- 803,811 ----
  !ifdef TCL
  	$(TCL_LIB_FLAG)tcl.lib+
  !endif
+ !ifdef XPM
+ 	xpm.lib+
+ !endif
  !if ("$(USEDLL)"=="yes")
  	cw32i.lib
  !else
***************
*** 808,813 ****
--- 852,860 ----
  !ifdef TCL
  	$(TCL_LIB_FLAG)tcl.lib+
  !endif
+ !ifdef XPM
+ 	xpm.lib+
+ !endif
  !if ("$(USEDLL)"=="yes")
  	cw32i.lib
  !else
***************
*** 842,847 ****
--- 889,900 ----
  $(OBJDIR)\if_tcl.obj: if_tcl.c tcl.lib
  	$(CC) $(CCARG) $(CC1) $(CC2)$@ -pc if_tcl.c
  
+ $(OBJDIR)\xpm_w32.obj: xpm_w32.c xpm.lib
+ 	$(CC) $(CCARG) $(CC1) $(CC2)$@ -pc xpm_w32.c
+ 
+ $(OBJDIR)\netbeans.obj: netbeans.c $(NBDEBUG_DEP)
+ 	$(CC) $(CCARG) $(CC1) $(CC2)$@ netbeans.c
+ 
  $(OBJDIR)\vim.res: vim.rc version.h tools.bmp tearoff.bmp \
  		vim.ico vim_error.ico vim_alert.ico vim_info.ico vim_quest.ico
  	$(BRC) -fo$(OBJDIR)\vim.res -i $(BOR)\include -w32 -r vim.rc @&&|
***************
*** 876,881 ****
--- 929,939 ----
  
  ruby.lib: $(RUBY)\lib\$(RUBY_INSTALL_NAME).lib
  	coff2omf $(RUBY)\lib\$(RUBY_INSTALL_NAME).lib $@
+ 
+ # For some reason, the coff2omf method doesn't work on libXpm.lib, so
+ # we have to manually generate an import library straight from the DLL.
+ xpm.lib: $(XPM)\lib\libXpm.lib
+ 	implib -a $@ $(XPM)\bin\libXpm.dll
  
  tcl.lib: $(TCL_LIB)
  !if ("$(DYNAMIC_TCL)" == "yes")
*** ../vim-6.2.106/src/Make_cyg.mak	Sun Jul 27 13:40:24 2003
--- src/Make_cyg.mak	Fri Sep 12 21:52:50 2003
***************
*** 4,10 ****
  # This compiles Vim as a Windows application.  If you want Vim to run as a
  # Cygwin application use the Makefile (just like on Unix).
  #
! # Last updated by Dan Sharp.  Last Change: 2003 Jun 22
  #
  # GUI		no or yes: set to yes if you want the GUI version (yes)
  # PERL		define to path to Perl dir to get Perl support (not defined)
--- 4,10 ----
  # This compiles Vim as a Windows application.  If you want Vim to run as a
  # Cygwin application use the Makefile (just like on Unix).
  #
! # Last updated by Dan Sharp.  Last Change: 2003 Sep 12
  #
  # GUI		no or yes: set to yes if you want the GUI version (yes)
  # PERL		define to path to Perl dir to get Perl support (not defined)
***************
*** 35,40 ****
--- 35,43 ----
  # WINVER	Lowest Win32 version to support.  (0x400)
  # CSCOPE	no or yes: to include cscope interface support (yes)
  # OPTIMIZE	SPACE, SPEED, or MAXSPEED: set optimization level (MAXSPEED)
+ # NETBEANS	no or yes: to include netbeans interface support (yes when GUI
+ #		is yes)
+ # XPM		define to path to XPM dir to get XPM image support (not defined) 
  #>>>>> choose options:
  ifndef GUI
  GUI=yes
***************
*** 76,81 ****
--- 79,90 ----
  CSCOPE = yes
  endif
  
+ ifndef NETBEANS
+ ifeq ($(GUI),yes)
+ NETBEANS = yes
+ endif
+ endif
+ 
  ifndef OPTIMIZE
  OPTIMIZE = MAXSPEED
  endif
***************
*** 266,271 ****
--- 275,301 ----
  endif
  
  ##############################
+ ifeq (yes, $(NETBEANS))
+ DEFINES += -DFEAT_NETBEANS_INTG
+ EXTRA_OBJS += $(OUTDIR)/netbeans.o $(OUTDIR)/gui_beval.o
+ EXTRA_LIBS += -lws2_32
+ 
+ ifeq (yes, $(DEBUG))
+ DEFINES += -DNBDEBUG
+ NBDEBUG_DEP = nbdebug.h nbdebug.c
+ endif
+ 
+ endif
+ 
+ ##############################
+ ifdef XPM
+ DEFINES += -DFEAT_XPM_W32
+ INCLUDES += -I$(XPM)/include
+ EXTRA_OBJS += $(OUTDIR)/xpm_w32.o
+ EXTRA_LIBS += -L$(XPM)/lib -lXpm
+ endif
+ 
+ ##############################
  ifeq (yes, $(OLE))
  DEFINES += -DFEAT_OLE
  EXTRA_OBJS += $(OUTDIR)/if_ole.o
***************
*** 417,422 ****
--- 447,455 ----
  
  $(OUTDIR)/if_ruby.o:	if_ruby.c $(INCL)
  	$(CC) -c $(CFLAGS) -U_WIN32 if_ruby.c -o $(OUTDIR)/if_ruby.o
+ 
+ $(OUTDIR)/netbeans.o:	netbeans.c $(INCL) $(NBDEBUG_DEP)
+ 	$(CC) -c $(CFLAGS) netbeans.c -o $(OUTDIR)/netbeans.o
  
  $(OUTDIR)/vimrc.o:	vim.rc version.h gui_w32_rc.h
  	$(RC) $(RCFLAGS) vim.rc -o $(OUTDIR)/vimrc.o
*** ../vim-6.2.106/src/Make_ming.mak	Tue May 27 21:15:20 2003
--- src/Make_ming.mak	Fri Sep 12 22:03:17 2003
***************
*** 52,59 ****
  OLE=no
  # Set the default $(WINVER) to make it work with pre-Win2k
  WINVER = 0x0400
! #set to yes to enable Cscope support
  CSCOPE=yes
  
  # If the user doesn't want gettext, undefine it.
  ifeq (no, $(GETTEXT))
--- 52,62 ----
  OLE=no
  # Set the default $(WINVER) to make it work with pre-Win2k
  WINVER = 0x0400
! # Set to yes to enable Cscope support
  CSCOPE=yes
+ # Set to yes to enable Netbeans support
+ NETBEANS=$(GUI)
+ 
  
  # If the user doesn't want gettext, undefine it.
  ifeq (no, $(GETTEXT))
***************
*** 270,275 ****
--- 273,291 ----
  DEFINES += -DFEAT_CSCOPE
  endif
  
+ ifeq ($(NETBEANS),yes)
+ DEFINES += -DFEAT_NETBEANS_INTG
+ ifeq ($(DEBUG), yes)
+ DEFINES += -DNBDEBUG
+ NBDEBUG_INCL = nbdebug.h
+ NBDEBUG_SRC = nbdebug.c
+ endif
+ endif
+ 
+ ifdef XPM
+ CFLAGS += -DFEAT_XPM_W32 -I $(XPM)/include
+ endif
+ 
  ifeq ($(DEBUG),yes)
  CFLAGS += -g -fstack-check
  DEBUG_SUFFIX=d
***************
*** 348,353 ****
--- 364,378 ----
  ifeq ($(CSCOPE),yes)
  OBJ += $(OUTDIR)/if_cscope.o
  endif
+ ifeq ($(NETBEANS),yes)
+ OBJ += $(OUTDIR)/netbeans.o $(OUTDIR)/gui_beval.o
+ LIB += -lws2_32
+ endif
+ ifdef XPM
+ OBJ += $(OUTDIR)/xpm_w32.o
+ # You'll need libXpm.a from http://gnuwin32.sf.net
+ LIB += -L $(XPM)/lib -lXpm
+ endif
  
  
  ifeq ($(GUI),yes)
***************
*** 487,492 ****
--- 512,520 ----
  if_perl.c: if_perl.xs typemap
  	perl $(PERLLIB)/ExtUtils/xsubpp -prototypes -typemap \
  	     $(PERLLIB)/ExtUtils/typemap if_perl.xs > $@
+ 
+ $(OUTDIR)/netbeans.o:	netbeans.c $(INCL) $(NBDEBUG_INCL) $(NBDEBUG_SRC)
+ 	$(CC) -c $(CFLAGS) netbeans.c -o $(OUTDIR)/netbeans.o
  
  pathdef.c: $(INCL)
  ifneq (sh.exe, $(SHELL))
*** ../vim-6.2.106/src/Make_mvc.mak	Sun Aug 10 22:37:55 2003
--- src/Make_mvc.mak	Fri Sep 12 22:07:37 2003
***************
*** 12,18 ****
  #	nmake -f Make_mvc.mak
  # This will build the console version of vim with no additional interfaces.
  # To add interfaces, define any of the following:
! #	GUI interface: GUI=yes
  #	OLE interface: OLE=yes (usually with GUI=yes)
  #	Multibyte support: MBYTE=yes
  #	IME support: IME=yes	(requires GUI=yes)
--- 12,18 ----
  #	nmake -f Make_mvc.mak
  # This will build the console version of vim with no additional interfaces.
  # To add interfaces, define any of the following:
! #	GUI interface: GUI=yes (default is no)
  #	OLE interface: OLE=yes (usually with GUI=yes)
  #	Multibyte support: MBYTE=yes
  #	IME support: IME=yes	(requires GUI=yes)
***************
*** 39,52 ****
  #	  TCL_VER=[Tcl version, e.g. 80, 83]  (default is 83)
  #	  TCL_VER_LONG=[Tcl version, eg 8.3] (default is 8.3)
  #	    You must set TCL_VER_LONG when you set TCL_VER.
- #	Cscope support: CSCOPE=yes
  #	Debug version: DEBUG=yes
  #	Mapfile: MAP=[no, yes or lines] (default is yes)
  #	  no:    Don't write a mapfile.
  #	  yes:   Write a normal mapfile.
  #	  lines: Write a mapfile with line numbers (only for VC6 and later)
  #	SNiFF+ interface: SNIFF=yes
! #	Cscope interface: CSCOPE=yes
  #	Iconv library support (always dynamically loaded):
  #	  ICONV=[yes or no]  (default is yes)
  #	Intl library support (always dynamically loaded):
--- 39,51 ----
  #	  TCL_VER=[Tcl version, e.g. 80, 83]  (default is 83)
  #	  TCL_VER_LONG=[Tcl version, eg 8.3] (default is 8.3)
  #	    You must set TCL_VER_LONG when you set TCL_VER.
  #	Debug version: DEBUG=yes
  #	Mapfile: MAP=[no, yes or lines] (default is yes)
  #	  no:    Don't write a mapfile.
  #	  yes:   Write a normal mapfile.
  #	  lines: Write a mapfile with line numbers (only for VC6 and later)
  #	SNiFF+ interface: SNIFF=yes
! #	Cscope support: CSCOPE=yes
  #	Iconv library support (always dynamically loaded):
  #	  ICONV=[yes or no]  (default is yes)
  #	Intl library support (always dynamically loaded):
***************
*** 57,62 ****
--- 56,63 ----
  #       Version Support: WINVER=[0x400, 0x500] (default is 0x400)
  #       Processor Version: CPUNR=[i386, i486, i586, i686] (default is i386)
  #       Optimization: OPTIMIZE=[SPACE, SPEED, MAXSPEED] (default is MAXSPEED)
+ #       Netbeans Support: NETBEANS=[yes or no] (default is yes if GUI is yes)
+ #       XPM Image Support: XPM=[path to XPM directory]
  #
  # You can combine any of these interfaces
  #
***************
*** 173,178 ****
--- 174,183 ----
  MULTITHREADED = yes
  !endif
  
+ !ifndef CSCOPE
+ CSCOPE = yes
+ !endif
+ 
  !if "$(CSCOPE)" == "yes"
  # CSCOPE - Include support for Cscope
  CSCOPE_INCL  = if_cscope.h
***************
*** 180,185 ****
--- 185,216 ----
  CSCOPE_DEFS  = -DFEAT_CSCOPE
  !endif
  
+ !ifndef NETBEANS
+ NETBEANS = $(GUI)
+ !endif
+ 
+ !if "$(NETBEANS)" == "yes"
+ # NETBEANS - Include support for Netbeans integration
+ NETBEANS_PRO	= proto/netbeans.pro
+ NETBEANS_OBJ	= $(OBJDIR)/netbeans.obj $(OBJDIR)/gui_beval.obj
+ NETBEANS_DEFS	= -DFEAT_NETBEANS_INTG
+ !if "$(DEBUG)" == "yes"
+ NBDEBUG_DEFS	= -DNBDEBUG
+ NBDEBUG_INCL	= nbdebug.h
+ NBDEBUG_SRC	= nbdebug.c
+ !endif
+ NETBEANS_LIB   = Ws2_32.lib
+ !endif
+ 
+ !ifdef XPM
+ # XPM - Include support for XPM signs
+ # you can get xpm.lib from http://iamphet.nm.ru/xpm or create it yourself
+ XPM_OBJ   = $(OBJDIR)/xpm_w32.obj
+ XPM_DEFS  = -DFEAT_XPM_W32
+ XPM_LIB   = $(XPM)\lib\libXpm.lib
+ XPM_INC	  = -I $(XPM)\include
+ !endif
+ 
  !if defined(USE_MSVCRT)
  CVARS = $(cvarsdll)
  !elseif defined(MULTITHREADED)
***************
*** 208,215 ****
  #VIMRUNTIMEDIR = somewhere
  
  CFLAGS = -c /W3 /nologo $(CVARS) -I. -Iproto -DHAVE_PATHDEF -DWIN32 \
! 		$(SNIFF_DEFS) $(CSCOPE_DEFS) $(DEFINES) \
! 		-DWINVER=$(WINVER) -D_WIN32_WINNT=$(WINVER)
  
  #>>>>> end of choices
  ###########################################################################
--- 239,247 ----
  #VIMRUNTIMEDIR = somewhere
  
  CFLAGS = -c /W3 /nologo $(CVARS) -I. -Iproto -DHAVE_PATHDEF -DWIN32 \
! 		$(SNIFF_DEFS) $(CSCOPE_DEFS) $(NETBEANS_DEFS) \
! 		$(NBDEBUG_DEFS) $(XPM_DEFS) \
! 		$(DEFINES) -DWINVER=$(WINVER) -D_WIN32_WINNT=$(WINVER)
  
  #>>>>> end of choices
  ###########################################################################
***************
*** 285,291 ****
  !endif # DEBUG
  
  INCL =	vim.h os_win32.h ascii.h feature.h globals.h keymap.h macros.h \
! 	proto.h option.h structs.h term.h $(SNIFF_INCL) $(CSCOPE_INCL)
  
  OBJ = \
  	$(OUTDIR)\buffer.obj \
--- 317,324 ----
  !endif # DEBUG
  
  INCL =	vim.h os_win32.h ascii.h feature.h globals.h keymap.h macros.h \
! 	proto.h option.h structs.h term.h $(SNIFF_INCL) $(CSCOPE_INCL) \
! 	$(NBDEBUG_INCL)
  
  OBJ = \
  	$(OUTDIR)\buffer.obj \
***************
*** 568,581 ****
  
  LINKARGS1 = $(linkdebug) $(conflags) /nodefaultlib:libc
  LINKARGS2 = $(CON_LIB) $(GUI_LIB) $(LIBC) $(OLE_LIB)  user32.lib $(SNIFF_LIB) \
! 		$(PERL_LIB) $(PYTHON_LIB) $(RUBY_LIB) $(TCL_LIB) $(LINK_PDB)
  
  all:	$(VIM) vimrun.exe install.exe uninstal.exe xxd/xxd.exe GvimExt/gvimext.dll
  
! $(VIM): $(OUTDIR) $(OBJ) $(GUI_OBJ) $(OLE_OBJ) $(OLE_IDL) $(PERL_OBJ) $(PYTHON_OBJ) $(RUBY_OBJ) $(TCL_OBJ) $(SNIFF_OBJ) $(CSCOPE_OBJ) version.c version.h
  	$(CC) $(CFLAGS)  version.c /Fo$(OUTDIR)/version.obj $(PDB)
  	$(link) $(LINKARGS1) -out:$*.exe $(OBJ) $(GUI_OBJ) $(OLE_OBJ) \
! 		$(PERL_OBJ) $(PYTHON_OBJ) $(RUBY_OBJ) $(TCL_OBJ) $(SNIFF_OBJ) $(CSCOPE_OBJ) \
  		$(OUTDIR)\version.obj $(LINKARGS2)
  
  $(VIM).exe: $(VIM)
--- 601,616 ----
  
  LINKARGS1 = $(linkdebug) $(conflags) /nodefaultlib:libc
  LINKARGS2 = $(CON_LIB) $(GUI_LIB) $(LIBC) $(OLE_LIB)  user32.lib $(SNIFF_LIB) \
! 		$(PERL_LIB) $(PYTHON_LIB) $(RUBY_LIB) $(TCL_LIB) \
! 		$(NETBEANS_LIB) $(XPM_LIB) $(LINK_PDB)
  
  all:	$(VIM) vimrun.exe install.exe uninstal.exe xxd/xxd.exe GvimExt/gvimext.dll
  
! $(VIM): $(OUTDIR) $(OBJ) $(GUI_OBJ) $(OLE_OBJ) $(OLE_IDL) $(PERL_OBJ) $(PYTHON_OBJ) $(RUBY_OBJ) $(TCL_OBJ) $(SNIFF_OBJ) $(CSCOPE_OBJ) $(NETBEANS_OBJ) $(XPM_OBJ) version.c version.h
  	$(CC) $(CFLAGS)  version.c /Fo$(OUTDIR)/version.obj $(PDB)
  	$(link) $(LINKARGS1) -out:$*.exe $(OBJ) $(GUI_OBJ) $(OLE_OBJ) \
! 		$(PERL_OBJ) $(PYTHON_OBJ) $(RUBY_OBJ) $(TCL_OBJ) $(SNIFF_OBJ) \
! 		$(CSCOPE_OBJ) $(NETBEANS_OBJ) $(XPM_OBJ) \
  		$(OUTDIR)\version.obj $(LINKARGS2)
  
  $(VIM).exe: $(VIM)
***************
*** 695,700 ****
--- 730,737 ----
  
  $(OUTDIR)/gui_w32.obj:	$(OUTDIR) gui_w32.c gui_w48.c $(INCL) $(GUI_INCL)
  
+ $(OUTDIR)/if_cscope.obj: $(OUTDIR) if_cscope.c  $(INCL)
+ 
  if_perl.c : if_perl.xs typemap
  	$(PERL_EXE) $(XSUBPP) -prototypes -typemap $(XSUBPP_TYPEMAP) -typemap typemap if_perl.xs > if_perl.c
  
***************
*** 738,743 ****
--- 775,782 ----
  
  $(OUTDIR)/mbyte.obj: $(OUTDIR) mbyte.c  $(INCL)
  
+ $(OUTDIR)/netbeans.obj: $(OUTDIR) netbeans.c $(NBDEBUG_SRC) $(INCL)
+ 
  $(OUTDIR)/normal.obj:	$(OUTDIR) normal.c  $(INCL)
  
  $(OUTDIR)/option.obj:	$(OUTDIR) option.c  $(INCL)
***************
*** 773,778 ****
--- 812,820 ----
  
  $(OUTDIR)/window.obj:	$(OUTDIR) window.c  $(INCL)
  
+ $(OUTDIR)/xpm_w32.obj: $(OUTDIR) xpm_w32.c
+ 	$(CC) $(CFLAGS) $(XPM_INC) xpm_w32.c /Fo$(OUTDIR)/xpm_w32.obj $(PDB)
+ 
  $(OUTDIR)/vim.res:	$(OUTDIR) vim.rc version.h tools.bmp tearoff.bmp vim.ico vim_error.ico vim_alert.ico vim_info.ico vim_quest.ico
  	$(RC) /l 0x409 /Fo$(OUTDIR)/vim.res $(RCFLAGS) vim.rc
  
***************
*** 839,844 ****
  	proto/term.pro \
  	proto/ui.pro \
  	proto/undo.pro \
! 	proto/window.pro
  
  # vim: set noet sw=8 ts=8 sts=0 wm=0 tw=0:
--- 881,887 ----
  	proto/term.pro \
  	proto/ui.pro \
  	proto/undo.pro \
! 	proto/window.pro \
! 	$(NETBEANS_PRO)
  
  # vim: set noet sw=8 ts=8 sts=0 wm=0 tw=0:
*** ../vim-6.2.106/src/bigvim.bat	Mon Apr 28 21:30:10 2003
--- src/bigvim.bat	Fri Sep 12 22:08:59 2003
***************
*** 1,3 ****
  :: command to build big Vim with OLE, Perl, Python and Tcl
! nmake -f make_mvc.mak GUI=yes OLE=yes PERL=E:\perl DYNAMIC_PERL=yes PERL_VER=56 PYTHON=e:\python21 DYNAMIC_PYTHON=yes PYTHON_VER=21 TCL=e:\tcl DYNAMIC_TCL=yes %1 IME=yes CSCOPE=yes
  
--- 1,3 ----
  :: command to build big Vim with OLE, Perl, Python and Tcl
! nmake -f make_mvc.mak GUI=yes OLE=yes PERL=E:\perl DYNAMIC_PERL=yes PERL_VER=56 PYTHON=e:\python21 DYNAMIC_PYTHON=yes PYTHON_VER=21 TCL=e:\tcl DYNAMIC_TCL=yes %1 IME=yes CSCOPE=yes XPM=e:\xpm
  
*** ../vim-6.2.106/src/feature.h	Mon Jun 30 22:18:22 2003
--- src/feature.h	Fri Sep 12 22:14:26 2003
***************
*** 1109,1118 ****
  #endif
  
  /*
!  * The Netbeans features currently only work with Motif and GTK.
   * It also requires +listcmds and +eval.
   */
! #if ((!defined(FEAT_GUI_MOTIF) && !defined(FEAT_GUI_GTK)) \
  		|| !defined(FEAT_LISTCMDS) || !defined(FEAT_EVAL)) \
  	&& defined(FEAT_NETBEANS_INTG)
  # undef FEAT_NETBEANS_INTG
--- 1109,1118 ----
  #endif
  
  /*
!  * The Netbeans features currently only work with Motif and GTK and Win32.
   * It also requires +listcmds and +eval.
   */
! #if ((!defined(FEAT_GUI_MOTIF) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_W32)) \
  		|| !defined(FEAT_LISTCMDS) || !defined(FEAT_EVAL)) \
  	&& defined(FEAT_NETBEANS_INTG)
  # undef FEAT_NETBEANS_INTG
***************
*** 1139,1150 ****
   *			Currently only for Athena and Motif.
   */
  #if (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) \
! 			     || defined(FEAT_GUI_GTK)) \
! 	&& (   (defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_GTK)) \
  	    || defined(FEAT_SUN_WORKSHOP) \
  	    || defined(FEAT_NETBEANS_INTG))
  # define FEAT_BEVAL
! # if !defined(FEAT_XFONTSET) && !defined(FEAT_GUI_GTK)
  #  define FEAT_XFONTSET
  # endif
  #endif
--- 1139,1152 ----
   *			Currently only for Athena and Motif.
   */
  #if (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) \
! 	|| defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32)) \
! 	&& (   (defined(FEAT_TOOLBAR) \
! 		&& !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_W32)) \
  	    || defined(FEAT_SUN_WORKSHOP) \
  	    || defined(FEAT_NETBEANS_INTG))
  # define FEAT_BEVAL
! # if !defined(FEAT_XFONTSET) && !defined(FEAT_GUI_GTK) \
! 	&& !defined(FEAT_GUI_W32)
  #  define FEAT_XFONTSET
  # endif
  #endif
*** ../vim-6.2.106/src/gui_beval.c	Sat May 31 22:30:51 2003
--- src/gui_beval.c	Fri Sep 12 22:17:52 2003
***************
*** 12,17 ****
--- 12,20 ----
  
  #if defined(FEAT_BEVAL) || defined(PROTO)
  
+ /* on Win32 only gui_mch_get_beval_info is required */
+ #if !defined(FEAT_GUI_W32) || defined(PROTO)
+ 
  #ifdef FEAT_GUI_GTK
  # include <gdk/gdkkeysyms.h>
  # include <gtk/gtk.h>
***************
*** 194,199 ****
--- 197,203 ----
      return current_beval;
  }
  #endif
+ #endif /* !FEAT_GUI_W32 */
  
  #if defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG) || defined(PROTO)
  /*
***************
*** 256,265 ****
  		    if (VIsual_active
  			    && wp->w_buffer == curwin->w_buffer
  			    && (lnum == spos->lnum
! 				? col >= spos->col
  				: lnum > spos->lnum)
  			    && (lnum == epos->lnum
! 				? col <= epos->col
  				: lnum < epos->lnum))
  		    {
  			/* Visual mode and pointing to the line with the
--- 260,269 ----
  		    if (VIsual_active
  			    && wp->w_buffer == curwin->w_buffer
  			    && (lnum == spos->lnum
! 				? col >= (int)spos->col
  				: lnum > spos->lnum)
  			    && (lnum == epos->lnum
! 				? col <= (int)epos->col
  				: lnum < epos->lnum))
  		    {
  			/* Visual mode and pointing to the line with the
***************
*** 300,305 ****
--- 304,311 ----
      return FAIL;
  }
  
+ # if !defined(FEAT_GUI_W32) || defined(PROTO)
+ 
  /*
   * Show a balloon with "mesg".
   */
***************
*** 314,321 ****
      else
  	undrawBalloon(beval);
  }
! #endif
  
  #if defined(FEAT_BEVAL_TIP) || defined(PROTO)
  /*
   * Hide the given balloon.
--- 320,329 ----
      else
  	undrawBalloon(beval);
  }
! # endif /* FEAT_GUI_W32 */
! #endif /* FEAT_SUN_WORKSHOP || FEAT_NETBEANS_INTG || PROTO */
  
+ #if !defined(FEAT_GUI_W32) || defined(PROTO)
  #if defined(FEAT_BEVAL_TIP) || defined(PROTO)
  /*
   * Hide the given balloon.
***************
*** 1255,1259 ****
--- 1263,1268 ----
  }
  
  #endif /* !FEAT_GUI_GTK */
+ #endif /* !FEAT_GUI_W32 */
  
  #endif /* FEAT_BEVAL */
*** ../vim-6.2.106/src/gui_beval.h	Sat Apr 19 16:06:43 2003
--- src/gui_beval.h	Mon Sep 29 09:56:44 2003
***************
*** 13,19 ****
  #ifdef FEAT_GUI_GTK
  # include <gtk/gtkwidget.h>
  #else
! # include <X11/Intrinsic.h>
  #endif
  
  typedef enum
--- 13,21 ----
  #ifdef FEAT_GUI_GTK
  # include <gtk/gtkwidget.h>
  #else
! # if defined(FEAT_GUI_X11)
! #  include <X11/Intrinsic.h>
! # endif
  #endif
  
  typedef enum
***************
*** 36,41 ****
--- 38,44 ----
      int			y;
      unsigned int	state;		/* Button/Modifier key state */
  #else
+ # if !defined(FEAT_GUI_W32)
      Widget		target;		/* widget we are monitoring */
      Widget		balloonShell;
      Widget		balloonLabel;
***************
*** 47,58 ****
      Position		x_root;
      Position		y_root;
      int			state;		/* Button/Modifier key state */
  #endif
      int			ts;		/* tabstop setting for this buffer */
      char_u		*msg;
      void		(*msgCB)();
      void		*clientData;	/* For callback */
! #ifndef FEAT_GUI_GTK
      Dimension		screen_width;	/* screen width in pixels */
      Dimension		screen_height;	/* screen height in pixels */
  #endif
--- 50,68 ----
      Position		x_root;
      Position		y_root;
      int			state;		/* Button/Modifier key state */
+ # else
+     HWND		target;
+     HWND		balloon;
+     int			x;
+     int			y;
+     BeState		showState;	/* tells us whats currently going on */
+ # endif
  #endif
      int			ts;		/* tabstop setting for this buffer */
      char_u		*msg;
      void		(*msgCB)();
      void		*clientData;	/* For callback */
! #if !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_W32)
      Dimension		screen_width;	/* screen width in pixels */
      Dimension		screen_height;	/* screen height in pixels */
  #endif
*** ../vim-6.2.106/src/gui_w32.c	Fri Jul 25 22:43:59 2003
--- src/gui_w32.c	Mon Sep 29 11:29:15 2003
***************
*** 44,49 ****
--- 44,52 ----
   */
  #include "gui_w48.c"
  
+ #ifdef FEAT_XPM_W32
+ # include "xpm_w32.h"
+ #endif
  
  #ifdef __MINGW32__
  /*
***************
*** 170,175 ****
--- 173,192 ----
  #endif
  
  
+ #ifdef FEAT_BEVAL
+ # define ID_BEVAL_TOOLTIP   200
+ # define BEVAL_TEXT_LEN	    MAXPATHL
+ 
+ static void make_tooltip __ARGS((BalloonEval *beval, char *text, POINT pt));
+ static void delete_tooltip __ARGS((BalloonEval *beval));
+ static VOID CALLBACK BevalTimerProc __ARGS((HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime));
+ void TrackUserActivity __ARGS((UINT uMsg));
+ 
+ static BalloonEval  *cur_beval = NULL;
+ static UINT	    BevalTimerId = 0;
+ static DWORD	    LastActivity = 0;
+ #endif
+ 
  /* Local variables: */
  
  #ifdef FEAT_MENU
***************
*** 182,188 ****
  # define USE_SYSMENU_FONT
  #endif
  
- 
  #define VIM_NAME	"vim"
  #define VIM_CLASS	"Vim"
  
--- 199,204 ----
***************
*** 287,293 ****
  static TMonitorFromWindow   pMonitorFromWindow = NULL;
  static TGetMonitorInfo	    pGetMonitorInfo = NULL;
  static HANDLE		    user32_lib = NULL;
! 
  /*
   * Return TRUE when running under Windows NT 3.x or Win32s, both of which have
   * less fancy GUI APIs.
--- 303,311 ----
  static TMonitorFromWindow   pMonitorFromWindow = NULL;
  static TGetMonitorInfo	    pGetMonitorInfo = NULL;
  static HANDLE		    user32_lib = NULL;
! #ifdef FEAT_NETBEANS_INTG
! int WSInitialized = FALSE; /* WinSock is initialized */
! #endif
  /*
   * Return TRUE when running under Windows NT 3.x or Win32s, both of which have
   * less fancy GUI APIs.
***************
*** 512,517 ****
--- 530,557 ----
  }
  #endif
  
+ #ifdef FEAT_NETBEANS_INTG
+     static void
+ _OnWindowPosChanged(
+     HWND hwnd,
+     const LPWINDOWPOS lpwpos)
+ {
+     static int x = 0, y = 0, cx = 0, cy = 0;
+ 
+     if (WSInitialized && (lpwpos->x != x || lpwpos->y != y
+ 				     || lpwpos->cx != cx || lpwpos->cy != cy))
+     {
+ 	x = lpwpos->x;
+ 	y = lpwpos->y;
+ 	cx = lpwpos->cx;
+ 	cy = lpwpos->cy;
+         netbeans_frame_moved(x, y);
+     }
+     /* Allow to send WM_SIZE and WM_MOVE */
+     FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, DefWindowProc);
+ }
+ #endif
+ 
      static int
  _DuringSizing(
      HWND hwnd,
***************
*** 588,593 ****
--- 628,636 ----
  	HANDLE_MSG(hwnd, WM_VSCROLL,	_OnScroll);
  	// HANDLE_MSG(hwnd, WM_WINDOWPOSCHANGING,	_OnWindowPosChanging);
  	HANDLE_MSG(hwnd, WM_ACTIVATEAPP, _OnActivateApp);
+ #ifdef FEAT_NETBEANS_INTG
+ 	HANDLE_MSG(hwnd, WM_WINDOWPOSCHANGED, _OnWindowPosChanged);
+ #endif
  
      case WM_QUERYENDSESSION:	/* System wants to go down. */
  	gui_shell_closed();	/* Will exit when no changed buffers. */
***************
*** 838,843 ****
--- 881,914 ----
      }
  #endif
  
+ #ifdef FEAT_NETBEANS_INTG
+     {
+ 	/* stolen from gui_x11.x */
+ 	int arg;
+ 
+ 	for (arg = 1; arg < *argc; arg++)
+ 	    if (strncmp("-nb", argv[arg], 3) == 0)
+ 	    {
+ 		usingNetbeans++;
+ 		netbeansArg = argv[arg];
+ 		mch_memmove(&argv[arg], &argv[arg + 1],
+ 					    (--*argc - arg) * sizeof(char *));
+ 		break;	/* enough? */
+ 	    }
+ 
+ 	if (usingNetbeans)
+ 	{
+ 	    WSADATA wsaData;
+ 	    int wsaerr;
+ 
+ 	    /* Init WinSock */
+ 	    wsaerr = WSAStartup(MAKEWORD(2, 2), &wsaData);
+ 	    if (wsaerr == 0)
+ 		WSInitialized = TRUE;
+ 	}
+     }
+ #endif
+ 
      /* get the OS version info */
      os_version.dwOSVersionInfoSize = sizeof(os_version);
      GetVersionEx(&os_version); /* this call works on Win32s, Win95 and WinNT */
***************
*** 1034,1039 ****
--- 1105,1114 ----
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
  #endif
+ #ifdef FEAT_NETBEANS_INTG
+     if (usingNetbeans)
+ 	netbeans_w32_connect();
+ #endif
  
      return OK;
  }
***************
*** 3359,3368 ****
--- 3434,3451 ----
  #endif
  
  #if defined(FEAT_SIGN_ICONS) || defined(PROTO)
+ 
+ # ifdef FEAT_XPM_W32
+ #  define IMAGE_XPM   100
+ # endif
+ 
  typedef struct _signicon_t
  {
      HANDLE	hImage;
      UINT	uType;
+ #ifdef FEAT_XPM_W32
+     HANDLE	hShape;	/* Mask bitmap handle */
+ #endif
  } signicon_t;
  
      void
***************
*** 3399,3404 ****
--- 3482,3506 ----
  	case IMAGE_CURSOR:
  	    DrawIconEx(s_hdc, x, y, (HICON)sign->hImage, w, h, 0, NULL, DI_NORMAL);
  	    break;
+ #ifdef FEAT_XPM_W32
+ 	case IMAGE_XPM:
+ 	    {
+ 		HDC hdcMem;
+ 		HBITMAP hbmpOld;
+ 
+ 		hdcMem = CreateCompatibleDC(s_hdc);
+ 		hbmpOld = (HBITMAP)SelectObject(hdcMem, sign->hShape);
+ 		/* Make hole */
+ 		BitBlt(s_hdc, x, y, w, h, hdcMem, 0, 0, SRCAND);
+ 
+ 		SelectObject(hdcMem, sign->hImage);
+ 		/* Paint sign */
+ 		BitBlt(s_hdc, x, y, w, h, hdcMem, 0, 0, SRCPAINT);
+ 		SelectObject(hdcMem, hbmpOld);
+ 		DeleteDC(hdcMem);
+ 	    }
+ 	    break;
+ #endif
      }
  }
  
***************
*** 3417,3422 ****
--- 3519,3530 ----
  	    case IMAGE_ICON:
  		DestroyIcon((HICON)sign->hImage);
  		break;
+ #ifdef FEAT_XPM_W32
+ 	    case IMAGE_XPM:
+ 		DeleteObject((HBITMAP)sign->hImage);
+ 		DeleteObject((HBITMAP)sign->hShape);
+ 		break;
+ #endif
  	}
  }
  
***************
*** 3452,3457 ****
--- 3560,3572 ----
  	    sign.hImage = (HANDLE)LoadImage(NULL, signfile, sign.uType,
  		    gui.char_width * 2, gui.char_height,
  		    LR_LOADFROMFILE | LR_CREATEDIBSECTION);
+ #ifdef FEAT_XPM_W32
+ 	if (!STRICMP(ext, ".xpm"))
+ 	{
+ 	    sign.uType = IMAGE_XPM;
+ 	    LoadXpmImage(signfile, (HBITMAP *)&sign.hImage, (HBITMAP *)&sign.hShape);
+ 	}
+ #endif
      }
  
      psign = NULL;
***************
*** 3479,3482 ****
--- 3594,3864 ----
  	vim_free(sign);
      }
  }
+ 
+ #if defined(FEAT_BEVAL) || defined(PROTO)
+ 
+ /* BALLOON-EVAL IMPLEMENTATION FOR WINDOWS.
+  *  Added by Sergey Khorev
+  *
+  * The only reused thing is gui_beval.h and gui_mch_get_beval_info()
+  * from gui_beval.c (note it uses x and y of the BalloonEval struct
+  * to get current mouse position).
+  *
+  * Trying to use as more Windows services as possible, and as less
+  * IE version as possible :)).
+  *
+  * 1) Don't create ToolTip in gui_mch_create_beval_area, only initialize
+  * BalloonEval struct.
+  * 2) Enable/Disable simply create/kill BalloonEval Timer
+  * 3) When there was enough inactivity, timer procedure posts
+  * async request to debugger
+  * 4) gui_mch_post_balloon (invoked from netbeans.c) creates tooltip control
+  * and performs some actions to show it ASAP
+  * 5) WM_NOTOFY:TTN_POP destroys created tooltip
+  */
+ 
+     static void
+ make_tooltip(beval, text, pt)
+     BalloonEval *beval;
+     char *text;
+     POINT pt;
+ {
+     TOOLINFO	ti;
+ 
+     beval->balloon = CreateWindowEx(WS_EX_TOPMOST, TOOLTIPS_CLASS,
+ 	    NULL, WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
+ 	    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
+ 	    beval->target, NULL, s_hinst, NULL);
+ 
+     SetWindowPos(beval->balloon, HWND_TOPMOST, 0, 0, 0, 0,
+ 	    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
+ 
+     ti.cbSize = sizeof(TOOLINFO);
+     ti.uFlags = TTF_SUBCLASS;
+     ti.hwnd = beval->target;
+     ti.hinst = 0; /* Don't use string resources */
+     ti.uId = ID_BEVAL_TOOLTIP;
+     ti.lpszText = text;
+ 
+     /* Limit ballooneval bounding rect to CursorPos neighbourhood */
+     ti.rect.left = pt.x - 3;
+     ti.rect.top = pt.y - 3;
+     ti.rect.right = pt.x + 3;
+     ti.rect.bottom = pt.y + 3;
+ 
+     SendMessage(beval->balloon, TTM_ADDTOOL, 0, (LPARAM)&ti);
+     /* Make tooltip appear sooner */
+     SendMessage(beval->balloon, TTM_SETDELAYTIME, TTDT_INITIAL, 10);
+     /*
+      * HACK: force tooltip to appear, because it'll not appear until
+      * first mouse move. D*mn M$
+      */
+     mouse_event(MOUSEEVENTF_MOVE, 1, 1, 0, 0);
+     mouse_event(MOUSEEVENTF_MOVE, -1, -1, 0, 0);
+ }
+ 
+     static void
+ delete_tooltip(beval)
+     BalloonEval	*beval;
+ {
+     DestroyWindow(beval->balloon);
+ }
+ 
+     static VOID CALLBACK
+ BevalTimerProc(hwnd, uMsg, idEvent, dwTime)
+     HWND    hwnd;
+     UINT    uMsg;
+     UINT    idEvent;
+     DWORD   dwTime;
+ {
+     POINT	pt;
+     RECT	rect;
+ 
+     if (cur_beval == NULL || cur_beval->showState == ShS_SHOWING || !p_beval)
+ 	return;
+ 
+     GetCursorPos(&pt);
+     if (WindowFromPoint(pt) != s_textArea)
+ 	return;
+ 
+     ScreenToClient(s_textArea, &pt);
+     GetClientRect(s_textArea, &rect);
+     if (!PtInRect(&rect, pt))
+ 	return;
+ 
+     if (LastActivity > 0
+ 	    && (dwTime - LastActivity) >= (DWORD)p_bdlay
+ 	    && (cur_beval->showState != ShS_PENDING
+ 		|| abs(cur_beval->x - pt.x) > 3
+ 		|| abs(cur_beval->y - pt.y) > 3))
+     {
+ 	/* Pointer resting in one place long enough, it's time to show
+ 	 * the tooltip. */
+ 	cur_beval->showState = ShS_PENDING;
+ 	cur_beval->x = pt.x;
+ 	cur_beval->y = pt.y;
+ 
+ 	TRACE0("BevalTimerProc: sending request");
+ 
+ 	if (cur_beval->msgCB != NULL)
+ 	    (*cur_beval->msgCB)(cur_beval, 0);
+     }
+ }
+ 
+     void
+ gui_mch_disable_beval_area(beval)
+     BalloonEval	*beval;
+ {
+     TRACE0("gui_mch_disable_beval_area {{{");
+     KillTimer(s_textArea, BevalTimerId);
+     TRACE0("gui_mch_disable_beval_area }}}");
+ }
+ 
+     void
+ gui_mch_enable_beval_area(beval)
+     BalloonEval	*beval;
+ {
+     TRACE0("gui_mch_enable_beval_area |||");
+     if (beval == NULL)
+ 	return;
+     TRACE0("gui_mch_enable_beval_area {{{");
+     BevalTimerId = SetTimer(s_textArea, 0, p_bdlay / 2, (TIMERPROC)BevalTimerProc);
+     TRACE0("gui_mch_enable_beval_area }}}");
+ }
+ 
+     void
+ gui_mch_post_balloon(beval, mesg)
+     BalloonEval	*beval;
+     char_u	*mesg;
+ {
+     POINT   pt;
+     TRACE0("gui_mch_post_balloon {{{");
+     if (beval->showState == ShS_SHOWING)
+ 	return;
+     GetCursorPos(&pt);
+     ScreenToClient(s_textArea, &pt);
+ 
+     if (abs(beval->x - pt.x) < 3 && abs(beval->y - pt.y) < 3)
+ 	/* cursor is still here */
+     {
+ 	gui_mch_disable_beval_area(cur_beval);
+ 	beval->showState = ShS_SHOWING;
+ 	make_tooltip(beval, mesg, pt);
+     }
+     TRACE0("gui_mch_post_balloon }}}");
+ }
+ 
+     BalloonEval *
+ gui_mch_create_beval_area(target, mesg, mesgCB, clientData)
+     void	*target;	/* ignored, always use s_textArea */
+     char_u	*mesg;
+     void	(*mesgCB)__ARGS((BalloonEval *, int));
+     void	*clientData;
+ {
+     /* partially stolen from gui_beval.c */
+     BalloonEval	*beval;
+ 
+     if (mesg != NULL && mesgCB != NULL)
+     {
+ 	EMSG(_("E232: Cannot create BalloonEval with both message and callback"));
+ 	return NULL;
+     }
+ 
+     beval = (BalloonEval *)alloc(sizeof(BalloonEval));
+     if (beval != NULL)
+     {
+ 	beval->target = s_textArea;
+ 	beval->balloon = NULL;
+ 
+ 	beval->showState = ShS_NEUTRAL;
+ 	beval->x = 0;
+ 	beval->y = 0;
+ 	beval->msg = mesg;
+ 	beval->msgCB = mesgCB;
+ 	beval->clientData = clientData;
+ 
+ 	InitCommonControls();
+ 
+ 	cur_beval = beval;
+ 
+ 	if (p_beval)
+ 	    gui_mch_enable_beval_area(beval);
+ 
+     }
+     return beval;
+ }
+ 
+     void
+ Handle_WM_Notify(hwnd, pnmh)
+     HWND hwnd;
+     LPNMHDR pnmh;
+ {
+     if (pnmh->idFrom != ID_BEVAL_TOOLTIP) /* it is not our tooltip */
+ 	return;
+ 
+     if (cur_beval != NULL)
+     {
+ 	if (pnmh->code == TTN_SHOW)
+ 	{
+ 	    TRACE0("TTN_SHOW {{{");
+ 	    TRACE0("TTN_SHOW }}}");
+ 	}
+ 	else if (pnmh->code == TTN_POP) /* Before tooltip disappear */
+ 	{
+ 	    TRACE0("TTN_POP {{{");
+ 	    delete_tooltip(cur_beval);
+ 	    gui_mch_enable_beval_area(cur_beval);
+ 	    TRACE0("TTN_POP }}}");
+ 
+ 	    cur_beval->showState = ShS_NEUTRAL;
+ 	}
+     }
+ }
+ 
+ void TrackUserActivity (uMsg)
+     UINT    uMsg;
+ {
+     if ((uMsg >= WM_MOUSEFIRST && uMsg <= WM_MOUSELAST) ||
+ 	    (uMsg >= WM_KEYFIRST && uMsg <= WM_KEYLAST))
+     {
+ 	LastActivity = GetTickCount();
+     }
+ }
+ 
+     void
+ gui_mch_destroy_beval_area(beval)
+     BalloonEval	*beval;
+ {
+     vim_free(beval);
+ }
+ #endif /* FEAT_BEVAL */
+ 
+ #if defined(FEAT_NETBEANS_INTG) || defined(PROTO)
+ /*
+  * We have multiple signs to draw at the same location. Draw the
+  * multi-sign indicator (down-arrow) instead. This is the Win32 version.
+  */
+     void
+ netbeans_draw_multisign_indicator(int row)
+ {
+     int i;
+     int y;
+     int x;
+ 
+     x = 0;
+     y = TEXT_Y(row);
+ 
+     for (i = 0; i < gui.char_height - 3; i++)
+ 	SetPixel(s_hdc, x+2, y++, gui.currFgColor);
+ 
+     SetPixel(s_hdc, x+0, y, gui.currFgColor);
+     SetPixel(s_hdc, x+2, y, gui.currFgColor);
+     SetPixel(s_hdc, x+4, y++, gui.currFgColor);
+     SetPixel(s_hdc, x+1, y, gui.currFgColor);
+     SetPixel(s_hdc, x+2, y, gui.currFgColor);
+     SetPixel(s_hdc, x+3, y++, gui.currFgColor);
+     SetPixel(s_hdc, x+2, y, gui.currFgColor);
+ }
+ #endif
+ 
  #endif
*** ../vim-6.2.106/src/gui_w48.c	Sat Sep 27 19:40:03 2003
--- src/gui_w48.c	Fri Oct  3 15:13:55 2003
***************
*** 28,34 ****
  #ifndef __MINGW32__
  # include <shellapi.h>
  #endif
! #ifdef FEAT_TOOLBAR
  # include <commctrl.h>
  #endif
  #ifdef WIN16
--- 28,34 ----
  #ifndef __MINGW32__
  # include <shellapi.h>
  #endif
! #if defined(FEAT_TOOLBAR) || defined(FEAT_BEVAL)
  # include <commctrl.h>
  #endif
  #ifdef WIN16
***************
*** 113,123 ****
  typedef int UINT;
  typedef int WORD;
  typedef int WPARAM;
! typedef void * HINSTANCE;
! typedef void * HMENU;
! typedef void * HWND;
  typedef void *HDC;
  typedef void VOID;
  #endif
  
  #ifndef GET_X_LPARAM
--- 113,125 ----
  typedef int UINT;
  typedef int WORD;
  typedef int WPARAM;
! typedef void *HINSTANCE;
! typedef void *HMENU;
! typedef void *HWND;
  typedef void *HDC;
  typedef void VOID;
+ typedef int LPNMHDR;
+ typedef int LONG;
  #endif
  
  #ifndef GET_X_LPARAM
***************
*** 228,233 ****
--- 230,238 ----
      {VK_F20,		'F', 'A'},
  
      {VK_F21,		'F', 'B'},
+ #ifdef FEAT_NETBEANS_INTG
+     {VK_PAUSE,		'F', 'B'},	/* Pause == F21 (see gui_gtk_x11.c) */
+ #endif
      {VK_F22,		'F', 'C'},
      {VK_F23,		'F', 'D'},
      {VK_F24,		'F', 'E'},	/* winuser.h defines up to F24 */
***************
*** 279,284 ****
--- 284,295 ----
  static int		s_timed_out = FALSE;
  static int		dead_key = 0;	/* 0 - no dead key, 1 - dead key pressed */
  
+ #ifdef FEAT_BEVAL
+ /* balloon-eval WM_NOTIFY_HANDLER */
+ void Handle_WM_Notify __ARGS((HWND hwnd, LPNMHDR pnmh));
+ void TrackUserActivity __ARGS((UINT uMsg));
+ #endif
+ 
  /*
   * For control IME.
   */
***************
*** 900,905 ****
--- 911,920 ----
      s_wParam = wParam;
      s_lParam = lParam;
  
+ #ifdef FEAT_BEVAL
+     TrackUserActivity(uMsg);
+ #endif
+ 
      switch (uMsg)
      {
  	HANDLE_MSG(hwnd, WM_LBUTTONDBLCLK,_OnMouseButtonDown);
***************
*** 919,924 ****
--- 934,944 ----
  	HANDLE_MSG(hwnd, WM_XBUTTONUP,	_OnMouseMoveOrRelease);
  #endif
  
+ #ifdef FEAT_BEVAL
+ 	case WM_NOTIFY: Handle_WM_Notify(hwnd, (LPNMHDR)lParam);
+ 	    return TRUE;
+ #endif
+ 
      default:
  	return DefWindowProc(hwnd, uMsg, wParam, lParam);
      }
***************
*** 1472,1477 ****
--- 1492,1505 ----
      }
  #endif
  
+ #ifdef FEAT_NETBEANS_INTG
+     if (msg.message == WM_NETBEANS)
+     {
+ 	messageFromNetbeansW32();
+ 	return;
+     }
+ #endif
+ 
  #ifdef FEAT_SNIFF
      if (sniff_request_waiting && want_sniff_request)
      {
*** ../vim-6.2.106/src/menu.c	Fri Sep 12 20:13:48 2003
--- src/menu.c	Fri Sep 12 21:30:03 2003
***************
*** 764,770 ****
  		menu->silent[i] = menuarg->silent[0];
  	    }
  	}
! #if defined(FEAT_TOOLBAR) && (defined(FEAT_BEVAL) || defined(FEAT_GUI_GTK))
  	/* Need to update the menu tip. */
  	if (modes & MENU_TIP_MODE)
  	    gui_mch_menu_set_tip(menu);
--- 764,771 ----
  		menu->silent[i] = menuarg->silent[0];
  	    }
  	}
! #if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32) \
! 	&& (defined(FEAT_BEVAL) || defined(FEAT_GUI_GTK))
  	/* Need to update the menu tip. */
  	if (modes & MENU_TIP_MODE)
  	    gui_mch_menu_set_tip(menu);
***************
*** 942,948 ****
  	if (modes & MENU_TIP_MODE)
  	{
  	    free_menu_string(menu, MENU_INDEX_TIP);
! #if defined(FEAT_TOOLBAR) && (defined(FEAT_BEVAL) || defined(FEAT_GUI_GTK))
  	    /* Need to update the menu tip. */
  	    if (gui.in_use)
  		gui_mch_menu_set_tip(menu);
--- 943,950 ----
  	if (modes & MENU_TIP_MODE)
  	{
  	    free_menu_string(menu, MENU_INDEX_TIP);
! #if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32) \
! 	    && (defined(FEAT_BEVAL) || defined(FEAT_GUI_GTK))
  	    /* Need to update the menu tip. */
  	    if (gui.in_use)
  		gui_mch_menu_set_tip(menu);
*** ../vim-6.2.106/src/nbdebug.c	Thu Feb 13 16:41:13 2003
--- src/nbdebug.c	Tue Sep 16 11:42:48 2003
***************
*** 38,45 ****
  void		 nbtrace(char *, ...);
  
  static int	 lookup(char *);
  static int	 errorHandler(Display *, XErrorEvent *);
! 
  
  /*
   * nbdebug_wait	-   This function can be used to delay or stop execution of vim.
--- 38,46 ----
  void		 nbtrace(char *, ...);
  
  static int	 lookup(char *);
+ #ifndef FEAT_GUI_W32
  static int	 errorHandler(Display *, XErrorEvent *);
! #endif
  
  /*
   * nbdebug_wait	-   This function can be used to delay or stop execution of vim.
***************
*** 83,93 ****
  	char		*cp;		/* nb_dlevel pointer */
  
  	if (log_var && (file = getenv(log_var)) != NULL) {
! 		char buf[BUFSIZ];
  
! 		sprintf(buf, "date > %s", file);
! 		system(buf);
! 		nb_debug = fopen(file, "a");
  		if (level_var && (cp = getenv(level_var)) != NULL) {
  			nb_dlevel = strtoul(cp, NULL, 0);
  		} else {
--- 84,94 ----
  	char		*cp;		/* nb_dlevel pointer */
  
  	if (log_var && (file = getenv(log_var)) != NULL) {
! 		time_t now;
  
! 		nb_debug = fopen(file, "w");
! 		time(&now);
! 		fprintf(nb_debug, "%s", asctime(localtime(&now)));
  		if (level_var && (cp = getenv(level_var)) != NULL) {
  			nb_dlevel = strtoul(cp, NULL, 0);
  		} else {
***************
*** 142,151 ****
  	char		 buf[BUFSIZ];
  
  	expand_env((char_u *) file, (char_u *) buf, BUFSIZ);
! 	return (access(buf, F_OK) == 0);
  
  }    /* end lookup */
  
  static int
  errorHandler(
  	Display		*dpy,
--- 143,158 ----
  	char		 buf[BUFSIZ];
  
  	expand_env((char_u *) file, (char_u *) buf, BUFSIZ);
! 	return
! #ifndef FEAT_GUI_W32
! 		(access(buf, F_OK) == 0);
! #else
! 		(access(buf, 0) == 0);
! #endif
  
  }    /* end lookup */
  
+ #ifndef FEAT_GUI_W32
  static int
  errorHandler(
  	Display		*dpy,
***************
*** 169,175 ****
  
  	return 0;
  }
! 
  
  
  #endif /* NBDEBUG */
--- 176,182 ----
  
  	return 0;
  }
! #endif
  
  
  #endif /* NBDEBUG */
*** ../vim-6.2.106/src/nbdebug.h	Thu Feb 13 16:41:13 2003
--- src/nbdebug.h	Fri Sep 12 21:30:03 2003
***************
*** 45,50 ****
--- 45,52 ----
  void		 nbdbg(char *, ...);
  void		 nbtrace(char *, ...);
  
+ void nbdebug_wait __ARGS((u_int wait_flags, char *wait_var, u_int wait_secs));
+ void nbdebug_log_init __ARGS((char *log_var, char *level_var));
  
  extern FILE	*nb_debug;
  extern u_int	 nb_dlevel;		/* nb_debug verbosity level */
*** ../vim-6.2.106/src/netbeans.c	Sun Aug 10 22:43:27 2003
--- src/netbeans.c	Mon Sep 15 14:27:09 2003
***************
*** 2,7 ****
--- 2,8 ----
   *
   * VIM - Vi IMproved	by Bram Moolenaar
   *			Netbeans integration by David Weatherford
+  *			Adopted for Win32 by Sergey Khorev
   *
   * Do ":help uganda"  in Vim to read copying and usage conditions.
   * Do ":help credits" in Vim to see a list of people who contributed.
***************
*** 20,32 ****
  #if defined(FEAT_NETBEANS_INTG) || defined(PROTO)
  
  /* Note: when making changes here also adjust configure.in. */
! #include <stdarg.h>
! #include <fcntl.h>
! #include <netdb.h>
! #include <netinet/in.h>
! #include <sys/socket.h>
! #ifdef HAVE_LIBGEN_H
! # include <libgen.h>
  #endif
  
  #include "version.h"
--- 21,54 ----
  #if defined(FEAT_NETBEANS_INTG) || defined(PROTO)
  
  /* Note: when making changes here also adjust configure.in. */
! # include <stdarg.h>
! # include <fcntl.h>
! #ifdef WIN32
! # ifdef DEBUG
! #  include <tchar.h>	/* for _T definition for TRACEn macros */
! # endif
! # include <io.h>
! # include <winsock2.h>
! /* WinSock API is separated from C API
!  * So we can't use read, write, errno...
!  */
! # define sock_errno WSAGetLastError()
! # define ECONNREFUSED WSAECONNREFUSED
! # define sock_write(sd, buf, len) send(sd, buf, len, 0)
! # define sock_read(sd, buf, len) recv(sd, buf, len, 0)
! # define sock_close(sd) closesocket(sd)
! # define sleep(t) Sleep(t*1000) /* WinAPI Sleep() accepts milliseconds */
! #else
! # include <netdb.h>
! # include <netinet/in.h>
! # include <sys/socket.h>
! # ifdef HAVE_LIBGEN_H
! #  include <libgen.h>
! # endif
! # define sock_errno errno
! # define sock_write(sd, buf, len) write(sd, buf, len)
! # define sock_read(sd, buf, len) read(sd, buf, len)
! # define sock_close(sd) close(sd)
  #endif
  
  #include "version.h"
***************
*** 69,74 ****
--- 91,100 ----
  #ifdef FEAT_GUI_GTK
  static gint inputHandler;		/* Cookie for input */
  #endif
+ #ifdef FEAT_GUI_W32
+ static int  inputHandler = -1;		/* simply ret.value of WSAAsyncSelect() */
+ extern HWND s_hwnd;			/* Gvim's Window handle */
+ #endif
  static int cmdno;			/* current command number for reply */
  static int haveConnection = FALSE;	/* socket is connected and
  					   initialization is done */
***************
*** 160,172 ****
--- 186,234 ----
  }
  #endif /* FEAT_GUI_GTK */
  
+ #if defined(FEAT_GUI_W32) || defined(PROTO)
+     void
+ netbeans_w32_connect(void)
+ {
+     netbeans_connect();
+     if (sd > 0)
+     {
+ 	/*
+ 	 * Tell Windows we are interested in receiving message when there
+ 	 * is input on the editor connection socket
+ 	 */
+ 	inputHandler = WSAAsyncSelect(sd, s_hwnd, WM_NETBEANS, FD_READ);
+     }
+ }
+ 
+     static void
+ netbeans_disconnect(void)
+ {
+     if (inputHandler == 0)
+     {
+ 	WSAAsyncSelect(sd, s_hwnd, 0, 0);
+ 	inputHandler = -1;
+     }
+     sd = -1;
+     haveConnection = FALSE;
+ 
+     /* It seems that Motif and GTK versions also need this: */
+     gui_mch_destroy_beval_area(balloonEval);
+     balloonEval = NULL;
+ }
+ #endif /* FEAT_GUI_W32 */
+ 
      static void
  netbeans_connect(void)
  {
  #ifdef INET_SOCKETS
      struct sockaddr_in	server;
      struct hostent *	host;
+ # ifdef FEAT_GUI_W32
+     u_short		port;
+ # else
      int			port;
+ #endif
  #else
      struct sockaddr_un	server;
  #endif
***************
*** 243,252 ****
      /* Connect to server */
      if (connect(sd, (struct sockaddr *)&server, sizeof(server)))
      {
! 	nbdebug(("netbeans_connect: Connect failed with errno %d\n", errno));
! 	if (errno == ECONNREFUSED)
  	{
! 	    close(sd);
  #ifdef INET_SOCKETS
  	    if ((sd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
  	    {
--- 305,314 ----
      /* Connect to server */
      if (connect(sd, (struct sockaddr *)&server, sizeof(server)))
      {
! 	nbdebug(("netbeans_connect: Connect failed with errno %d\n", sock_errno));
! 	if (sock_errno == ECONNREFUSED)
  	{
! 	    sock_close(sd);
  #ifdef INET_SOCKETS
  	    if ((sd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
  	    {
***************
*** 265,271 ****
  		int retries = 36;
  		int success = FALSE;
  		while (retries--
! 			     && ((errno == ECONNREFUSED) || (errno == EINTR)))
  		{
  		    nbdebug(("retrying...\n"));
  		    sleep(5);
--- 327,333 ----
  		int retries = 36;
  		int success = FALSE;
  		while (retries--
! 			     && ((sock_errno == ECONNREFUSED) || (sock_errno == EINTR)))
  		{
  		    nbdebug(("retrying...\n"));
  		    sleep(5);
***************
*** 509,522 ****
   * Read and process a command from netbeans.
   */
  /*ARGSUSED*/
! #ifdef FEAT_GUI_MOTIF
      static void
  messageFromNetbeans(XtPointer clientData, int *unused1, XtInputId *unused2)
! #endif
! #ifdef FEAT_GUI_GTK
      static void
  messageFromNetbeans(gpointer clientData, gint unused1,
  						    GdkInputCondition unused2)
  #endif
  {
      static char_u	*buf = NULL;
--- 571,590 ----
   * Read and process a command from netbeans.
   */
  /*ARGSUSED*/
! #if defined(FEAT_GUI_W32) || defined(PROTO)
! /* Use this one when generating prototypes, the others are static. */
!     void
! messageFromNetbeansW32()
! #else
! # ifdef FEAT_GUI_MOTIF
      static void
  messageFromNetbeans(XtPointer clientData, int *unused1, XtInputId *unused2)
! # endif
! # ifdef FEAT_GUI_GTK
      static void
  messageFromNetbeans(gpointer clientData, gint unused1,
  						    GdkInputCondition unused2)
+ # endif
  #endif
  {
      static char_u	*buf = NULL;
***************
*** 543,556 ****
      /* Keep on reading for as long as there is something to read. */
      for (;;)
      {
! 	len = read(sd, buf, MAXMSGSIZE);
  	if (len <= 0)
  	    break;	/* error or nothing more to read */
  
  	/* Store the read message in the queue. */
  	save(buf, len);
  	readlen += len;
- 
  	if (len < MAXMSGSIZE)
  	    break;	/* did read everything that's available */
      }
--- 611,623 ----
      /* Keep on reading for as long as there is something to read. */
      for (;;)
      {
! 	len = sock_read(sd, buf, MAXMSGSIZE);
  	if (len <= 0)
  	    break;	/* error or nothing more to read */
  
  	/* Store the read message in the queue. */
  	save(buf, len);
  	readlen += len;
  	if (len < MAXMSGSIZE)
  	    break;	/* did read everything that's available */
      }
***************
*** 600,606 ****
      {
  	/* We assume the server knows that we can safely exit! */
  	if (sd >= 0)
! 	    close(sd);
  	/* Disconnect before exiting, Motif hangs in a Select error
  	 * message otherwise. */
  	netbeans_disconnect();
--- 667,673 ----
      {
  	/* We assume the server knows that we can safely exit! */
  	if (sd >= 0)
! 	    sock_close(sd);
  	/* Disconnect before exiting, Motif hangs in a Select error
  	 * message otherwise. */
  	netbeans_disconnect();
***************
*** 612,618 ****
      {
  	/* The IDE is breaking the connection. */
  	if (sd >= 0)
! 	    close(sd);
  	netbeans_disconnect();
  	return;
      }
--- 679,685 ----
      {
  	/* The IDE is breaking the connection. */
  	if (sd >= 0)
! 	    sock_close(sd);
  	netbeans_disconnect();
  	return;
      }
***************
*** 660,680 ****
  struct nbbuf_struct
  {
      buf_T		*bufp;
- #if 0 /* never used */
-     unsigned int	 netbeansOwns:1;
-     unsigned int	 fireCaret:1;
- #endif
      unsigned int	 fireChanges:1;
      unsigned int	 initDone:1;
      unsigned int	 modified:1;
- #if 0  /* never used */
-     char		*internalname;
- #endif
      char		*displayname;
      char_u		*partial_line;
      int			*signmap;
!     ushort		 signmaplen;
!     ushort		 signmapused;
  };
  
  typedef struct nbbuf_struct nbbuf_T;
--- 727,740 ----
  struct nbbuf_struct
  {
      buf_T		*bufp;
      unsigned int	 fireChanges:1;
      unsigned int	 initDone:1;
      unsigned int	 modified:1;
      char		*displayname;
      char_u		*partial_line;
      int			*signmap;
!     short_u		 signmaplen;
!     short_u		 signmapused;
  };
  
  typedef struct nbbuf_struct nbbuf_T;
***************
*** 796,802 ****
  	nbdebug(("EVT: %s", buf));
  /*	nb_send(buf, "netbeans_end");    avoid "write failed" messages */
  	if (sd >= 0)
! 	    write(sd, buf, STRLEN(buf));  /* ignore errors */
      }
  
      /* Give NetBeans a chance to write some clean-up cmds to the socket before
--- 856,862 ----
  	nbdebug(("EVT: %s", buf));
  /*	nb_send(buf, "netbeans_end");    avoid "write failed" messages */
  	if (sd >= 0)
! 	    sock_write(sd, buf, STRLEN(buf));  /* ignore errors */
      }
  
      /* Give NetBeans a chance to write some clean-up cmds to the socket before
***************
*** 811,820 ****
      static void
  nb_send(char *buf, char *fun)
  {
      if (sd < 0)
! 	EMSG2("E630: %s(): write while not connected", fun);
!     else if (write(sd, buf, STRLEN(buf)) != STRLEN(buf))
! 	EMSG2("E631: %s(): write failed", fun);
  }
  
  /*
--- 871,894 ----
      static void
  nb_send(char *buf, char *fun)
  {
+     /* Avoid giving pages full of error messages when the other side has
+      * exited, only mention the first error until the connection works again. */
+     static int did_error = FALSE;
+ 
      if (sd < 0)
!     {
! 	if (!did_error)
! 	    EMSG2("E630: %s(): write while not connected", fun);
! 	did_error = TRUE;
!     }
!     else if (sock_write(sd, buf, STRLEN(buf)) != (int)STRLEN(buf))
!     {
! 	if (!did_error)
! 	    EMSG2("E631: %s(): write failed", fun);
! 	did_error = TRUE;
!     }
!     else
! 	did_error = FALSE;
  }
  
  /*
***************
*** 888,893 ****
--- 962,969 ----
      char_u *p = txt;
      char_u *q = buf;
  
+     if (buf == NULL)
+ 	return NULL;
      for (; *p; p++)
      {
  	switch (*p)
***************
*** 1244,1249 ****
--- 1320,1331 ----
  	    }
  	    else if (args != NULL)
  	    {
+ 		/* We need to detect EOL style
+ 		 * because addAnno passes char-offset
+ 		 */
+ 		int    ff_detected = EOL_UNKNOWN;
+ 		int    buf_was_empty = (buf->bufp->b_ml.ml_flags & ML_EMPTY);
+ 
  		oldFire = netbeansFireChanges;
  		netbeansFireChanges = 0;
  
***************
*** 1295,1308 ****
--- 1377,1413 ----
  			nbdebug(("    PARTIAL[%d]: %s\n", lnum, args));
  			break;
  		    }
+ 		    /* EOL detecting.
+ 		     * Not sure how to deal with '\n' on Mac
+ 		     * it will fail already in nl = ... above
+ 		     */
+ 		    if (buf_was_empty && /* There is need to detect EOLs */
+ 			    /* AND: string is empty */
+ 			    (args == nl
+ 			     /* OR hasn't '\r' at the end */
+ 			    || *(nl - 1) != '\r'))
+ 			ff_detected = EOL_UNIX;
+ 
  		    *nl = '\0';
  		    nbdebug(("    INSERT[%d]: %s\n", lnum, args));
  		    ml_append((linenr_T)(lnum++ - 1), args,
  						     STRLEN(args) + 1, FALSE);
  		    args = nl + 1;
  		}
+ 
  		appended_lines_mark(pos->lnum - 1, lnum - pos->lnum);
  
+ 		/* We can change initial ff without consequences
+ 		 * Isn't it a kind of hacking?
+ 		 */
+ 		if (buf_was_empty)
+ 		{
+ 		    if (ff_detected == EOL_UNKNOWN)
+ 			ff_detected = EOL_DOS;
+ 		    set_fileformat(ff_detected, OPT_LOCAL);
+ 		    buf->bufp->b_start_ffc = *buf->bufp->b_p_ff;
+ 		}
+ 
  		if (*args)
  		{
  		    /*
***************
*** 1596,1601 ****
--- 1701,1709 ----
  	    {
  		curwin->w_cursor = *pos;
  		check_cursor();
+ #ifdef FEAT_FOLDING
+ 		foldOpenCursor();
+ #endif
  	    }
  	    else
  		nbdebug(("    BAD POSITION in setDot: %s\n", s));
***************
*** 1661,1666 ****
--- 1769,1775 ----
  	    int typeNum;
  	    char_u *typeName;
  	    char_u *tooltip;
+ 	    char_u *p;
  	    char_u *glyphFile;
  	    int use_fg = 0;
  	    int use_bg = 0;
***************
*** 1679,1685 ****
  	    args = skipwhite(args + 1);
  	    tooltip = (char_u *)nb_unquote(args, &args);
  	    args = skipwhite(args + 1);
! 	    glyphFile = (char_u *)nb_unquote(args, &args);
  	    args = skipwhite(args + 1);
  	    if (STRNCMP(args, "none", 4) == 0)
  		args += 5;
--- 1788,1798 ----
  	    args = skipwhite(args + 1);
  	    tooltip = (char_u *)nb_unquote(args, &args);
  	    args = skipwhite(args + 1);
! 
! 	    p = (char_u *)nb_unquote(args, &args);
! 	    glyphFile = vim_strsave_escaped(p, escape_chars);
! 	    vim_free(p);
! 
  	    args = skipwhite(args + 1);
  	    if (STRNCMP(args, "none", 4) == 0)
  		args += 5;
***************
*** 2049,2055 ****
      char_u	*text;
      int		line;
      int		col;
!     char	buf[MAXPATHLEN * 2 + 25];
      char_u	*p;
  
      /* Don't do anything when 'ballooneval' is off, messages scrolled the
--- 2192,2198 ----
      char_u	*text;
      int		line;
      int		col;
!     char	buf[MAXPATHL * 2 + 25];
      char_u	*p;
  
      /* Don't do anything when 'ballooneval' is off, messages scrolled the
***************
*** 2061,2067 ****
      {
  	/* Send debugger request.  Only when the text is of reasonable
  	 * length. */
! 	if (text != NULL && text[0] != NUL && STRLEN(text) < MAXPATHLEN)
  	{
  	    p = nb_quote(text);
  	    if (p != NULL)
--- 2204,2210 ----
      {
  	/* Send debugger request.  Only when the text is of reasonable
  	 * length. */
! 	if (text != NULL && text[0] != NUL && STRLEN(text) < MAXPATHL)
  	{
  	    p = nb_quote(text);
  	    if (p != NULL)
***************
*** 2089,2095 ****
      nbdebug(("EVT: %s", cmd));
      nb_send(cmd, "netbeans_startup_done");
  
! # if defined(FEAT_BEVAL) && defined(FEAT_GUI_MOTIF)
      if (gui.in_use)
      {
  	/*
--- 2232,2239 ----
      nbdebug(("EVT: %s", cmd));
      nb_send(cmd, "netbeans_startup_done");
  
! #ifdef FEAT_BEVAL
! # ifdef FEAT_GUI_MOTIF
      if (gui.in_use)
      {
  	/*
***************
*** 2102,2111 ****
  	if (!p_beval)
  	    gui_mch_disable_beval_area(balloonEval);
      }
  # endif
  }
  
! #if defined(FEAT_GUI_MOTIF) || defined(PROTO)
  /*
   * Tell netbeans that the window was moved or resized.
   */
--- 2246,2263 ----
  	if (!p_beval)
  	    gui_mch_disable_beval_area(balloonEval);
      }
+ # else
+ #  if defined(FEAT_GUI_W32) && defined(FEAT_BEVAL)
+ 	balloonEval = gui_mch_create_beval_area(NULL, NULL,
+ 						    &netbeans_beval_cb, NULL);
+ 	if (!p_beval)
+ 	    gui_mch_disable_beval_area(balloonEval);
+ #  endif
  # endif
+ #endif
  }
  
! #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_W32) || defined(PROTO)
  /*
   * Tell netbeans that the window was moved or resized.
   */
***************
*** 2130,2146 ****
      void
  netbeans_file_opened(char *filename)
  {
!     char buffer[2*MAXPATHLEN];
  
      if (!haveConnection)
  	return;
  
      sprintf(buffer, "0:fileOpened=%d \"%s\" %s %s\n",
  	    0,
! 	    nb_quote((char_u *)filename),
  	    "F",  /* open in NetBeans */
  	    "F"); /* modified */
  
      nbdebug(("EVT: %s", buffer));
  
      nb_send(buffer, "netbeans_file_opened");
--- 2282,2303 ----
      void
  netbeans_file_opened(char *filename)
  {
!     char    buffer[2*MAXPATHL];
!     char_u  *q;
  
      if (!haveConnection)
  	return;
  
+     q = nb_quote((char_u *)filename);
+     if (q == NULL)
+ 	return;
      sprintf(buffer, "0:fileOpened=%d \"%s\" %s %s\n",
  	    0,
! 	    (char *)q,
  	    "F",  /* open in NetBeans */
  	    "F"); /* modified */
  
+     vim_free(q);
      nbdebug(("EVT: %s", buffer));
  
      nb_send(buffer, "netbeans_file_opened");
***************
*** 2156,2162 ****
  {
      int		bufno = nb_getbufno(bufp);
      nbbuf_T	*nbbuf = nb_get_buf(bufno);
!     char	buffer[2*MAXPATHLEN];
  
      if (!haveConnection)
  	return;
--- 2313,2319 ----
  {
      int		bufno = nb_getbufno(bufp);
      nbbuf_T	*nbbuf = nb_get_buf(bufno);
!     char	buffer[2*MAXPATHL];
  
      if (!haveConnection)
  	return;
***************
*** 2265,2275 ****
      newtxt[newlen] = '\0';
      p = nb_quote(newtxt);
      if (p != NULL)
  	sprintf((char *)buf, "%d:insert=%d %ld \"%s\"\n", bufno, cmdno, off, p);
      vim_free(p);
      vim_free(newtxt);
-     nbdebug(("EVT: %s", buf));
-     nb_send((char *)buf, "netbeans_inserted");
      vim_free(buf);
  }
  
--- 2422,2434 ----
      newtxt[newlen] = '\0';
      p = nb_quote(newtxt);
      if (p != NULL)
+     {
  	sprintf((char *)buf, "%d:insert=%d %ld \"%s\"\n", bufno, cmdno, off, p);
+ 	nbdebug(("EVT: %s", buf));
+ 	nb_send((char *)buf, "netbeans_inserted");
+     }
      vim_free(p);
      vim_free(newtxt);
      vim_free(buf);
  }
  
***************
*** 2339,2348 ****
      void
  netbeans_keycommand(int key)
  {
!     char	buf[2*MAXPATHLEN];
      int		bufno;
      char	keyName[60];
      long	off;
  
      if (!haveConnection)
  	return;
--- 2498,2508 ----
      void
  netbeans_keycommand(int key)
  {
!     char	buf[2*MAXPATHL];
      int		bufno;
      char	keyName[60];
      long	off;
+     char_u	*q;
  
      if (!haveConnection)
  	return;
***************
*** 2355,2365 ****
      if (bufno == -1)
      {
  	nbdebug(("got keycommand for non-NetBeans buffer, opening...\n"));
  	sprintf(buf, "0:fileOpened=%d \"%s\" %s %s\n", 0,
! 		curbuf->b_ffname == NULL ? (char_u *)""
! 						 : nb_quote(curbuf->b_ffname),
  		"T",  /* open in NetBeans */
  		"F"); /* modified */
  	nbdebug(("EVT: %s", buf));
  	nb_send(buf, "netbeans_keycommand");
  
--- 2515,2530 ----
      if (bufno == -1)
      {
  	nbdebug(("got keycommand for non-NetBeans buffer, opening...\n"));
+ 	q = curbuf->b_ffname == NULL ? (char_u *)""
+ 						 : nb_quote(curbuf->b_ffname);
+ 	if (q == NULL)
+ 	    return;
  	sprintf(buf, "0:fileOpened=%d \"%s\" %s %s\n", 0,
! 		q,
  		"T",  /* open in NetBeans */
  		"F"); /* modified */
+ 	if (curbuf->b_ffname != NULL)
+ 	    vim_free(q);
  	nbdebug(("EVT: %s", buf));
  	nb_send(buf, "netbeans_keycommand");
  
***************
*** 2372,2377 ****
--- 2537,2547 ----
      sprintf(buf, "%d:newDotAndMark=%d %ld %ld\n", bufno, cmdno, off, off);
      nbdebug(("EVT: %s", buf));
      nb_send(buf, "netbeans_keycommand");
+ 
+     /* To work on Win32 you must apply patch to ExtEditor module
+      * from ExtEdCaret.java.diff - make EVT_newDotAndMark handler
+      * more synchronous
+      */
  
      /* now send keyCommand event */
      sprintf(buf, "%d:keyCommand=%d \"%s\"\n", bufno, cmdno, keyName);
*** ../vim-6.2.106/src/os_mswin.c	Mon Aug  4 22:04:43 2003
--- src/os_mswin.c	Fri Sep 12 21:30:03 2003
***************
*** 163,168 ****
--- 163,169 ----
  # endif
  #endif
  
+ extern int WSInitialized;
  
  /* Don't generate prototypes here, because some systems do have these
   * functions. */
***************
*** 229,234 ****
--- 230,242 ----
  
  # ifdef FEAT_OLE
      UninitOLE();
+ # endif
+ # ifdef FEAT_NETBEANS_INTG
+     if (WSInitialized)
+     {
+ 	WSInitialized = FALSE;
+         WSACleanup();
+     }
  # endif
  #ifdef DYNAMIC_GETTEXT
      dyn_libintl_end();
*** ../vim-6.2.106/src/os_win32.h	Wed May  7 22:53:05 2003
--- src/os_win32.h	Fri Sep 12 21:30:03 2003
***************
*** 140,145 ****
--- 140,146 ----
  # define TRACE1(sz, p1)		Trace(_T(sz), p1)
  # define TRACE2(sz, p1, p2)	Trace(_T(sz), p1, p2)
  # define TRACE3(sz, p1, p2, p3) Trace(_T(sz), p1, p2, p3)
+ # define TRACE4(sz, p1, p2, p3, p4) Trace(_T(sz), p1, p2, p3, p4)
  
  /* In debug version, writes trace messages to debug stream */
  void __cdecl
***************
*** 156,161 ****
--- 157,163 ----
  # define TRACE1(sz, p1)
  # define TRACE2(sz, p1, p2)
  # define TRACE3(sz, p1, p2, p3)
+ # define TRACE4(sz, p1, p2, p3, p4)
  
  #endif /* !_DEBUG */
  
*** ../vim-6.2.106/src/proto/gui_w32.pro	Sun Jun  1 12:26:27 2003
--- src/proto/gui_w32.pro	Sat Sep 13 21:28:07 2003
***************
*** 78,81 ****
--- 78,88 ----
  void gui_mch_drawsign __ARGS((int row, int col, int typenr));
  void *gui_mch_register_sign __ARGS((char_u *signfile));
  void gui_mch_destroy_sign __ARGS((void *sign));
+ void gui_mch_disable_beval_area __ARGS((BalloonEval *beval));
+ void gui_mch_enable_beval_area __ARGS((BalloonEval *beval));
+ void gui_mch_post_balloon __ARGS((BalloonEval *beval, char_u *mesg));
+ BalloonEval *gui_mch_create_beval_area __ARGS((void *target, char_u *mesg, void (*mesgCB)(BalloonEval *, int), void *clientData));
+ void Handle_WM_Notify __ARGS((HWND hwnd, LPNMHDR pnmh));
+ void gui_mch_destroy_beval_area __ARGS((BalloonEval *beval));
+ void netbeans_draw_multisign_indicator __ARGS((int row));
  /* vim: set ft=c : */
*** ../vim-6.2.106/src/proto/netbeans.pro	Sun Jul 27 14:16:53 2003
--- src/proto/netbeans.pro	Sat Sep 13 21:27:52 2003
***************
*** 1,6 ****
--- 1,8 ----
  /* netbeans.c */
  void netbeans_Xt_connect __ARGS((void *context));
  void netbeans_gtk_connect __ARGS((void));
+ void netbeans_w32_connect __ARGS((void));
+ void messageFromNetbeansW32 __ARGS((void));
  void netbeans_end __ARGS((void));
  void netbeans_startup_done __ARGS((void));
  void netbeans_frame_moved __ARGS((int new_x, int new_y));
***************
*** 13,18 ****
--- 15,21 ----
  void netbeans_saved __ARGS((buf_T *bufp));
  void netbeans_deleted_all_lines __ARGS((buf_T *bufp));
  int netbeans_is_guarded __ARGS((linenr_T top, linenr_T bot));
+ void netbeans_draw_multisign_indicator __ARGS((int row));
  void netbeans_draw_multisign_indicator __ARGS((int row));
  void netbeans_gutter_click __ARGS((linenr_T lnum));
  /* vim: set ft=c : */
*** ../vim-6.2.106/src/proto.h	Sat May 24 17:27:36 2003
--- src/proto.h	Tue Sep 30 20:57:53 2003
***************
*** 172,177 ****
--- 172,182 ----
  #  ifdef FEAT_GUI_W16
  #   include "gui_w16.pro"
  #  endif
+     /* Ugly solution for "BalloonEval" not being defined while it's used in
+      * the prototypes. */
+ #  ifndef FEAT_BEVAL
+ #   define BalloonEval int
+ #  endif
  #  ifdef FEAT_GUI_W32
  #   include "gui_w32.pro"
  #  endif
*** ../vim-6.2.106/src/vim.h	Thu Sep 11 21:25:44 2003
--- src/vim.h	Wed Sep 17 22:15:42 2003
***************
*** 17,23 ****
      defined(FEAT_TCL) || \
      defined(DYNAMIC_GETTEXT) || \
      defined(DYNAMIC_ICONV) || \
!     defined(DYNAMIC_IME)
  #  pragma option -pc
  # else
  #  pragma option -pr
--- 17,24 ----
      defined(FEAT_TCL) || \
      defined(DYNAMIC_GETTEXT) || \
      defined(DYNAMIC_ICONV) || \
!     defined(DYNAMIC_IME) || \
!     defined(XPM)
  #  pragma option -pc
  # else
  #  pragma option -pr
***************
*** 1463,1468 ****
--- 1470,1479 ----
  # ifdef FEAT_GUI_W32
  #  ifdef FEAT_OLE
  #   define WM_OLE (WM_APP+0)
+ #  endif
+ #  ifdef FEAT_NETBEANS_INTG
+     /* message for Netbeans socket event */
+ #   define WM_NETBEANS (WM_APP+1)
  #  endif
  # endif
  
*** ../vim-6.2.106/src/xpm_w32.c	Sun Sep 14 16:09:21 2003
--- src/xpm_w32.c	Fri Sep 12 21:49:22 2003
***************
*** 0 ****
--- 1,60 ----
+ /*
+  * Load XPM image.
+  *
+  * This function is placed in separate file because Xpm headers conflict with
+  * Vim ones :(
+  *
+  * Written by Sergey Khorev.
+  * http://iamphet.nm.ru/vim/index.html
+  */
+ 
+ #ifndef WIN32_LEAN_AND_MEAN
+ # define WIN32_LEAN_AND_MEAN
+ #endif
+ #include <windows.h>
+ 
+ /* reduced def from Vim.h */
+ #ifndef __ARGS
+ # if defined(__STDC__) || defined(__GNUC__) || defined(WIN3264)
+ #  define __ARGS(x) x
+ # else
+ #  define __ARGS(x) ()
+ # endif
+ #endif
+ 
+ #include "xpm_w32.h"
+ 
+ /* Engage Windows support in libXpm */
+ #define FOR_MSW
+ 
+ #include "xpm.h"
+ 
+ /*
+  * Tries to load Xpm image from file 'filename'.
+  * If fails return -1.
+  * success - 0 and image and mask BITMAPS
+  */
+     int
+ LoadXpmImage(filename, hImage, hShape)
+     char    *filename;
+     HBITMAP *hImage;
+     HBITMAP *hShape;
+ {
+     XImage	    *img;   /* loaded image */
+     XImage	    *shp;  /* shapeimage */
+     XpmAttributes   attr;
+     int		    res;
+     HDC		    hdc = CreateCompatibleDC(NULL);
+ 
+     attr.valuemask = 0;
+     res = XpmReadFileToImage(&hdc, filename, &img, &shp, &attr);
+     DeleteDC(hdc);
+     if (res < 0)
+ 	return -1;
+     else
+     {
+ 	*hImage = img->bitmap;
+ 	*hShape = shp->bitmap;
+ 	return 0;
+     }
+ }
*** ../vim-6.2.106/src/xpm_w32.h	Sun Sep 14 16:09:21 2003
--- src/xpm_w32.h	Fri Sep 12 21:49:01 2003
***************
*** 0 ****
--- 1,7 ----
+ /*
+  * Header file for xpm_w32.c
+  */
+ 
+ #ifndef XPM_W32__H
+ int LoadXpmImage __ARGS((char *filename, HBITMAP *hImage, HBITMAP *hShape));
+ #endif
*** ../vim-6.2.106/src/version.c	Sat Sep 27 20:18:38 2003
--- src/version.c	Sun Oct 12 16:27:29 2003
***************
*** 626,629 ****
--- 626,636 ----
  	"-xterm_save",
  #endif
+ #ifdef WIN3264
+ # ifdef FEAT_XPM_W32
+ 	"+xpm_w32",
+ # else
+ 	"-xpm_w32",
+ # endif
+ #endif
  	NULL
  };
***************
*** 632,633 ****
--- 638,641 ----
  {   /* Add new patch number below this line */
+ /**/
+     107,
  /**/

-- 
If Microsoft would build a car...
... Occasionally, executing a maneuver such as a left turn
would cause your car to shut down and refuse to restart, in
which case you would have to reinstall the engine.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///          Creator of Vim - Vi IMproved -- http://www.Vim.org          \\\
\\\              Project leader for A-A-P -- http://www.A-A-P.org        ///
 \\\  Help AIDS victims, buy here: http://ICCF-Holland.org/click1.html  ///
