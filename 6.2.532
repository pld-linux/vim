To: vim-dev@vim.org
Subject: Patch 6.2.532 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 6.2.532 (extra)
Problem:    Compiling for Win32s with VC 4.1 doesn't work.
Solution:   Don't use CP_UTF8 if it's not defined.  Don't use CSIDL_COMMON*
            when not defined.
Files:      src/dosinst.h, src/fileio.c


*** ../vim-6.2.531/src/dosinst.h	Tue May  4 15:53:18 2004
--- src/dosinst.h	Wed May  5 14:43:43 2004
***************
*** 227,240 ****
--- 227,248 ----
      if (strcmp(shell_folder_name, "desktop") == 0)
      {
  	pcsidl = &desktop_csidl;
+ #ifdef CSIDL_COMMON_DESKTOPDIRECTORY
  	csidl = CSIDL_COMMON_DESKTOPDIRECTORY;
  	alt_csidl = CSIDL_DESKTOP;
+ #else
+ 	csidl = CSIDL_DESKTOP;
+ #endif
      }
      else if (strncmp(shell_folder_name, "Programs", 8) == 0)
      {
  	pcsidl = &programs_csidl;
+ #ifdef CSIDL_COMMON_PROGRAMS
  	csidl = CSIDL_COMMON_PROGRAMS;
  	alt_csidl = CSIDL_PROGRAMS;
+ #else
+ 	csidl = CSIDL_PROGRAMS;
+ #endif
      }
      else
      {
*** ../vim-6.2.531/src/fileio.c	Sat May  1 21:04:31 2004
--- src/fileio.c	Wed May  5 14:36:19 2004
***************
*** 1357,1385 ****
  		int	needed;
  		char_u	*p;
  		int	u8c;
- 		int	l, len;
  
  		/*
  		 * 1. find out how many ucs-2 characters there are.
  		 */
  		if (FIO_GET_CP(fio_flags) == CP_UTF8)
  		{
  		    /* Handle CP_UTF8 ourselves to be able to handle trailing
  		     * bytes properly.  First find out the number of
  		     * characters and check for trailing bytes. */
  		    needed = 0;
  		    p = ptr;
! 		    for (len = from_size; len > 0; len -= l)
  		    {
! 			l = utf_ptr2len_check_len(p, len);
! 			if (l > len)			/* incomplete char */
  			{
  			    if (l > CONV_RESTLEN)
  				/* weird overlong byte sequence */
  				goto rewind_retry;
! 			    mch_memmove(conv_rest, p, len);
! 			    conv_restlen = len;
! 			    from_size -= len;
  			    break;
  			}
  			if (l == 1 && *p >= 0x80)	/* illegal byte */
--- 1357,1387 ----
  		int	needed;
  		char_u	*p;
  		int	u8c;
  
  		/*
  		 * 1. find out how many ucs-2 characters there are.
  		 */
+ #  ifdef CP_UTF8	/* VC 4.1 doesn't define CP_UTF8 */
  		if (FIO_GET_CP(fio_flags) == CP_UTF8)
  		{
+ 		    int		l, flen;
+ 
  		    /* Handle CP_UTF8 ourselves to be able to handle trailing
  		     * bytes properly.  First find out the number of
  		     * characters and check for trailing bytes. */
  		    needed = 0;
  		    p = ptr;
! 		    for (flen = from_size; flen > 0; flen -= l)
  		    {
! 			l = utf_ptr2len_check_len(p, flen);
! 			if (l > flen)			/* incomplete char */
  			{
  			    if (l > CONV_RESTLEN)
  				/* weird overlong byte sequence */
  				goto rewind_retry;
! 			    mch_memmove(conv_rest, p, flen);
! 			    conv_restlen = flen;
! 			    from_size -= flen;
  			    break;
  			}
  			if (l == 1 && *p >= 0x80)	/* illegal byte */
***************
*** 1389,1394 ****
--- 1391,1397 ----
  		    }
  		}
  		else
+ #  endif
  		{
  		    /* We can't tell if the last byte of an MBCS string is
  		     * valid and MultiByteToWideChar() returns zero if it
***************
*** 1425,1438 ****
  		if (ucsp < ptr + size)
  		    goto rewind_retry;
  
  		if (FIO_GET_CP(fio_flags) == CP_UTF8)
  		{
  		    /* Convert from utf-8 to ucs-2. */
  		    needed = 0;
  		    p = ptr;
! 		    for (len = from_size; len > 0; len -= l)
  		    {
! 			l = utf_ptr2len_check_len(p, len);
  			u8c = utf_ptr2char(p);
  			ucsp[needed * 2] = (u8c & 0xff);
  			ucsp[needed * 2 + 1] = (u8c >> 8);
--- 1428,1444 ----
  		if (ucsp < ptr + size)
  		    goto rewind_retry;
  
+ #  ifdef CP_UTF8	/* VC 4.1 doesn't define CP_UTF8 */
  		if (FIO_GET_CP(fio_flags) == CP_UTF8)
  		{
+ 		    int		l, flen;
+ 
  		    /* Convert from utf-8 to ucs-2. */
  		    needed = 0;
  		    p = ptr;
! 		    for (flen = from_size; flen > 0; flen -= l)
  		    {
! 			l = utf_ptr2len_check_len(p, flen);
  			u8c = utf_ptr2char(p);
  			ucsp[needed * 2] = (u8c & 0xff);
  			ucsp[needed * 2 + 1] = (u8c >> 8);
***************
*** 1441,1446 ****
--- 1447,1453 ----
  		    }
  		}
  		else
+ #  endif
  		    needed = MultiByteToWideChar(FIO_GET_CP(fio_flags),
  					    MB_ERR_INVALID_CHARS, (LPCSTR)ptr,
  					     from_size, (LPWSTR)ucsp, needed);
***************
*** 4705,4710 ****
--- 4712,4718 ----
  
  	    fromlen = to - ip->bw_conv_buf;
  	    buf = to;
+ #  ifdef CP_UTF8	/* VC 4.1 doesn't define CP_UTF8 */
  	    if (FIO_GET_CP(flags) == CP_UTF8)
  	    {
  		/* Convert from UCS-2 to UTF-8, using the remainder of the
***************
*** 4723,4728 ****
--- 4731,4737 ----
  		len = to - buf;
  	    }
  	    else
+ #endif
  	    {
  		/* Convert from UCS-2 to the codepage, using the remainder of
  		 * the conversion buffer.  If the conversion uses the default
***************
*** 5064,5072 ****
--- 5073,5083 ----
      cp = encname2codepage(ptr);
      if (cp == 0)
      {
+ #  ifdef CP_UTF8	/* VC 4.1 doesn't define CP_UTF8 */
  	if (STRCMP(ptr, "utf-8") == 0)
  	    cp = CP_UTF8;
  	else
+ #  endif
  	    return 0;
      }
      return FIO_PUT_CP(cp) | FIO_CODEPAGE;
*** ../vim-6.2.531/src/version.c	Wed May  5 12:38:40 2004
--- src/version.c	Wed May  5 14:45:21 2004
***************
*** 643,644 ****
--- 643,646 ----
  {   /* Add new patch number below this line */
+ /**/
+     532,
  /**/

-- 
An actual excerpt from a classified section of a city newspaper:
"Illiterate?  Write today for free help!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        Sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\              Project leader for A-A-P -- http://www.A-A-P.org        ///
 \\\  Buy at Amazon and help AIDS victims -- http://ICCF.nl/click1.html ///
