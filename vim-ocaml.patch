diff -Naur vim61.old/runtime/indent/ocaml.vim vim61/runtime/indent/ocaml.vim
--- vim61.old/runtime/indent/ocaml.vim	Wed Oct 30 22:10:31 2002
+++ vim61/runtime/indent/ocaml.vim	Wed Oct 30 22:12:09 2002
@@ -1,11 +1,12 @@
 " Vim indent file
 " Language:     OCaml
-" Maintainers:  Mike Leary    <leary@nwlink.com>
-"               Markus Mottl  <markus@oefai.at>
-" URL:          http://www.ai.univie.ac.at/~markus/vim/indent/ocaml.vim
-" Last Change:  2001 Oct 03 - minor addition  (MM)
-"               2001 Sep 02 - set option 'expandtab'  (MM)
-"               2001 Aug 29 - revised all rules  (MM)
+" Maintainers:  Jean-Francois Yuen  <jfyuen@ifrance.com>
+"               Mike Leary          <leary@nwlink.com>
+"               Markus Mottl        <markus@oefai.at>
+" URL:          http://www.oefai.at/~markus/vim/indent/ocaml.vim
+" Last Change:  2002 Oct 28 - Fixed bug with indentation of ']' (MM)
+"               2002 Oct 22 - Major rewrite (JY)
+"               2002 Sep 08 - improved ';;' handling (JY)
 
 " Only load this indent file when no other was loaded.
 if exists("b:did_indent")
@@ -15,16 +16,68 @@
 
 setlocal expandtab
 setlocal indentexpr=GetOCamlIndent()
-setlocal indentkeys+=0=done,0=end,0=if,0=then,0=else,0=and,0=in,0=with,0=>],0=\|],0},0],0)
+setlocal indentkeys+=0=and,0=constraint,0=done,0=else,0=end,0=exception,0=external,0=if,0=in,0=include,0=inherit,0=initializer,0=let,0=method,0=open,0=then,0=type,0=val,0=with,0=;;,0=>\],0=\|\],0=\|,0=*),0},0\],0)
 setlocal nolisp
 setlocal nosmartindent
 setlocal textwidth=80
 
+" Comment formatting
+if (has("comments"))
+  set comments=sr:(*,mb:*,ex:*)
+  set fo=cqort
+endif
+
 " Only define the function once.
 if exists("*GetOCamlIndent")
   finish
 endif
 
+" Define some patterns:
+let s:beflet = '^\s*\(try\|method\)\|\(\<\(begin\|do\|else\|in\|then\|try\)\|->\|;\)\s*$'
+let s:letpat = '^\s*\(let\|type\|module\|class\|open\|exception\|val\|include\|external\)\>'
+let s:letlim = '\(\<\(sig\|struct\)\|;;\)\s*$'
+let s:lim = '^\s*\(exception\|external\|include\|let\|module\|open\|type\|val\)\>'
+let s:module = '\<\%(begin\|sig\|struct\|object\)\>'
+let s:obj = '^\s*\(constraint\|inherit\|initializer\|method\|val\)\>\|\<\(object\|object\s*(.*)\)\s*$'
+let s:type = '^\s*\%(let\|type\)\>.*='
+let s:val = '^\s*\(val\|external\)\>.*:'
+
+" Skipping pattern, for comments
+function s:SkipPattern(lnum, pat)
+  let def = prevnonblank(a:lnum - 1)
+  while def > 0 && getline(def) =~ a:pat
+    let def = prevnonblank(def - 1)
+  endwhile
+  return def
+endfunction
+
+" Indent for ';;' to match multiple 'let'
+function s:GetInd(lnum, pat, lim)
+  let llet = search(a:pat, 'bW')
+  let old = indent(a:lnum)
+  while llet > 0
+    let old = indent(llet)
+    let nb = s:SkipPattern(llet, '^\s*(\*.*\*)\s*$')
+    if getline(nb) =~ a:lim
+      return old
+    endif
+    let llet = search(a:pat, 'bW')
+  endwhile
+  return old
+endfunction
+
+" Indent pairs
+function s:FindPair(pstart, pmid, pend)
+  call search(a:pend, 'bW')
+  return indent(searchpair(a:pstart, a:pmid, a:pend, 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"'))
+endfunction
+
+" Indent 'let'
+function s:FindLet(pstart, pmid, pend)
+  call search(a:pend, 'bW')
+  return indent(searchpair(a:pstart, a:pmid, a:pend, 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment" || getline(".") =~ "^\\s*let\\>.*=.*\\<in\\s*$" || getline(prevnonblank(".") - 1) =~ "^\\s*let\\>.*=\\s*$\\|" . s:beflet'))
+endfunction
+
 function GetOCamlIndent()
   " Find a non-blank line above the current line.
   let lnum = prevnonblank(v:lnum - 1)
@@ -34,8 +87,8 @@
     return 0
   endif
 
-  let ind=indent(lnum)
-  let lline=getline(lnum)
+  let ind = indent(lnum)
+  let lline = getline(lnum)
 
   " Return double 'shiftwidth' after lines matching:
   if lline =~ '^\s*|.*->\s*$'
@@ -43,17 +96,118 @@
   endif
 
   " Add a 'shiftwidth' after lines ending with:
-  if lline =~ '\(:\|=\|->\|<-\|(\|[\|{\|[|\|[<\|(\*\|\<\(begin\|struct\|sig\|functor\|object\|try\|do\|if\|then\|else\|fun\|function\|parser\)\>\)\s*$'
+  if lline =~ '\(:\|=\|->\|<-\|(\|[\|{\|[|\|[<\|\<\(begin\|struct\|sig\|functor\|object\|try\|do\|if\|then\|else\|fun\|function\|parser\)\|\<object\s*(.*)\)\s*$'
     let ind = ind + &sw
+
+  " Back to normal indent after lines ending with ';;':
+  elseif lline =~ ';;\s*$' && lline !~ '^\s*;;'
+    let ind = s:GetInd(v:lnum, s:letpat, s:letlim)
+
+  " Back to normal indent after lines ending with 'end':
+  elseif lline =~ '\<end\s*$' && lline !~ '^\s*end\>'
+    let ind = s:FindPair(s:module, '','\<end\>')
+
+  " Back to normal indent after lines ending with 'in':
+  elseif lline =~ '\<in\s*$' && lline !~ '^\s*in\>'
+    let ind = s:FindPair('\<let\>', '', '\<in\>')
+
+  " Back to normal indent after lines ending with 'done':
+  elseif lline =~ '\<done\s*$' && lline !~ '^\s*done\>'
+    let ind = s:FindPair('\<do\>', '','\<done\>')
+
+  " Back to normal indent after lines ending with '}':
+  elseif lline =~ '}\s*$' && lline !~ '^\s*}'
+    let ind = s:FindPair('{', '','}')
+
+  " Back to normal indent after lines ending with '>]':
+  elseif lline =~ '>\]\s*$' && lline !~ '^\s*>\]'
+    let ind = s:FindPair('\[<', '','>\]')
+
+  " Back to normal indent after lines ending with '|]':
+  elseif lline =~ '|\]\s*$' && lline !~ '^\s*|\]'
+    let ind = s:FindPair('\[|', '','|\]')
+
+  " Back to normal indent after lines ending with ']':
+  elseif lline =~ '\]\s*$' && lline !~ '^\s*\]'
+    let ind = s:FindPair('\[', '','\]')
+
+  " Back to normal indent after comments:
+  elseif lline =~ '\*)\s*$' && lline !~ '^\s*\*)'
+    call search('\*)', 'bW')
+    let ind = indent(searchpair('(\*', '', '\*)', 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"'))
+
+  " Back to normal indent after lines ending with ')':
+  elseif lline =~ ')\s*$' && lline !~ '^\s*)'
+    let ind = s:FindPair('(', '',')')
+
+  endif
+
+  " Subtract a 'shiftwidth' after lines matching 'match ... with parser':
+  if lline =~ '^\s*match\>.*\<with\>\s*\<parser\s*$'
+    let ind = ind - &sw
   endif
 
-  let line=getline(v:lnum)
+  let line = getline(v:lnum)
 
-  " Subtract a 'shiftwidth' if current line begins with:
-  if line =~ '^\s*\(\(done\|end\)\>\|>]\||]\|}\|]\|)\)'
-    return ind - &sw
+  " Indent if current line begins with 'end'
+  " for 'sig', 'struct', 'object' and 'begin':
+  if line =~ '^\s*end\>'
+    return s:FindPair(s:module, '','\<end\>')
+
+  " Indent if current line begins with 'done' for 'do':
+  elseif line =~ '^\s*done\>'
+    return s:FindPair('\<do\>', '','\<done\>')
+
+  " Indent if current line begins with '}':
+  elseif line =~ '^\s*}'
+    return s:FindPair('{', '','}')
+
+  " Indent if current line begins with '>]':
+  elseif line =~ '^\s*>\]'
+    return s:FindPair('\[<', '','>\]')
+
+  " Indent if current line begins with '|]':
+  elseif line =~ '^\s*|\]'
+    return s:FindPair('\[|', '','|\]')
+
+  " Indent if current line begins with ']':
+  elseif line =~ '^\s*\]'
+    return s:FindPair('\[', '','\]')
+
+  " Indent if current line begins with ')':
+  elseif line =~ '^\s*)'
+    return s:FindPair('(', '',')')
+
+  " Indent if current line begins with 'let'
+  " and last line does not begin with 'let' or end with 'in' or ';;':
+  elseif line =~ '^\s*let\>'
+    if lline !~ s:lim . '\|' . s:letlim . '\|' . s:beflet
+      return s:FindLet(s:type, '','\<let\s*$')
+    else return ind
+    endif
 
-  " Subtract a 'shiftwidth' if current line begins with 'if' and last
+  " Indent if current line begins with 'type'
+  " and last line does not end with 'and' or ';;':
+  elseif line =~ '^\s*type\>'
+    if lline !~ s:lim . '\|\<and\s*$\|' . s:letlim
+      return s:FindLet(s:type, '','\<type\s*$')
+    else return ind
+    endif
+
+  " Indent for pattern matching:
+  elseif line =~ '^\s*|'
+    if lline !~ '^\s*\(|\|\(match\|with\|type\)\>\)\|\<\(function\|parser\|with\)\s*$'
+      return s:FindPair('^\s*\(type\|match\)\>\|\<\(with\|function\|parser\)\s*$', '', '|')
+    else return ind
+    endif
+
+  " Indent if current line begins with ';;':
+  elseif line =~ '^\s*;;'
+    if lline !~ ';;\s*$'
+      return s:GetInd(v:lnum, s:letpat, s:letlim)
+    endif
+
+  " Subtract a 'shiftwidth' if current line begins with 'if' and previous
   " line ends with 'else':
   elseif line =~ '^\s*if\>'
     if lline =~ '\<else\s*$'
@@ -61,39 +215,114 @@
     else return ind
     endif
 
-  " Subtract a 'shiftwidth' if current line begins with 'in' and last
+  " Indent if current line begins with 'in' and previous
   " line does not start with 'let' or 'and':
   elseif line =~ '^\s*in\>'
     if lline !~ '^\s*\(let\|and\)\>'
-      return ind - &sw
+      return s:FindPair('\<let\>', '', '\<in\>')
     else return ind
     endif
 
-  " Subtract a 'shiftwidth' if current line begins with 'else' or 'then'
-  " and previous line does not start with 'if', 'then' or 'else'
-  elseif line =~ '^\s*\(else\|then\)\>'
+  " Indent if current line begins with 'else'
+  " and previous line does not start with 'if', 'then' or 'else':
+  elseif line =~ '^\s*else\>'
     if lline !~ '^\s*\(if\|else\|then\)\>'
-      return ind - &sw
+      return s:FindPair('\<if\>', '', '\<else\>')
     else return ind
     endif
 
-  " Subtract a 'shiftwidth' if current line begins with 'and' and previous
-  " line does not start with 'let', 'and' or 'type' or end with 'end'
-  " (for classes):
+  " Indent if current line begins with 'then'
+  " and previous line does not start with 'if', 'then' or 'else':
+  elseif line =~ '^\s*then\>'
+    if lline !~ '^\s*\(if\|else\|then\)\>'
+      return s:FindPair('\<if\>', '', '\<then\>')
+    else return ind
+    endif
+
+  " Indent if current line begins with 'and' and previous
+  " line does not start with 'let', 'and' or 'type':
   elseif line =~ '^\s*and\>'
-    if lline !~ '^\s*\(let\|and\|type\)\>\|\<end\s*$'
-      return ind - &sw
+    if lline !~ '^\s*\(and\|let\|type\)\>'
+      return s:FindPair('^\s*\%(let\|type\|class\)\>', '', '\<and\>')
     else return ind
     endif
 
-  " Subtract a 'shiftwidth' if current line begins with 'with'
+  " Indent if current line begins with 'with'
   " and previous line does not start with 'match' or 'try':
   elseif line =~ '^\s*with\>'
     if lline !~ '^\s*\(match\|try\)\>'
-      return ind - &sw
+      return s:FindPair('\<\%(match\|try\)\>', '','\<with\>')
+    else return ind
+    endif
+
+  " Indent if current line begins with 'exception':
+  elseif line =~ '^\s*exception\>'
+    if lline !~ s:lim . '\|' . s:letlim
+      return indent(search(s:val . '\|^\s*\(external\|include\|open\|type\)\>'))
+    else return ind
+    endif
+
+  " Indent if current line begins with 'external':
+  elseif line =~ '^\s*external\>'
+    if lline !~ s:lim . '\|' . s:letlim
+      return indent(search(s:val . '\|^\s*\(exception\|include\|open\|type\)\>'))
+    else return ind
+    endif
+
+  " Indent if current line begins with 'include':
+  elseif line =~ '^\s*include\>'
+    if lline !~ s:lim . '\|' . s:letlim
+      return indent(search(s:val . '\|^\s*\(exception\|external\|open\|type\)\>'))
+    else return ind
+    endif
+
+  " Indent if current line begins with 'open':
+  elseif line =~ '^\s*open\>'
+    if lline !~ s:lim . '\|' . s:letlim
+      return indent(search(s:val . '\|^\s*\(exception\|external\|include\|type\)\>'))
+    else return ind
+    endif
+
+  " Indent if current line begins with 'val':
+  elseif line =~ '^\s*val\>'
+    if lline !~ '^\s*\(exception\|external\|include\|open\)\>\|' . s:obj . '\|' . s:letlim
+      return indent(search(s:val . '\|^\s*\(exception\|include\|initializer\|method\|open\|type\)\>', 'bW'))
     else return ind
     endif
 
+  " Indent if current line begins with 'constraint':
+  elseif line =~ '^\s*constraint\>'
+    if lline !~ s:obj
+      return indent(search('^\s*\(inherit\|initializer\|method\|val\)\>'))
+    else return ind
+    endif
+
+  " Indent if current line begins with 'inherit':
+  elseif line =~ '^\s*inherit\>'
+    if lline !~ s:obj
+      return indent(search('^\s*\(constraint\|initializer\|method\|val\)\>'))
+    else return ind
+    endif
+
+  " Indent if current line begins with 'inherit':
+  elseif line =~ '^\s*initializer\>'
+    if lline !~ s:obj
+      return indent(search('^\s*\(constraint\|inherit\|method\|val\)\>'))
+    else return ind
+    endif
+
+  " Indent if current line begins with 'method':
+  elseif line =~ '^\s*method\>'
+    if lline !~ s:obj
+      return indent(search('^\s*\(constraint\|inherit\|initializer\|val\)\>'))
+    else return ind
+    endif
+
+  " Indent back to normal after comments:
+  elseif line =~ '^\s*\*)'
+    call search('\*)', 'bW')
+    return indent(searchpair('(\*', '', '\*)', 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"'))
+
   endif
 
   return ind
diff -Naur vim61.old/runtime/syntax/ocaml.vim vim61/runtime/syntax/ocaml.vim
--- vim61.old/runtime/syntax/ocaml.vim	Wed Oct 30 22:10:33 2002
+++ vim61/runtime/syntax/ocaml.vim	Wed Oct 30 22:11:41 2002
@@ -3,12 +3,11 @@
 " Filenames:    *.ml *.mli *.mll *.mly
 " Maintainers:  Markus Mottl      <markus@oefai.at>
 "               Karl-Heinz Sylla  <Karl-Heinz.Sylla@gmd.de>
-" URL:          http://www.ai.univie.ac.at/~markus/vim/syntax/ocaml.vim
-" Last Change:  2001 Nov 20 - Fixed small bug with modules  (MM)
-"               2001 Sep 01 - Fixed small bug with '\''  (MM)
-"               2001 Aug 29 - Added rules for scripting directives  (MM)
-"               2001 Aug 28 - Upgraded URL & mail address  (MM)
-"               2001 Apr 26 - upgraded for new Vim version  (MM)
+"               Issac Trotts      <<ijtrotts@ucdavis.edu>
+" URL:          http://www.oefai.at/~markus/vim/syntax/ocaml.vim
+" Last Change:  2002 Oct 30 - New variable "ocaml_revised" (MM)
+"               2002 Oct 24 - Small fix for "module type" (MM)
+"               2002 Jun 16 - Added "&&", "<" and ">" as operators (MM)
 
 " For version 5.x: Clear all syntax items
 " For version 6.x: Quit when a syntax file was already loaded
@@ -42,7 +41,11 @@
 
 syn match    ocamlCountErr   "\<downto\>"
 syn match    ocamlCountErr   "\<to\>"
-syn match    ocamlDoErr      "\<do\>"
+
+if !exists("ocaml_revised")
+  syn match    ocamlDoErr      "\<do\>"
+endif
+
 syn match    ocamlDoneErr    "\<done\>"
 syn match    ocamlThenErr    "\<then\>"
 
@@ -79,7 +82,9 @@
 
 
 " Blocks
-syn region   ocamlEnd matchgroup=ocamlKeyword start="\<begin\>" matchgroup=ocamlKeyword end="\<end\>" contains=ALLBUT,@ocamlContained,ocamlEndErr
+if !exists("ocaml_revised")
+  syn region   ocamlEnd matchgroup=ocamlKeyword start="\<begin\>" matchgroup=ocamlKeyword end="\<end\>" contains=ALLBUT,@ocamlContained,ocamlEndErr
+endif
 
 
 " "for"
@@ -87,8 +92,9 @@
 
 
 " "do"
-syn region   ocamlDo matchgroup=ocamlKeyword start="\<do\>" matchgroup=ocamlKeyword end="\<done\>" contains=ALLBUT,@ocamlContained,ocamlDoneErr
-
+if !exists("ocaml_revised")
+  syn region   ocamlDo matchgroup=ocamlKeyword start="\<do\>" matchgroup=ocamlKeyword end="\<done\>" contains=ALLBUT,@ocamlContained,ocamlDoneErr
+endif
 
 " "if"
 syn region   ocamlNone matchgroup=ocamlKeyword start="\<if\>" matchgroup=ocamlKeyword end="\<then\>" contains=ALLBUT,@ocamlContained,ocamlThenErr
@@ -134,12 +140,13 @@
 syn region   ocamlWithRest start="[^)]" end=")"me=e-1 contained contains=ALLBUT,@ocamlContained
 
 " "module type"
-syn region   ocamlKeyword start="\<module\s*type\>" matchgroup=ocamlModule end="\<\w\(\w\|'\)*\>" contains=ocamlComment skipwhite skipempty nextgroup=ocamlMTDef
+syn region   ocamlKeyword start="\<module\>\s*\<type\>" matchgroup=ocamlModule end="\<\w\(\w\|'\)*\>" contains=ocamlComment skipwhite skipempty nextgroup=ocamlMTDef
 syn match    ocamlMTDef "=\s*\w\(\w\|'\)*\>"hs=s+1,me=s
 
 syn keyword  ocamlKeyword  and as assert class
 syn keyword  ocamlKeyword  constraint else
-syn keyword  ocamlKeyword  exception external fun function
+syn keyword  ocamlKeyword  exception external fun
+
 syn keyword  ocamlKeyword  in inherit initializer
 syn keyword  ocamlKeyword  land lazy let match
 syn keyword  ocamlKeyword  method mutable new of
@@ -147,12 +154,20 @@
 syn keyword  ocamlKeyword  try type
 syn keyword  ocamlKeyword  val virtual when while with
 
+if exists("ocaml_revised")
+  syn keyword  ocamlKeyword  do value
+  syn keyword  ocamlBoolean  True False
+else
+  syn keyword  ocamlKeyword  function
+  syn keyword  ocamlBoolean  true false
+  syn match    ocamlKeyChar  "!"
+endif
+
 syn keyword  ocamlType     array bool char exn float format int
 syn keyword  ocamlType     list option string unit
 
-syn keyword  ocamlOperator asr lor lsl lsr lxor mod not or
+syn keyword  ocamlOperator asr lor lsl lsr lxor mod not
 
-syn keyword  ocamlBoolean      true false
 syn match    ocamlConstructor  "(\s*)"
 syn match    ocamlConstructor  "\[\s*\]"
 syn match    ocamlConstructor  "\[|\s*>|]"
@@ -175,9 +190,11 @@
 syn match    ocamlTopStop      ";;"
 syn match    ocamlOperator     "\^"
 syn match    ocamlOperator     "::"
-syn match    ocamlOperator     "<-"
+
+syn match    ocamlOperator     "&&"
+syn match    ocamlOperator     "<"
+syn match    ocamlOperator     ">"
 syn match    ocamlAnyVar       "\<_\>"
-syn match    ocamlKeyChar      "!"
 syn match    ocamlKeyChar      "|[^\]]"me=e-1
 syn match    ocamlKeyChar      ";"
 syn match    ocamlKeyChar      "\~"
@@ -185,6 +202,12 @@
 syn match    ocamlKeyChar      "\*"
 syn match    ocamlKeyChar      "="
 
+if exists("ocaml_revised")
+  syn match    ocamlErr        "<-"
+else
+  syn match    ocamlOperator   "<-"
+endif
+
 syn match    ocamlNumber        "\<-\=\d\+\>"
 syn match    ocamlNumber        "\<-\=0[x|X]\x\+\>"
 syn match    ocamlNumber        "\<-\=0[o|O]\o\+\>"
@@ -201,9 +224,17 @@
 syn sync minlines=50
 syn sync maxlines=500
 
-syn sync match ocamlDoSync      grouphere  ocamlDo      "\<do\>"
-syn sync match ocamlDoSync      groupthere ocamlDo      "\<done\>"
-syn sync match ocamlEndSync     grouphere  ocamlEnd     "\<\(begin\|object\)\>"
+if !exists("ocaml_revised")
+  syn sync match ocamlDoSync      grouphere  ocamlDo      "\<do\>"
+  syn sync match ocamlDoSync      groupthere ocamlDo      "\<done\>"
+endif
+
+if exists("ocaml_revised")
+  syn sync match ocamlEndSync     grouphere  ocamlEnd     "\<\(object\)\>"
+else
+  syn sync match ocamlEndSync     grouphere  ocamlEnd     "\<\(begin\|object\)\>"
+endif
+
 syn sync match ocamlEndSync     groupthere ocamlEnd     "\<end\>"
 syn sync match ocamlStructSync  grouphere  ocamlStruct  "\<struct\>"
 syn sync match ocamlStructSync  groupthere ocamlStruct  "\<end\>"
@@ -236,6 +267,8 @@
 
   HiLink ocamlCharErr      Error
 
+  HiLink ocamlErr          Error
+
   HiLink ocamlComment      Comment
 
   HiLink ocamlModPath      Include
