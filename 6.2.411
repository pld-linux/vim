To: vim-dev@vim.org
Subject: Patch 6.2.411
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 6.2.411
Problem:    A "\n" inside a string is not seen as a line break by the regular
	    expression matching. (Hari Krishna Dara)
Solution:   Add the vim_regexec_nl() function for strings where "\n" is to be
	    matched with a line break.
Files:	    src/eval.c, src/ex_eval.c, src/proto/regexp.c, src/regexp.c


*** ../vim-6.2.410/src/eval.c	Sat Mar 27 13:23:01 2004
--- src/eval.c	Sun Mar 28 11:56:13 2004
***************
*** 1996,2002 ****
  			    regmatch.rm_ic = ic;
  			    if (regmatch.regprog != NULL)
  			    {
! 				n1 = vim_regexec(&regmatch, s1, (colnr_T)0);
  				vim_free(regmatch.regprog);
  				if (type == TYPE_NOMATCH)
  				    n1 = !n1;
--- 1998,2004 ----
  			    regmatch.rm_ic = ic;
  			    if (regmatch.regprog != NULL)
  			    {
! 				n1 = vim_regexec_nl(&regmatch, s1, (colnr_T)0);
  				vim_free(regmatch.regprog);
  				if (type == TYPE_NOMATCH)
  				    n1 = !n1;
***************
*** 5763,5769 ****
      if (regmatch.regprog != NULL)
      {
  	regmatch.rm_ic = p_ic;
! 	if (vim_regexec(&regmatch, str, (colnr_T)0))
  	{
  	    if (type == 2)
  		retvar->var_val.var_string = vim_strnsave(regmatch.startp[0],
--- 5765,5771 ----
      if (regmatch.regprog != NULL)
      {
  	regmatch.rm_ic = p_ic;
! 	if (vim_regexec_nl(&regmatch, str, (colnr_T)0))
  	{
  	    if (type == 2)
  		retvar->var_val.var_string = vim_strnsave(regmatch.startp[0],
***************
*** 5771,5779 ****
  	    else
  	    {
  		if (type != 0)
! 		    retvar->var_val.var_number = (varnumber_T) (regmatch.startp[0] - str);
  		else
! 		    retvar->var_val.var_number = (varnumber_T) (regmatch.endp[0] - str);
  		retvar->var_val.var_number += start;
  	    }
  	}
--- 5773,5783 ----
  	    else
  	    {
  		if (type != 0)
! 		    retvar->var_val.var_number =
! 				      (varnumber_T)(regmatch.startp[0] - str);
  		else
! 		    retvar->var_val.var_number =
! 					(varnumber_T)(regmatch.endp[0] - str);
  		retvar->var_val.var_number += start;
  	    }
  	}
***************
*** 8235,8241 ****
  
  /*
   * Get the string value of a (global/local) variable.
!  * Returns NULL when it doesn't exit.
   */
      char_u *
  get_var_value(name)
--- 8239,8245 ----
  
  /*
   * Get the string value of a (global/local) variable.
!  * Returns NULL when it doesn't exist.
   */
      char_u *
  get_var_value(name)
***************
*** 10477,10483 ****
      if (regmatch.regprog != NULL)
      {
  	tail = str;
! 	while (vim_regexec(&regmatch, str, (colnr_T)(tail - str)))
  	{
  	    /*
  	     * Get some space for a temporary buffer to do the substitution
--- 10481,10487 ----
      if (regmatch.regprog != NULL)
      {
  	tail = str;
! 	while (vim_regexec_nl(&regmatch, str, (colnr_T)(tail - str)))
  	{
  	    /*
  	     * Get some space for a temporary buffer to do the substitution
*** ../vim-6.2.410/src/ex_eval.c	Thu Feb  5 16:04:26 2004
--- src/ex_eval.c	Fri Mar 26 12:23:47 2004
***************
*** 1456,1462 ****
  		     */
  		    prev_got_int = got_int;
  		    got_int = FALSE;
! 		    caught = vim_regexec(&regmatch, current_exception->value,
  			    (colnr_T)0);
  		    got_int |= prev_got_int;
  		    vim_free(regmatch.regprog);
--- 1456,1462 ----
  		     */
  		    prev_got_int = got_int;
  		    got_int = FALSE;
! 		    caught = vim_regexec_nl(&regmatch, current_exception->value,
  			    (colnr_T)0);
  		    got_int |= prev_got_int;
  		    vim_free(regmatch.regprog);
diff: src/proto/regexp.c: No such file or directory
*** ../vim-6.2.410/src/regexp.c	Wed Mar 17 14:08:56 2004
--- src/regexp.c	Fri Mar 26 12:46:45 2004
***************
*** 2671,2676 ****
--- 2671,2677 ----
   * reg_buf		<invalid>		buffer in which to search
   * reg_firstlnum	<invalid>		first line in which to search
   * reg_maxline		0			last line nr
+  * reg_line_lbr		FALSE or TRUE		FALSE
   */
  static regmatch_T	*reg_match;
  static regmmatch_T	*reg_mmatch;
***************
*** 2682,2687 ****
--- 2683,2689 ----
  static buf_T		*reg_buf;
  static linenr_T		reg_firstlnum;
  static linenr_T		reg_maxline;
+ static int		reg_line_lbr;	    /* "\n" in string is line break */
  
  /*
   * Get pointer to the line "lnum", which is relative to "reg_firstlnum".
***************
*** 2725,2730 ****
--- 2727,2733 ----
      reg_match = rmp;
      reg_mmatch = NULL;
      reg_maxline = 0;
+     reg_line_lbr = FALSE;
      reg_win = NULL;
      ireg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
***************
*** 2733,2738 ****
--- 2736,2764 ----
      return (vim_regexec_both(line, col) != 0);
  }
  
+ #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
+ /*
+  * Like vim_regexec(), but consider a "\n" in "line" to be a line break.
+  */
+     int
+ vim_regexec_nl(rmp, line, col)
+     regmatch_T	*rmp;
+     char_u	*line;	/* string to match against */
+     colnr_T	col;	/* column to start looking for match */
+ {
+     reg_match = rmp;
+     reg_mmatch = NULL;
+     reg_maxline = 0;
+     reg_line_lbr = TRUE;
+     reg_win = NULL;
+     ireg_ic = rmp->rm_ic;
+ #ifdef FEAT_MBYTE
+     ireg_icombine = FALSE;
+ #endif
+     return (vim_regexec_both(line, col) != 0);
+ }
+ #endif
+ 
  /*
   * Match a regexp against multiple lines.
   * "rmp->regprog" is a compiled regexp as returned by vim_regcomp().
***************
*** 2758,2763 ****
--- 2784,2790 ----
      reg_win = win;
      reg_firstlnum = lnum;
      reg_maxline = reg_buf->b_ml.ml_line_count - lnum;
+     reg_line_lbr = FALSE;
      ireg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
      ireg_icombine = FALSE;
***************
*** 3230,3235 ****
--- 3257,3266 ----
  	{
  	    reg_nextline();
  	}
+ 	else if (reg_line_lbr && WITH_NL(op) && *reginput == '\n')
+ 	{
+ 	    ADVANCE_REGINPUT();
+ 	}
  	else
  	{
  	  if (WITH_NL(op))
***************
*** 4201,4209 ****
  	    break;
  
  	  case NEWL:
! 	    if (c != NUL || reglnum == reg_maxline)
  		return FALSE;
! 	    reg_nextline();
  	    break;
  
  	  case END:
--- 4232,4244 ----
  	    break;
  
  	  case NEWL:
! 	    if ((c != NUL || reglnum == reg_maxline)
! 					      && (c != '\n' || !reg_line_lbr))
  		return FALSE;
! 	    if (reg_line_lbr)
! 		ADVANCE_REGINPUT();
! 	    else
! 		reg_nextline();
  	    break;
  
  	  case END:
***************
*** 4299,4304 ****
--- 4334,4341 ----
  		if (got_int)
  		    break;
  	    }
+ 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
+ 		++scan;
  	    else
  		break;
  	    ++count;
***************
*** 4326,4331 ****
--- 4363,4370 ----
  		if (got_int)
  		    break;
  	    }
+ 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
+ 		++scan;
  	    else
  		break;
  	    ++count;
***************
*** 4353,4358 ****
--- 4392,4399 ----
  		if (got_int)
  		    break;
  	    }
+ 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
+ 		++scan;
  	    else
  		break;
  	    ++count;
***************
*** 4380,4385 ****
--- 4421,4428 ----
  	    {
  		ADVANCE_P(scan);
  	    }
+ 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
+ 		++scan;
  	    else
  		break;
  	    ++count;
***************
*** 4414,4419 ****
--- 4457,4464 ----
  #endif
  	    else if ((class_tab[*scan] & mask) == testval)
  		++scan;
+ 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
+ 		++scan;
  	    else
  		break;
  	    ++count;
***************
*** 4565,4570 ****
--- 4610,4617 ----
  		if (got_int)
  		    break;
  	    }
+ 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
+ 		++scan;
  #ifdef FEAT_MBYTE
  	    else if (has_mbyte && (len = (*mb_ptr2len_check)(scan)) > 1)
  	    {
***************
*** 4584,4593 ****
  	break;
  
        case NEWL:
! 	while (count < maxcount && *scan == NUL && reglnum < reg_maxline)
  	{
  	    count++;
! 	    reg_nextline();
  	    scan = reginput;
  	    if (got_int)
  		break;
--- 4631,4645 ----
  	break;
  
        case NEWL:
! 	while (count < maxcount
! 		&& ((*scan == NUL && reglnum < reg_maxline)
! 		    || (*scan == '\n' && reg_line_lbr)))
  	{
  	    count++;
! 	    if (reg_line_lbr)
! 		ADVANCE_REGINPUT();
! 	    else
! 		reg_nextline();
  	    scan = reginput;
  	    if (got_int)
  		break;
*** ../vim-6.2.410/src/version.c	Mon Mar 29 12:16:31 2004
--- src/version.c	Mon Mar 29 14:29:22 2004
***************
*** 639,640 ****
--- 639,642 ----
  {   /* Add new patch number below this line */
+ /**/
+     411,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
171. You invent another person and chat with yourself in empty chat rooms.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        Sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\              Project leader for A-A-P -- http://www.A-A-P.org        ///
 \\\  Buy at Amazon and help AIDS victims -- http://ICCF.nl/click1.html ///
