To: vim-dev@vim.org
Subject: Patch 7.0.070
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.0.070
Problem:    Compiler warnings for shadowed variables and uninitialized
	    variables.
Solution:   Rename variables such as "index", "msg" and "dup".  Initialize
	    variables.
Files:	    src/edit.c, src/eval.c, src/ex_cmds.c, src/ex_cmds2.c,
	    src/ex_docmd.c, src/gui_beval.c, src/gui_gtk.c, src/gui_gtk_x11.c,
	    src/hardcopy.c, src/if_cscope.c, src/main.c, src/mbyte.c,
	    src/memline.c, src/netbeans.c, src/normal.c, src/option.c,
	    src/os_unix.c, src/quickfix.c, src/regexp.c, src/screen.c,
	    src/search.c, src/spell.c, src/ui.c, src/undo.c, src/window.c,
	    src/version.c


*** ../vim-7.0.069/src/edit.c	Tue Aug 29 16:33:23 2006
--- src/edit.c	Tue Aug 29 14:57:46 2006
***************
*** 129,135 ****
  
  static void ins_ctrl_x __ARGS((void));
  static int  has_compl_option __ARGS((int dict_opt));
! static int ins_compl_add __ARGS((char_u *str, int len, int icase, char_u *fname, char_u **cptext, int cdir, int flags, int dup));
  static int  ins_compl_equal __ARGS((compl_T *match, char_u *str, int len));
  static void ins_compl_longest_match __ARGS((compl_T *match));
  static void ins_compl_add_matches __ARGS((int num_matches, char_u **matches, int icase));
--- 129,135 ----
  
  static void ins_ctrl_x __ARGS((void));
  static int  has_compl_option __ARGS((int dict_opt));
! static int ins_compl_add __ARGS((char_u *str, int len, int icase, char_u *fname, char_u **cptext, int cdir, int flags, int adup));
  static int  ins_compl_equal __ARGS((compl_T *match, char_u *str, int len));
  static void ins_compl_longest_match __ARGS((compl_T *match));
  static void ins_compl_add_matches __ARGS((int num_matches, char_u **matches, int icase));
***************
*** 2118,2124 ****
   * maybe because alloc() returns NULL, then FAIL is returned.
   */
      static int
! ins_compl_add(str, len, icase, fname, cptext, cdir, flags, dup)
      char_u	*str;
      int		len;
      int		icase;
--- 2118,2124 ----
   * maybe because alloc() returns NULL, then FAIL is returned.
   */
      static int
! ins_compl_add(str, len, icase, fname, cptext, cdir, flags, adup)
      char_u	*str;
      int		len;
      int		icase;
***************
*** 2126,2132 ****
      char_u	**cptext;   /* extra text for popup menu or NULL */
      int		cdir;
      int		flags;
!     int		dup;	    /* accept duplicate match */
  {
      compl_T	*match;
      int		dir = (cdir == 0 ? compl_direction : cdir);
--- 2126,2132 ----
      char_u	**cptext;   /* extra text for popup menu or NULL */
      int		cdir;
      int		flags;
!     int		adup;	    /* accept duplicate match */
  {
      compl_T	*match;
      int		dir = (cdir == 0 ? compl_direction : cdir);
***************
*** 2140,2146 ****
      /*
       * If the same match is already present, don't add it.
       */
!     if (compl_first_match != NULL && !dup)
      {
  	match = compl_first_match;
  	do
--- 2140,2146 ----
      /*
       * If the same match is already present, don't add it.
       */
!     if (compl_first_match != NULL && !adup)
      {
  	match = compl_first_match;
  	do
***************
*** 3608,3614 ****
  {
      char_u	*word;
      int		icase = FALSE;
!     int		dup = FALSE;
      char_u	*(cptext[CPT_COUNT]);
  
      if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)
--- 3608,3614 ----
  {
      char_u	*word;
      int		icase = FALSE;
!     int		adup = FALSE;
      char_u	*(cptext[CPT_COUNT]);
  
      if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)
***************
*** 3625,3631 ****
  	if (get_dict_string(tv->vval.v_dict, (char_u *)"icase", FALSE) != NULL)
  	    icase = get_dict_number(tv->vval.v_dict, (char_u *)"icase");
  	if (get_dict_string(tv->vval.v_dict, (char_u *)"dup", FALSE) != NULL)
! 	    dup = get_dict_number(tv->vval.v_dict, (char_u *)"dup");
      }
      else
      {
--- 3625,3631 ----
  	if (get_dict_string(tv->vval.v_dict, (char_u *)"icase", FALSE) != NULL)
  	    icase = get_dict_number(tv->vval.v_dict, (char_u *)"icase");
  	if (get_dict_string(tv->vval.v_dict, (char_u *)"dup", FALSE) != NULL)
! 	    adup = get_dict_number(tv->vval.v_dict, (char_u *)"dup");
      }
      else
      {
***************
*** 3634,3640 ****
      }
      if (word == NULL || *word == NUL)
  	return FAIL;
!     return ins_compl_add(word, -1, icase, NULL, cptext, dir, 0, dup);
  }
  #endif
  
--- 3634,3640 ----
      }
      if (word == NULL || *word == NUL)
  	return FAIL;
!     return ins_compl_add(word, -1, icase, NULL, cptext, dir, 0, adup);
  }
  #endif
  
*** ../vim-7.0.069/src/eval.c	Wed Aug 16 22:03:35 2006
--- src/eval.c	Thu Aug 24 22:00:09 2006
***************
*** 454,460 ****
  static char_u *deref_func_name __ARGS((char_u *name, int *lenp));
  static int get_func_tv __ARGS((char_u *name, int len, typval_T *rettv, char_u **arg, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict));
  static int call_func __ARGS((char_u *name, int len, typval_T *rettv, int argcount, typval_T *argvars, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict));
! static void emsg_funcname __ARGS((char *msg, char_u *name));
  
  static void f_add __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_append __ARGS((typval_T *argvars, typval_T *rettv));
--- 454,460 ----
  static char_u *deref_func_name __ARGS((char_u *name, int *lenp));
  static int get_func_tv __ARGS((char_u *name, int len, typval_T *rettv, char_u **arg, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict));
  static int call_func __ARGS((char_u *name, int len, typval_T *rettv, int argcount, typval_T *argvars, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict));
! static void emsg_funcname __ARGS((char *ermsg, char_u *name));
  
  static void f_add __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_append __ARGS((typval_T *argvars, typval_T *rettv));
***************
*** 2260,2266 ****
  	    EMSG(_(e_letunexp));
  	else
  	{
! 	    char_u	*tofree = NULL;
  	    char_u	*s;
  
  	    p = get_tv_string_chk(tv);
--- 2260,2266 ----
  	    EMSG(_(e_letunexp));
  	else
  	{
! 	    char_u	*ptofree = NULL;
  	    char_u	*s;
  
  	    p = get_tv_string_chk(tv);
***************
*** 2269,2275 ****
  		s = get_reg_contents(*arg == '@' ? '"' : *arg, TRUE, TRUE);
  		if (s != NULL)
  		{
! 		    p = tofree = concat_str(s, p);
  		    vim_free(s);
  		}
  	    }
--- 2269,2275 ----
  		s = get_reg_contents(*arg == '@' ? '"' : *arg, TRUE, TRUE);
  		if (s != NULL)
  		{
! 		    p = ptofree = concat_str(s, p);
  		    vim_free(s);
  		}
  	    }
***************
*** 2278,2284 ****
  		write_reg_contents(*arg == '@' ? '"' : *arg, p, -1, FALSE);
  		arg_end = arg + 1;
  	    }
! 	    vim_free(tofree);
  	}
      }
  
--- 2278,2284 ----
  		write_reg_contents(*arg == '@' ? '"' : *arg, p, -1, FALSE);
  		arg_end = arg + 1;
  	    }
! 	    vim_free(ptofree);
  	}
      }
  
***************
*** 7595,7602 ****
   * Give an error message with a function name.  Handle <SNR> things.
   */
      static void
! emsg_funcname(msg, name)
!     char	*msg;
      char_u	*name;
  {
      char_u	*p;
--- 7595,7602 ----
   * Give an error message with a function name.  Handle <SNR> things.
   */
      static void
! emsg_funcname(ermsg, name)
!     char	*ermsg;
      char_u	*name;
  {
      char_u	*p;
***************
*** 7605,7611 ****
  	p = concat_str((char_u *)"<SNR>", name + 3);
      else
  	p = name;
!     EMSG2(_(msg), p);
      if (p != name)
  	vim_free(p);
  }
--- 7605,7611 ----
  	p = concat_str((char_u *)"<SNR>", name + 3);
      else
  	p = name;
!     EMSG2(_(ermsg), p);
      if (p != name)
  	vim_free(p);
  }
***************
*** 9179,9203 ****
      typval_T	save_key;
      int		rem;
      int		todo;
!     char_u	*msg = map ? (char_u *)"map()" : (char_u *)"filter()";
      int		save_did_emsg;
  
      rettv->vval.v_number = 0;
      if (argvars[0].v_type == VAR_LIST)
      {
  	if ((l = argvars[0].vval.v_list) == NULL
! 		|| (map && tv_check_lock(l->lv_lock, msg)))
  	    return;
      }
      else if (argvars[0].v_type == VAR_DICT)
      {
  	if ((d = argvars[0].vval.v_dict) == NULL
! 		|| (map && tv_check_lock(d->dv_lock, msg)))
  	    return;
      }
      else
      {
! 	EMSG2(_(e_listdictarg), msg);
  	return;
      }
  
--- 9179,9203 ----
      typval_T	save_key;
      int		rem;
      int		todo;
!     char_u	*ermsg = map ? (char_u *)"map()" : (char_u *)"filter()";
      int		save_did_emsg;
  
      rettv->vval.v_number = 0;
      if (argvars[0].v_type == VAR_LIST)
      {
  	if ((l = argvars[0].vval.v_list) == NULL
! 		|| (map && tv_check_lock(l->lv_lock, ermsg)))
  	    return;
      }
      else if (argvars[0].v_type == VAR_DICT)
      {
  	if ((d = argvars[0].vval.v_dict) == NULL
! 		|| (map && tv_check_lock(d->dv_lock, ermsg)))
  	    return;
      }
      else
      {
! 	EMSG2(_(e_listdictarg), ermsg);
  	return;
      }
  
***************
*** 9229,9235 ****
  		{
  		    --todo;
  		    di = HI2DI(hi);
! 		    if (tv_check_lock(di->di_tv.v_lock, msg))
  			break;
  		    vimvars[VV_KEY].vv_str = vim_strsave(di->di_key);
  		    if (filter_map_one(&di->di_tv, expr, map, &rem) == FAIL
--- 9229,9235 ----
  		{
  		    --todo;
  		    di = HI2DI(hi);
! 		    if (tv_check_lock(di->di_tv.v_lock, ermsg))
  			break;
  		    vimvars[VV_KEY].vv_str = vim_strsave(di->di_key);
  		    if (filter_map_one(&di->di_tv, expr, map, &rem) == FAIL
***************
*** 9248,9254 ****
  	{
  	    for (li = l->lv_first; li != NULL; li = nli)
  	    {
! 		if (tv_check_lock(li->li_tv.v_lock, msg))
  		    break;
  		nli = li->li_next;
  		if (filter_map_one(&li->li_tv, expr, map, &rem) == FAIL
--- 9248,9254 ----
  	{
  	    for (li = l->lv_first; li != NULL; li = nli)
  	    {
! 		if (tv_check_lock(li->li_tv.v_lock, ermsg))
  		    break;
  		nli = li->li_next;
  		if (filter_map_one(&li->li_tv, expr, map, &rem) == FAIL
***************
*** 19789,19795 ****
  	    if (p_verbose >= 14)
  	    {
  		char_u	buf[MSG_BUF_LEN];
! 		char_u	numbuf[NUMBUFLEN];
  		char_u	*tofree;
  
  		msg_puts((char_u *)"(");
--- 19789,19795 ----
  	    if (p_verbose >= 14)
  	    {
  		char_u	buf[MSG_BUF_LEN];
! 		char_u	numbuf2[NUMBUFLEN];
  		char_u	*tofree;
  
  		msg_puts((char_u *)"(");
***************
*** 19801,19808 ****
  			msg_outnum((long)argvars[i].vval.v_number);
  		    else
  		    {
! 			trunc_string(tv2string(&argvars[i], &tofree, numbuf, 0),
! 							    buf, MSG_BUF_CLEN);
  			msg_puts(buf);
  			vim_free(tofree);
  		    }
--- 19801,19808 ----
  			msg_outnum((long)argvars[i].vval.v_number);
  		    else
  		    {
! 			trunc_string(tv2string(&argvars[i], &tofree,
! 					      numbuf2, 0), buf, MSG_BUF_CLEN);
  			msg_puts(buf);
  			vim_free(tofree);
  		    }
***************
*** 19880,19892 ****
  	else
  	{
  	    char_u	buf[MSG_BUF_LEN];
! 	    char_u	numbuf[NUMBUFLEN];
  	    char_u	*tofree;
  
  	    /* The value may be very long.  Skip the middle part, so that we
  	     * have some idea how it starts and ends. smsg() would always
  	     * truncate it at the end. */
! 	    trunc_string(tv2string(fc.rettv, &tofree, numbuf, 0),
  							   buf, MSG_BUF_CLEN);
  	    smsg((char_u *)_("%s returning %s"), sourcing_name, buf);
  	    vim_free(tofree);
--- 19880,19892 ----
  	else
  	{
  	    char_u	buf[MSG_BUF_LEN];
! 	    char_u	numbuf2[NUMBUFLEN];
  	    char_u	*tofree;
  
  	    /* The value may be very long.  Skip the middle part, so that we
  	     * have some idea how it starts and ends. smsg() would always
  	     * truncate it at the end. */
! 	    trunc_string(tv2string(fc.rettv, &tofree, numbuf2, 0),
  							   buf, MSG_BUF_CLEN);
  	    smsg((char_u *)_("%s returning %s"), sourcing_name, buf);
  	    vim_free(tofree);
*** ../vim-7.0.069/src/ex_cmds.c	Sun Apr 23 00:33:23 2006
--- src/ex_cmds.c	Mon Aug 28 21:42:29 2006
***************
*** 185,190 ****
--- 185,191 ----
  	    new_indent = indent;
  	else
  	{
+ 	    has_tab = FALSE;	/* avoid uninit warnings */
  	    len = linelen(eap->cmdidx == CMD_right ? &has_tab
  						   : NULL) - get_indent();
  
***************
*** 1772,1781 ****
  				? (st_old.st_mode & 0020)
  				: (st_old.st_mode & 0002))))
  	{
! 	    int	tt;
  
  	    /* avoid a wait_return for this message, it's annoying */
- 	    tt = msg_didany;
  	    EMSG2(_("E137: Viminfo file is not writable: %s"), fname);
  	    msg_didany = tt;
  	    fclose(fp_in);
--- 1773,1781 ----
  				? (st_old.st_mode & 0020)
  				: (st_old.st_mode & 0002))))
  	{
! 	    int	tt = msg_didany;
  
  	    /* avoid a wait_return for this message, it's annoying */
  	    EMSG2(_("E137: Viminfo file is not writable: %s"), fname);
  	    msg_didany = tt;
  	    fclose(fp_in);
*** ../vim-7.0.069/src/ex_cmds2.c	Tue Apr 18 00:10:47 2006
--- src/ex_cmds2.c	Thu Aug 24 22:01:44 2006
***************
*** 3648,3660 ****
   * Return FALSE when not sourcing a file.
   */
      int
! source_finished(getline, cookie)
!     char_u	*(*getline) __ARGS((int, void *, int));
      void	*cookie;
  {
!     return (getline_equal(getline, cookie, getsourceline)
  	    && ((struct source_cookie *)getline_cookie(
! 						 getline, cookie))->finished);
  }
  #endif
  
--- 3648,3660 ----
   * Return FALSE when not sourcing a file.
   */
      int
! source_finished(fgetline, cookie)
!     char_u	*(*fgetline) __ARGS((int, void *, int));
      void	*cookie;
  {
!     return (getline_equal(fgetline, cookie, getsourceline)
  	    && ((struct source_cookie *)getline_cookie(
! 						fgetline, cookie))->finished);
  }
  #endif
  
*** ../vim-7.0.069/src/ex_docmd.c	Wed Aug 16 17:06:22 2006
--- src/ex_docmd.c	Thu Aug 24 22:03:17 2006
***************
*** 58,66 ****
  #endif
  
  #ifdef FEAT_EVAL
! static char_u	*do_one_cmd __ARGS((char_u **, int, struct condstack *, char_u *(*getline)(int, void *, int), void *cookie));
  #else
! static char_u	*do_one_cmd __ARGS((char_u **, int, char_u *(*getline)(int, void *, int), void *cookie));
  static int	if_level = 0;		/* depth in :if */
  #endif
  static char_u	*find_command __ARGS((exarg_T *eap, int *full));
--- 58,66 ----
  #endif
  
  #ifdef FEAT_EVAL
! static char_u	*do_one_cmd __ARGS((char_u **, int, struct condstack *, char_u *(*fgetline)(int, void *, int), void *cookie));
  #else
! static char_u	*do_one_cmd __ARGS((char_u **, int, char_u *(*fgetline)(int, void *, int), void *cookie));
  static int	if_level = 0;		/* depth in :if */
  #endif
  static char_u	*find_command __ARGS((exarg_T *eap, int *full));
***************
*** 831,840 ****
  
      /*
       * If requested, store and reset the global values controlling the
!      * exception handling (used when debugging).
       */
      if (flags & DOCMD_EXCRESET)
  	save_dbg_stuff(&debug_saved);
  
      initial_trylevel = trylevel;
  
--- 831,843 ----
  
      /*
       * If requested, store and reset the global values controlling the
!      * exception handling (used when debugging).  Otherwise clear it to avoid
!      * a bogus compiler warning when the optimizer uses inline functions...
       */
      if (flags & DOCMD_EXCRESET)
  	save_dbg_stuff(&debug_saved);
+     else
+ 	memset(&debug_saved, 0, 1);
  
      initial_trylevel = trylevel;
  
***************
*** 1574,1597 ****
  #endif
  
  /*
!  * If "getline" is get_loop_line(), return TRUE if the getline it uses equals
!  * "func".  * Otherwise return TRUE when "getline" equals "func".
   */
  /*ARGSUSED*/
      int
! getline_equal(getline, cookie, func)
!     char_u	*(*getline) __ARGS((int, void *, int));
!     void	*cookie;		/* argument for getline() */
      char_u	*(*func) __ARGS((int, void *, int));
  {
  #ifdef FEAT_EVAL
      char_u		*(*gp) __ARGS((int, void *, int));
      struct loop_cookie *cp;
  
!     /* When "getline" is "get_loop_line()" use the "cookie" to find the
       * function that's orignally used to obtain the lines.  This may be nested
       * several levels. */
!     gp = getline;
      cp = (struct loop_cookie *)cookie;
      while (gp == get_loop_line)
      {
--- 1577,1600 ----
  #endif
  
  /*
!  * If "fgetline" is get_loop_line(), return TRUE if the getline it uses equals
!  * "func".  * Otherwise return TRUE when "fgetline" equals "func".
   */
  /*ARGSUSED*/
      int
! getline_equal(fgetline, cookie, func)
!     char_u	*(*fgetline) __ARGS((int, void *, int));
!     void	*cookie;		/* argument for fgetline() */
      char_u	*(*func) __ARGS((int, void *, int));
  {
  #ifdef FEAT_EVAL
      char_u		*(*gp) __ARGS((int, void *, int));
      struct loop_cookie *cp;
  
!     /* When "fgetline" is "get_loop_line()" use the "cookie" to find the
       * function that's orignally used to obtain the lines.  This may be nested
       * several levels. */
!     gp = fgetline;
      cp = (struct loop_cookie *)cookie;
      while (gp == get_loop_line)
      {
***************
*** 1600,1628 ****
      }
      return gp == func;
  #else
!     return getline == func;
  #endif
  }
  
  #if defined(FEAT_EVAL) || defined(FEAT_MBYTE) || defined(PROTO)
  /*
!  * If "getline" is get_loop_line(), return the cookie used by the original
   * getline function.  Otherwise return "cookie".
   */
  /*ARGSUSED*/
      void *
! getline_cookie(getline, cookie)
!     char_u	*(*getline) __ARGS((int, void *, int));
!     void	*cookie;		/* argument for getline() */
  {
  # ifdef FEAT_EVAL
      char_u		*(*gp) __ARGS((int, void *, int));
      struct loop_cookie *cp;
  
!     /* When "getline" is "get_loop_line()" use the "cookie" to find the
       * cookie that's orignally used to obtain the lines.  This may be nested
       * several levels. */
!     gp = getline;
      cp = (struct loop_cookie *)cookie;
      while (gp == get_loop_line)
      {
--- 1603,1631 ----
      }
      return gp == func;
  #else
!     return fgetline == func;
  #endif
  }
  
  #if defined(FEAT_EVAL) || defined(FEAT_MBYTE) || defined(PROTO)
  /*
!  * If "fgetline" is get_loop_line(), return the cookie used by the original
   * getline function.  Otherwise return "cookie".
   */
  /*ARGSUSED*/
      void *
! getline_cookie(fgetline, cookie)
!     char_u	*(*fgetline) __ARGS((int, void *, int));
!     void	*cookie;		/* argument for fgetline() */
  {
  # ifdef FEAT_EVAL
      char_u		*(*gp) __ARGS((int, void *, int));
      struct loop_cookie *cp;
  
!     /* When "fgetline" is "get_loop_line()" use the "cookie" to find the
       * cookie that's orignally used to obtain the lines.  This may be nested
       * several levels. */
!     gp = fgetline;
      cp = (struct loop_cookie *)cookie;
      while (gp == get_loop_line)
      {
***************
*** 1648,1654 ****
   * 5. parse arguments
   * 6. switch on command name
   *
!  * Note: "getline" can be NULL.
   *
   * This function may be called recursively!
   */
--- 1651,1657 ----
   * 5. parse arguments
   * 6. switch on command name
   *
!  * Note: "fgetline" can be NULL.
   *
   * This function may be called recursively!
   */
***************
*** 1663,1676 ****
  #ifdef FEAT_EVAL
  			    cstack,
  #endif
! 				    getline, cookie)
      char_u		**cmdlinep;
      int			sourcing;
  #ifdef FEAT_EVAL
      struct condstack	*cstack;
  #endif
!     char_u		*(*getline) __ARGS((int, void *, int));
!     void		*cookie;		/* argument for getline() */
  {
      char_u		*p;
      linenr_T		lnum;
--- 1666,1679 ----
  #ifdef FEAT_EVAL
  			    cstack,
  #endif
! 				    fgetline, cookie)
      char_u		**cmdlinep;
      int			sourcing;
  #ifdef FEAT_EVAL
      struct condstack	*cstack;
  #endif
!     char_u		*(*fgetline) __ARGS((int, void *, int));
!     void		*cookie;		/* argument for fgetline() */
  {
      char_u		*p;
      linenr_T		lnum;
***************
*** 1698,1704 ****
      if (quitmore
  #ifdef FEAT_EVAL
  	    /* avoid that a function call in 'statusline' does this */
! 	    && !getline_equal(getline, cookie, get_func_line)
  #endif
  	    )
  	--quitmore;
--- 1701,1707 ----
      if (quitmore
  #ifdef FEAT_EVAL
  	    /* avoid that a function call in 'statusline' does this */
! 	    && !getline_equal(fgetline, cookie, get_func_line)
  #endif
  	    )
  	--quitmore;
***************
*** 1728,1735 ****
  
  	/* in ex mode, an empty line works like :+ */
  	if (*ea.cmd == NUL && exmode_active
! 			&& (getline_equal(getline, cookie, getexmodeline)
! 			    || getline_equal(getline, cookie, getexline))
  			&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
  	{
  	    ea.cmd = (char_u *)"+";
--- 1731,1738 ----
  
  	/* in ex mode, an empty line works like :+ */
  	if (*ea.cmd == NUL && exmode_active
! 			&& (getline_equal(fgetline, cookie, getexmodeline)
! 			    || getline_equal(fgetline, cookie, getexline))
  			&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
  	{
  	    ea.cmd = (char_u *)"+";
***************
*** 1918,1926 ****
      /* Count this line for profiling if ea.skip is FALSE. */
      if (do_profiling == PROF_YES && !ea.skip)
      {
! 	if (getline_equal(getline, cookie, get_func_line))
! 	    func_line_exec(getline_cookie(getline, cookie));
! 	else if (getline_equal(getline, cookie, getsourceline))
  	    script_line_exec();
      }
  #endif
--- 1921,1929 ----
      /* Count this line for profiling if ea.skip is FALSE. */
      if (do_profiling == PROF_YES && !ea.skip)
      {
! 	if (getline_equal(fgetline, cookie, get_func_line))
! 	    func_line_exec(getline_cookie(fgetline, cookie));
! 	else if (getline_equal(fgetline, cookie, getsourceline))
  	    script_line_exec();
      }
  #endif
***************
*** 2589,2595 ****
   * The "ea" structure holds the arguments that can be used.
   */
      ea.cmdlinep = cmdlinep;
!     ea.getline = getline;
      ea.cookie = cookie;
  #ifdef FEAT_EVAL
      ea.cstack = cstack;
--- 2592,2598 ----
   * The "ea" structure holds the arguments that can be used.
   */
      ea.cmdlinep = cmdlinep;
!     ea.getline = fgetline;
      ea.cookie = cookie;
  #ifdef FEAT_EVAL
      ea.cstack = cstack;
***************
*** 2627,2635 ****
  	do_throw(cstack);
      else if (check_cstack)
      {
! 	if (source_finished(getline, cookie))
  	    do_finish(&ea, TRUE);
! 	else if (getline_equal(getline, cookie, get_func_line)
  						   && current_func_returned())
  	    do_return(&ea, TRUE, FALSE, NULL);
      }
--- 2630,2638 ----
  	do_throw(cstack);
      else if (check_cstack)
      {
! 	if (source_finished(fgetline, cookie))
  	    do_finish(&ea, TRUE);
! 	else if (getline_equal(fgetline, cookie, get_func_line)
  						   && current_func_returned())
  	    do_return(&ea, TRUE, FALSE, NULL);
      }
*** ../vim-7.0.069/src/gui_beval.c	Thu May  4 23:57:11 2006
--- src/gui_beval.c	Thu Aug 24 22:39:50 2006
***************
*** 926,932 ****
  #  define IS_NONPRINTABLE(c) (((c) < 0x20 && (c) != TAB && (c) != NL) \
  			      || (c) == DEL)
      static void
! set_printable_label_text(GtkLabel *label, char_u *msg)
  {
      char_u	    *convbuf = NULL;
      char_u	    *buf;
--- 926,932 ----
  #  define IS_NONPRINTABLE(c) (((c) < 0x20 && (c) != TAB && (c) != NL) \
  			      || (c) == DEL)
      static void
! set_printable_label_text(GtkLabel *label, char_u *text)
  {
      char_u	    *convbuf = NULL;
      char_u	    *buf;
***************
*** 940,953 ****
      /* Convert to UTF-8 if it isn't already */
      if (output_conv.vc_type != CONV_NONE)
      {
! 	convbuf = string_convert(&output_conv, msg, NULL);
  	if (convbuf != NULL)
! 	    msg = convbuf;
      }
  
      /* First let's see how much we need to allocate */
      len = 0;
!     for (p = msg; *p != NUL; p += charlen)
      {
  	if ((*p & 0x80) == 0)	/* be quick for ASCII */
  	{
--- 940,953 ----
      /* Convert to UTF-8 if it isn't already */
      if (output_conv.vc_type != CONV_NONE)
      {
! 	convbuf = string_convert(&output_conv, text, NULL);
  	if (convbuf != NULL)
! 	    text = convbuf;
      }
  
      /* First let's see how much we need to allocate */
      len = 0;
!     for (p = text; *p != NUL; p += charlen)
      {
  	if ((*p & 0x80) == 0)	/* be quick for ASCII */
  	{
***************
*** 992,998 ****
  				     (unsigned long)pixel, &color);
  
  	pdest = buf;
! 	p = msg;
  	while (*p != NUL)
  	{
  	    /* Be quick for ASCII */
--- 992,998 ----
  				     (unsigned long)pixel, &color);
  
  	pdest = buf;
! 	p = text;
  	while (*p != NUL)
  	{
  	    /* Be quick for ASCII */
*** ../vim-7.0.069/src/gui_gtk.c	Fri May  5 23:13:49 2006
--- src/gui_gtk.c	Thu Aug 24 22:34:30 2006
***************
*** 957,971 ****
  get_menu_position(vimmenu_T *menu)
  {
      vimmenu_T	*node;
!     int		index = 0;
  
      for (node = menu->parent->children; node != menu; node = node->next)
      {
  	g_return_val_if_fail(node != NULL, -1);
! 	++index;
      }
  
!     return index;
  }
  #endif /* FEAT_TOOLBAR && HAVE_GTK2 */
  
--- 957,971 ----
  get_menu_position(vimmenu_T *menu)
  {
      vimmenu_T	*node;
!     int		idx = 0;
  
      for (node = menu->parent->children; node != menu; node = node->next)
      {
  	g_return_val_if_fail(node != NULL, -1);
! 	++idx;
      }
  
!     return idx;
  }
  #endif /* FEAT_TOOLBAR && HAVE_GTK2 */
  
***************
*** 2127,2133 ****
      char    **ync;  /* "yes no cancel" */
      char    **buttons;
      int	    n_buttons = 0;
!     int	    index;
  
      button_string = vim_strsave(button_string); /* must be writable */
      if (button_string == NULL)
--- 2128,2134 ----
      char    **ync;  /* "yes no cancel" */
      char    **buttons;
      int	    n_buttons = 0;
!     int	    idx;
  
      button_string = vim_strsave(button_string); /* must be writable */
      if (button_string == NULL)
***************
*** 2161,2172 ****
       * Well, apparently somebody changed his mind: with GTK 2.2.4 it works the
       * other way around...
       */
!     for (index = 1; index <= n_buttons; ++index)
      {
  	char	*label;
  	char_u	*label8;
  
! 	label = buttons[index - 1];
  	/*
  	 * Perform some guesswork to find appropriate stock items for the
  	 * buttons.  We have to compare with a sample of the translated
--- 2162,2173 ----
       * Well, apparently somebody changed his mind: with GTK 2.2.4 it works the
       * other way around...
       */
!     for (idx = 1; idx <= n_buttons; ++idx)
      {
  	char	*label;
  	char_u	*label8;
  
! 	label = buttons[idx - 1];
  	/*
  	 * Perform some guesswork to find appropriate stock items for the
  	 * buttons.  We have to compare with a sample of the translated
***************
*** 2188,2194 ****
  	    else if (button_equal(label, "Cancel")) label = GTK_STOCK_CANCEL;
  	}
  	label8 = CONVERT_TO_UTF8((char_u *)label);
! 	gtk_dialog_add_button(dialog, (const gchar *)label8, index);
  	CONVERT_TO_UTF8_FREE(label8);
      }
  
--- 2189,2195 ----
  	    else if (button_equal(label, "Cancel")) label = GTK_STOCK_CANCEL;
  	}
  	label8 = CONVERT_TO_UTF8((char_u *)label);
! 	gtk_dialog_add_button(dialog, (const gchar *)label8, idx);
  	CONVERT_TO_UTF8_FREE(label8);
      }
  
*** ../vim-7.0.069/src/gui_gtk_x11.c	Fri May  5 23:16:59 2006
--- src/gui_gtk_x11.c	Thu Aug 24 22:35:59 2006
***************
*** 3233,3244 ****
  on_select_tab(
  	GtkNotebook	*notebook,
  	GtkNotebookPage *page,
! 	gint		index,
  	gpointer	data)
  {
      if (!ignore_tabline_evt)
      {
! 	if (send_tabline_event(index + 1) && gtk_main_level() > 0)
  	    gtk_main_quit();
      }
  }
--- 3233,3244 ----
  on_select_tab(
  	GtkNotebook	*notebook,
  	GtkNotebookPage *page,
! 	gint		idx,
  	gpointer	data)
  {
      if (!ignore_tabline_evt)
      {
! 	if (send_tabline_event(idx + 1) && gtk_main_level() > 0)
  	    gtk_main_quit();
      }
  }
***************
*** 5303,5315 ****
  # ifdef HAVE_GTK2
      if (font != NOFONT)
      {
! 	char	*name = pango_font_description_to_string(font);
  
! 	if (name != NULL)
  	{
! 	    char_u	*s = vim_strsave((char_u *)name);
  
! 	    g_free(name);
  	    return s;
  	}
      }
--- 5303,5315 ----
  # ifdef HAVE_GTK2
      if (font != NOFONT)
      {
! 	char	*pangoname = pango_font_description_to_string(font);
  
! 	if (pangoname != NULL)
  	{
! 	    char_u	*s = vim_strsave((char_u *)pangoname);
  
! 	    g_free(pangoname);
  	    return s;
  	}
      }
***************
*** 6241,6264 ****
  {
      GdkGCValues values;
      GdkGC *invert_gc;
-     GdkColor foreground;
-     GdkColor background;
  
      if (gui.drawarea->window == NULL)
  	return;
  
!     foreground.pixel = gui.norm_pixel ^ gui.back_pixel;
!     background.pixel = gui.norm_pixel ^ gui.back_pixel;
! 
!     values.foreground = foreground;
!     values.background = background;
      values.function = GDK_XOR;
      invert_gc = gdk_gc_new_with_values(gui.drawarea->window,
  				       &values,
  				       GDK_GC_FOREGROUND |
  				       GDK_GC_BACKGROUND |
  				       GDK_GC_FUNCTION);
!     gdk_gc_set_exposures(invert_gc, gui.visibility != GDK_VISIBILITY_UNOBSCURED);
      gdk_draw_rectangle(gui.drawarea->window, invert_gc,
  		       TRUE,
  		       FILL_X(c), FILL_Y(r),
--- 6241,6260 ----
  {
      GdkGCValues values;
      GdkGC *invert_gc;
  
      if (gui.drawarea->window == NULL)
  	return;
  
!     values.foreground.pixel = gui.norm_pixel ^ gui.back_pixel;
!     values.background.pixel = gui.norm_pixel ^ gui.back_pixel;
      values.function = GDK_XOR;
      invert_gc = gdk_gc_new_with_values(gui.drawarea->window,
  				       &values,
  				       GDK_GC_FOREGROUND |
  				       GDK_GC_BACKGROUND |
  				       GDK_GC_FUNCTION);
!     gdk_gc_set_exposures(invert_gc, gui.visibility !=
! 						   GDK_VISIBILITY_UNOBSCURED);
      gdk_draw_rectangle(gui.drawarea->window, invert_gc,
  		       TRUE,
  		       FILL_X(c), FILL_Y(r),
*** ../vim-7.0.069/src/hardcopy.c	Thu May  4 23:53:57 2006
--- src/hardcopy.c	Thu Aug 24 22:04:32 2006
***************
*** 1794,1822 ****
      static int
  prt_resfile_next_line()
  {
!     int     index;
  
      /* Move to start of next line and then find end of line */
!     index = prt_resfile.line_end + 1;
!     while (index < prt_resfile.len)
      {
! 	if (prt_resfile.buffer[index] != PSLF && prt_resfile.buffer[index]
! 									!= PSCR)
  	    break;
! 	index++;
      }
!     prt_resfile.line_start = index;
  
!     while (index < prt_resfile.len)
      {
! 	if (prt_resfile.buffer[index] == PSLF || prt_resfile.buffer[index]
! 									== PSCR)
  	    break;
! 	index++;
      }
!     prt_resfile.line_end = index;
  
!     return (index < prt_resfile.len);
  }
  
      static int
--- 1794,1820 ----
      static int
  prt_resfile_next_line()
  {
!     int     idx;
  
      /* Move to start of next line and then find end of line */
!     idx = prt_resfile.line_end + 1;
!     while (idx < prt_resfile.len)
      {
! 	if (prt_resfile.buffer[idx] != PSLF && prt_resfile.buffer[idx] != PSCR)
  	    break;
! 	idx++;
      }
!     prt_resfile.line_start = idx;
  
!     while (idx < prt_resfile.len)
      {
! 	if (prt_resfile.buffer[idx] == PSLF || prt_resfile.buffer[idx] == PSCR)
  	    break;
! 	idx++;
      }
!     prt_resfile.line_end = idx;
  
!     return (idx < prt_resfile.len);
  }
  
      static int
***************
*** 1837,1850 ****
  prt_resfile_skip_nonws(offset)
      int     offset;
  {
!     int     index;
  
!     index = prt_resfile.line_start + offset;
!     while (index < prt_resfile.line_end)
      {
! 	if (isspace(prt_resfile.buffer[index]))
! 	    return index - prt_resfile.line_start;
! 	index++;
      }
      return -1;
  }
--- 1835,1848 ----
  prt_resfile_skip_nonws(offset)
      int     offset;
  {
!     int     idx;
  
!     idx = prt_resfile.line_start + offset;
!     while (idx < prt_resfile.line_end)
      {
! 	if (isspace(prt_resfile.buffer[idx]))
! 	    return idx - prt_resfile.line_start;
! 	idx++;
      }
      return -1;
  }
***************
*** 1853,1866 ****
  prt_resfile_skip_ws(offset)
      int     offset;
  {
!     int     index;
  
!     index = prt_resfile.line_start + offset;
!     while (index < prt_resfile.line_end)
      {
! 	if (!isspace(prt_resfile.buffer[index]))
! 	    return index - prt_resfile.line_start;
! 	index++;
      }
      return -1;
  }
--- 1851,1864 ----
  prt_resfile_skip_ws(offset)
      int     offset;
  {
!     int     idx;
  
!     idx = prt_resfile.line_start + offset;
!     while (idx < prt_resfile.line_end)
      {
! 	if (!isspace(prt_resfile.buffer[idx]))
! 	    return idx - prt_resfile.line_start;
! 	idx++;
      }
      return -1;
  }
***************
*** 2478,2484 ****
      char_u	*p_encoding;
      struct prt_ps_encoding_S *p_mbenc;
      struct prt_ps_encoding_S *p_mbenc_first;
!     struct prt_ps_charset_S  *p_mbchar;
  #endif
  
  #if 0
--- 2476,2482 ----
      char_u	*p_encoding;
      struct prt_ps_encoding_S *p_mbenc;
      struct prt_ps_encoding_S *p_mbenc_first;
!     struct prt_ps_charset_S  *p_mbchar = NULL;
  #endif
  
  #if 0
***************
*** 2516,2522 ****
      if (!(props & ENC_8BIT) && ((*p_pmcs != NUL) || !(props & ENC_UNICODE)))
      {
  	p_mbenc_first = NULL;
- 	p_mbchar = NULL;
  	for (cmap = 0; cmap < NUM_ELEMENTS(prt_ps_mbfonts); cmap++)
  	    if (prt_match_encoding((char *)p_encoding, &prt_ps_mbfonts[cmap],
  								    &p_mbenc))
--- 2514,2519 ----
*** ../vim-7.0.069/src/if_cscope.c	Tue Apr 18 23:49:18 2006
--- src/if_cscope.c	Sat Jul  8 22:34:46 2006
***************
*** 989,996 ****
  {
      int i;
      char *cmd;
!     char **matches, **contexts;
!     int nummatches[CSCOPE_MAX_CONNECTIONS], totmatches, matched;
  #ifdef FEAT_QUICKFIX
      char cmdletter;
      char *qfpos;
--- 989,995 ----
  {
      int i;
      char *cmd;
!     int nummatches[CSCOPE_MAX_CONNECTIONS], totmatches;
  #ifdef FEAT_QUICKFIX
      char cmdletter;
      char *qfpos;
***************
*** 1141,1146 ****
--- 1140,1148 ----
      else
  #endif /* FEAT_QUICKFIX */
      {
+ 	char **matches = NULL, **contexts = NULL;
+ 	int matched = 0;
+ 
  	/* read output */
  	cs_fill_results((char *)pat, totmatches, nummatches, &matches,
  							 &contexts, &matched);
*** ../vim-7.0.069/src/main.c	Tue Aug 15 21:42:17 2006
--- src/main.c	Thu Aug 24 22:05:09 2006
***************
*** 2285,2291 ****
      mparm_T	*parmp;
  {
  #ifdef FEAT_WINDOWS
!     int		rewind;
      int		done = 0;
  
      /*
--- 2285,2291 ----
      mparm_T	*parmp;
  {
  #ifdef FEAT_WINDOWS
!     int		dorewind;
      int		done = 0;
  
      /*
***************
*** 2342,2351 ****
  	++autocmd_no_leave;
  #endif
  #ifdef FEAT_WINDOWS
! 	rewind = TRUE;
  	while (done++ < 1000)
  	{
! 	    if (rewind)
  	    {
  		if (parmp->window_layout == WIN_TABS)
  		    goto_tabpage(1);
--- 2342,2351 ----
  	++autocmd_no_leave;
  #endif
  #ifdef FEAT_WINDOWS
! 	dorewind = TRUE;
  	while (done++ < 1000)
  	{
! 	    if (dorewind)
  	    {
  		if (parmp->window_layout == WIN_TABS)
  		    goto_tabpage(1);
***************
*** 2364,2370 ****
  		    break;
  		curwin = curwin->w_next;
  	    }
! 	    rewind = FALSE;
  #endif
  	    curbuf = curwin->w_buffer;
  	    if (curbuf->b_ml.ml_mfp == NULL)
--- 2364,2370 ----
  		    break;
  		curwin = curwin->w_next;
  	    }
! 	    dorewind = FALSE;
  #endif
  	    curbuf = curwin->w_buffer;
  	    if (curbuf->b_ml.ml_mfp == NULL)
***************
*** 2385,2391 ****
  		check_swap_exists_action();
  #endif
  #ifdef FEAT_AUTOCMD
! 		rewind = TRUE;		/* start again */
  #endif
  	    }
  #ifdef FEAT_WINDOWS
--- 2385,2391 ----
  		check_swap_exists_action();
  #endif
  #ifdef FEAT_AUTOCMD
! 		dorewind = TRUE;		/* start again */
  #endif
  	    }
  #ifdef FEAT_WINDOWS
*** ../vim-7.0.069/src/mbyte.c	Tue Aug 29 16:10:54 2006
--- src/mbyte.c	Tue Aug 29 14:41:45 2006
***************
*** 3861,3873 ****
  
      if (preedit_string != NULL && attr_list != NULL)
      {
! 	int index;
  
  	/* Get the byte index as used by PangoAttrIterator */
! 	for (index = 0; col > 0 && preedit_string[index] != '\0'; --col)
! 	    index += utfc_ptr2len((char_u *)preedit_string + index);
  
! 	if (preedit_string[index] != '\0')
  	{
  	    PangoAttrIterator	*iter;
  	    int			start, end;
--- 3861,3873 ----
  
      if (preedit_string != NULL && attr_list != NULL)
      {
! 	int idx;
  
  	/* Get the byte index as used by PangoAttrIterator */
! 	for (idx = 0; col > 0 && preedit_string[idx] != '\0'; --col)
! 	    idx += utfc_ptr2len((char_u *)preedit_string + idx);
  
! 	if (preedit_string[idx] != '\0')
  	{
  	    PangoAttrIterator	*iter;
  	    int			start, end;
***************
*** 3880,3886 ****
  	    {
  		pango_attr_iterator_range(iter, &start, &end);
  
! 		if (index >= start && index < end)
  		    char_attr |= translate_pango_attributes(iter);
  	    }
  	    while (pango_attr_iterator_next(iter));
--- 3880,3886 ----
  	    {
  		pango_attr_iterator_range(iter, &start, &end);
  
! 		if (idx >= start && idx < end)
  		    char_attr |= translate_pango_attributes(iter);
  	    }
  	    while (pango_attr_iterator_next(iter));
*** ../vim-7.0.069/src/memline.c	Fri Apr 21 00:16:47 2006
--- src/memline.c	Thu Aug 24 22:06:17 2006
***************
*** 215,221 ****
  #define ML_FLUSH	0x02	    /* flush locked block */
  #define ML_SIMPLE(x)	(x & 0x10)  /* DEL, INS or FIND */
  
! static void ml_upd_block0 __ARGS((buf_T *buf, int setfname));
  static void set_b0_fname __ARGS((ZERO_BL *, buf_T *buf));
  static void set_b0_dir_flag __ARGS((ZERO_BL *b0p, buf_T *buf));
  #ifdef FEAT_MBYTE
--- 215,221 ----
  #define ML_FLUSH	0x02	    /* flush locked block */
  #define ML_SIMPLE(x)	(x & 0x10)  /* DEL, INS or FIND */
  
! static void ml_upd_block0 __ARGS((buf_T *buf, int set_fname));
  static void set_b0_fname __ARGS((ZERO_BL *, buf_T *buf));
  static void set_b0_dir_flag __ARGS((ZERO_BL *b0p, buf_T *buf));
  #ifdef FEAT_MBYTE
***************
*** 679,687 ****
   * Update the timestamp or the B0_SAME_DIR flag of the .swp file.
   */
      static void
! ml_upd_block0(buf, setfname)
      buf_T	*buf;
!     int		setfname;
  {
      memfile_T	*mfp;
      bhdr_T	*hp;
--- 679,687 ----
   * Update the timestamp or the B0_SAME_DIR flag of the .swp file.
   */
      static void
! ml_upd_block0(buf, set_fname)
      buf_T	*buf;
!     int		set_fname;
  {
      memfile_T	*mfp;
      bhdr_T	*hp;
***************
*** 695,701 ****
  	EMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
      else
      {
! 	if (setfname)
  	    set_b0_fname(b0p, buf);
  	else
  	    set_b0_dir_flag(b0p, buf);
--- 695,701 ----
  	EMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
      else
      {
! 	if (set_fname)
  	    set_b0_fname(b0p, buf);
  	else
  	    set_b0_dir_flag(b0p, buf);
*** ../vim-7.0.069/src/netbeans.c	Tue Aug  8 21:36:15 2006
--- src/netbeans.c	Thu Aug 24 22:42:09 2006
***************
*** 103,109 ****
  static int  inputHandler = -1;		/* simply ret.value of WSAAsyncSelect() */
  extern HWND s_hwnd;			/* Gvim's Window handle */
  #endif
! static int cmdno;			/* current command number for reply */
  static int haveConnection = FALSE;	/* socket is connected and
  					   initialization is done */
  #ifdef FEAT_GUI_MOTIF
--- 103,109 ----
  static int  inputHandler = -1;		/* simply ret.value of WSAAsyncSelect() */
  extern HWND s_hwnd;			/* Gvim's Window handle */
  #endif
! static int r_cmdno;			/* current command number for reply */
  static int haveConnection = FALSE;	/* socket is connected and
  					   initialization is done */
  #ifdef FEAT_GUI_MOTIF
***************
*** 832,842 ****
  	return;
      }
  
!     cmdno = strtol(q, &q, 10);
  
      q = (char *)skipwhite((char_u *)q);
  
!     if (nb_do_cmd(bufno, (char_u *)verb, isfunc, cmdno, (char_u *)q) == FAIL)
      {
  #ifdef NBDEBUG
  	/*
--- 832,842 ----
  	return;
      }
  
!     r_cmdno = strtol(q, &q, 10);
  
      q = (char *)skipwhite((char_u *)q);
  
!     if (nb_do_cmd(bufno, (char_u *)verb, isfunc, r_cmdno, (char_u *)q) == FAIL)
      {
  #ifdef NBDEBUG
  	/*
***************
*** 1008,1018 ****
  	if (netbeansForcedQuit)
  	{
  	    /* mark as unmodified so NetBeans won't put up dialog on "killed" */
! 	    sprintf(buf, "%d:unmodified=%d\n", i, cmdno);
  	    nbdebug(("EVT: %s", buf));
  	    nb_send(buf, "netbeans_end");
  	}
! 	sprintf(buf, "%d:killed=%d\n", i, cmdno);
  	nbdebug(("EVT: %s", buf));
  /*	nb_send(buf, "netbeans_end");    avoid "write failed" messages */
  	if (sd >= 0)
--- 1008,1018 ----
  	if (netbeansForcedQuit)
  	{
  	    /* mark as unmodified so NetBeans won't put up dialog on "killed" */
! 	    sprintf(buf, "%d:unmodified=%d\n", i, r_cmdno);
  	    nbdebug(("EVT: %s", buf));
  	    nb_send(buf, "netbeans_end");
  	}
! 	sprintf(buf, "%d:killed=%d\n", i, r_cmdno);
  	nbdebug(("EVT: %s", buf));
  /*	nb_send(buf, "netbeans_end");    avoid "write failed" messages */
  	if (sd >= 0)
***************
*** 2563,2569 ****
  	    if (p != NULL)
  	    {
  		vim_snprintf(buf, sizeof(buf),
! 				       "0:balloonText=%d \"%s\"\n", cmdno, p);
  		vim_free(p);
  	    }
  	    nbdebug(("EVT: %s", buf));
--- 2563,2569 ----
  	    if (p != NULL)
  	    {
  		vim_snprintf(buf, sizeof(buf),
! 				       "0:balloonText=%d \"%s\"\n", r_cmdno, p);
  		vim_free(p);
  	    }
  	    nbdebug(("EVT: %s", buf));
***************
*** 2617,2623 ****
  
      if (haveConnection)
      {
! 	sprintf(buf, "0:disconnect=%d\n", cmdno);
  	nbdebug(("EVT: %s", buf));
  	nb_send(buf, "netbeans_disconnect");
      }
--- 2617,2623 ----
  
      if (haveConnection)
      {
! 	sprintf(buf, "0:disconnect=%d\n", r_cmdno);
  	nbdebug(("EVT: %s", buf));
  	nb_send(buf, "netbeans_disconnect");
      }
***************
*** 2636,2642 ****
  	return;
  
      sprintf(buf, "0:geometry=%d %d %d %d %d\n",
! 		    cmdno, (int)Columns, (int)Rows, new_x, new_y);
      /*nbdebug(("EVT: %s", buf)); happens too many times during a move */
      nb_send(buf, "netbeans_frame_moved");
  }
--- 2636,2642 ----
  	return;
  
      sprintf(buf, "0:geometry=%d %d %d %d %d\n",
! 		    r_cmdno, (int)Columns, (int)Rows, new_x, new_y);
      /*nbdebug(("EVT: %s", buf)); happens too many times during a move */
      nb_send(buf, "netbeans_frame_moved");
  }
***************
*** 2745,2751 ****
      if (bufno <= 0)
  	return;
  
!     sprintf(buffer, "%d:killed=%d\n", bufno, cmdno);
  
      nbdebug(("EVT: %s", buffer));
  
--- 2745,2751 ----
      if (bufno <= 0)
  	return;
  
!     sprintf(buffer, "%d:killed=%d\n", bufno, r_cmdno);
  
      nbdebug(("EVT: %s", buffer));
  
***************
*** 2819,2825 ****
      if (p != NULL)
      {
  	buf = alloc(128 + 2*newlen);
! 	sprintf((char *)buf, "%d:insert=%d %ld \"%s\"\n", bufno, cmdno, off, p);
  	nbdebug(("EVT: %s", buf));
  	nb_send((char *)buf, "netbeans_inserted");
  	vim_free(p);
--- 2819,2826 ----
      if (p != NULL)
      {
  	buf = alloc(128 + 2*newlen);
! 	sprintf((char *)buf, "%d:insert=%d %ld \"%s\"\n",
! 						      bufno, r_cmdno, off, p);
  	nbdebug(("EVT: %s", buf));
  	nb_send((char *)buf, "netbeans_inserted");
  	vim_free(p);
***************
*** 2861,2867 ****
  
      off = pos2off(bufp, &pos);
  
!     sprintf((char *)buf, "%d:remove=%d %ld %ld\n", bufno, cmdno, off, len);
      nbdebug(("EVT: %s", buf));
      nb_send((char *)buf, "netbeans_removed");
  }
--- 2862,2868 ----
  
      off = pos2off(bufp, &pos);
  
!     sprintf((char *)buf, "%d:remove=%d %ld %ld\n", bufno, r_cmdno, off, len);
      nbdebug(("EVT: %s", buf));
      nb_send((char *)buf, "netbeans_removed");
  }
***************
*** 2886,2892 ****
  
      nbbuf->modified = 0;
  
!     sprintf((char *)buf, "%d:unmodified=%d\n", bufno, cmdno);
      nbdebug(("EVT: %s", buf));
      nb_send((char *)buf, "netbeans_unmodified");
  #endif
--- 2887,2893 ----
  
      nbbuf->modified = 0;
  
!     sprintf((char *)buf, "%d:unmodified=%d\n", bufno, r_cmdno);
      nbdebug(("EVT: %s", buf));
      nb_send((char *)buf, "netbeans_unmodified");
  #endif
***************
*** 2910,2920 ****
  	long off = pos2off(curbuf, &curwin->w_cursor);
  
  	/* sync the cursor position */
! 	sprintf(buf, "%d:newDotAndMark=%d %ld %ld\n", bufno, cmdno, off, off);
  	nbdebug(("EVT: %s", buf));
  	nb_send(buf, "netbeans_button_release[newDotAndMark]");
  
! 	sprintf(buf, "%d:buttonRelease=%d %d %ld %d\n", bufno, cmdno,
  				    button, (long)curwin->w_cursor.lnum, col);
  	nbdebug(("EVT: %s", buf));
  	nb_send(buf, "netbeans_button_release");
--- 2911,2921 ----
  	long off = pos2off(curbuf, &curwin->w_cursor);
  
  	/* sync the cursor position */
! 	sprintf(buf, "%d:newDotAndMark=%d %ld %ld\n", bufno, r_cmdno, off, off);
  	nbdebug(("EVT: %s", buf));
  	nb_send(buf, "netbeans_button_release[newDotAndMark]");
  
! 	sprintf(buf, "%d:buttonRelease=%d %d %ld %d\n", bufno, r_cmdno,
  				    button, (long)curwin->w_cursor.lnum, col);
  	nbdebug(("EVT: %s", buf));
  	nb_send(buf, "netbeans_button_release");
***************
*** 2975,2981 ****
  
      /* sync the cursor position */
      off = pos2off(curbuf, &curwin->w_cursor);
!     sprintf(buf, "%d:newDotAndMark=%d %ld %ld\n", bufno, cmdno, off, off);
      nbdebug(("EVT: %s", buf));
      nb_send(buf, "netbeans_keycommand");
  
--- 2976,2982 ----
  
      /* sync the cursor position */
      off = pos2off(curbuf, &curwin->w_cursor);
!     sprintf(buf, "%d:newDotAndMark=%d %ld %ld\n", bufno, r_cmdno, off, off);
      nbdebug(("EVT: %s", buf));
      nb_send(buf, "netbeans_keycommand");
  
***************
*** 2986,2998 ****
  
      /* now send keyCommand event */
      vim_snprintf(buf, sizeof(buf), "%d:keyCommand=%d \"%s\"\n",
! 						       bufno, cmdno, keyName);
      nbdebug(("EVT: %s", buf));
      nb_send(buf, "netbeans_keycommand");
  
      /* New: do both at once and include the lnum/col. */
      vim_snprintf(buf, sizeof(buf), "%d:keyAtPos=%d \"%s\" %ld %ld/%ld\n",
! 	    bufno, cmdno, keyName,
  		off, (long)curwin->w_cursor.lnum, (long)curwin->w_cursor.col);
      nbdebug(("EVT: %s", buf));
      nb_send(buf, "netbeans_keycommand");
--- 2987,2999 ----
  
      /* now send keyCommand event */
      vim_snprintf(buf, sizeof(buf), "%d:keyCommand=%d \"%s\"\n",
! 						     bufno, r_cmdno, keyName);
      nbdebug(("EVT: %s", buf));
      nb_send(buf, "netbeans_keycommand");
  
      /* New: do both at once and include the lnum/col. */
      vim_snprintf(buf, sizeof(buf), "%d:keyAtPos=%d \"%s\" %ld %ld/%ld\n",
! 	    bufno, r_cmdno, keyName,
  		off, (long)curwin->w_cursor.lnum, (long)curwin->w_cursor.col);
      nbdebug(("EVT: %s", buf));
      nb_send(buf, "netbeans_keycommand");
***************
*** 3015,3021 ****
  
      nbbuf->modified = 0;
  
!     sprintf((char *)buf, "%d:save=%d\n", bufno, cmdno);
      nbdebug(("EVT: %s", buf));
      nb_send((char *)buf, "netbeans_save_buffer");
  }
--- 3016,3022 ----
  
      nbbuf->modified = 0;
  
!     sprintf((char *)buf, "%d:save=%d\n", bufno, r_cmdno);
      nbdebug(("EVT: %s", buf));
      nb_send((char *)buf, "netbeans_save_buffer");
  }
***************
*** 3039,3045 ****
      if (nbbuf->insertDone)
  	nbbuf->modified = 1;
  
!     sprintf((char *)buf, "%d:remove=%d 0 -1\n", bufno, cmdno);
      nbdebug(("EVT(suppressed): %s", buf));
  /*     nb_send(buf, "netbeans_deleted_all_lines"); */
  }
--- 3040,3046 ----
      if (nbbuf->insertDone)
  	nbbuf->modified = 1;
  
!     sprintf((char *)buf, "%d:remove=%d 0 -1\n", bufno, r_cmdno);
      nbdebug(("EVT(suppressed): %s", buf));
  /*     nb_send(buf, "netbeans_deleted_all_lines"); */
  }
*** ../vim-7.0.069/src/normal.c	Wed Aug 16 21:42:34 2006
--- src/normal.c	Thu Aug 24 22:17:37 2006
***************
*** 4127,4133 ****
      int		save_p_ws;
      int		save_p_scs;
      int		retval = OK;
!     int		incl;
  
      if ((pat = alloc(len + 7)) == NULL)
  	return FAIL;
--- 4127,4133 ----
      int		save_p_ws;
      int		save_p_scs;
      int		retval = OK;
!     int		incll;
  
      if ((pat = alloc(len + 7)) == NULL)
  	return FAIL;
***************
*** 4147,4153 ****
       * With "gd" Search back for the start of the current function, then go
       * back until a blank line.  If this fails go to line 1.
       */
!     if (!locally || !findpar(&incl, BACKWARD, 1L, '{', FALSE))
      {
  	setpcmark();			/* Set in findpar() otherwise */
  	curwin->w_cursor.lnum = 1;
--- 4147,4153 ----
       * With "gd" Search back for the start of the current function, then go
       * back until a blank line.  If this fails go to line 1.
       */
!     if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))
      {
  	setpcmark();			/* Set in findpar() otherwise */
  	curwin->w_cursor.lnum = 1;
*** ../vim-7.0.069/src/option.c	Tue Aug  8 16:30:51 2006
--- src/option.c	Wed Aug 16 21:54:45 2006
***************
*** 5268,5312 ****
      char_u	*s;
      char_u	**varp;
      int		both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;
  
!     if (opt_idx == -1)		/* use name */
      {
! 	opt_idx = findoption(name);
! 	if (opt_idx < 0)	/* not found (should not happen) */
  	{
  	    EMSG2(_(e_intern2), "set_string_option_direct()");
  	    return;
  	}
      }
  
!     if (options[opt_idx].var == NULL)	/* can't set hidden option */
  	return;
  
      s = vim_strsave(val);
      if (s != NULL)
      {
! 	varp = (char_u **)get_varp_scope(&(options[opt_idx]),
  					       both ? OPT_LOCAL : opt_flags);
! 	if ((opt_flags & OPT_FREE) && (options[opt_idx].flags & P_ALLOCED))
  	    free_string_option(*varp);
  	*varp = s;
  
  	/* For buffer/window local option may also set the global value. */
  	if (both)
! 	    set_string_option_global(opt_idx, varp);
  
! 	options[opt_idx].flags |= P_ALLOCED;
  
  	/* When setting both values of a global option with a local value,
  	 * make the local value empty, so that the global value is used. */
! 	if (((int)options[opt_idx].indir & PV_BOTH) && both)
  	{
  	    free_string_option(*varp);
  	    *varp = empty_option;
  	}
  # ifdef FEAT_EVAL
  	if (set_sid != SID_NONE)
! 	    set_option_scriptID_idx(opt_idx, opt_flags,
  					set_sid == 0 ? current_SID : set_sid);
  # endif
      }
--- 5268,5313 ----
      char_u	*s;
      char_u	**varp;
      int		both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;
+     int		idx = opt_idx;
  
!     if (idx == -1)		/* use name */
      {
! 	idx = findoption(name);
! 	if (idx < 0)	/* not found (should not happen) */
  	{
  	    EMSG2(_(e_intern2), "set_string_option_direct()");
  	    return;
  	}
      }
  
!     if (options[idx].var == NULL)	/* can't set hidden option */
  	return;
  
      s = vim_strsave(val);
      if (s != NULL)
      {
! 	varp = (char_u **)get_varp_scope(&(options[idx]),
  					       both ? OPT_LOCAL : opt_flags);
! 	if ((opt_flags & OPT_FREE) && (options[idx].flags & P_ALLOCED))
  	    free_string_option(*varp);
  	*varp = s;
  
  	/* For buffer/window local option may also set the global value. */
  	if (both)
! 	    set_string_option_global(idx, varp);
  
! 	options[idx].flags |= P_ALLOCED;
  
  	/* When setting both values of a global option with a local value,
  	 * make the local value empty, so that the global value is used. */
! 	if (((int)options[idx].indir & PV_BOTH) && both)
  	{
  	    free_string_option(*varp);
  	    *varp = empty_option;
  	}
  # ifdef FEAT_EVAL
  	if (set_sid != SID_NONE)
! 	    set_option_scriptID_idx(idx, opt_flags,
  					set_sid == 0 ? current_SID : set_sid);
  # endif
      }
*** ../vim-7.0.069/src/os_unix.c	Thu Jun 22 19:47:11 2006
--- src/os_unix.c	Thu Aug 24 22:21:56 2006
***************
*** 3934,3940 ****
  		    {
  			linenr_T    lnum = curbuf->b_op_start.lnum;
  			int	    written = 0;
! 			char_u	    *p = ml_get(lnum);
  			char_u	    *s;
  			size_t	    l;
  
--- 3934,3940 ----
  		    {
  			linenr_T    lnum = curbuf->b_op_start.lnum;
  			int	    written = 0;
! 			char_u	    *lp = ml_get(lnum);
  			char_u	    *s;
  			size_t	    l;
  
***************
*** 3942,3958 ****
  			close(fromshell_fd);
  			for (;;)
  			{
! 			    l = STRLEN(p + written);
  			    if (l == 0)
  				len = 0;
! 			    else if (p[written] == NL)
  				/* NL -> NUL translation */
  				len = write(toshell_fd, "", (size_t)1);
  			    else
  			    {
! 				s = vim_strchr(p + written, NL);
! 				len = write(toshell_fd, (char *)p + written,
! 					   s == NULL ? l : s - (p + written));
  			    }
  			    if (len == l)
  			    {
--- 3942,3958 ----
  			close(fromshell_fd);
  			for (;;)
  			{
! 			    l = STRLEN(lp + written);
  			    if (l == 0)
  				len = 0;
! 			    else if (lp[written] == NL)
  				/* NL -> NUL translation */
  				len = write(toshell_fd, "", (size_t)1);
  			    else
  			    {
! 				s = vim_strchr(lp + written, NL);
! 				len = write(toshell_fd, (char *)lp + written,
! 					   s == NULL ? l : s - (lp + written));
  			    }
  			    if (len == l)
  			    {
***************
*** 3973,3979 ****
  				    toshell_fd = -1;
  				    break;
  				}
! 				p = ml_get(lnum);
  				written = 0;
  			    }
  			    else if (len > 0)
--- 3973,3979 ----
  				    toshell_fd = -1;
  				    break;
  				}
! 				lp = ml_get(lnum);
  				written = 0;
  			    }
  			    else if (len > 0)
*** ../vim-7.0.069/src/quickfix.c	Wed Aug 16 19:34:59 2006
--- src/quickfix.c	Thu Aug 24 22:23:31 2006
***************
*** 500,507 ****
  	{
  	    if (tv != NULL)
  	    {
- 		int len;
- 
  		if (tv->v_type == VAR_STRING)
  		{
  		    /* Get the next line from the supplied string */
--- 500,505 ----
*** ../vim-7.0.069/src/regexp.c	Sun Apr 30 20:38:22 2006
--- src/regexp.c	Thu Aug 24 22:25:15 2006
***************
*** 3912,3918 ****
  		{
  		    colnr_T	    start, end;
  		    colnr_T	    start2, end2;
! 		    colnr_T	    col;
  
  		    getvvcol(wp, &top, &start, NULL, &end);
  		    getvvcol(wp, &bot, &start2, NULL, &end2);
--- 3919,3925 ----
  		{
  		    colnr_T	    start, end;
  		    colnr_T	    start2, end2;
! 		    colnr_T	    cols;
  
  		    getvvcol(wp, &top, &start, NULL, &end);
  		    getvvcol(wp, &bot, &start2, NULL, &end2);
***************
*** 3922,3930 ****
  			end = end2;
  		    if (top.col == MAXCOL || bot.col == MAXCOL)
  			end = MAXCOL;
! 		    col = win_linetabsize(wp,
  				      regline, (colnr_T)(reginput - regline));
! 		    if (col < start || col > end - (*p_sel == 'e'))
  			status = RA_NOMATCH;
  		}
  	    }
--- 3929,3937 ----
  			end = end2;
  		    if (top.col == MAXCOL || bot.col == MAXCOL)
  			end = MAXCOL;
! 		    cols = win_linetabsize(wp,
  				      regline, (colnr_T)(reginput - regline));
! 		    if (cols < start || cols > end - (*p_sel == 'e'))
  			status = RA_NOMATCH;
  		}
  	    }
***************
*** 4253,4259 ****
  	    {
  		int	i, len;
  		char_u	*opnd;
! 		int	opndc, inpc;
  
  		opnd = OPERAND(scan);
  		/* Safety check (just in case 'encoding' was changed since
--- 4260,4266 ----
  	    {
  		int	i, len;
  		char_u	*opnd;
! 		int	opndc = 0, inpc;
  
  		opnd = OPERAND(scan);
  		/* Safety check (just in case 'encoding' was changed since
*** ../vim-7.0.069/src/screen.c	Tue Jul 11 22:59:04 2006
--- src/screen.c	Thu Aug 24 22:26:16 2006
***************
*** 7099,7105 ****
      tabpage_T	    *tp;
  #endif
      static int	    entered = FALSE;		/* avoid recursiveness */
!     static int	    did_outofmem_msg = FALSE;	/* did outofmem message */
  
      /*
       * Allocation of the screen buffers is done only when the size changes and
--- 7099,7105 ----
      tabpage_T	    *tp;
  #endif
      static int	    entered = FALSE;		/* avoid recursiveness */
!     static int	    done_outofmem_msg = FALSE;	/* did outofmem message */
  
      /*
       * Allocation of the screen buffers is done only when the size changes and
***************
*** 7207,7220 ****
  #endif
  	    || outofmem)
      {
! 	if (ScreenLines != NULL || !did_outofmem_msg)
  	{
  	    /* guess the size */
  	    do_outofmem_msg((long_u)((Rows + 1) * Columns));
  
  	    /* Remember we did this to avoid getting outofmem messages over
  	     * and over again. */
! 	    did_outofmem_msg = TRUE;
  	}
  	vim_free(new_ScreenLines);
  	new_ScreenLines = NULL;
--- 7207,7220 ----
  #endif
  	    || outofmem)
      {
! 	if (ScreenLines != NULL || !done_outofmem_msg)
  	{
  	    /* guess the size */
  	    do_outofmem_msg((long_u)((Rows + 1) * Columns));
  
  	    /* Remember we did this to avoid getting outofmem messages over
  	     * and over again. */
! 	    done_outofmem_msg = TRUE;
  	}
  	vim_free(new_ScreenLines);
  	new_ScreenLines = NULL;
***************
*** 7242,7248 ****
      }
      else
      {
! 	did_outofmem_msg = FALSE;
  
  	for (new_row = 0; new_row < Rows; ++new_row)
  	{
--- 7242,7248 ----
      }
      else
      {
! 	done_outofmem_msg = FALSE;
  
  	for (new_row = 0; new_row < Rows; ++new_row)
  	{
*** ../vim-7.0.069/src/search.c	Tue Aug 29 16:33:23 2006
--- src/search.c	Tue Aug 29 14:56:15 2006
***************
*** 4826,4840 ****
  
  		if ((compl_cont_status & CONT_ADDING) && i == compl_length)
  		{
- 		    /* get the next line */
  		    /* IOSIZE > compl_length, so the STRNCPY works */
  		    STRNCPY(IObuff, aux, i);
! 		    if (!(     depth < 0
! 			    && lnum < end_lnum
! 			    && (line = ml_get(++lnum)) != NULL)
! 			&& !(	depth >= 0
! 			    && !vim_fgets(line = file_line,
! 						     LSIZE, files[depth].fp)))
  			goto exit_matched;
  
  		    /* we read a line, set "already" to check this "line" later
--- 4826,4845 ----
  
  		if ((compl_cont_status & CONT_ADDING) && i == compl_length)
  		{
  		    /* IOSIZE > compl_length, so the STRNCPY works */
  		    STRNCPY(IObuff, aux, i);
! 
! 		    /* Get the next line: when "depth" < 0  from the current
! 		     * buffer, otherwise from the included file.  Jump to
! 		     * exit_matched when past the last line. */
! 		    if (depth < 0)
! 		    {
! 			if (lnum >= end_lnum)
! 			    goto exit_matched;
! 			line = ml_get(++lnum);
! 		    }
! 		    else if (vim_fgets(line = file_line,
! 						      LSIZE, files[depth].fp))
  			goto exit_matched;
  
  		    /* we read a line, set "already" to check this "line" later
*** ../vim-7.0.069/src/spell.c	Tue Aug 29 16:33:23 2006
--- src/spell.c	Tue Aug 29 14:56:26 2006
***************
*** 2043,2050 ****
      int		len;
  # ifdef FEAT_SYN_HL
      int		has_syntax = syntax_present(wp->w_buffer);
-     int		col;
  # endif
      int		can_spell;
      char_u	*buf = NULL;
      int		buflen = 0;
--- 2043,2050 ----
      int		len;
  # ifdef FEAT_SYN_HL
      int		has_syntax = syntax_present(wp->w_buffer);
  # endif
+     int		col;
      int		can_spell;
      char_u	*buf = NULL;
      int		buflen = 0;
***************
*** 2093,2101 ****
  	    capcol = (int)(skipwhite(line) - line);
  	else if (curline && wp == curwin)
  	{
- 	    int	    col = (int)(skipwhite(line) - line);
- 
  	    /* For spellbadword(): check if first word needs a capital. */
  	    if (check_need_cap(lnum, col))
  		capcol = col;
  
--- 2093,2100 ----
  	    capcol = (int)(skipwhite(line) - line);
  	else if (curline && wp == curwin)
  	{
  	    /* For spellbadword(): check if first word needs a capital. */
+ 	    col = (int)(skipwhite(line) - line);
  	    if (check_need_cap(lnum, col))
  		capcol = col;
  
***************
*** 5061,5067 ****
      int		do_rep;
      int		do_repsal;
      int		do_sal;
!     int		do_map;
      int		found_map = FALSE;
      hashitem_T	*hi;
      int		l;
--- 5060,5066 ----
      int		do_rep;
      int		do_repsal;
      int		do_sal;
!     int		do_mapline;
      int		found_map = FALSE;
      hashitem_T	*hi;
      int		l;
***************
*** 5099,5105 ****
      do_sal = spin->si_sal.ga_len == 0;
  
      /* Only do MAP lines when not done in another .aff file already. */
!     do_map = spin->si_map.ga_len == 0;
  
      /*
       * Allocate and init the afffile_T structure.
--- 5098,5104 ----
      do_sal = spin->si_sal.ga_len == 0;
  
      /* Only do MAP lines when not done in another .aff file already. */
!     do_mapline = spin->si_map.ga_len == 0;
  
      /*
       * Allocate and init the afffile_T structure.
***************
*** 5781,5787 ****
  			smsg((char_u *)_("Expected MAP count in %s line %d"),
  								 fname, lnum);
  		}
! 		else if (do_map)
  		{
  		    int		c;
  
--- 5780,5786 ----
  			smsg((char_u *)_("Expected MAP count in %s line %d"),
  								 fname, lnum);
  		}
! 		else if (do_mapline)
  		{
  		    int		c;
  
***************
*** 7508,7514 ****
  {
      char_u	*p = p_msm;
      long	start = 0;
!     long	inc = 0;
      long	added = 0;
  
      if (!VIM_ISDIGIT(*p))
--- 7507,7513 ----
  {
      char_u	*p = p_msm;
      long	start = 0;
!     long	incr = 0;
      long	added = 0;
  
      if (!VIM_ISDIGIT(*p))
***************
*** 7520,7526 ****
      ++p;
      if (!VIM_ISDIGIT(*p))
  	return FAIL;
!     inc = (getdigits(&p) * 102) / (SBLOCKSIZE / 10);
      if (*p != ',')
  	return FAIL;
      ++p;
--- 7519,7525 ----
      ++p;
      if (!VIM_ISDIGIT(*p))
  	return FAIL;
!     incr = (getdigits(&p) * 102) / (SBLOCKSIZE / 10);
      if (*p != ',')
  	return FAIL;
      ++p;
***************
*** 7530,7540 ****
      if (*p != NUL)
  	return FAIL;
  
!     if (start == 0 || inc == 0 || added == 0 || inc > start)
  	return FAIL;
  
      compress_start = start;
!     compress_inc = inc;
      compress_added = added;
      return OK;
  }
--- 7529,7539 ----
      if (*p != NUL)
  	return FAIL;
  
!     if (start == 0 || incr == 0 || added == 0 || incr > start)
  	return FAIL;
  
      compress_start = start;
!     compress_inc = incr;
      compress_added = added;
      return OK;
  }
***************
*** 8292,8305 ****
   * Returns the number of nodes used.
   */
      static int
! put_node(fd, node, index, regionmask, prefixtree)
      FILE	*fd;		/* NULL when only counting */
      wordnode_T	*node;
!     int		index;
      int		regionmask;
      int		prefixtree;	/* TRUE for PREFIXTREE */
  {
!     int		newindex = index;
      int		siblingcount = 0;
      wordnode_T	*np;
      int		flags;
--- 8291,8304 ----
   * Returns the number of nodes used.
   */
      static int
! put_node(fd, node, idx, regionmask, prefixtree)
      FILE	*fd;		/* NULL when only counting */
      wordnode_T	*node;
!     int		idx;
      int		regionmask;
      int		prefixtree;	/* TRUE for PREFIXTREE */
  {
!     int		newindex = idx;
      int		siblingcount = 0;
      wordnode_T	*np;
      int		flags;
***************
*** 8309,8315 ****
  	return 0;
  
      /* Store the index where this node is written. */
!     node->wn_u1.index = index;
  
      /* Count the number of siblings. */
      for (np = node; np != NULL; np = np->wn_sibling)
--- 8308,8314 ----
  	return 0;
  
      /* Store the index where this node is written. */
!     node->wn_u1.index = idx;
  
      /* Count the number of siblings. */
      for (np = node; np != NULL; np = np->wn_sibling)
***************
*** 9244,9254 ****
   * Add "word[len]" to 'spellfile' as a good or bad word.
   */
      void
! spell_add_word(word, len, bad, index, undo)
      char_u	*word;
      int		len;
      int		bad;
!     int		index;	    /* "zG" and "zW": zero, otherwise index in
  			       'spellfile' */
      int		undo;	    /* TRUE for "zug", "zuG", "zuw" and "zuW" */
  {
--- 9243,9253 ----
   * Add "word[len]" to 'spellfile' as a good or bad word.
   */
      void
! spell_add_word(word, len, bad, idx, undo)
      char_u	*word;
      int		len;
      int		bad;
!     int		idx;	    /* "zG" and "zW": zero, otherwise index in
  			       'spellfile' */
      int		undo;	    /* TRUE for "zug", "zuG", "zuw" and "zuW" */
  {
***************
*** 9262,9268 ****
      int		i;
      char_u	*spf;
  
!     if (index == 0)	    /* use internal wordlist */
      {
  	if (int_wordlist == NULL)
  	{
--- 9261,9267 ----
      int		i;
      char_u	*spf;
  
!     if (idx == 0)	    /* use internal wordlist */
      {
  	if (int_wordlist == NULL)
  	{
***************
*** 9290,9300 ****
  	for (spf = curbuf->b_p_spf, i = 1; *spf != NUL; ++i)
  	{
  	    copy_option_part(&spf, fnamebuf, MAXPATHL, ",");
! 	    if (i == index)
  		break;
  	    if (*spf == NUL)
  	    {
! 		EMSGN(_("E765: 'spellfile' does not have %ld entries"), index);
  		return;
  	    }
  	}
--- 9289,9299 ----
  	for (spf = curbuf->b_p_spf, i = 1; *spf != NUL; ++i)
  	{
  	    copy_option_part(&spf, fnamebuf, MAXPATHL, ",");
! 	    if (i == idx)
  		break;
  	    if (*spf == NUL)
  	    {
! 		EMSGN(_("E765: 'spellfile' does not have %ld entries"), idx);
  		return;
  	    }
  	}
***************
*** 13581,13633 ****
  	 * the first "the" to itself. */
  	return;
  
!     /* Check if the word is already there.  Also check the length that is
!      * being replaced "thes," -> "these" is a different suggestion from
!      * "thes" -> "these". */
!     stp = &SUG(*gap, 0);
!     for (i = gap->ga_len; --i >= 0; ++stp)
! 	if (stp->st_wordlen == goodlen
! 		&& stp->st_orglen == badlen
! 		&& STRNCMP(stp->st_word, goodword, goodlen) == 0)
! 	{
! 	    /*
! 	     * Found it.  Remember the word with the lowest score.
! 	     */
! 	    if (stp->st_slang == NULL)
! 		stp->st_slang = slang;
  
! 	    new_sug.st_score = score;
! 	    new_sug.st_altscore = altscore;
! 	    new_sug.st_had_bonus = had_bonus;
! 
! 	    if (stp->st_had_bonus != had_bonus)
! 	    {
! 		/* Only one of the two had the soundalike score computed.
! 		 * Need to do that for the other one now, otherwise the
! 		 * scores can't be compared.  This happens because
! 		 * suggest_try_change() doesn't compute the soundalike
! 		 * word to keep it fast, while some special methods set
! 		 * the soundalike score to zero. */
! 		if (had_bonus)
! 		    rescore_one(su, stp);
! 		else
! 		{
! 		    new_sug.st_word = stp->st_word;
! 		    new_sug.st_wordlen = stp->st_wordlen;
! 		    new_sug.st_slang = stp->st_slang;
! 		    new_sug.st_orglen = badlen;
! 		    rescore_one(su, &new_sug);
  		}
- 	    }
  
! 	    if (stp->st_score > new_sug.st_score)
! 	    {
! 		stp->st_score = new_sug.st_score;
! 		stp->st_altscore = new_sug.st_altscore;
! 		stp->st_had_bonus = new_sug.st_had_bonus;
  	    }
! 	    break;
! 	}
  
      if (i < 0 && ga_grow(gap, 1) == OK)
      {
--- 13580,13637 ----
  	 * the first "the" to itself. */
  	return;
  
!     if (gap->ga_len == 0)
! 	i = -1;
!     else
!     {
! 	/* Check if the word is already there.  Also check the length that is
! 	 * being replaced "thes," -> "these" is a different suggestion from
! 	 * "thes" -> "these". */
! 	stp = &SUG(*gap, 0);
! 	for (i = gap->ga_len; --i >= 0; ++stp)
! 	    if (stp->st_wordlen == goodlen
! 		    && stp->st_orglen == badlen
! 		    && STRNCMP(stp->st_word, goodword, goodlen) == 0)
! 	    {
! 		/*
! 		 * Found it.  Remember the word with the lowest score.
! 		 */
! 		if (stp->st_slang == NULL)
! 		    stp->st_slang = slang;
  
! 		new_sug.st_score = score;
! 		new_sug.st_altscore = altscore;
! 		new_sug.st_had_bonus = had_bonus;
! 
! 		if (stp->st_had_bonus != had_bonus)
! 		{
! 		    /* Only one of the two had the soundalike score computed.
! 		     * Need to do that for the other one now, otherwise the
! 		     * scores can't be compared.  This happens because
! 		     * suggest_try_change() doesn't compute the soundalike
! 		     * word to keep it fast, while some special methods set
! 		     * the soundalike score to zero. */
! 		    if (had_bonus)
! 			rescore_one(su, stp);
! 		    else
! 		    {
! 			new_sug.st_word = stp->st_word;
! 			new_sug.st_wordlen = stp->st_wordlen;
! 			new_sug.st_slang = stp->st_slang;
! 			new_sug.st_orglen = badlen;
! 			rescore_one(su, &new_sug);
! 		    }
  		}
  
! 		if (stp->st_score > new_sug.st_score)
! 		{
! 		    stp->st_score = new_sug.st_score;
! 		    stp->st_altscore = new_sug.st_altscore;
! 		    stp->st_had_bonus = new_sug.st_had_bonus;
! 		}
! 		break;
  	    }
!     }
  
      if (i < 0 && ga_grow(gap, 1) == OK)
      {
*** ../vim-7.0.069/src/ui.c	Mon Mar 27 23:02:40 2006
--- src/ui.c	Thu Aug 24 22:31:38 2006
***************
*** 1137,1143 ****
      int		len;
  #ifdef FEAT_MBYTE
      char_u	*p;
-     int		i;
  #endif
      int		row1 = clip_star.start.lnum;
      int		col1 = clip_star.start.col;
--- 1137,1142 ----
***************
*** 1218,1223 ****
--- 1217,1224 ----
  #ifdef FEAT_MBYTE
  	    if (enc_dbcs != 0)
  	    {
+ 		int	i;
+ 
  		p = ScreenLines + LineOffset[row];
  		for (i = start_col; i < end_col; ++i)
  		    if (enc_dbcs == DBCS_JPNU && p[i] == 0x8e)
*** ../vim-7.0.069/src/undo.c	Wed Jul 12 21:48:56 2006
--- src/undo.c	Thu Aug 24 22:32:41 2006
***************
*** 1187,1193 ****
      int		did_undo;	/* just did an undo */
      int		absolute;	/* used ":undo N" */
  {
!     char	*msg;
      u_header_T	*uhp;
      char_u	msgbuf[80];
  
--- 1187,1193 ----
      int		did_undo;	/* just did an undo */
      int		absolute;	/* used ":undo N" */
  {
!     char	*msgstr;
      u_header_T	*uhp;
      char_u	msgbuf[80];
  
***************
*** 1205,1224 ****
  
      u_oldcount -= u_newcount;
      if (u_oldcount == -1)
! 	msg = N_("more line");
      else if (u_oldcount < 0)
! 	msg = N_("more lines");
      else if (u_oldcount == 1)
! 	msg = N_("line less");
      else if (u_oldcount > 1)
! 	msg = N_("fewer lines");
      else
      {
  	u_oldcount = u_newcount;
  	if (u_newcount == 1)
! 	    msg = N_("change");
  	else
! 	    msg = N_("changes");
      }
  
      if (curbuf->b_u_curhead != NULL)
--- 1205,1224 ----
  
      u_oldcount -= u_newcount;
      if (u_oldcount == -1)
! 	msgstr = N_("more line");
      else if (u_oldcount < 0)
! 	msgstr = N_("more lines");
      else if (u_oldcount == 1)
! 	msgstr = N_("line less");
      else if (u_oldcount > 1)
! 	msgstr = N_("fewer lines");
      else
      {
  	u_oldcount = u_newcount;
  	if (u_newcount == 1)
! 	    msgstr = N_("change");
  	else
! 	    msgstr = N_("changes");
      }
  
      if (curbuf->b_u_curhead != NULL)
***************
*** 1244,1250 ****
  
      smsg((char_u *)_("%ld %s; %s #%ld  %s"),
  	    u_oldcount < 0 ? -u_oldcount : u_oldcount,
! 	    _(msg),
  	    did_undo ? _("before") : _("after"),
  	    uhp == NULL ? 0L : uhp->uh_seq,
  	    msgbuf);
--- 1244,1250 ----
  
      smsg((char_u *)_("%ld %s; %s #%ld  %s"),
  	    u_oldcount < 0 ? -u_oldcount : u_oldcount,
! 	    _(msgstr),
  	    did_undo ? _("before") : _("after"),
  	    uhp == NULL ? 0L : uhp->uh_seq,
  	    msgbuf);
*** ../vim-7.0.069/src/window.c	Sat May  6 23:37:40 2006
--- src/window.c	Thu Aug 24 22:33:40 2006
***************
*** 340,349 ****
  		{
  		    tabpage_T	*oldtab = curtab;
  		    tabpage_T	*newtab;
- 		    win_T	*wp = curwin;
  
  		    /* First create a new tab with the window, then go back to
  		     * the old tab and close the window there. */
  		    if (win_new_tabpage((int)Prenum) == OK
  						     && valid_tabpage(oldtab))
  		    {
--- 340,349 ----
  		{
  		    tabpage_T	*oldtab = curtab;
  		    tabpage_T	*newtab;
  
  		    /* First create a new tab with the window, then go back to
  		     * the old tab and close the window there. */
+ 		    wp = curwin;
  		    if (win_new_tabpage((int)Prenum) == OK
  						     && valid_tabpage(oldtab))
  		    {
*** ../vim-7.0.069/src/version.c	Tue Aug 29 16:52:01 2006
--- src/version.c	Tue Aug 29 17:02:00 2006
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     70,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
267. You get an extra phone line so you can get phone calls.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
