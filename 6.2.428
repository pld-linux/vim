To: vim-dev@vim.org
Subject: Patch 6.2.428
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

CORRECTED PATCH: chunk in gui_gtk_x11.c was removed, it didn't belong here.

Patch 6.2.428
Problem:    The X11 clipboard supports the Vim selection for char/line/block
	    mode, but since the encoding is not included  can't copy/paste
	    between two Vims with a different 'encoding'.
Solution:   Add a new selection format that includes the 'encoding'.  Perform
	    conversion when necessary.
Files:	    src/gui_gtk_x11.c, src/ui.c, src/vim.h


*** ../vim-6.2.427/src/gui_gtk_x11.c	Tue Mar 23 21:19:08 2004
--- src/gui_gtk_x11.c	Fri Apr  2 12:52:16 2004
***************
*** 102,108 ****
      TARGET_TEXT,
      TARGET_TEXT_URI_LIST,
      TARGET_TEXT_PLAIN,
!     TARGET_VIM
  };
  
  /*
--- 102,109 ----
      TARGET_TEXT,
      TARGET_TEXT_URI_LIST,
      TARGET_TEXT_PLAIN,
!     TARGET_VIM,
!     TARGET_VIMENC
  };
  
  /*
***************
*** 111,116 ****
--- 112,118 ----
   */
  static const GtkTargetEntry selection_targets[] =
  {
+     {VIMENC_ATOM_NAME,	0, TARGET_VIMENC},
      {VIM_ATOM_NAME,	0, TARGET_VIM},
  #ifdef FEAT_MBYTE
      {"UTF8_STRING",	0, TARGET_UTF8_STRING},
***************
*** 175,180 ****
--- 177,185 ----
  static GdkAtom text_atom = GDK_NONE;
  #endif
  static GdkAtom vim_atom = GDK_NONE;	/* Vim's own special selection format */
+ #ifdef FEAT_MBYTE
+ static GdkAtom vimenc_atom = GDK_NONE;	/* Vim's extended selection format */
+ #endif
  
  /*
   * Keycodes recognized by vim.
***************
*** 1244,1249 ****
--- 1255,1288 ----
  	motion_type = *text++;
  	--len;
      }
+ 
+ #ifdef FEAT_MBYTE
+     else if (data->type == vimenc_atom)
+     {
+ 	char_u		*enc;
+ 	vimconv_T	conv;
+ 
+ 	motion_type = *text++;
+ 	--len;
+ 
+ 	enc = text;
+ 	text += STRLEN(text) + 1;
+ 	len -= text - enc;
+ 
+ 	/* If the encoding of the text is different from 'encoding', attempt
+ 	 * converting it. */
+ 	conv.vc_type = CONV_NONE;
+ 	convert_setup(&conv, enc, p_enc);
+ 	if (conv.vc_type != CONV_NONE)
+ 	{
+ 	    tmpbuf = string_convert(&conv, text, &len);
+ 	    if (tmpbuf != NULL)
+ 		text = tmpbuf;
+ 	    convert_setup(&conv, NULL, NULL);
+ 	}
+     }
+ #endif
+ 
  #ifdef HAVE_GTK2
      /* gtk_selection_data_get_text() handles all the nasty details
       * and targets and encodings etc.  This rocks so hard. */
***************
*** 1351,1356 ****
--- 1390,1396 ----
      if (info != (guint)TARGET_STRING
  #ifdef FEAT_MBYTE
  	    && info != (guint)TARGET_UTF8_STRING
+ 	    && info != (guint)TARGET_VIMENC
  #endif
  	    && info != (guint)TARGET_VIM
  	    && info != (guint)TARGET_COMPOUND_TEXT
***************
*** 1382,1387 ****
--- 1422,1448 ----
  	string = tmpbuf;
  	type = vim_atom;
      }
+ 
+ #ifdef FEAT_MBYTE
+     else if (info == (guint)TARGET_VIMENC)
+     {
+ 	int l = STRLEN(p_enc);
+ 
+ 	/* contents: motion_type 'encoding' NUL text */
+ 	tmpbuf = alloc((unsigned)length + l + 2);
+ 	if (tmpbuf != NULL)
+ 	{
+ 	    tmpbuf[0] = motion_type;
+ 	    STRCPY(tmpbuf + 1, p_enc);
+ 	    mch_memmove(tmpbuf + l + 2, string, (size_t)length);
+ 	}
+ 	length += l + 2;
+ 	vim_free(string);
+ 	string = tmpbuf;
+ 	type = vimenc_atom;
+     }
+ #endif
+ 
  #ifdef HAVE_GTK2
      /* gtk_selection_data_set_text() handles everything for us.  This is
       * so easy and simple and cool, it'd be insane not to use it. */
***************
*** 3180,3185 ****
--- 3241,3249 ----
       * Set clipboard specific atoms
       */
      vim_atom = gdk_atom_intern(VIM_ATOM_NAME, FALSE);
+ #ifdef FEAT_MBYTE
+     vimenc_atom = gdk_atom_intern(VIMENC_ATOM_NAME, FALSE);
+ #endif
      clip_star.gtk_sel_atom = GDK_SELECTION_PRIMARY;
      clip_plus.gtk_sel_atom = gdk_atom_intern("CLIPBOARD", FALSE);
  
***************
*** 5128,5134 ****
  	char_u *p;
  
  	for (p = s; p < s + len; ++p)
! 	    if (*p & 0x80) goto not_ascii;
  
  	pango_glyph_string_set_size(glyphs, len);
  
--- 5188,5195 ----
  	char_u *p;
  
  	for (p = s; p < s + len; ++p)
! 	    if (*p & 0x80)
! 		goto not_ascii;
  
  	pango_glyph_string_set_size(glyphs, len);
  
*** ../vim-6.2.427/src/ui.c	Fri Apr  2 11:36:09 2004
--- src/ui.c	Fri Apr  2 12:51:57 2004
***************
*** 1913,1918 ****
--- 1913,1921 ----
  }
  
  static Atom	vim_atom;	/* Vim's own special selection format */
+ #ifdef FEAT_MBYTE
+ static Atom	vimenc_atom;	/* Vim's extended selection format */
+ #endif
  static Atom	compound_text_atom;
  static Atom	text_atom;
  static Atom	targets_atom;
***************
*** 1922,1927 ****
--- 1925,1933 ----
      Display	*dpy;
  {
      vim_atom	       = XInternAtom(dpy, VIM_ATOM_NAME,   False);
+ #ifdef FEAT_MBYTE
+     vimenc_atom	       = XInternAtom(dpy, VIMENC_ATOM_NAME,False);
+ #endif
      compound_text_atom = XInternAtom(dpy, "COMPOUND_TEXT", False);
      text_atom	       = XInternAtom(dpy, "TEXT",	   False);
      targets_atom       = XInternAtom(dpy, "TARGETS",       False);
***************
*** 1952,1957 ****
--- 1958,1966 ----
      char_u	*p;
      char	**text_list = NULL;
      VimClipboard	*cbd;
+ #ifdef FEAT_MBYTE
+     char_u	*tmpbuf = NULL;
+ #endif
  
      if (*sel_atom == clip_plus.sel_atom)
  	cbd = &clip_plus;
***************
*** 1972,1977 ****
--- 1981,2017 ----
  	motion_type = *p++;
  	len--;
      }
+ 
+ #ifdef FEAT_MBYTE
+     else if (*type == vimenc_atom)
+     {
+ 	char_u		*enc;
+ 	vimconv_T	conv;
+ 	int		convlen;
+ 
+ 	motion_type = *p++;
+ 	--len;
+ 
+ 	enc = p;
+ 	p += STRLEN(p) + 1;
+ 	len -= p - enc;
+ 
+ 	/* If the encoding of the text is different from 'encoding', attempt
+ 	 * converting it. */
+ 	conv.vc_type = CONV_NONE;
+ 	convert_setup(&conv, enc, p_enc);
+ 	if (conv.vc_type != CONV_NONE)
+ 	{
+ 	    convlen = len;	/* Need to use an int here. */
+ 	    tmpbuf = string_convert(&conv, p, &convlen);
+ 	    len = convlen;
+ 	    if (tmpbuf != NULL)
+ 		p = tmpbuf;
+ 	    convert_setup(&conv, NULL, NULL);
+ 	}
+     }
+ #endif
+ 
      else if (*type == compound_text_atom || (
  #ifdef FEAT_MBYTE
  		enc_dbcs != 0 &&
***************
*** 2000,2006 ****
  
      if (text_list != NULL)
  	XFreeStringList(text_list);
! 
      XtFree((char *)value);
      *(int *)success = TRUE;
  }
--- 2040,2048 ----
  
      if (text_list != NULL)
  	XFreeStringList(text_list);
! #ifdef FEAT_MBYTE
!     vim_free(tmpbuf);
! #endif
      XtFree((char *)value);
      *(int *)success = TRUE;
  }
***************
*** 2018,2030 ****
      int		nbytes = 0;
      char_u	*buffer;
  
!     for (i = 0; i < 4; i++)
      {
  	switch (i)
  	{
! 	    case 0:  type = vim_atom;	break;
! 	    case 1:  type = compound_text_atom; break;
! 	    case 2:  type = text_atom;	break;
  	    default: type = XA_STRING;
  	}
  	XtGetSelectionValue(myShell, cbd->sel_atom, type,
--- 2060,2081 ----
      int		nbytes = 0;
      char_u	*buffer;
  
!     for (i =
! #ifdef FEAT_MBYTE
! 	    0
! #else
! 	    1
! #endif
! 	    ; i < 5; i++)
      {
  	switch (i)
  	{
! #ifdef FEAT_MBYTE
! 	    case 0:  type = vimenc_atom;	break;
! #endif
! 	    case 1:  type = vim_atom;		break;
! 	    case 2:  type = compound_text_atom; break;
! 	    case 3:  type = text_atom;		break;
  	    default: type = XA_STRING;
  	}
  	XtGetSelectionValue(myShell, cbd->sel_atom, type,
***************
*** 2084,2089 ****
--- 2138,2144 ----
      char_u	*result;
      int		motion_type;
      VimClipboard	*cbd;
+     int		i;
  
      if (*sel_atom == clip_plus.sel_atom)
  	cbd = &clip_plus;
***************
*** 2098,2120 ****
      {
  	Atom *array;
  
! 	if ((array = (Atom *)XtMalloc((unsigned)(sizeof(Atom) * 5))) == NULL)
  	    return False;
  	*value = (XtPointer)array;
! 	array[0] = XA_STRING;
! 	array[1] = targets_atom;
! 	array[2] = vim_atom;
! 	array[3] = text_atom;
! 	array[4] = compound_text_atom;
  	*type = XA_ATOM;
  	/* This used to be: *format = sizeof(Atom) * 8; but that caused
  	 * crashes on 64 bit machines. (Peter Derr) */
  	*format = 32;
! 	*length = 5;
  	return True;
      }
  
      if (       *target != XA_STRING
  	    && *target != vim_atom
  	    && *target != text_atom
  	    && *target != compound_text_atom)
--- 2153,2182 ----
      {
  	Atom *array;
  
! 	if ((array = (Atom *)XtMalloc((unsigned)(sizeof(Atom) * 6))) == NULL)
  	    return False;
  	*value = (XtPointer)array;
! 	i = 0;
! 	array[i++] = XA_STRING;
! 	array[i++] = targets_atom;
! #ifdef FEAT_MBYTE
! 	array[i++] = vimenc_atom;
! #endif
! 	array[i++] = vim_atom;
! 	array[i++] = text_atom;
! 	array[i++] = compound_text_atom;
  	*type = XA_ATOM;
  	/* This used to be: *format = sizeof(Atom) * 8; but that caused
  	 * crashes on 64 bit machines. (Peter Derr) */
  	*format = 32;
! 	*length = i;
  	return True;
      }
  
      if (       *target != XA_STRING
+ #ifdef FEAT_MBYTE
+ 	    && *target != vimenc_atom
+ #endif
  	    && *target != vim_atom
  	    && *target != text_atom
  	    && *target != compound_text_atom)
***************
*** 2129,2134 ****
--- 2191,2202 ----
      if (*target == vim_atom)
  	(*length)++;
  
+ #ifdef FEAT_MBYTE
+     /* Our own format with encoding: motion 'encoding' NUL text */
+     if (*target == vimenc_atom)
+ 	*length += STRLEN(p_enc) + 2;
+ #endif
+ 
      *value = XtMalloc((Cardinal)*length);
      result = (char_u *)*value;
      if (result == NULL)
***************
*** 2159,2164 ****
--- 2227,2245 ----
  	*length = text_prop.nitems;
  	*type = compound_text_atom;
      }
+ 
+ #ifdef FEAT_MBYTE
+     else if (*target == vimenc_atom)
+     {
+ 	int l = STRLEN(p_enc);
+ 
+ 	result[0] = motion_type;
+ 	STRCPY(result + 1, p_enc);
+ 	mch_memmove(result + l + 2, string, (size_t)(*length - l - 2));
+ 	*type = vimenc_atom;
+     }
+ #endif
+ 
      else
      {
  	result[0] = motion_type;
*** ../vim-6.2.427/src/vim.h	Thu Mar 18 14:39:31 2004
--- src/vim.h	Fri Apr  2 12:34:09 2004
***************
*** 1473,1480 ****
  
  #ifdef FEAT_CLIPBOARD
  
! /* Vim-specific selection type for X11 */
  #define VIM_ATOM_NAME "_VIM_TEXT"
  
  /* Selection states for modeless selection */
  # define SELECT_CLEARED		0
--- 1473,1483 ----
  
  #ifdef FEAT_CLIPBOARD
  
! /* VIM_ATOM_NAME is the older Vim-specific selection type for X11.  Still
!  * supported for when a mix of Vim versions is used. VIMENC_ATOM_NAME includes
!  * the encoding to support Vims using different 'encoding' values. */
  #define VIM_ATOM_NAME "_VIM_TEXT"
+ #define VIMENC_ATOM_NAME "_VIMENC_TEXT"
  
  /* Selection states for modeless selection */
  # define SELECT_CLEARED		0
*** ../vim-6.2.427/src/version.c	Fri Apr  2 11:36:09 2004
--- src/version.c	Fri Apr  2 14:05:46 2004
***************
*** 639,640 ****
--- 639,642 ----
  {   /* Add new patch number below this line */
+ /**/
+     428,
  /**/

-- 
You can tune a file system, but you can't tuna fish
							-- man tunefs

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        Sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\              Project leader for A-A-P -- http://www.A-A-P.org        ///
 \\\  Buy at Amazon and help AIDS victims -- http://ICCF.nl/click1.html ///
